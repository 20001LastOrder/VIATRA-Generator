/*
 * generated by Xtext 2.16.0
 */
package hu.bme.mit.inf.dslreasoner.faulttree.components.serializer;

import com.google.inject.Inject;
import hu.bme.mit.inf.dslreasoner.faulttree.components.cftLanguage.AndGate;
import hu.bme.mit.inf.dslreasoner.faulttree.components.cftLanguage.Assignment;
import hu.bme.mit.inf.dslreasoner.faulttree.components.cftLanguage.BasicEventDefinition;
import hu.bme.mit.inf.dslreasoner.faulttree.components.cftLanguage.CftLanguagePackage;
import hu.bme.mit.inf.dslreasoner.faulttree.components.cftLanguage.CftModel;
import hu.bme.mit.inf.dslreasoner.faulttree.components.cftLanguage.ComponentDefinition;
import hu.bme.mit.inf.dslreasoner.faulttree.components.cftLanguage.ComponentInstance;
import hu.bme.mit.inf.dslreasoner.faulttree.components.cftLanguage.EventReference;
import hu.bme.mit.inf.dslreasoner.faulttree.components.cftLanguage.ImportDeclaration;
import hu.bme.mit.inf.dslreasoner.faulttree.components.cftLanguage.InputEvent;
import hu.bme.mit.inf.dslreasoner.faulttree.components.cftLanguage.LookupDefinition;
import hu.bme.mit.inf.dslreasoner.faulttree.components.cftLanguage.MappingDefinition;
import hu.bme.mit.inf.dslreasoner.faulttree.components.cftLanguage.MappingParameter;
import hu.bme.mit.inf.dslreasoner.faulttree.components.cftLanguage.OrGate;
import hu.bme.mit.inf.dslreasoner.faulttree.components.cftLanguage.TransformationDefinition;
import hu.bme.mit.inf.dslreasoner.faulttree.components.services.CftLanguageGrammarAccess;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class CftLanguageSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private CftLanguageGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == CftLanguagePackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case CftLanguagePackage.AND_GATE:
				sequence_AndGate(context, (AndGate) semanticObject); 
				return; 
			case CftLanguagePackage.ASSIGNMENT:
				sequence_Assignment(context, (Assignment) semanticObject); 
				return; 
			case CftLanguagePackage.BASIC_EVENT_DEFINITION:
				sequence_BasicEventDefinition(context, (BasicEventDefinition) semanticObject); 
				return; 
			case CftLanguagePackage.CFT_MODEL:
				sequence_CftModel(context, (CftModel) semanticObject); 
				return; 
			case CftLanguagePackage.COMPONENT_DEFINITION:
				sequence_ComponentDefinition(context, (ComponentDefinition) semanticObject); 
				return; 
			case CftLanguagePackage.COMPONENT_INSTANCE:
				sequence_ComponentInstance(context, (ComponentInstance) semanticObject); 
				return; 
			case CftLanguagePackage.EVENT_REFERENCE:
				sequence_EventReference(context, (EventReference) semanticObject); 
				return; 
			case CftLanguagePackage.IMPORT_DECLARATION:
				sequence_ImportDeclaration(context, (ImportDeclaration) semanticObject); 
				return; 
			case CftLanguagePackage.INPUT_EVENT:
				sequence_InputEvent(context, (InputEvent) semanticObject); 
				return; 
			case CftLanguagePackage.LOOKUP_DEFINITION:
				sequence_LookupDefinition(context, (LookupDefinition) semanticObject); 
				return; 
			case CftLanguagePackage.MAPPING_DEFINITION:
				sequence_MappingDefinition(context, (MappingDefinition) semanticObject); 
				return; 
			case CftLanguagePackage.MAPPING_PARAMETER:
				sequence_MappingParameter(context, (MappingParameter) semanticObject); 
				return; 
			case CftLanguagePackage.OR_GATE:
				sequence_OrGate(context, (OrGate) semanticObject); 
				return; 
			case CftLanguagePackage.TRANSFORMATION_DEFINITION:
				sequence_TransformationDefinition(context, (TransformationDefinition) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     EventDeclaration returns AndGate
	 *     EventDefinition returns AndGate
	 *     GateDefinition returns AndGate
	 *     AndGate returns AndGate
	 *
	 * Constraint:
	 *     (name=ID inputEvents+=[EventDeclaration|ID]*)
	 */
	protected void sequence_AndGate(ISerializationContext context, AndGate semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Assignment returns Assignment
	 *
	 * Constraint:
	 *     (input=EventReference multiple?='+='? output=EventReference)
	 */
	protected void sequence_Assignment(ISerializationContext context, Assignment semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EventDeclaration returns BasicEventDefinition
	 *     EventDefinition returns BasicEventDefinition
	 *     BasicEventDefinition returns BasicEventDefinition
	 *
	 * Constraint:
	 *     (name=ID rate=DOULBE)
	 */
	protected void sequence_BasicEventDefinition(ISerializationContext context, BasicEventDefinition semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CftLanguagePackage.Literals.EVENT_DECLARATION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CftLanguagePackage.Literals.EVENT_DECLARATION__NAME));
			if (transientValues.isValueTransient(semanticObject, CftLanguagePackage.Literals.BASIC_EVENT_DEFINITION__RATE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CftLanguagePackage.Literals.BASIC_EVENT_DEFINITION__RATE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBasicEventDefinitionAccess().getNameIDTerminalRuleCall_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getBasicEventDefinitionAccess().getRateDOULBETerminalRuleCall_3_0(), semanticObject.getRate());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     CftModel returns CftModel
	 *
	 * Constraint:
	 *     (
	 *         packageName=QualifiedName 
	 *         imports+=ImportDeclaration* 
	 *         (componentDefinitions+=ComponentDefinition | transformationDefinitions+=TransformationDefinition)*
	 *     )
	 */
	protected void sequence_CftModel(ISerializationContext context, CftModel semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ComponentDefinition returns ComponentDefinition
	 *
	 * Constraint:
	 *     (name=ID (inputEvents+=InputEvent | outputEvents+=[EventDeclaration|ID])* eventDefinitions+=EventDefinition*)
	 */
	protected void sequence_ComponentDefinition(ISerializationContext context, ComponentDefinition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Variable returns ComponentInstance
	 *     ComponentInstance returns ComponentInstance
	 *
	 * Constraint:
	 *     (componentType=[ComponentDefinition|QualifiedName] name=ID?)
	 */
	protected void sequence_ComponentInstance(ISerializationContext context, ComponentInstance semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EventReference returns EventReference
	 *
	 * Constraint:
	 *     (component=[Variable|ID] event=[EventDeclaration|ID])
	 */
	protected void sequence_EventReference(ISerializationContext context, EventReference semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CftLanguagePackage.Literals.EVENT_REFERENCE__COMPONENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CftLanguagePackage.Literals.EVENT_REFERENCE__COMPONENT));
			if (transientValues.isValueTransient(semanticObject, CftLanguagePackage.Literals.EVENT_REFERENCE__EVENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CftLanguagePackage.Literals.EVENT_REFERENCE__EVENT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEventReferenceAccess().getComponentVariableIDTerminalRuleCall_0_0_1(), semanticObject.eGet(CftLanguagePackage.Literals.EVENT_REFERENCE__COMPONENT, false));
		feeder.accept(grammarAccess.getEventReferenceAccess().getEventEventDeclarationIDTerminalRuleCall_2_0_1(), semanticObject.eGet(CftLanguagePackage.Literals.EVENT_REFERENCE__EVENT, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ImportDeclaration returns ImportDeclaration
	 *
	 * Constraint:
	 *     importedNamespace=QualifiedNameWithWildcard
	 */
	protected void sequence_ImportDeclaration(ISerializationContext context, ImportDeclaration semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CftLanguagePackage.Literals.IMPORT_DECLARATION__IMPORTED_NAMESPACE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CftLanguagePackage.Literals.IMPORT_DECLARATION__IMPORTED_NAMESPACE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getImportDeclarationAccess().getImportedNamespaceQualifiedNameWithWildcardParserRuleCall_1_0(), semanticObject.getImportedNamespace());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     EventDeclaration returns InputEvent
	 *     InputEvent returns InputEvent
	 *
	 * Constraint:
	 *     (name=ID multiple?='[]'?)
	 */
	protected void sequence_InputEvent(ISerializationContext context, InputEvent semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     LookupDefinition returns LookupDefinition
	 *     Variable returns LookupDefinition
	 *
	 * Constraint:
	 *     (mapping=[MappingDefinition|ID] arguments+=[MappingParameter|ID] arguments+=[MappingParameter|ID]* name=ID)
	 */
	protected void sequence_LookupDefinition(ISerializationContext context, LookupDefinition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MappingDefinition returns MappingDefinition
	 *
	 * Constraint:
	 *     (
	 *         topLevel?='toplevel'? 
	 *         pattern=[Pattern|QualifiedName] 
	 *         parameters+=MappingParameter 
	 *         parameters+=MappingParameter* 
	 *         componentInstance=ComponentInstance? 
	 *         (lookupDefinitions+=LookupDefinition | assignments+=Assignment)*
	 *     )
	 */
	protected void sequence_MappingDefinition(ISerializationContext context, MappingDefinition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MappingParameter returns MappingParameter
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_MappingParameter(ISerializationContext context, MappingParameter semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CftLanguagePackage.Literals.MAPPING_PARAMETER__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CftLanguagePackage.Literals.MAPPING_PARAMETER__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMappingParameterAccess().getNameIDTerminalRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     EventDeclaration returns OrGate
	 *     EventDefinition returns OrGate
	 *     GateDefinition returns OrGate
	 *     OrGate returns OrGate
	 *
	 * Constraint:
	 *     (name=ID inputEvents+=[EventDeclaration|ID]*)
	 */
	protected void sequence_OrGate(ISerializationContext context, OrGate semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TransformationDefinition returns TransformationDefinition
	 *
	 * Constraint:
	 *     (name=ID mappingDefinitions+=MappingDefinition*)
	 */
	protected void sequence_TransformationDefinition(ISerializationContext context, TransformationDefinition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
