/*
 * generated by Xtext 2.16.0
 */
package hu.bme.mit.inf.dslreasoner.faulttree.components.scoping

import com.google.common.collect.Lists
import com.google.inject.Inject
import hu.bme.mit.inf.dslreasoner.faulttree.components.cftLanguage.ComponentInstance
import hu.bme.mit.inf.dslreasoner.faulttree.components.cftLanguage.EventReference
import hu.bme.mit.inf.dslreasoner.faulttree.components.cftLanguage.LookupDefinition
import hu.bme.mit.inf.dslreasoner.faulttree.components.cftLanguage.MappingDefinition
import hu.bme.mit.inf.dslreasoner.faulttree.components.cftLanguage.TransformationDefinition
import hu.bme.mit.inf.dslreasoner.faulttree.components.cftLanguage.Variable
import hu.bme.mit.inf.dslreasoner.faulttree.model.cft.ComponentDefinition
import org.eclipse.emf.common.notify.Notifier
import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.EReference
import org.eclipse.xtext.EcoreUtil2
import org.eclipse.xtext.resource.EObjectDescription
import org.eclipse.xtext.resource.IResourceDescriptions
import org.eclipse.xtext.resource.IResourceDescriptionsProvider
import org.eclipse.xtext.scoping.IScope
import org.eclipse.xtext.scoping.Scopes
import org.eclipse.xtext.scoping.impl.SimpleScope

import static hu.bme.mit.inf.dslreasoner.faulttree.components.cftLanguage.CftLanguagePackage.Literals.*

/**
 * This class contains custom scoping description.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#scoping
 * on how and when to use it.
 */
class CftLanguageScopeProvider extends AbstractCftLanguageScopeProvider {
	public static val SINGLETON_VARIABLE_PREFIX = "_"
	
	@Inject IResourceDescriptionsProvider resourceDescriptionsProvider
	@Inject CftLanguageImportedNamespaceAwareLocalScopeProvider importedNamespaceProvider

	override getScope(EObject context, EReference reference) {
		switch (reference) {
			case LOOKUP_DEFINITION__MAPPING:
				getRuleDefinitionsScope(context, reference)
			case LOOKUP_DEFINITION__ARGUMENTS:
				getMappingParametersScope(context)
			case EVENT_REFERENCE__COMPONENT:
				getComponentInstancesScope(context)
			case EVENT_REFERENCE__EVENT:
				getEventDeclarationsScope(context)
			default:
				super.getScope(context, reference)
		}
	}

	protected def getRuleDefinitionsScope(EObject context, EReference referece) {
		val transformationDefinition = EcoreUtil2.getContainerOfType(context, TransformationDefinition)
		if (transformationDefinition === null) {
			return IScope.NULLSCOPE
		}
		val resourceDescriptions = getResourceDescriptions(transformationDefinition)
		val mappingDefinitionDescriptions = toMappingDefinitionDescriptions(resourceDescriptions,
			transformationDefinition.mappingDefinitions)
		val ruleDefinitionsScope = new SimpleScope(IScope.NULLSCOPE, mappingDefinitionDescriptions)
		importedNamespaceProvider.createImportNormalizedScope(ruleDefinitionsScope, context, referece)
	}

	protected def toMappingDefinitionDescriptions(IResourceDescriptions resourceDescriptions,
		Iterable<? extends MappingDefinition> ruleDefinitions) {
		val mappingDefinitionDescriptions = Lists.newArrayListWithExpectedSize(ruleDefinitions.size)
		for (ruleDefinition : ruleDefinitions) {
			val pattern = ruleDefinition?.pattern
			if (pattern !== null) {
				val patternName = resourceDescriptions.getExportedObjectsByObject(pattern).head?.qualifiedName
				if (patternName !== null) {
					mappingDefinitionDescriptions += EObjectDescription.create(patternName, ruleDefinition)
				}
			}

		}
		mappingDefinitionDescriptions
	}

	private def getResourceDescriptions(Notifier notifier) {
		val resourceSet = EcoreUtil2.getResourceSet(notifier)
		if (resourceSet === null) {
			new IResourceDescriptions.NullImpl
		} else {
			resourceDescriptionsProvider.getResourceDescriptions(resourceSet)
		}
	}
	
	protected def getMappingParametersScope(EObject context) {
		val mappingDefinition = EcoreUtil2.getContainerOfType(context, MappingDefinition)
		if (mappingDefinition === null) {
			return IScope.NULLSCOPE
		}
		val variables = mappingDefinition.parameters.filter [
			!name.startsWith(SINGLETON_VARIABLE_PREFIX)
		]
		Scopes.scopeFor(variables)
	}

	protected def getComponentInstancesScope(EObject context) {
		val mappingDefinition = EcoreUtil2.getContainerOfType(context, MappingDefinition)
		if (mappingDefinition === null) {
			return IScope.NULLSCOPE
		}
		val componentInstances = <Variable>newArrayList
		componentInstances.addAll(mappingDefinition.lookupDefinitions)
		if (mappingDefinition.componentInstance !== null) {
			componentInstances += mappingDefinition.componentInstance
		}
		Scopes.scopeFor(componentInstances)
	}

	protected def getEventDeclarationsScope(EObject context) {
		val variable = EcoreUtil2.getContainerOfType(context, EventReference)?.component
		val events = switch (variable) {
			ComponentInstance:
				variable.componentType?.allEventDeclarations
			LookupDefinition:
				variable.mapping?.componentInstance?.componentType?.allEventDeclarations
			default:
				null
		}
		if (events === null) {
			return IScope.NULLSCOPE
		}
		Scopes.scopeFor(events)
	}

	private def getAllEventDeclarations(ComponentDefinition componentDefinition) {
		val eventDeclarations = newArrayList
		eventDeclarations.addAll(componentDefinition.inputEvents)
		eventDeclarations.addAll(componentDefinition.eventDefinitions)
		eventDeclarations
	}
}
