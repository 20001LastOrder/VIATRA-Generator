grammar hu.bme.mit.inf.dslreasoner.faulttree.components.CftLanguage with org.eclipse.xtext.common.Terminals

import "http://www.eclipse.org/emf/2002/Ecore" as ecore
import "http://www.eclipse.org/viatra/query/patternlanguage/emf/PatternLanguage" as vql
import "http://www.bme.hu/mit/inf/dslreasoner/faulttree/model/ft" as ft
import "http://www.bme.hu/mit/inf/dslreasoner/faulttree/model/cft" as cft
generate cftLanguage "http://www.bme.hu/mit/inf/dslreasoner/faulttree/components/CftLanguage"

CftModel:
	"package" packageName=QualifiedName ";"?
	imports+=ImportDeclaration*
	(componentDefinitions+=ComponentDefinition | transformationDefinitions+=TransformationDefinition)*;

ImportDeclaration:
	"import" importedNamespace=QualifiedNameWithWildcard ";"?;

ComponentDefinition returns cft::ComponentDefinition:
	"cft" name=ValidId "{"
	(("in" inputEvents+=InputEvent* ";")? & ("out" outputEvents+=[cft::EventDeclaration|ValidId]* ";")?)
	(eventDefinitions+=EventDefinition ";")*
	"}";

InputEvent returns cft::InputEvent:
	name=ValidId multiple?="[]"?;

EventDefinition returns cft::EventDefinition:
	BasicEventDefinition | GateDefinition;

BasicEventDefinition returns cft::BasicEventDefinition:
	name=ValidId distribution=Distribution;

Distribution returns ft::Distribution:
	ConstantDistribution | ExponentialDistribution;

ConstantDistribution returns ft::ConstantDistribution:
	"prob" "=" p=Double;

ExponentialDistribution returns ft::ExponentialDistribution:
	"lambda" "=" lambda=Double;

GateDefinition returns cft::GateDefinition:
	AndGateDefinition | OrGateDefinition | KOfMGateDefinition;

AndGateDefinition returns cft::AndGateDefinition:
	name=ValidId "and" inputEvents+=[cft::EventDeclaration|ValidId]*;

OrGateDefinition returns cft::OrGateDefinition:
	name=ValidId "or" inputEvents+=[cft::EventDeclaration|ValidId]*;

KOfMGateDefinition returns cft::KOfMGateDefinition:
	name=ValidId k=INT ("of" m=INT | m=OF_INT) inputEvents+=[cft::EventDeclaration|ValidId]*;

TransformationDefinition:
	"transformation" name=ValidId "{"
	mappingDefinitions+=MappingDefinition*
	"}";

MappingDefinition:
	topLevel?="toplevel"? "mapping" pattern=[vql::Pattern|QualifiedName]
	"(" parameters+=MappingParameter ("," parameters+=MappingParameter)* ")"
	(componentInstance=ComponentInstance)? ("{"
	((lookupDefinitions+=LookupDefinition | assignments+=Assignment) ";")*
	"}")?;

MappingParameter:
	name=ValidId;

LookupDefinition:
	"lookup" mapping=[MappingDefinition|QualifiedName]
	"(" arguments+=[MappingParameter|ValidId] ("," arguments+=[MappingParameter|ValidId])* ")"
	"as" name=ValidId;

Variable:
	ComponentInstance | LookupDefinition;

Assignment:
	input=EventReference (multiple?="+=" | ":=") output=EventReference;

EventReference:
	component=[Variable|ValidId] "." event=[cft::EventDeclaration|ValidId];

ComponentInstance:
	"=>" componentType=[cft::ComponentDefinition|QualifiedName] name=ValidId?;

QualifiedName returns ecore::EString:
	ValidId ("." ValidId)*;

QualifiedNameWithWildcard returns ecore::EString:
	QualifiedName ("." "*")?;

ValidId:
	ID | OF_INT;

Double returns ecore::EDouble:
	INT | T_DOUBLE;

terminal OF_INT returns ecore::EInt:
	"o" "f" ('0'..'9')+;

terminal T_DOUBLE:
	('0'..'9')+ ("." ('0'..'9')+ | ("." ('0'..'9')+)? ("e" | "E") ("+" | "-")? ('0'..'9')+);
