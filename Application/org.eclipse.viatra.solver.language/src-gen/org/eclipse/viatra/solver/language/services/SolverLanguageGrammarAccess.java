/*
 * generated by Xtext 2.21.0
 */
package org.eclipse.viatra.solver.language.services;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import java.util.List;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Alternatives;
import org.eclipse.xtext.Assignment;
import org.eclipse.xtext.CrossReference;
import org.eclipse.xtext.EnumLiteralDeclaration;
import org.eclipse.xtext.EnumRule;
import org.eclipse.xtext.Grammar;
import org.eclipse.xtext.GrammarUtil;
import org.eclipse.xtext.Group;
import org.eclipse.xtext.Keyword;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.RuleCall;
import org.eclipse.xtext.TerminalRule;
import org.eclipse.xtext.common.services.TerminalsGrammarAccess;
import org.eclipse.xtext.service.AbstractElementFinder.AbstractEnumRuleElementFinder;
import org.eclipse.xtext.service.AbstractElementFinder.AbstractGrammarElementFinder;
import org.eclipse.xtext.service.GrammarProvider;

@Singleton
public class SolverLanguageGrammarAccess extends AbstractGrammarElementFinder {
	
	public class ProblemElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.viatra.solver.language.SolverLanguage.Problem");
		private final Assignment cStatementsAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cStatementsStatementParserRuleCall_0 = (RuleCall)cStatementsAssignment.eContents().get(0);
		
		//Problem:
		//	statements+=Statement*;
		@Override public ParserRule getRule() { return rule; }
		
		//statements+=Statement*
		public Assignment getStatementsAssignment() { return cStatementsAssignment; }
		
		//Statement
		public RuleCall getStatementsStatementParserRuleCall_0() { return cStatementsStatementParserRuleCall_0; }
	}
	public class StatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.viatra.solver.language.SolverLanguage.Statement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Alternatives cAlternatives_0 = (Alternatives)cGroup.eContents().get(0);
		private final RuleCall cAssertionOrDefinitionParserRuleCall_0_0 = (RuleCall)cAlternatives_0.eContents().get(0);
		private final RuleCall cPredicateDefinitionParserRuleCall_0_1 = (RuleCall)cAlternatives_0.eContents().get(1);
		private final RuleCall cUnnamedErrorPrediateDefinitionParserRuleCall_0_2 = (RuleCall)cAlternatives_0.eContents().get(2);
		private final RuleCall cDefaultDefinitionParserRuleCall_0_3 = (RuleCall)cAlternatives_0.eContents().get(3);
		private final RuleCall cExternPredicateDefinitionParserRuleCall_0_4 = (RuleCall)cAlternatives_0.eContents().get(4);
		private final RuleCall cMetricDefinitionParserRuleCall_0_5 = (RuleCall)cAlternatives_0.eContents().get(5);
		private final RuleCall cExternMetricDefinitionParserRuleCall_0_6 = (RuleCall)cAlternatives_0.eContents().get(6);
		private final RuleCall cClassDefinitionParserRuleCall_0_7 = (RuleCall)cAlternatives_0.eContents().get(7);
		private final RuleCall cScopeDefinitionParserRuleCall_0_8 = (RuleCall)cAlternatives_0.eContents().get(8);
		private final RuleCall cObjectiveDefinitionParserRuleCall_0_9 = (RuleCall)cAlternatives_0.eContents().get(9);
		private final RuleCall cFULL_STOPTerminalRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		
		//Statement:
		//	(AssertionOrDefinition | PredicateDefinition | UnnamedErrorPrediateDefinition | DefaultDefinition |
		//	ExternPredicateDefinition | MetricDefinition | ExternMetricDefinition | ClassDefinition | ScopeDefinition |
		//	ObjectiveDefinition) FULL_STOP;
		@Override public ParserRule getRule() { return rule; }
		
		//(AssertionOrDefinition | PredicateDefinition | UnnamedErrorPrediateDefinition | DefaultDefinition |
		//ExternPredicateDefinition | MetricDefinition | ExternMetricDefinition | ClassDefinition | ScopeDefinition |
		//ObjectiveDefinition) FULL_STOP
		public Group getGroup() { return cGroup; }
		
		//(AssertionOrDefinition | PredicateDefinition | UnnamedErrorPrediateDefinition | DefaultDefinition |
		//ExternPredicateDefinition | MetricDefinition | ExternMetricDefinition | ClassDefinition | ScopeDefinition |
		//ObjectiveDefinition)
		public Alternatives getAlternatives_0() { return cAlternatives_0; }
		
		//AssertionOrDefinition
		public RuleCall getAssertionOrDefinitionParserRuleCall_0_0() { return cAssertionOrDefinitionParserRuleCall_0_0; }
		
		//PredicateDefinition
		public RuleCall getPredicateDefinitionParserRuleCall_0_1() { return cPredicateDefinitionParserRuleCall_0_1; }
		
		//UnnamedErrorPrediateDefinition
		public RuleCall getUnnamedErrorPrediateDefinitionParserRuleCall_0_2() { return cUnnamedErrorPrediateDefinitionParserRuleCall_0_2; }
		
		//DefaultDefinition
		public RuleCall getDefaultDefinitionParserRuleCall_0_3() { return cDefaultDefinitionParserRuleCall_0_3; }
		
		//ExternPredicateDefinition
		public RuleCall getExternPredicateDefinitionParserRuleCall_0_4() { return cExternPredicateDefinitionParserRuleCall_0_4; }
		
		//MetricDefinition
		public RuleCall getMetricDefinitionParserRuleCall_0_5() { return cMetricDefinitionParserRuleCall_0_5; }
		
		//ExternMetricDefinition
		public RuleCall getExternMetricDefinitionParserRuleCall_0_6() { return cExternMetricDefinitionParserRuleCall_0_6; }
		
		//ClassDefinition
		public RuleCall getClassDefinitionParserRuleCall_0_7() { return cClassDefinitionParserRuleCall_0_7; }
		
		//ScopeDefinition
		public RuleCall getScopeDefinitionParserRuleCall_0_8() { return cScopeDefinitionParserRuleCall_0_8; }
		
		//ObjectiveDefinition
		public RuleCall getObjectiveDefinitionParserRuleCall_0_9() { return cObjectiveDefinitionParserRuleCall_0_9; }
		
		//FULL_STOP
		public RuleCall getFULL_STOPTerminalRuleCall_1() { return cFULL_STOPTerminalRuleCall_1; }
	}
	public class AssertionOrDefinitionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.viatra.solver.language.SolverLanguage.AssertionOrDefinition");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Alternatives cAlternatives_1 = (Alternatives)cGroup.eContents().get(1);
		private final Group cGroup_1_0 = (Group)cAlternatives_1.eContents().get(0);
		private final Action cAssertionBodyAction_1_0_0 = (Action)cGroup_1_0.eContents().get(0);
		private final Group cGroup_1_0_1 = (Group)cGroup_1_0.eContents().get(1);
		private final Keyword cColonKeyword_1_0_1_0 = (Keyword)cGroup_1_0_1.eContents().get(0);
		private final Assignment cRangeAssignment_1_0_1_1 = (Assignment)cGroup_1_0_1.eContents().get(1);
		private final RuleCall cRangeExpressionParserRuleCall_1_0_1_1_0 = (RuleCall)cRangeAssignment_1_0_1_1.eContents().get(0);
		private final Group cGroup_1_1 = (Group)cAlternatives_1.eContents().get(1);
		private final Action cPredicateDefinitionHeadAction_1_1_0 = (Action)cGroup_1_1.eContents().get(0);
		private final Keyword cColonHyphenMinusKeyword_1_1_1 = (Keyword)cGroup_1_1.eContents().get(1);
		private final Assignment cBodyAssignment_1_1_2 = (Assignment)cGroup_1_1.eContents().get(2);
		private final RuleCall cBodyExpressionParserRuleCall_1_1_2_0 = (RuleCall)cBodyAssignment_1_1_2.eContents().get(0);
		private final Group cGroup_1_2 = (Group)cAlternatives_1.eContents().get(2);
		private final Action cMetricDefinitionHeadAction_1_2_0 = (Action)cGroup_1_2.eContents().get(0);
		private final Keyword cEqualsSignKeyword_1_2_1 = (Keyword)cGroup_1_2.eContents().get(1);
		private final Assignment cBodyAssignment_1_2_2 = (Assignment)cGroup_1_2.eContents().get(2);
		private final RuleCall cBodyExpressionParserRuleCall_1_2_2_0 = (RuleCall)cBodyAssignment_1_2_2.eContents().get(0);
		
		//AssertionOrDefinition Statement:
		//	Expression ({Assertion.body=current} (":" range=Expression)? | {PredicateDefinition.head=current} ":-"
		//	body=Expression | {MetricDefinition.head=current} "=" body=Expression);
		@Override public ParserRule getRule() { return rule; }
		
		//Expression ({Assertion.body=current} (":" range=Expression)? | {PredicateDefinition.head=current} ":-" body=Expression |
		//{MetricDefinition.head=current} "=" body=Expression)
		public Group getGroup() { return cGroup; }
		
		//Expression
		public RuleCall getExpressionParserRuleCall_0() { return cExpressionParserRuleCall_0; }
		
		//({Assertion.body=current} (":" range=Expression)? | {PredicateDefinition.head=current} ":-" body=Expression |
		//{MetricDefinition.head=current} "=" body=Expression)
		public Alternatives getAlternatives_1() { return cAlternatives_1; }
		
		//{Assertion.body=current} (":" range=Expression)?
		public Group getGroup_1_0() { return cGroup_1_0; }
		
		//{Assertion.body=current}
		public Action getAssertionBodyAction_1_0_0() { return cAssertionBodyAction_1_0_0; }
		
		//(":" range=Expression)?
		public Group getGroup_1_0_1() { return cGroup_1_0_1; }
		
		//":"
		public Keyword getColonKeyword_1_0_1_0() { return cColonKeyword_1_0_1_0; }
		
		//range=Expression
		public Assignment getRangeAssignment_1_0_1_1() { return cRangeAssignment_1_0_1_1; }
		
		//Expression
		public RuleCall getRangeExpressionParserRuleCall_1_0_1_1_0() { return cRangeExpressionParserRuleCall_1_0_1_1_0; }
		
		//{PredicateDefinition.head=current} ":-" body=Expression
		public Group getGroup_1_1() { return cGroup_1_1; }
		
		//{PredicateDefinition.head=current}
		public Action getPredicateDefinitionHeadAction_1_1_0() { return cPredicateDefinitionHeadAction_1_1_0; }
		
		//":-"
		public Keyword getColonHyphenMinusKeyword_1_1_1() { return cColonHyphenMinusKeyword_1_1_1; }
		
		//body=Expression
		public Assignment getBodyAssignment_1_1_2() { return cBodyAssignment_1_1_2; }
		
		//Expression
		public RuleCall getBodyExpressionParserRuleCall_1_1_2_0() { return cBodyExpressionParserRuleCall_1_1_2_0; }
		
		//{MetricDefinition.head=current} "=" body=Expression
		public Group getGroup_1_2() { return cGroup_1_2; }
		
		//{MetricDefinition.head=current}
		public Action getMetricDefinitionHeadAction_1_2_0() { return cMetricDefinitionHeadAction_1_2_0; }
		
		//"="
		public Keyword getEqualsSignKeyword_1_2_1() { return cEqualsSignKeyword_1_2_1; }
		
		//body=Expression
		public Assignment getBodyAssignment_1_2_2() { return cBodyAssignment_1_2_2; }
		
		//Expression
		public RuleCall getBodyExpressionParserRuleCall_1_2_2_0() { return cBodyExpressionParserRuleCall_1_2_2_0; }
	}
	public class PredicateDefinitionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.viatra.solver.language.SolverLanguage.PredicateDefinition");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Alternatives cAlternatives_0 = (Alternatives)cGroup.eContents().get(0);
		private final Group cGroup_0_0 = (Group)cAlternatives_0.eContents().get(0);
		private final Assignment cFunctionalAssignment_0_0_0 = (Assignment)cGroup_0_0.eContents().get(0);
		private final Keyword cFunctionalFunctionalKeyword_0_0_0_0 = (Keyword)cFunctionalAssignment_0_0_0.eContents().get(0);
		private final Assignment cErrorAssignment_0_0_1 = (Assignment)cGroup_0_0.eContents().get(1);
		private final Keyword cErrorErrorKeyword_0_0_1_0 = (Keyword)cErrorAssignment_0_0_1.eContents().get(0);
		private final Group cGroup_0_1 = (Group)cAlternatives_0.eContents().get(1);
		private final Assignment cErrorAssignment_0_1_0 = (Assignment)cGroup_0_1.eContents().get(0);
		private final Keyword cErrorErrorKeyword_0_1_0_0 = (Keyword)cErrorAssignment_0_1_0.eContents().get(0);
		private final Assignment cFunctionalAssignment_0_1_1 = (Assignment)cGroup_0_1.eContents().get(1);
		private final Keyword cFunctionalFunctionalKeyword_0_1_1_0 = (Keyword)cFunctionalAssignment_0_1_1.eContents().get(0);
		private final Assignment cHeadAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cHeadCallParserRuleCall_1_0 = (RuleCall)cHeadAssignment_1.eContents().get(0);
		private final Keyword cColonHyphenMinusKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cBodyAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cBodyExpressionParserRuleCall_3_0 = (RuleCall)cBodyAssignment_3.eContents().get(0);
		
		//PredicateDefinition:
		//	(functional?="functional" error?="error"? | error?="error" functional?="functional"?) head=Call ":-" body=Expression;
		@Override public ParserRule getRule() { return rule; }
		
		//(functional?="functional" error?="error"? | error?="error" functional?="functional"?) head=Call ":-" body=Expression
		public Group getGroup() { return cGroup; }
		
		//(functional?="functional" error?="error"? | error?="error" functional?="functional"?)
		public Alternatives getAlternatives_0() { return cAlternatives_0; }
		
		//functional?="functional" error?="error"?
		public Group getGroup_0_0() { return cGroup_0_0; }
		
		//functional?="functional"
		public Assignment getFunctionalAssignment_0_0_0() { return cFunctionalAssignment_0_0_0; }
		
		//"functional"
		public Keyword getFunctionalFunctionalKeyword_0_0_0_0() { return cFunctionalFunctionalKeyword_0_0_0_0; }
		
		//error?="error"?
		public Assignment getErrorAssignment_0_0_1() { return cErrorAssignment_0_0_1; }
		
		//"error"
		public Keyword getErrorErrorKeyword_0_0_1_0() { return cErrorErrorKeyword_0_0_1_0; }
		
		//error?="error" functional?="functional"?
		public Group getGroup_0_1() { return cGroup_0_1; }
		
		//error?="error"
		public Assignment getErrorAssignment_0_1_0() { return cErrorAssignment_0_1_0; }
		
		//"error"
		public Keyword getErrorErrorKeyword_0_1_0_0() { return cErrorErrorKeyword_0_1_0_0; }
		
		//functional?="functional"?
		public Assignment getFunctionalAssignment_0_1_1() { return cFunctionalAssignment_0_1_1; }
		
		//"functional"
		public Keyword getFunctionalFunctionalKeyword_0_1_1_0() { return cFunctionalFunctionalKeyword_0_1_1_0; }
		
		//head=Call
		public Assignment getHeadAssignment_1() { return cHeadAssignment_1; }
		
		//Call
		public RuleCall getHeadCallParserRuleCall_1_0() { return cHeadCallParserRuleCall_1_0; }
		
		//":-"
		public Keyword getColonHyphenMinusKeyword_2() { return cColonHyphenMinusKeyword_2; }
		
		//body=Expression
		public Assignment getBodyAssignment_3() { return cBodyAssignment_3; }
		
		//Expression
		public RuleCall getBodyExpressionParserRuleCall_3_0() { return cBodyExpressionParserRuleCall_3_0; }
	}
	public class UnnamedErrorPrediateDefinitionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.viatra.solver.language.SolverLanguage.UnnamedErrorPrediateDefinition");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cErrorKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cArgumentListAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cArgumentListArgumentListParserRuleCall_1_0 = (RuleCall)cArgumentListAssignment_1.eContents().get(0);
		private final Keyword cColonHyphenMinusKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cBodyAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cBodyExpressionParserRuleCall_3_0 = (RuleCall)cBodyAssignment_3.eContents().get(0);
		
		//UnnamedErrorPrediateDefinition:
		//	"error" argumentList=ArgumentList ":-" body=Expression;
		@Override public ParserRule getRule() { return rule; }
		
		//"error" argumentList=ArgumentList ":-" body=Expression
		public Group getGroup() { return cGroup; }
		
		//"error"
		public Keyword getErrorKeyword_0() { return cErrorKeyword_0; }
		
		//argumentList=ArgumentList
		public Assignment getArgumentListAssignment_1() { return cArgumentListAssignment_1; }
		
		//ArgumentList
		public RuleCall getArgumentListArgumentListParserRuleCall_1_0() { return cArgumentListArgumentListParserRuleCall_1_0; }
		
		//":-"
		public Keyword getColonHyphenMinusKeyword_2() { return cColonHyphenMinusKeyword_2; }
		
		//body=Expression
		public Assignment getBodyAssignment_3() { return cBodyAssignment_3; }
		
		//Expression
		public RuleCall getBodyExpressionParserRuleCall_3_0() { return cBodyExpressionParserRuleCall_3_0; }
	}
	public class DefaultDefinitionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.viatra.solver.language.SolverLanguage.DefaultDefinition");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cDefaultKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cHeadAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cHeadCallParserRuleCall_1_0 = (RuleCall)cHeadAssignment_1.eContents().get(0);
		private final Keyword cColonKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cRangeAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cRangeExpressionParserRuleCall_3_0 = (RuleCall)cRangeAssignment_3.eContents().get(0);
		
		//DefaultDefinition:
		//	"default" head=Call ":" range=Expression;
		@Override public ParserRule getRule() { return rule; }
		
		//"default" head=Call ":" range=Expression
		public Group getGroup() { return cGroup; }
		
		//"default"
		public Keyword getDefaultKeyword_0() { return cDefaultKeyword_0; }
		
		//head=Call
		public Assignment getHeadAssignment_1() { return cHeadAssignment_1; }
		
		//Call
		public RuleCall getHeadCallParserRuleCall_1_0() { return cHeadCallParserRuleCall_1_0; }
		
		//":"
		public Keyword getColonKeyword_2() { return cColonKeyword_2; }
		
		//range=Expression
		public Assignment getRangeAssignment_3() { return cRangeAssignment_3; }
		
		//Expression
		public RuleCall getRangeExpressionParserRuleCall_3_0() { return cRangeExpressionParserRuleCall_3_0; }
	}
	public class ExternPredicateDefinitionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.viatra.solver.language.SolverLanguage.ExternPredicateDefinition");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cExternKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cHeadAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cHeadCallParserRuleCall_1_0 = (RuleCall)cHeadAssignment_1.eContents().get(0);
		
		//ExternPredicateDefinition:
		//	"extern" head=Call;
		@Override public ParserRule getRule() { return rule; }
		
		//"extern" head=Call
		public Group getGroup() { return cGroup; }
		
		//"extern"
		public Keyword getExternKeyword_0() { return cExternKeyword_0; }
		
		//head=Call
		public Assignment getHeadAssignment_1() { return cHeadAssignment_1; }
		
		//Call
		public RuleCall getHeadCallParserRuleCall_1_0() { return cHeadCallParserRuleCall_1_0; }
	}
	public class MetricDefinitionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.viatra.solver.language.SolverLanguage.MetricDefinition");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cTypeAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cTypeMetricTypeEnumRuleCall_0_0 = (RuleCall)cTypeAssignment_0.eContents().get(0);
		private final Assignment cHeadAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cHeadExpressionParserRuleCall_1_0 = (RuleCall)cHeadAssignment_1.eContents().get(0);
		private final Keyword cEqualsSignKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cBodyAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cBodyExpressionParserRuleCall_3_0 = (RuleCall)cBodyAssignment_3.eContents().get(0);
		
		//MetricDefinition:
		//	type=MetricType head=Expression "=" body=Expression;
		@Override public ParserRule getRule() { return rule; }
		
		//type=MetricType head=Expression "=" body=Expression
		public Group getGroup() { return cGroup; }
		
		//type=MetricType
		public Assignment getTypeAssignment_0() { return cTypeAssignment_0; }
		
		//MetricType
		public RuleCall getTypeMetricTypeEnumRuleCall_0_0() { return cTypeMetricTypeEnumRuleCall_0_0; }
		
		//head=Expression
		public Assignment getHeadAssignment_1() { return cHeadAssignment_1; }
		
		//Expression
		public RuleCall getHeadExpressionParserRuleCall_1_0() { return cHeadExpressionParserRuleCall_1_0; }
		
		//"="
		public Keyword getEqualsSignKeyword_2() { return cEqualsSignKeyword_2; }
		
		//body=Expression
		public Assignment getBodyAssignment_3() { return cBodyAssignment_3; }
		
		//Expression
		public RuleCall getBodyExpressionParserRuleCall_3_0() { return cBodyExpressionParserRuleCall_3_0; }
	}
	public class ExternMetricDefinitionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.viatra.solver.language.SolverLanguage.ExternMetricDefinition");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cExternKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cTypeAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cTypeMetricTypeEnumRuleCall_1_0 = (RuleCall)cTypeAssignment_1.eContents().get(0);
		private final Assignment cHeadAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cHeadCallParserRuleCall_2_0 = (RuleCall)cHeadAssignment_2.eContents().get(0);
		
		//ExternMetricDefinition:
		//	"extern" type=MetricType head=Call;
		@Override public ParserRule getRule() { return rule; }
		
		//"extern" type=MetricType head=Call
		public Group getGroup() { return cGroup; }
		
		//"extern"
		public Keyword getExternKeyword_0() { return cExternKeyword_0; }
		
		//type=MetricType
		public Assignment getTypeAssignment_1() { return cTypeAssignment_1; }
		
		//MetricType
		public RuleCall getTypeMetricTypeEnumRuleCall_1_0() { return cTypeMetricTypeEnumRuleCall_1_0; }
		
		//head=Call
		public Assignment getHeadAssignment_2() { return cHeadAssignment_2; }
		
		//Call
		public RuleCall getHeadCallParserRuleCall_2_0() { return cHeadCallParserRuleCall_2_0; }
	}
	public class ExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.viatra.solver.language.SolverLanguage.Expression");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cIfElseParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cDisjunctiveExpressionParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//Expression:
		//	IfElse | DisjunctiveExpression;
		@Override public ParserRule getRule() { return rule; }
		
		//IfElse | DisjunctiveExpression
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//IfElse
		public RuleCall getIfElseParserRuleCall_0() { return cIfElseParserRuleCall_0; }
		
		//DisjunctiveExpression
		public RuleCall getDisjunctiveExpressionParserRuleCall_1() { return cDisjunctiveExpressionParserRuleCall_1; }
	}
	public class IfElseElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.viatra.solver.language.SolverLanguage.IfElse");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cIfKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cConditionAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cConditionExpressionParserRuleCall_1_0 = (RuleCall)cConditionAssignment_1.eContents().get(0);
		private final Keyword cThenKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cThenAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cThenExpressionParserRuleCall_3_0 = (RuleCall)cThenAssignment_3.eContents().get(0);
		private final Keyword cElseKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Assignment cElseAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final RuleCall cElseExpressionParserRuleCall_5_0 = (RuleCall)cElseAssignment_5.eContents().get(0);
		
		//IfElse:
		//	"if" condition=Expression "then" then=Expression "else" else=Expression;
		@Override public ParserRule getRule() { return rule; }
		
		//"if" condition=Expression "then" then=Expression "else" else=Expression
		public Group getGroup() { return cGroup; }
		
		//"if"
		public Keyword getIfKeyword_0() { return cIfKeyword_0; }
		
		//condition=Expression
		public Assignment getConditionAssignment_1() { return cConditionAssignment_1; }
		
		//Expression
		public RuleCall getConditionExpressionParserRuleCall_1_0() { return cConditionExpressionParserRuleCall_1_0; }
		
		//"then"
		public Keyword getThenKeyword_2() { return cThenKeyword_2; }
		
		//then=Expression
		public Assignment getThenAssignment_3() { return cThenAssignment_3; }
		
		//Expression
		public RuleCall getThenExpressionParserRuleCall_3_0() { return cThenExpressionParserRuleCall_3_0; }
		
		//"else"
		public Keyword getElseKeyword_4() { return cElseKeyword_4; }
		
		//else=Expression
		public Assignment getElseAssignment_5() { return cElseAssignment_5; }
		
		//Expression
		public RuleCall getElseExpressionParserRuleCall_5_0() { return cElseExpressionParserRuleCall_5_0; }
	}
	public class DisjunctiveExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.viatra.solver.language.SolverLanguage.DisjunctiveExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cConjunctiveExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Alternatives cAlternatives_1 = (Alternatives)cGroup.eContents().get(1);
		private final Group cGroup_1_0 = (Group)cAlternatives_1.eContents().get(0);
		private final Action cDisjunctionChildrenAction_1_0_0 = (Action)cGroup_1_0.eContents().get(0);
		private final Group cGroup_1_0_1 = (Group)cGroup_1_0.eContents().get(1);
		private final Keyword cSemicolonKeyword_1_0_1_0 = (Keyword)cGroup_1_0_1.eContents().get(0);
		private final Assignment cChildrenAssignment_1_0_1_1 = (Assignment)cGroup_1_0_1.eContents().get(1);
		private final RuleCall cChildrenConjunctiveExpressionParserRuleCall_1_0_1_1_0 = (RuleCall)cChildrenAssignment_1_0_1_1.eContents().get(0);
		private final Group cGroup_1_1 = (Group)cAlternatives_1.eContents().get(1);
		private final Action cCaseConditionAction_1_1_0 = (Action)cGroup_1_1.eContents().get(0);
		private final Keyword cHyphenMinusGreaterThanSignKeyword_1_1_1 = (Keyword)cGroup_1_1.eContents().get(1);
		private final Assignment cBodyAssignment_1_1_2 = (Assignment)cGroup_1_1.eContents().get(2);
		private final RuleCall cBodyConjunctiveExpressionParserRuleCall_1_1_2_0 = (RuleCall)cBodyAssignment_1_1_2.eContents().get(0);
		private final Action cSwitchCasesAction_1_1_3 = (Action)cGroup_1_1.eContents().get(3);
		private final Group cGroup_1_1_4 = (Group)cGroup_1_1.eContents().get(4);
		private final Keyword cSemicolonKeyword_1_1_4_0 = (Keyword)cGroup_1_1_4.eContents().get(0);
		private final Assignment cCasesAssignment_1_1_4_1 = (Assignment)cGroup_1_1_4.eContents().get(1);
		private final RuleCall cCasesCaseParserRuleCall_1_1_4_1_0 = (RuleCall)cCasesAssignment_1_1_4_1.eContents().get(0);
		
		//DisjunctiveExpression Expression:
		//	ConjunctiveExpression ({Disjunction.children+=current} (";" children+=ConjunctiveExpression)+ |
		//	{Case.condition=current} "->" body=ConjunctiveExpression {Switch.cases+=current} (";" cases+=Case)*)?;
		@Override public ParserRule getRule() { return rule; }
		
		//ConjunctiveExpression ({Disjunction.children+=current} (";" children+=ConjunctiveExpression)+ | {Case.condition=current}
		//"->" body=ConjunctiveExpression {Switch.cases+=current} (";" cases+=Case)*)?
		public Group getGroup() { return cGroup; }
		
		//ConjunctiveExpression
		public RuleCall getConjunctiveExpressionParserRuleCall_0() { return cConjunctiveExpressionParserRuleCall_0; }
		
		//({Disjunction.children+=current} (";" children+=ConjunctiveExpression)+ | {Case.condition=current} "->"
		//body=ConjunctiveExpression {Switch.cases+=current} (";" cases+=Case)*)?
		public Alternatives getAlternatives_1() { return cAlternatives_1; }
		
		//{Disjunction.children+=current} (";" children+=ConjunctiveExpression)+
		public Group getGroup_1_0() { return cGroup_1_0; }
		
		//{Disjunction.children+=current}
		public Action getDisjunctionChildrenAction_1_0_0() { return cDisjunctionChildrenAction_1_0_0; }
		
		//(";" children+=ConjunctiveExpression)+
		public Group getGroup_1_0_1() { return cGroup_1_0_1; }
		
		//";"
		public Keyword getSemicolonKeyword_1_0_1_0() { return cSemicolonKeyword_1_0_1_0; }
		
		//children+=ConjunctiveExpression
		public Assignment getChildrenAssignment_1_0_1_1() { return cChildrenAssignment_1_0_1_1; }
		
		//ConjunctiveExpression
		public RuleCall getChildrenConjunctiveExpressionParserRuleCall_1_0_1_1_0() { return cChildrenConjunctiveExpressionParserRuleCall_1_0_1_1_0; }
		
		//{Case.condition=current} "->" body=ConjunctiveExpression {Switch.cases+=current} (";" cases+=Case)*
		public Group getGroup_1_1() { return cGroup_1_1; }
		
		//{Case.condition=current}
		public Action getCaseConditionAction_1_1_0() { return cCaseConditionAction_1_1_0; }
		
		//"->"
		public Keyword getHyphenMinusGreaterThanSignKeyword_1_1_1() { return cHyphenMinusGreaterThanSignKeyword_1_1_1; }
		
		//body=ConjunctiveExpression
		public Assignment getBodyAssignment_1_1_2() { return cBodyAssignment_1_1_2; }
		
		//ConjunctiveExpression
		public RuleCall getBodyConjunctiveExpressionParserRuleCall_1_1_2_0() { return cBodyConjunctiveExpressionParserRuleCall_1_1_2_0; }
		
		//{Switch.cases+=current}
		public Action getSwitchCasesAction_1_1_3() { return cSwitchCasesAction_1_1_3; }
		
		//(";" cases+=Case)*
		public Group getGroup_1_1_4() { return cGroup_1_1_4; }
		
		//";"
		public Keyword getSemicolonKeyword_1_1_4_0() { return cSemicolonKeyword_1_1_4_0; }
		
		//cases+=Case
		public Assignment getCasesAssignment_1_1_4_1() { return cCasesAssignment_1_1_4_1; }
		
		//Case
		public RuleCall getCasesCaseParserRuleCall_1_1_4_1_0() { return cCasesCaseParserRuleCall_1_1_4_1_0; }
	}
	public class CaseElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.viatra.solver.language.SolverLanguage.Case");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cConditionAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cConditionConjunctiveExpressionParserRuleCall_0_0 = (RuleCall)cConditionAssignment_0.eContents().get(0);
		private final Keyword cHyphenMinusGreaterThanSignKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cBodyAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cBodyConjunctiveExpressionParserRuleCall_2_0 = (RuleCall)cBodyAssignment_2.eContents().get(0);
		
		//Case:
		//	condition=ConjunctiveExpression "->" body=ConjunctiveExpression;
		@Override public ParserRule getRule() { return rule; }
		
		//condition=ConjunctiveExpression "->" body=ConjunctiveExpression
		public Group getGroup() { return cGroup; }
		
		//condition=ConjunctiveExpression
		public Assignment getConditionAssignment_0() { return cConditionAssignment_0; }
		
		//ConjunctiveExpression
		public RuleCall getConditionConjunctiveExpressionParserRuleCall_0_0() { return cConditionConjunctiveExpressionParserRuleCall_0_0; }
		
		//"->"
		public Keyword getHyphenMinusGreaterThanSignKeyword_1() { return cHyphenMinusGreaterThanSignKeyword_1; }
		
		//body=ConjunctiveExpression
		public Assignment getBodyAssignment_2() { return cBodyAssignment_2; }
		
		//ConjunctiveExpression
		public RuleCall getBodyConjunctiveExpressionParserRuleCall_2_0() { return cBodyConjunctiveExpressionParserRuleCall_2_0; }
	}
	public class ConjunctiveExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.viatra.solver.language.SolverLanguage.ConjunctiveExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cComparisonExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cConjunctionChildrenAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Group cGroup_1_1 = (Group)cGroup_1.eContents().get(1);
		private final Keyword cCommaKeyword_1_1_0 = (Keyword)cGroup_1_1.eContents().get(0);
		private final Assignment cChildrenAssignment_1_1_1 = (Assignment)cGroup_1_1.eContents().get(1);
		private final RuleCall cChildrenComparisonExpressionParserRuleCall_1_1_1_0 = (RuleCall)cChildrenAssignment_1_1_1.eContents().get(0);
		
		//ConjunctiveExpression Expression:
		//	ComparisonExpression ({Conjunction.children+=current} ("," children+=ComparisonExpression)+)?;
		@Override public ParserRule getRule() { return rule; }
		
		//ComparisonExpression ({Conjunction.children+=current} ("," children+=ComparisonExpression)+)?
		public Group getGroup() { return cGroup; }
		
		//ComparisonExpression
		public RuleCall getComparisonExpressionParserRuleCall_0() { return cComparisonExpressionParserRuleCall_0; }
		
		//({Conjunction.children+=current} ("," children+=ComparisonExpression)+)?
		public Group getGroup_1() { return cGroup_1; }
		
		//{Conjunction.children+=current}
		public Action getConjunctionChildrenAction_1_0() { return cConjunctionChildrenAction_1_0; }
		
		//("," children+=ComparisonExpression)+
		public Group getGroup_1_1() { return cGroup_1_1; }
		
		//","
		public Keyword getCommaKeyword_1_1_0() { return cCommaKeyword_1_1_0; }
		
		//children+=ComparisonExpression
		public Assignment getChildrenAssignment_1_1_1() { return cChildrenAssignment_1_1_1; }
		
		//ComparisonExpression
		public RuleCall getChildrenComparisonExpressionParserRuleCall_1_1_1_0() { return cChildrenComparisonExpressionParserRuleCall_1_1_1_0; }
	}
	public class ComparisonExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.viatra.solver.language.SolverLanguage.ComparisonExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cAdditiveExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cComparisonLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOpAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cOpComparisonOperatorEnumRuleCall_1_1_0 = (RuleCall)cOpAssignment_1_1.eContents().get(0);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightAdditiveExpressionParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//ComparisonExpression Expression:
		//	AdditiveExpression ({Comparison.left=current} op=ComparisonOperator right=AdditiveExpression)?;
		@Override public ParserRule getRule() { return rule; }
		
		//AdditiveExpression ({Comparison.left=current} op=ComparisonOperator right=AdditiveExpression)?
		public Group getGroup() { return cGroup; }
		
		//AdditiveExpression
		public RuleCall getAdditiveExpressionParserRuleCall_0() { return cAdditiveExpressionParserRuleCall_0; }
		
		//({Comparison.left=current} op=ComparisonOperator right=AdditiveExpression)?
		public Group getGroup_1() { return cGroup_1; }
		
		//{Comparison.left=current}
		public Action getComparisonLeftAction_1_0() { return cComparisonLeftAction_1_0; }
		
		//op=ComparisonOperator
		public Assignment getOpAssignment_1_1() { return cOpAssignment_1_1; }
		
		//ComparisonOperator
		public RuleCall getOpComparisonOperatorEnumRuleCall_1_1_0() { return cOpComparisonOperatorEnumRuleCall_1_1_0; }
		
		//right=AdditiveExpression
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }
		
		//AdditiveExpression
		public RuleCall getRightAdditiveExpressionParserRuleCall_1_2_0() { return cRightAdditiveExpressionParserRuleCall_1_2_0; }
	}
	public class AdditiveExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.viatra.solver.language.SolverLanguage.AdditiveExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cMultiplicativeExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cBinaryExpressionLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOpAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cOpAdditiveBinaryOperatorEnumRuleCall_1_1_0 = (RuleCall)cOpAssignment_1_1.eContents().get(0);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightMultiplicativeExpressionParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//AdditiveExpression Expression:
		//	MultiplicativeExpression ({BinaryExpression.left=current} op=AdditiveBinaryOperator right=MultiplicativeExpression)*;
		@Override public ParserRule getRule() { return rule; }
		
		//MultiplicativeExpression ({BinaryExpression.left=current} op=AdditiveBinaryOperator right=MultiplicativeExpression)*
		public Group getGroup() { return cGroup; }
		
		//MultiplicativeExpression
		public RuleCall getMultiplicativeExpressionParserRuleCall_0() { return cMultiplicativeExpressionParserRuleCall_0; }
		
		//({BinaryExpression.left=current} op=AdditiveBinaryOperator right=MultiplicativeExpression)*
		public Group getGroup_1() { return cGroup_1; }
		
		//{BinaryExpression.left=current}
		public Action getBinaryExpressionLeftAction_1_0() { return cBinaryExpressionLeftAction_1_0; }
		
		//op=AdditiveBinaryOperator
		public Assignment getOpAssignment_1_1() { return cOpAssignment_1_1; }
		
		//AdditiveBinaryOperator
		public RuleCall getOpAdditiveBinaryOperatorEnumRuleCall_1_1_0() { return cOpAdditiveBinaryOperatorEnumRuleCall_1_1_0; }
		
		//right=MultiplicativeExpression
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }
		
		//MultiplicativeExpression
		public RuleCall getRightMultiplicativeExpressionParserRuleCall_1_2_0() { return cRightMultiplicativeExpressionParserRuleCall_1_2_0; }
	}
	public class MultiplicativeExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.viatra.solver.language.SolverLanguage.MultiplicativeExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cExponentialExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cBinaryExpressionLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOpAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cOpMultiplicativeBinaryOperatorEnumRuleCall_1_1_0 = (RuleCall)cOpAssignment_1_1.eContents().get(0);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightExponentialExpressionParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//MultiplicativeExpression Expression:
		//	ExponentialExpression ({BinaryExpression.left=current} op=MultiplicativeBinaryOperator right=ExponentialExpression)*;
		@Override public ParserRule getRule() { return rule; }
		
		//ExponentialExpression ({BinaryExpression.left=current} op=MultiplicativeBinaryOperator right=ExponentialExpression)*
		public Group getGroup() { return cGroup; }
		
		//ExponentialExpression
		public RuleCall getExponentialExpressionParserRuleCall_0() { return cExponentialExpressionParserRuleCall_0; }
		
		//({BinaryExpression.left=current} op=MultiplicativeBinaryOperator right=ExponentialExpression)*
		public Group getGroup_1() { return cGroup_1; }
		
		//{BinaryExpression.left=current}
		public Action getBinaryExpressionLeftAction_1_0() { return cBinaryExpressionLeftAction_1_0; }
		
		//op=MultiplicativeBinaryOperator
		public Assignment getOpAssignment_1_1() { return cOpAssignment_1_1; }
		
		//MultiplicativeBinaryOperator
		public RuleCall getOpMultiplicativeBinaryOperatorEnumRuleCall_1_1_0() { return cOpMultiplicativeBinaryOperatorEnumRuleCall_1_1_0; }
		
		//right=ExponentialExpression
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }
		
		//ExponentialExpression
		public RuleCall getRightExponentialExpressionParserRuleCall_1_2_0() { return cRightExponentialExpressionParserRuleCall_1_2_0; }
	}
	public class ExponentialExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.viatra.solver.language.SolverLanguage.ExponentialExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cUnaryExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cBinaryExpressionLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOpAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cOpExponentialOpEnumRuleCall_1_1_0 = (RuleCall)cOpAssignment_1_1.eContents().get(0);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightExponentialExpressionParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//ExponentialExpression Expression:
		//	UnaryExpression ({BinaryExpression.left=current} op=ExponentialOp right=ExponentialExpression)?;
		@Override public ParserRule getRule() { return rule; }
		
		//UnaryExpression ({BinaryExpression.left=current} op=ExponentialOp right=ExponentialExpression)?
		public Group getGroup() { return cGroup; }
		
		//UnaryExpression
		public RuleCall getUnaryExpressionParserRuleCall_0() { return cUnaryExpressionParserRuleCall_0; }
		
		//({BinaryExpression.left=current} op=ExponentialOp right=ExponentialExpression)?
		public Group getGroup_1() { return cGroup_1; }
		
		//{BinaryExpression.left=current}
		public Action getBinaryExpressionLeftAction_1_0() { return cBinaryExpressionLeftAction_1_0; }
		
		//op=ExponentialOp
		public Assignment getOpAssignment_1_1() { return cOpAssignment_1_1; }
		
		//ExponentialOp
		public RuleCall getOpExponentialOpEnumRuleCall_1_1_0() { return cOpExponentialOpEnumRuleCall_1_1_0; }
		
		//right=ExponentialExpression
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }
		
		//ExponentialExpression
		public RuleCall getRightExponentialExpressionParserRuleCall_1_2_0() { return cRightExponentialExpressionParserRuleCall_1_2_0; }
	}
	public class UnaryExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.viatra.solver.language.SolverLanguage.UnaryExpression");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cAggregationExpressionParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Action cUnaryExpressionAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOpAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cOpUnaryOpEnumRuleCall_1_1_0 = (RuleCall)cOpAssignment_1_1.eContents().get(0);
		private final Assignment cBodyAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cBodyAggregationExpressionParserRuleCall_1_2_0 = (RuleCall)cBodyAssignment_1_2.eContents().get(0);
		
		//UnaryExpression Expression:
		//	AggregationExpression | {UnaryExpression} op=UnaryOp body=AggregationExpression;
		@Override public ParserRule getRule() { return rule; }
		
		//AggregationExpression | {UnaryExpression} op=UnaryOp body=AggregationExpression
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//AggregationExpression
		public RuleCall getAggregationExpressionParserRuleCall_0() { return cAggregationExpressionParserRuleCall_0; }
		
		//{UnaryExpression} op=UnaryOp body=AggregationExpression
		public Group getGroup_1() { return cGroup_1; }
		
		//{UnaryExpression}
		public Action getUnaryExpressionAction_1_0() { return cUnaryExpressionAction_1_0; }
		
		//op=UnaryOp
		public Assignment getOpAssignment_1_1() { return cOpAssignment_1_1; }
		
		//UnaryOp
		public RuleCall getOpUnaryOpEnumRuleCall_1_1_0() { return cOpUnaryOpEnumRuleCall_1_1_0; }
		
		//body=AggregationExpression
		public Assignment getBodyAssignment_1_2() { return cBodyAssignment_1_2; }
		
		//AggregationExpression
		public RuleCall getBodyAggregationExpressionParserRuleCall_1_2_0() { return cBodyAggregationExpressionParserRuleCall_1_2_0; }
	}
	public class AggregationExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.viatra.solver.language.SolverLanguage.AggregationExpression");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cAtomicExpressionParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cCountParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cAggregationParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		
		//AggregationExpression Expression:
		//	AtomicExpression | Count | Aggregation;
		@Override public ParserRule getRule() { return rule; }
		
		//AtomicExpression | Count | Aggregation
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//AtomicExpression
		public RuleCall getAtomicExpressionParserRuleCall_0() { return cAtomicExpressionParserRuleCall_0; }
		
		//Count
		public RuleCall getCountParserRuleCall_1() { return cCountParserRuleCall_1; }
		
		//Aggregation
		public RuleCall getAggregationParserRuleCall_2() { return cAggregationParserRuleCall_2; }
	}
	public class CountElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.viatra.solver.language.SolverLanguage.Count");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cCountKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cBodyAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cBodyExpressionParserRuleCall_2_0 = (RuleCall)cBodyAssignment_2.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//Count:
		//	"count" "{" body=Expression "}";
		@Override public ParserRule getRule() { return rule; }
		
		//"count" "{" body=Expression "}"
		public Group getGroup() { return cGroup; }
		
		//"count"
		public Keyword getCountKeyword_0() { return cCountKeyword_0; }
		
		//"{"
		public Keyword getLeftCurlyBracketKeyword_1() { return cLeftCurlyBracketKeyword_1; }
		
		//body=Expression
		public Assignment getBodyAssignment_2() { return cBodyAssignment_2; }
		
		//Expression
		public RuleCall getBodyExpressionParserRuleCall_2_0() { return cBodyExpressionParserRuleCall_2_0; }
		
		//"}"
		public Keyword getRightCurlyBracketKeyword_3() { return cRightCurlyBracketKeyword_3; }
	}
	public class AggregationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.viatra.solver.language.SolverLanguage.Aggregation");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cOpAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cOpAggregationOpEnumRuleCall_0_0 = (RuleCall)cOpAssignment_0.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cBodyAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cBodyExpressionParserRuleCall_2_0 = (RuleCall)cBodyAssignment_2.eContents().get(0);
		private final Keyword cVerticalLineKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cConditionAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cConditionExpressionParserRuleCall_4_0 = (RuleCall)cConditionAssignment_4.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_5 = (Keyword)cGroup.eContents().get(5);
		
		//Aggregation:
		//	op=AggregationOp "{" body=Expression "|" condition=Expression "}";
		@Override public ParserRule getRule() { return rule; }
		
		//op=AggregationOp "{" body=Expression "|" condition=Expression "}"
		public Group getGroup() { return cGroup; }
		
		//op=AggregationOp
		public Assignment getOpAssignment_0() { return cOpAssignment_0; }
		
		//AggregationOp
		public RuleCall getOpAggregationOpEnumRuleCall_0_0() { return cOpAggregationOpEnumRuleCall_0_0; }
		
		//"{"
		public Keyword getLeftCurlyBracketKeyword_1() { return cLeftCurlyBracketKeyword_1; }
		
		//body=Expression
		public Assignment getBodyAssignment_2() { return cBodyAssignment_2; }
		
		//Expression
		public RuleCall getBodyExpressionParserRuleCall_2_0() { return cBodyExpressionParserRuleCall_2_0; }
		
		//"|"
		public Keyword getVerticalLineKeyword_3() { return cVerticalLineKeyword_3; }
		
		//condition=Expression
		public Assignment getConditionAssignment_4() { return cConditionAssignment_4; }
		
		//Expression
		public RuleCall getConditionExpressionParserRuleCall_4_0() { return cConditionExpressionParserRuleCall_4_0; }
		
		//"}"
		public Keyword getRightCurlyBracketKeyword_5() { return cRightCurlyBracketKeyword_5; }
	}
	public class AtomicExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.viatra.solver.language.SolverLanguage.AtomicExpression");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cReferenceParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cCallParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cIntervalParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cLiteralParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		private final Group cGroup_4 = (Group)cAlternatives.eContents().get(4);
		private final Keyword cLeftParenthesisKeyword_4_0 = (Keyword)cGroup_4.eContents().get(0);
		private final RuleCall cExpressionParserRuleCall_4_1 = (RuleCall)cGroup_4.eContents().get(1);
		private final Keyword cRightParenthesisKeyword_4_2 = (Keyword)cGroup_4.eContents().get(2);
		
		//AtomicExpression Expression:
		//	Reference | Call | Interval | Literal | "(" Expression ")";
		@Override public ParserRule getRule() { return rule; }
		
		//Reference | Call | Interval | Literal | "(" Expression ")"
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//Reference
		public RuleCall getReferenceParserRuleCall_0() { return cReferenceParserRuleCall_0; }
		
		//Call
		public RuleCall getCallParserRuleCall_1() { return cCallParserRuleCall_1; }
		
		//Interval
		public RuleCall getIntervalParserRuleCall_2() { return cIntervalParserRuleCall_2; }
		
		//Literal
		public RuleCall getLiteralParserRuleCall_3() { return cLiteralParserRuleCall_3; }
		
		//"(" Expression ")"
		public Group getGroup_4() { return cGroup_4; }
		
		//"("
		public Keyword getLeftParenthesisKeyword_4_0() { return cLeftParenthesisKeyword_4_0; }
		
		//Expression
		public RuleCall getExpressionParserRuleCall_4_1() { return cExpressionParserRuleCall_4_1; }
		
		//")"
		public Keyword getRightParenthesisKeyword_4_2() { return cRightParenthesisKeyword_4_2; }
	}
	public class CallElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.viatra.solver.language.SolverLanguage.Call");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cFunctorAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cFunctorReferenceParserRuleCall_0_0 = (RuleCall)cFunctorAssignment_0.eContents().get(0);
		private final Alternatives cAlternatives_1 = (Alternatives)cGroup.eContents().get(1);
		private final Assignment cTransitiveClosureAssignment_1_0 = (Assignment)cAlternatives_1.eContents().get(0);
		private final RuleCall cTransitiveClosureTRANSITIVE_CLOSURETerminalRuleCall_1_0_0 = (RuleCall)cTransitiveClosureAssignment_1_0.eContents().get(0);
		private final Assignment cReflexiveTransitiveClosureAssignment_1_1 = (Assignment)cAlternatives_1.eContents().get(1);
		private final RuleCall cReflexiveTransitiveClosureREFLEXIVE_TRANSITIVE_CLOSURETerminalRuleCall_1_1_0 = (RuleCall)cReflexiveTransitiveClosureAssignment_1_1.eContents().get(0);
		private final Assignment cArgumentListAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cArgumentListArgumentListParserRuleCall_2_0 = (RuleCall)cArgumentListAssignment_2.eContents().get(0);
		
		//Call:
		//	functor=Reference (transitiveClosure?=TRANSITIVE_CLOSURE | reflexiveTransitiveClosure?=REFLEXIVE_TRANSITIVE_CLOSURE)?
		//	argumentList=ArgumentList;
		@Override public ParserRule getRule() { return rule; }
		
		//functor=Reference (transitiveClosure?=TRANSITIVE_CLOSURE | reflexiveTransitiveClosure?=REFLEXIVE_TRANSITIVE_CLOSURE)?
		//argumentList=ArgumentList
		public Group getGroup() { return cGroup; }
		
		//functor=Reference
		public Assignment getFunctorAssignment_0() { return cFunctorAssignment_0; }
		
		//Reference
		public RuleCall getFunctorReferenceParserRuleCall_0_0() { return cFunctorReferenceParserRuleCall_0_0; }
		
		//(transitiveClosure?=TRANSITIVE_CLOSURE | reflexiveTransitiveClosure?=REFLEXIVE_TRANSITIVE_CLOSURE)?
		public Alternatives getAlternatives_1() { return cAlternatives_1; }
		
		//transitiveClosure?=TRANSITIVE_CLOSURE
		public Assignment getTransitiveClosureAssignment_1_0() { return cTransitiveClosureAssignment_1_0; }
		
		//TRANSITIVE_CLOSURE
		public RuleCall getTransitiveClosureTRANSITIVE_CLOSURETerminalRuleCall_1_0_0() { return cTransitiveClosureTRANSITIVE_CLOSURETerminalRuleCall_1_0_0; }
		
		//reflexiveTransitiveClosure?=REFLEXIVE_TRANSITIVE_CLOSURE
		public Assignment getReflexiveTransitiveClosureAssignment_1_1() { return cReflexiveTransitiveClosureAssignment_1_1; }
		
		//REFLEXIVE_TRANSITIVE_CLOSURE
		public RuleCall getReflexiveTransitiveClosureREFLEXIVE_TRANSITIVE_CLOSURETerminalRuleCall_1_1_0() { return cReflexiveTransitiveClosureREFLEXIVE_TRANSITIVE_CLOSURETerminalRuleCall_1_1_0; }
		
		//argumentList=ArgumentList
		public Assignment getArgumentListAssignment_2() { return cArgumentListAssignment_2; }
		
		//ArgumentList
		public RuleCall getArgumentListArgumentListParserRuleCall_2_0() { return cArgumentListArgumentListParserRuleCall_2_0; }
	}
	public class ArgumentListElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.viatra.solver.language.SolverLanguage.ArgumentList");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cArgumentListAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Assignment cArgumentsAssignment_2_0 = (Assignment)cGroup_2.eContents().get(0);
		private final RuleCall cArgumentsArgumentParserRuleCall_2_0_0 = (RuleCall)cArgumentsAssignment_2_0.eContents().get(0);
		private final Group cGroup_2_1 = (Group)cGroup_2.eContents().get(1);
		private final Keyword cCommaKeyword_2_1_0 = (Keyword)cGroup_2_1.eContents().get(0);
		private final Assignment cArgumentsAssignment_2_1_1 = (Assignment)cGroup_2_1.eContents().get(1);
		private final RuleCall cArgumentsArgumentParserRuleCall_2_1_1_0 = (RuleCall)cArgumentsAssignment_2_1_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//ArgumentList:
		//	{ArgumentList} "(" (arguments+=Argument ("," arguments+=Argument)*)? ")";
		@Override public ParserRule getRule() { return rule; }
		
		//{ArgumentList} "(" (arguments+=Argument ("," arguments+=Argument)*)? ")"
		public Group getGroup() { return cGroup; }
		
		//{ArgumentList}
		public Action getArgumentListAction_0() { return cArgumentListAction_0; }
		
		//"("
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }
		
		//(arguments+=Argument ("," arguments+=Argument)*)?
		public Group getGroup_2() { return cGroup_2; }
		
		//arguments+=Argument
		public Assignment getArgumentsAssignment_2_0() { return cArgumentsAssignment_2_0; }
		
		//Argument
		public RuleCall getArgumentsArgumentParserRuleCall_2_0_0() { return cArgumentsArgumentParserRuleCall_2_0_0; }
		
		//("," arguments+=Argument)*
		public Group getGroup_2_1() { return cGroup_2_1; }
		
		//","
		public Keyword getCommaKeyword_2_1_0() { return cCommaKeyword_2_1_0; }
		
		//arguments+=Argument
		public Assignment getArgumentsAssignment_2_1_1() { return cArgumentsAssignment_2_1_1; }
		
		//Argument
		public RuleCall getArgumentsArgumentParserRuleCall_2_1_1_0() { return cArgumentsArgumentParserRuleCall_2_1_1_0; }
		
		//")"
		public Keyword getRightParenthesisKeyword_3() { return cRightParenthesisKeyword_3; }
	}
	public class ArgumentElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.viatra.solver.language.SolverLanguage.Argument");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cExpressionArgumentParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cStarArgumentParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cTypedArgumentParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cTypedStarArgumentParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		
		//Argument:
		//	ExpressionArgument | StarArgument | TypedArgument | TypedStarArgument;
		@Override public ParserRule getRule() { return rule; }
		
		//ExpressionArgument | StarArgument | TypedArgument | TypedStarArgument
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//ExpressionArgument
		public RuleCall getExpressionArgumentParserRuleCall_0() { return cExpressionArgumentParserRuleCall_0; }
		
		//StarArgument
		public RuleCall getStarArgumentParserRuleCall_1() { return cStarArgumentParserRuleCall_1; }
		
		//TypedArgument
		public RuleCall getTypedArgumentParserRuleCall_2() { return cTypedArgumentParserRuleCall_2; }
		
		//TypedStarArgument
		public RuleCall getTypedStarArgumentParserRuleCall_3() { return cTypedStarArgumentParserRuleCall_3; }
	}
	public class ExpressionArgumentElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.viatra.solver.language.SolverLanguage.ExpressionArgument");
		private final Assignment cBodyAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cBodyComparisonExpressionParserRuleCall_0 = (RuleCall)cBodyAssignment.eContents().get(0);
		
		//ExpressionArgument:
		//	body=ComparisonExpression;
		@Override public ParserRule getRule() { return rule; }
		
		//body=ComparisonExpression
		public Assignment getBodyAssignment() { return cBodyAssignment; }
		
		//ComparisonExpression
		public RuleCall getBodyComparisonExpressionParserRuleCall_0() { return cBodyComparisonExpressionParserRuleCall_0; }
	}
	public class StarArgumentElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.viatra.solver.language.SolverLanguage.StarArgument");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cStarArgumentAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cAsteriskKeyword_1 = (Keyword)cGroup.eContents().get(1);
		
		//StarArgument:
		//	{StarArgument} "*";
		@Override public ParserRule getRule() { return rule; }
		
		//{StarArgument} "*"
		public Group getGroup() { return cGroup; }
		
		//{StarArgument}
		public Action getStarArgumentAction_0() { return cStarArgumentAction_0; }
		
		//"*"
		public Keyword getAsteriskKeyword_1() { return cAsteriskKeyword_1; }
	}
	public class TypedArgumentElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.viatra.solver.language.SolverLanguage.TypedArgument");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cTypeAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final CrossReference cTypeNamedElementCrossReference_0_0 = (CrossReference)cTypeAssignment_0.eContents().get(0);
		private final RuleCall cTypeNamedElementQualifiedNameParserRuleCall_0_0_1 = (RuleCall)cTypeNamedElementCrossReference_0_0.eContents().get(1);
		private final Assignment cVariableAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final CrossReference cVariableNamedElementCrossReference_1_0 = (CrossReference)cVariableAssignment_1.eContents().get(0);
		private final RuleCall cVariableNamedElementQualifiedNameParserRuleCall_1_0_1 = (RuleCall)cVariableNamedElementCrossReference_1_0.eContents().get(1);
		
		//TypedArgument:
		//	type=[NamedElement|QualifiedName] variable=[NamedElement|QualifiedName];
		@Override public ParserRule getRule() { return rule; }
		
		//type=[NamedElement|QualifiedName] variable=[NamedElement|QualifiedName]
		public Group getGroup() { return cGroup; }
		
		//type=[NamedElement|QualifiedName]
		public Assignment getTypeAssignment_0() { return cTypeAssignment_0; }
		
		//[NamedElement|QualifiedName]
		public CrossReference getTypeNamedElementCrossReference_0_0() { return cTypeNamedElementCrossReference_0_0; }
		
		//QualifiedName
		public RuleCall getTypeNamedElementQualifiedNameParserRuleCall_0_0_1() { return cTypeNamedElementQualifiedNameParserRuleCall_0_0_1; }
		
		//variable=[NamedElement|QualifiedName]
		public Assignment getVariableAssignment_1() { return cVariableAssignment_1; }
		
		//[NamedElement|QualifiedName]
		public CrossReference getVariableNamedElementCrossReference_1_0() { return cVariableNamedElementCrossReference_1_0; }
		
		//QualifiedName
		public RuleCall getVariableNamedElementQualifiedNameParserRuleCall_1_0_1() { return cVariableNamedElementQualifiedNameParserRuleCall_1_0_1; }
	}
	public class TypedStarArgumentElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.viatra.solver.language.SolverLanguage.TypedStarArgument");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cTypeAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final CrossReference cTypeNamedElementCrossReference_0_0 = (CrossReference)cTypeAssignment_0.eContents().get(0);
		private final RuleCall cTypeNamedElementQualifiedNameParserRuleCall_0_0_1 = (RuleCall)cTypeNamedElementCrossReference_0_0.eContents().get(1);
		private final Keyword cAsteriskKeyword_1 = (Keyword)cGroup.eContents().get(1);
		
		//TypedStarArgument:
		//	type=[NamedElement|QualifiedName] "*";
		@Override public ParserRule getRule() { return rule; }
		
		//type=[NamedElement|QualifiedName] "*"
		public Group getGroup() { return cGroup; }
		
		//type=[NamedElement|QualifiedName]
		public Assignment getTypeAssignment_0() { return cTypeAssignment_0; }
		
		//[NamedElement|QualifiedName]
		public CrossReference getTypeNamedElementCrossReference_0_0() { return cTypeNamedElementCrossReference_0_0; }
		
		//QualifiedName
		public RuleCall getTypeNamedElementQualifiedNameParserRuleCall_0_0_1() { return cTypeNamedElementQualifiedNameParserRuleCall_0_0_1; }
		
		//"*"
		public Keyword getAsteriskKeyword_1() { return cAsteriskKeyword_1; }
	}
	public class ReferenceElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.viatra.solver.language.SolverLanguage.Reference");
		private final Assignment cReferredAssignment = (Assignment)rule.eContents().get(1);
		private final CrossReference cReferredNamedElementCrossReference_0 = (CrossReference)cReferredAssignment.eContents().get(0);
		private final RuleCall cReferredNamedElementQualifiedNameParserRuleCall_0_1 = (RuleCall)cReferredNamedElementCrossReference_0.eContents().get(1);
		
		//Reference:
		//	referred=[NamedElement|QualifiedName];
		@Override public ParserRule getRule() { return rule; }
		
		//referred=[NamedElement|QualifiedName]
		public Assignment getReferredAssignment() { return cReferredAssignment; }
		
		//[NamedElement|QualifiedName]
		public CrossReference getReferredNamedElementCrossReference_0() { return cReferredNamedElementCrossReference_0; }
		
		//QualifiedName
		public RuleCall getReferredNamedElementQualifiedNameParserRuleCall_0_1() { return cReferredNamedElementQualifiedNameParserRuleCall_0_1; }
	}
	public class IntervalElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.viatra.solver.language.SolverLanguage.Interval");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLeftSquareBracketKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cLowerBoundAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cLowerBoundExpressionParserRuleCall_1_0 = (RuleCall)cLowerBoundAssignment_1.eContents().get(0);
		private final Keyword cFullStopFullStopKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cUpperBoundAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cUpperBoundExpressionParserRuleCall_3_0 = (RuleCall)cUpperBoundAssignment_3.eContents().get(0);
		private final Keyword cRightSquareBracketKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//Interval:
		//	"[" lowerBound=Expression ".." upperBound=Expression "]";
		@Override public ParserRule getRule() { return rule; }
		
		//"[" lowerBound=Expression ".." upperBound=Expression "]"
		public Group getGroup() { return cGroup; }
		
		//"["
		public Keyword getLeftSquareBracketKeyword_0() { return cLeftSquareBracketKeyword_0; }
		
		//lowerBound=Expression
		public Assignment getLowerBoundAssignment_1() { return cLowerBoundAssignment_1; }
		
		//Expression
		public RuleCall getLowerBoundExpressionParserRuleCall_1_0() { return cLowerBoundExpressionParserRuleCall_1_0; }
		
		//".."
		public Keyword getFullStopFullStopKeyword_2() { return cFullStopFullStopKeyword_2; }
		
		//upperBound=Expression
		public Assignment getUpperBoundAssignment_3() { return cUpperBoundAssignment_3; }
		
		//Expression
		public RuleCall getUpperBoundExpressionParserRuleCall_3_0() { return cUpperBoundExpressionParserRuleCall_3_0; }
		
		//"]"
		public Keyword getRightSquareBracketKeyword_4() { return cRightSquareBracketKeyword_4; }
	}
	public class LiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.viatra.solver.language.SolverLanguage.Literal");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cLogicLiteralParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cNumericLiteralParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cInfinityLiteralParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cEmptyIntervalLiteralParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		private final RuleCall cStringLiteralParserRuleCall_4 = (RuleCall)cAlternatives.eContents().get(4);
		
		//Literal:
		//	LogicLiteral | NumericLiteral | InfinityLiteral | EmptyIntervalLiteral | StringLiteral;
		@Override public ParserRule getRule() { return rule; }
		
		//LogicLiteral | NumericLiteral | InfinityLiteral | EmptyIntervalLiteral | StringLiteral
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//LogicLiteral
		public RuleCall getLogicLiteralParserRuleCall_0() { return cLogicLiteralParserRuleCall_0; }
		
		//NumericLiteral
		public RuleCall getNumericLiteralParserRuleCall_1() { return cNumericLiteralParserRuleCall_1; }
		
		//InfinityLiteral
		public RuleCall getInfinityLiteralParserRuleCall_2() { return cInfinityLiteralParserRuleCall_2; }
		
		//EmptyIntervalLiteral
		public RuleCall getEmptyIntervalLiteralParserRuleCall_3() { return cEmptyIntervalLiteralParserRuleCall_3; }
		
		//StringLiteral
		public RuleCall getStringLiteralParserRuleCall_4() { return cStringLiteralParserRuleCall_4; }
	}
	public class LogicLiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.viatra.solver.language.SolverLanguage.LogicLiteral");
		private final Assignment cValueAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cValueLogicValueEnumRuleCall_0 = (RuleCall)cValueAssignment.eContents().get(0);
		
		//LogicLiteral:
		//	value=LogicValue;
		@Override public ParserRule getRule() { return rule; }
		
		//value=LogicValue
		public Assignment getValueAssignment() { return cValueAssignment; }
		
		//LogicValue
		public RuleCall getValueLogicValueEnumRuleCall_0() { return cValueLogicValueEnumRuleCall_0; }
	}
	public class NumericLiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.viatra.solver.language.SolverLanguage.NumericLiteral");
		private final Assignment cValueAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cValueRealParserRuleCall_0 = (RuleCall)cValueAssignment.eContents().get(0);
		
		//NumericLiteral:
		//	value=Real;
		@Override public ParserRule getRule() { return rule; }
		
		//value=Real
		public Assignment getValueAssignment() { return cValueAssignment; }
		
		//Real
		public RuleCall getValueRealParserRuleCall_0() { return cValueRealParserRuleCall_0; }
	}
	public class InfinityLiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.viatra.solver.language.SolverLanguage.InfinityLiteral");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cInfinityLiteralAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cInfKeyword_1 = (Keyword)cGroup.eContents().get(1);
		
		//InfinityLiteral:
		//	{InfinityLiteral} "inf";
		@Override public ParserRule getRule() { return rule; }
		
		//{InfinityLiteral} "inf"
		public Group getGroup() { return cGroup; }
		
		//{InfinityLiteral}
		public Action getInfinityLiteralAction_0() { return cInfinityLiteralAction_0; }
		
		//"inf"
		public Keyword getInfKeyword_1() { return cInfKeyword_1; }
	}
	public class EmptyIntervalLiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.viatra.solver.language.SolverLanguage.EmptyIntervalLiteral");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cEmptyIntervalLiteralAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cEmptyKeyword_1 = (Keyword)cGroup.eContents().get(1);
		
		//EmptyIntervalLiteral:
		//	{EmptyIntervalLiteral} "empty";
		@Override public ParserRule getRule() { return rule; }
		
		//{EmptyIntervalLiteral} "empty"
		public Group getGroup() { return cGroup; }
		
		//{EmptyIntervalLiteral}
		public Action getEmptyIntervalLiteralAction_0() { return cEmptyIntervalLiteralAction_0; }
		
		//"empty"
		public Keyword getEmptyKeyword_1() { return cEmptyKeyword_1; }
	}
	public class StringLiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.viatra.solver.language.SolverLanguage.StringLiteral");
		private final Assignment cValueAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cValueSTRINGTerminalRuleCall_0 = (RuleCall)cValueAssignment.eContents().get(0);
		
		//StringLiteral:
		//	value=STRING;
		@Override public ParserRule getRule() { return rule; }
		
		//value=STRING
		public Assignment getValueAssignment() { return cValueAssignment; }
		
		//STRING
		public RuleCall getValueSTRINGTerminalRuleCall_0() { return cValueSTRINGTerminalRuleCall_0; }
	}
	public class ClassDefinitionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.viatra.solver.language.SolverLanguage.ClassDefinition");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cAbstractAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Keyword cAbstractAbstractKeyword_0_0 = (Keyword)cAbstractAssignment_0.eContents().get(0);
		private final Keyword cClassKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cNameAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cNameIDTerminalRuleCall_2_0 = (RuleCall)cNameAssignment_2.eContents().get(0);
		private final Group cGroup_3 = (Group)cGroup.eContents().get(3);
		private final Keyword cExtendsKeyword_3_0 = (Keyword)cGroup_3.eContents().get(0);
		private final Assignment cSuperclassesAssignment_3_1 = (Assignment)cGroup_3.eContents().get(1);
		private final CrossReference cSuperclassesNamedElementCrossReference_3_1_0 = (CrossReference)cSuperclassesAssignment_3_1.eContents().get(0);
		private final RuleCall cSuperclassesNamedElementQualifiedNameParserRuleCall_3_1_0_1 = (RuleCall)cSuperclassesNamedElementCrossReference_3_1_0.eContents().get(1);
		private final Group cGroup_3_2 = (Group)cGroup_3.eContents().get(2);
		private final Keyword cCommaKeyword_3_2_0 = (Keyword)cGroup_3_2.eContents().get(0);
		private final Assignment cSuperclassesAssignment_3_2_1 = (Assignment)cGroup_3_2.eContents().get(1);
		private final CrossReference cSuperclassesNamedElementCrossReference_3_2_1_0 = (CrossReference)cSuperclassesAssignment_3_2_1.eContents().get(0);
		private final RuleCall cSuperclassesNamedElementQualifiedNameParserRuleCall_3_2_1_0_1 = (RuleCall)cSuperclassesNamedElementCrossReference_3_2_1_0.eContents().get(1);
		private final Keyword cLeftCurlyBracketKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Assignment cMembersAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final RuleCall cMembersMemberDefinitionParserRuleCall_5_0 = (RuleCall)cMembersAssignment_5.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_6 = (Keyword)cGroup.eContents().get(6);
		
		//ClassDefinition:
		//	abstract?="abstract"? "class" name=ID ("extends" superclasses+=[NamedElement|QualifiedName] (","
		//	superclasses+=[NamedElement|QualifiedName])*)?
		//	"{" members+=MemberDefinition* "}";
		@Override public ParserRule getRule() { return rule; }
		
		//abstract?="abstract"? "class" name=ID ("extends" superclasses+=[NamedElement|QualifiedName] (","
		//superclasses+=[NamedElement|QualifiedName])*)? "{" members+=MemberDefinition* "}"
		public Group getGroup() { return cGroup; }
		
		//abstract?="abstract"?
		public Assignment getAbstractAssignment_0() { return cAbstractAssignment_0; }
		
		//"abstract"
		public Keyword getAbstractAbstractKeyword_0_0() { return cAbstractAbstractKeyword_0_0; }
		
		//"class"
		public Keyword getClassKeyword_1() { return cClassKeyword_1; }
		
		//name=ID
		public Assignment getNameAssignment_2() { return cNameAssignment_2; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_2_0() { return cNameIDTerminalRuleCall_2_0; }
		
		//("extends" superclasses+=[NamedElement|QualifiedName] ("," superclasses+=[NamedElement|QualifiedName])*)?
		public Group getGroup_3() { return cGroup_3; }
		
		//"extends"
		public Keyword getExtendsKeyword_3_0() { return cExtendsKeyword_3_0; }
		
		//superclasses+=[NamedElement|QualifiedName]
		public Assignment getSuperclassesAssignment_3_1() { return cSuperclassesAssignment_3_1; }
		
		//[NamedElement|QualifiedName]
		public CrossReference getSuperclassesNamedElementCrossReference_3_1_0() { return cSuperclassesNamedElementCrossReference_3_1_0; }
		
		//QualifiedName
		public RuleCall getSuperclassesNamedElementQualifiedNameParserRuleCall_3_1_0_1() { return cSuperclassesNamedElementQualifiedNameParserRuleCall_3_1_0_1; }
		
		//("," superclasses+=[NamedElement|QualifiedName])*
		public Group getGroup_3_2() { return cGroup_3_2; }
		
		//","
		public Keyword getCommaKeyword_3_2_0() { return cCommaKeyword_3_2_0; }
		
		//superclasses+=[NamedElement|QualifiedName]
		public Assignment getSuperclassesAssignment_3_2_1() { return cSuperclassesAssignment_3_2_1; }
		
		//[NamedElement|QualifiedName]
		public CrossReference getSuperclassesNamedElementCrossReference_3_2_1_0() { return cSuperclassesNamedElementCrossReference_3_2_1_0; }
		
		//QualifiedName
		public RuleCall getSuperclassesNamedElementQualifiedNameParserRuleCall_3_2_1_0_1() { return cSuperclassesNamedElementQualifiedNameParserRuleCall_3_2_1_0_1; }
		
		//"{"
		public Keyword getLeftCurlyBracketKeyword_4() { return cLeftCurlyBracketKeyword_4; }
		
		//members+=MemberDefinition*
		public Assignment getMembersAssignment_5() { return cMembersAssignment_5; }
		
		//MemberDefinition
		public RuleCall getMembersMemberDefinitionParserRuleCall_5_0() { return cMembersMemberDefinitionParserRuleCall_5_0; }
		
		//"}"
		public Keyword getRightCurlyBracketKeyword_6() { return cRightCurlyBracketKeyword_6; }
	}
	public class MemberDefinitionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.viatra.solver.language.SolverLanguage.MemberDefinition");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cContainmentAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Keyword cContainmentContainsKeyword_0_0 = (Keyword)cContainmentAssignment_0.eContents().get(0);
		private final Assignment cTypeAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final CrossReference cTypeNamedElementCrossReference_1_0 = (CrossReference)cTypeAssignment_1.eContents().get(0);
		private final RuleCall cTypeNamedElementQualifiedNameParserRuleCall_1_0_1 = (RuleCall)cTypeNamedElementCrossReference_1_0.eContents().get(1);
		private final Assignment cMultiplicityAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cMultiplicityMultiplicityParserRuleCall_2_0 = (RuleCall)cMultiplicityAssignment_2.eContents().get(0);
		private final Assignment cNameAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cNameIDTerminalRuleCall_3_0 = (RuleCall)cNameAssignment_3.eContents().get(0);
		private final Group cGroup_4 = (Group)cGroup.eContents().get(4);
		private final Keyword cOppositeKeyword_4_0 = (Keyword)cGroup_4.eContents().get(0);
		private final Assignment cOppositeAssignment_4_1 = (Assignment)cGroup_4.eContents().get(1);
		private final CrossReference cOppositeNamedElementCrossReference_4_1_0 = (CrossReference)cOppositeAssignment_4_1.eContents().get(0);
		private final RuleCall cOppositeNamedElementQualifiedNameParserRuleCall_4_1_0_1 = (RuleCall)cOppositeNamedElementCrossReference_4_1_0.eContents().get(1);
		private final Keyword cSemicolonKeyword_5 = (Keyword)cGroup.eContents().get(5);
		
		//MemberDefinition:
		//	containment?="contains"? type=[NamedElement|QualifiedName] multiplicity=Multiplicity? name=ID ("opposite"
		//	opposite=[NamedElement|QualifiedName])? ";"?;
		@Override public ParserRule getRule() { return rule; }
		
		//containment?="contains"? type=[NamedElement|QualifiedName] multiplicity=Multiplicity? name=ID ("opposite"
		//opposite=[NamedElement|QualifiedName])? ";"?
		public Group getGroup() { return cGroup; }
		
		//containment?="contains"?
		public Assignment getContainmentAssignment_0() { return cContainmentAssignment_0; }
		
		//"contains"
		public Keyword getContainmentContainsKeyword_0_0() { return cContainmentContainsKeyword_0_0; }
		
		//type=[NamedElement|QualifiedName]
		public Assignment getTypeAssignment_1() { return cTypeAssignment_1; }
		
		//[NamedElement|QualifiedName]
		public CrossReference getTypeNamedElementCrossReference_1_0() { return cTypeNamedElementCrossReference_1_0; }
		
		//QualifiedName
		public RuleCall getTypeNamedElementQualifiedNameParserRuleCall_1_0_1() { return cTypeNamedElementQualifiedNameParserRuleCall_1_0_1; }
		
		//multiplicity=Multiplicity?
		public Assignment getMultiplicityAssignment_2() { return cMultiplicityAssignment_2; }
		
		//Multiplicity
		public RuleCall getMultiplicityMultiplicityParserRuleCall_2_0() { return cMultiplicityMultiplicityParserRuleCall_2_0; }
		
		//name=ID
		public Assignment getNameAssignment_3() { return cNameAssignment_3; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_3_0() { return cNameIDTerminalRuleCall_3_0; }
		
		//("opposite" opposite=[NamedElement|QualifiedName])?
		public Group getGroup_4() { return cGroup_4; }
		
		//"opposite"
		public Keyword getOppositeKeyword_4_0() { return cOppositeKeyword_4_0; }
		
		//opposite=[NamedElement|QualifiedName]
		public Assignment getOppositeAssignment_4_1() { return cOppositeAssignment_4_1; }
		
		//[NamedElement|QualifiedName]
		public CrossReference getOppositeNamedElementCrossReference_4_1_0() { return cOppositeNamedElementCrossReference_4_1_0; }
		
		//QualifiedName
		public RuleCall getOppositeNamedElementQualifiedNameParserRuleCall_4_1_0_1() { return cOppositeNamedElementQualifiedNameParserRuleCall_4_1_0_1; }
		
		//";"?
		public Keyword getSemicolonKeyword_5() { return cSemicolonKeyword_5; }
	}
	public class MultiplicityElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.viatra.solver.language.SolverLanguage.Multiplicity");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cManyMultiplicityParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cExactMultiplicityParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cBoundedMultiplicityParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		
		//Multiplicity:
		//	ManyMultiplicity | ExactMultiplicity | BoundedMultiplicity;
		@Override public ParserRule getRule() { return rule; }
		
		//ManyMultiplicity | ExactMultiplicity | BoundedMultiplicity
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//ManyMultiplicity
		public RuleCall getManyMultiplicityParserRuleCall_0() { return cManyMultiplicityParserRuleCall_0; }
		
		//ExactMultiplicity
		public RuleCall getExactMultiplicityParserRuleCall_1() { return cExactMultiplicityParserRuleCall_1; }
		
		//BoundedMultiplicity
		public RuleCall getBoundedMultiplicityParserRuleCall_2() { return cBoundedMultiplicityParserRuleCall_2; }
	}
	public class ManyMultiplicityElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.viatra.solver.language.SolverLanguage.ManyMultiplicity");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cManyMultiplicityAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cLeftSquareBracketKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Keyword cRightSquareBracketKeyword_2 = (Keyword)cGroup.eContents().get(2);
		
		//ManyMultiplicity:
		//	{ManyMultiplicity} "[" "]";
		@Override public ParserRule getRule() { return rule; }
		
		//{ManyMultiplicity} "[" "]"
		public Group getGroup() { return cGroup; }
		
		//{ManyMultiplicity}
		public Action getManyMultiplicityAction_0() { return cManyMultiplicityAction_0; }
		
		//"["
		public Keyword getLeftSquareBracketKeyword_1() { return cLeftSquareBracketKeyword_1; }
		
		//"]"
		public Keyword getRightSquareBracketKeyword_2() { return cRightSquareBracketKeyword_2; }
	}
	public class ExactMultiplicityElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.viatra.solver.language.SolverLanguage.ExactMultiplicity");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLeftSquareBracketKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cMultiplicityAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cMultiplicityUpperMultiplictyParserRuleCall_1_0 = (RuleCall)cMultiplicityAssignment_1.eContents().get(0);
		private final Keyword cRightSquareBracketKeyword_2 = (Keyword)cGroup.eContents().get(2);
		
		//ExactMultiplicity:
		//	"[" multiplicity=UpperMultiplicty "]";
		@Override public ParserRule getRule() { return rule; }
		
		//"[" multiplicity=UpperMultiplicty "]"
		public Group getGroup() { return cGroup; }
		
		//"["
		public Keyword getLeftSquareBracketKeyword_0() { return cLeftSquareBracketKeyword_0; }
		
		//multiplicity=UpperMultiplicty
		public Assignment getMultiplicityAssignment_1() { return cMultiplicityAssignment_1; }
		
		//UpperMultiplicty
		public RuleCall getMultiplicityUpperMultiplictyParserRuleCall_1_0() { return cMultiplicityUpperMultiplictyParserRuleCall_1_0; }
		
		//"]"
		public Keyword getRightSquareBracketKeyword_2() { return cRightSquareBracketKeyword_2; }
	}
	public class BoundedMultiplicityElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.viatra.solver.language.SolverLanguage.BoundedMultiplicity");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLeftSquareBracketKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cLowerBoundAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cLowerBoundINTTerminalRuleCall_1_0 = (RuleCall)cLowerBoundAssignment_1.eContents().get(0);
		private final Keyword cFullStopFullStopKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cUpperBoundAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cUpperBoundUpperMultiplictyParserRuleCall_3_0 = (RuleCall)cUpperBoundAssignment_3.eContents().get(0);
		private final Keyword cRightSquareBracketKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//BoundedMultiplicity:
		//	"[" lowerBound=INT ".." upperBound=UpperMultiplicty "]";
		@Override public ParserRule getRule() { return rule; }
		
		//"[" lowerBound=INT ".." upperBound=UpperMultiplicty "]"
		public Group getGroup() { return cGroup; }
		
		//"["
		public Keyword getLeftSquareBracketKeyword_0() { return cLeftSquareBracketKeyword_0; }
		
		//lowerBound=INT
		public Assignment getLowerBoundAssignment_1() { return cLowerBoundAssignment_1; }
		
		//INT
		public RuleCall getLowerBoundINTTerminalRuleCall_1_0() { return cLowerBoundINTTerminalRuleCall_1_0; }
		
		//".."
		public Keyword getFullStopFullStopKeyword_2() { return cFullStopFullStopKeyword_2; }
		
		//upperBound=UpperMultiplicty
		public Assignment getUpperBoundAssignment_3() { return cUpperBoundAssignment_3; }
		
		//UpperMultiplicty
		public RuleCall getUpperBoundUpperMultiplictyParserRuleCall_3_0() { return cUpperBoundUpperMultiplictyParserRuleCall_3_0; }
		
		//"]"
		public Keyword getRightSquareBracketKeyword_4() { return cRightSquareBracketKeyword_4; }
	}
	public class ScopeDefinitionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.viatra.solver.language.SolverLanguage.ScopeDefinition");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cExactScopeDefinitionParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cBoundedScopeDefinitionParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cLowerBoundedScopeDefinitionParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		
		//ScopeDefinition:
		//	ExactScopeDefinition | BoundedScopeDefinition | LowerBoundedScopeDefinition;
		@Override public ParserRule getRule() { return rule; }
		
		//ExactScopeDefinition | BoundedScopeDefinition | LowerBoundedScopeDefinition
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//ExactScopeDefinition
		public RuleCall getExactScopeDefinitionParserRuleCall_0() { return cExactScopeDefinitionParserRuleCall_0; }
		
		//BoundedScopeDefinition
		public RuleCall getBoundedScopeDefinitionParserRuleCall_1() { return cBoundedScopeDefinitionParserRuleCall_1; }
		
		//LowerBoundedScopeDefinition
		public RuleCall getLowerBoundedScopeDefinitionParserRuleCall_2() { return cLowerBoundedScopeDefinitionParserRuleCall_2; }
	}
	public class ExactScopeDefinitionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.viatra.solver.language.SolverLanguage.ExactScopeDefinition");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cScopeKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cTypeAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final CrossReference cTypeNamedElementCrossReference_1_0 = (CrossReference)cTypeAssignment_1.eContents().get(0);
		private final RuleCall cTypeNamedElementQualifiedNameParserRuleCall_1_0_1 = (RuleCall)cTypeNamedElementCrossReference_1_0.eContents().get(1);
		private final Keyword cEqualsSignEqualsSignKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cExactScopeAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cExactScopeINTTerminalRuleCall_3_0 = (RuleCall)cExactScopeAssignment_3.eContents().get(0);
		
		//ExactScopeDefinition:
		//	"scope" type=[NamedElement|QualifiedName] "==" exactScope=INT;
		@Override public ParserRule getRule() { return rule; }
		
		//"scope" type=[NamedElement|QualifiedName] "==" exactScope=INT
		public Group getGroup() { return cGroup; }
		
		//"scope"
		public Keyword getScopeKeyword_0() { return cScopeKeyword_0; }
		
		//type=[NamedElement|QualifiedName]
		public Assignment getTypeAssignment_1() { return cTypeAssignment_1; }
		
		//[NamedElement|QualifiedName]
		public CrossReference getTypeNamedElementCrossReference_1_0() { return cTypeNamedElementCrossReference_1_0; }
		
		//QualifiedName
		public RuleCall getTypeNamedElementQualifiedNameParserRuleCall_1_0_1() { return cTypeNamedElementQualifiedNameParserRuleCall_1_0_1; }
		
		//"=="
		public Keyword getEqualsSignEqualsSignKeyword_2() { return cEqualsSignEqualsSignKeyword_2; }
		
		//exactScope=INT
		public Assignment getExactScopeAssignment_3() { return cExactScopeAssignment_3; }
		
		//INT
		public RuleCall getExactScopeINTTerminalRuleCall_3_0() { return cExactScopeINTTerminalRuleCall_3_0; }
	}
	public class BoundedScopeDefinitionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.viatra.solver.language.SolverLanguage.BoundedScopeDefinition");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cScopeKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Alternatives cAlternatives_1 = (Alternatives)cGroup.eContents().get(1);
		private final Group cGroup_1_0 = (Group)cAlternatives_1.eContents().get(0);
		private final Group cGroup_1_0_0 = (Group)cGroup_1_0.eContents().get(0);
		private final Assignment cLowerBoundAssignment_1_0_0_0 = (Assignment)cGroup_1_0_0.eContents().get(0);
		private final RuleCall cLowerBoundINTTerminalRuleCall_1_0_0_0_0 = (RuleCall)cLowerBoundAssignment_1_0_0_0.eContents().get(0);
		private final Keyword cLessThanSignEqualsSignKeyword_1_0_0_1 = (Keyword)cGroup_1_0_0.eContents().get(1);
		private final Assignment cTypeAssignment_1_0_1 = (Assignment)cGroup_1_0.eContents().get(1);
		private final CrossReference cTypeNamedElementCrossReference_1_0_1_0 = (CrossReference)cTypeAssignment_1_0_1.eContents().get(0);
		private final RuleCall cTypeNamedElementQualifiedNameParserRuleCall_1_0_1_0_1 = (RuleCall)cTypeNamedElementCrossReference_1_0_1_0.eContents().get(1);
		private final Keyword cLessThanSignEqualsSignKeyword_1_0_2 = (Keyword)cGroup_1_0.eContents().get(2);
		private final Assignment cUpperBoundAssignment_1_0_3 = (Assignment)cGroup_1_0.eContents().get(3);
		private final RuleCall cUpperBoundINTTerminalRuleCall_1_0_3_0 = (RuleCall)cUpperBoundAssignment_1_0_3.eContents().get(0);
		private final Group cGroup_1_1 = (Group)cAlternatives_1.eContents().get(1);
		private final Assignment cUpperBoundAssignment_1_1_0 = (Assignment)cGroup_1_1.eContents().get(0);
		private final RuleCall cUpperBoundINTTerminalRuleCall_1_1_0_0 = (RuleCall)cUpperBoundAssignment_1_1_0.eContents().get(0);
		private final Keyword cGreaterThanSignEqualsSignKeyword_1_1_1 = (Keyword)cGroup_1_1.eContents().get(1);
		private final Assignment cTypeAssignment_1_1_2 = (Assignment)cGroup_1_1.eContents().get(2);
		private final CrossReference cTypeNamedElementCrossReference_1_1_2_0 = (CrossReference)cTypeAssignment_1_1_2.eContents().get(0);
		private final RuleCall cTypeNamedElementQualifiedNameParserRuleCall_1_1_2_0_1 = (RuleCall)cTypeNamedElementCrossReference_1_1_2_0.eContents().get(1);
		private final Group cGroup_1_1_3 = (Group)cGroup_1_1.eContents().get(3);
		private final Keyword cGreaterThanSignEqualsSignKeyword_1_1_3_0 = (Keyword)cGroup_1_1_3.eContents().get(0);
		private final Assignment cLowerBoundAssignment_1_1_3_1 = (Assignment)cGroup_1_1_3.eContents().get(1);
		private final RuleCall cLowerBoundINTTerminalRuleCall_1_1_3_1_0 = (RuleCall)cLowerBoundAssignment_1_1_3_1.eContents().get(0);
		
		//BoundedScopeDefinition:
		//	"scope" ((lowerBound=INT "<=")? type=[NamedElement|QualifiedName] "<=" upperBound=INT | upperBound=INT ">="
		//	type=[NamedElement|QualifiedName] (">=" lowerBound=INT)?);
		@Override public ParserRule getRule() { return rule; }
		
		//"scope" ((lowerBound=INT "<=")? type=[NamedElement|QualifiedName] "<=" upperBound=INT | upperBound=INT ">="
		//type=[NamedElement|QualifiedName] (">=" lowerBound=INT)?)
		public Group getGroup() { return cGroup; }
		
		//"scope"
		public Keyword getScopeKeyword_0() { return cScopeKeyword_0; }
		
		//((lowerBound=INT "<=")? type=[NamedElement|QualifiedName] "<=" upperBound=INT | upperBound=INT ">="
		//type=[NamedElement|QualifiedName] (">=" lowerBound=INT)?)
		public Alternatives getAlternatives_1() { return cAlternatives_1; }
		
		//(lowerBound=INT "<=")? type=[NamedElement|QualifiedName] "<=" upperBound=INT
		public Group getGroup_1_0() { return cGroup_1_0; }
		
		//(lowerBound=INT "<=")?
		public Group getGroup_1_0_0() { return cGroup_1_0_0; }
		
		//lowerBound=INT
		public Assignment getLowerBoundAssignment_1_0_0_0() { return cLowerBoundAssignment_1_0_0_0; }
		
		//INT
		public RuleCall getLowerBoundINTTerminalRuleCall_1_0_0_0_0() { return cLowerBoundINTTerminalRuleCall_1_0_0_0_0; }
		
		//"<="
		public Keyword getLessThanSignEqualsSignKeyword_1_0_0_1() { return cLessThanSignEqualsSignKeyword_1_0_0_1; }
		
		//type=[NamedElement|QualifiedName]
		public Assignment getTypeAssignment_1_0_1() { return cTypeAssignment_1_0_1; }
		
		//[NamedElement|QualifiedName]
		public CrossReference getTypeNamedElementCrossReference_1_0_1_0() { return cTypeNamedElementCrossReference_1_0_1_0; }
		
		//QualifiedName
		public RuleCall getTypeNamedElementQualifiedNameParserRuleCall_1_0_1_0_1() { return cTypeNamedElementQualifiedNameParserRuleCall_1_0_1_0_1; }
		
		//"<="
		public Keyword getLessThanSignEqualsSignKeyword_1_0_2() { return cLessThanSignEqualsSignKeyword_1_0_2; }
		
		//upperBound=INT
		public Assignment getUpperBoundAssignment_1_0_3() { return cUpperBoundAssignment_1_0_3; }
		
		//INT
		public RuleCall getUpperBoundINTTerminalRuleCall_1_0_3_0() { return cUpperBoundINTTerminalRuleCall_1_0_3_0; }
		
		//upperBound=INT ">=" type=[NamedElement|QualifiedName] (">=" lowerBound=INT)?
		public Group getGroup_1_1() { return cGroup_1_1; }
		
		//upperBound=INT
		public Assignment getUpperBoundAssignment_1_1_0() { return cUpperBoundAssignment_1_1_0; }
		
		//INT
		public RuleCall getUpperBoundINTTerminalRuleCall_1_1_0_0() { return cUpperBoundINTTerminalRuleCall_1_1_0_0; }
		
		//">="
		public Keyword getGreaterThanSignEqualsSignKeyword_1_1_1() { return cGreaterThanSignEqualsSignKeyword_1_1_1; }
		
		//type=[NamedElement|QualifiedName]
		public Assignment getTypeAssignment_1_1_2() { return cTypeAssignment_1_1_2; }
		
		//[NamedElement|QualifiedName]
		public CrossReference getTypeNamedElementCrossReference_1_1_2_0() { return cTypeNamedElementCrossReference_1_1_2_0; }
		
		//QualifiedName
		public RuleCall getTypeNamedElementQualifiedNameParserRuleCall_1_1_2_0_1() { return cTypeNamedElementQualifiedNameParserRuleCall_1_1_2_0_1; }
		
		//(">=" lowerBound=INT)?
		public Group getGroup_1_1_3() { return cGroup_1_1_3; }
		
		//">="
		public Keyword getGreaterThanSignEqualsSignKeyword_1_1_3_0() { return cGreaterThanSignEqualsSignKeyword_1_1_3_0; }
		
		//lowerBound=INT
		public Assignment getLowerBoundAssignment_1_1_3_1() { return cLowerBoundAssignment_1_1_3_1; }
		
		//INT
		public RuleCall getLowerBoundINTTerminalRuleCall_1_1_3_1_0() { return cLowerBoundINTTerminalRuleCall_1_1_3_1_0; }
	}
	public class LowerBoundedScopeDefinitionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.viatra.solver.language.SolverLanguage.LowerBoundedScopeDefinition");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cScopeKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Alternatives cAlternatives_1 = (Alternatives)cGroup.eContents().get(1);
		private final Group cGroup_1_0 = (Group)cAlternatives_1.eContents().get(0);
		private final Assignment cLowerBoundAssignment_1_0_0 = (Assignment)cGroup_1_0.eContents().get(0);
		private final RuleCall cLowerBoundINTTerminalRuleCall_1_0_0_0 = (RuleCall)cLowerBoundAssignment_1_0_0.eContents().get(0);
		private final Keyword cLessThanSignEqualsSignKeyword_1_0_1 = (Keyword)cGroup_1_0.eContents().get(1);
		private final Assignment cTypeAssignment_1_0_2 = (Assignment)cGroup_1_0.eContents().get(2);
		private final CrossReference cTypeNamedElementCrossReference_1_0_2_0 = (CrossReference)cTypeAssignment_1_0_2.eContents().get(0);
		private final RuleCall cTypeNamedElementQualifiedNameParserRuleCall_1_0_2_0_1 = (RuleCall)cTypeNamedElementCrossReference_1_0_2_0.eContents().get(1);
		private final Group cGroup_1_1 = (Group)cAlternatives_1.eContents().get(1);
		private final Assignment cTypeAssignment_1_1_0 = (Assignment)cGroup_1_1.eContents().get(0);
		private final CrossReference cTypeNamedElementCrossReference_1_1_0_0 = (CrossReference)cTypeAssignment_1_1_0.eContents().get(0);
		private final RuleCall cTypeNamedElementQualifiedNameParserRuleCall_1_1_0_0_1 = (RuleCall)cTypeNamedElementCrossReference_1_1_0_0.eContents().get(1);
		private final Keyword cGreaterThanSignEqualsSignKeyword_1_1_1 = (Keyword)cGroup_1_1.eContents().get(1);
		private final Assignment cLowerBoundAssignment_1_1_2 = (Assignment)cGroup_1_1.eContents().get(2);
		private final RuleCall cLowerBoundINTTerminalRuleCall_1_1_2_0 = (RuleCall)cLowerBoundAssignment_1_1_2.eContents().get(0);
		
		//LowerBoundedScopeDefinition:
		//	"scope" (lowerBound=INT "<=" type=[NamedElement|QualifiedName] | type=[NamedElement|QualifiedName] ">="
		//	lowerBound=INT);
		@Override public ParserRule getRule() { return rule; }
		
		//"scope" (lowerBound=INT "<=" type=[NamedElement|QualifiedName] | type=[NamedElement|QualifiedName] ">=" lowerBound=INT)
		public Group getGroup() { return cGroup; }
		
		//"scope"
		public Keyword getScopeKeyword_0() { return cScopeKeyword_0; }
		
		//(lowerBound=INT "<=" type=[NamedElement|QualifiedName] | type=[NamedElement|QualifiedName] ">=" lowerBound=INT)
		public Alternatives getAlternatives_1() { return cAlternatives_1; }
		
		//lowerBound=INT "<=" type=[NamedElement|QualifiedName]
		public Group getGroup_1_0() { return cGroup_1_0; }
		
		//lowerBound=INT
		public Assignment getLowerBoundAssignment_1_0_0() { return cLowerBoundAssignment_1_0_0; }
		
		//INT
		public RuleCall getLowerBoundINTTerminalRuleCall_1_0_0_0() { return cLowerBoundINTTerminalRuleCall_1_0_0_0; }
		
		//"<="
		public Keyword getLessThanSignEqualsSignKeyword_1_0_1() { return cLessThanSignEqualsSignKeyword_1_0_1; }
		
		//type=[NamedElement|QualifiedName]
		public Assignment getTypeAssignment_1_0_2() { return cTypeAssignment_1_0_2; }
		
		//[NamedElement|QualifiedName]
		public CrossReference getTypeNamedElementCrossReference_1_0_2_0() { return cTypeNamedElementCrossReference_1_0_2_0; }
		
		//QualifiedName
		public RuleCall getTypeNamedElementQualifiedNameParserRuleCall_1_0_2_0_1() { return cTypeNamedElementQualifiedNameParserRuleCall_1_0_2_0_1; }
		
		//type=[NamedElement|QualifiedName] ">=" lowerBound=INT
		public Group getGroup_1_1() { return cGroup_1_1; }
		
		//type=[NamedElement|QualifiedName]
		public Assignment getTypeAssignment_1_1_0() { return cTypeAssignment_1_1_0; }
		
		//[NamedElement|QualifiedName]
		public CrossReference getTypeNamedElementCrossReference_1_1_0_0() { return cTypeNamedElementCrossReference_1_1_0_0; }
		
		//QualifiedName
		public RuleCall getTypeNamedElementQualifiedNameParserRuleCall_1_1_0_0_1() { return cTypeNamedElementQualifiedNameParserRuleCall_1_1_0_0_1; }
		
		//">="
		public Keyword getGreaterThanSignEqualsSignKeyword_1_1_1() { return cGreaterThanSignEqualsSignKeyword_1_1_1; }
		
		//lowerBound=INT
		public Assignment getLowerBoundAssignment_1_1_2() { return cLowerBoundAssignment_1_1_2; }
		
		//INT
		public RuleCall getLowerBoundINTTerminalRuleCall_1_1_2_0() { return cLowerBoundINTTerminalRuleCall_1_1_2_0; }
	}
	public class ObjectiveDefinitionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.viatra.solver.language.SolverLanguage.ObjectiveDefinition");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cKindAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cKindObjectiveKindEnumRuleCall_0_0 = (RuleCall)cKindAssignment_0.eContents().get(0);
		private final Assignment cObjectiveAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cObjectiveExpressionParserRuleCall_1_0 = (RuleCall)cObjectiveAssignment_1.eContents().get(0);
		
		//ObjectiveDefinition:
		//	kind=ObjectiveKind objective=Expression;
		@Override public ParserRule getRule() { return rule; }
		
		//kind=ObjectiveKind objective=Expression
		public Group getGroup() { return cGroup; }
		
		//kind=ObjectiveKind
		public Assignment getKindAssignment_0() { return cKindAssignment_0; }
		
		//ObjectiveKind
		public RuleCall getKindObjectiveKindEnumRuleCall_0_0() { return cKindObjectiveKindEnumRuleCall_0_0; }
		
		//objective=Expression
		public Assignment getObjectiveAssignment_1() { return cObjectiveAssignment_1; }
		
		//Expression
		public RuleCall getObjectiveExpressionParserRuleCall_1_0() { return cObjectiveExpressionParserRuleCall_1_0; }
	}
	public class UpperMultiplictyElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.viatra.solver.language.SolverLanguage.UpperMultiplicty");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cINTTerminalRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final Keyword cAsteriskKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		
		//UpperMultiplicty ecore::EInt:
		//	INT | "*";
		@Override public ParserRule getRule() { return rule; }
		
		//INT | "*"
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//INT
		public RuleCall getINTTerminalRuleCall_0() { return cINTTerminalRuleCall_0; }
		
		//"*"
		public Keyword getAsteriskKeyword_1() { return cAsteriskKeyword_1; }
	}
	public class RealElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.viatra.solver.language.SolverLanguage.Real");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cINTTerminalRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cFullStopKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final RuleCall cINTTerminalRuleCall_1_1 = (RuleCall)cGroup_1.eContents().get(1);
		
		//Real ecore::EBigDecimal hidden():
		//	INT ("." INT)?;
		@Override public ParserRule getRule() { return rule; }
		
		//INT ("." INT)?
		public Group getGroup() { return cGroup; }
		
		//INT
		public RuleCall getINTTerminalRuleCall_0() { return cINTTerminalRuleCall_0; }
		
		//("." INT)?
		public Group getGroup_1() { return cGroup_1; }
		
		//"."
		public Keyword getFullStopKeyword_1_0() { return cFullStopKeyword_1_0; }
		
		//INT
		public RuleCall getINTTerminalRuleCall_1_1() { return cINTTerminalRuleCall_1_1; }
	}
	public class QualifiedNameElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.viatra.solver.language.SolverLanguage.QualifiedName");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final RuleCall cIDTerminalRuleCall_0_0 = (RuleCall)cGroup_0.eContents().get(0);
		private final Group cGroup_0_1 = (Group)cGroup_0.eContents().get(1);
		private final Keyword cFullStopKeyword_0_1_0 = (Keyword)cGroup_0_1.eContents().get(0);
		private final RuleCall cIDTerminalRuleCall_0_1_1 = (RuleCall)cGroup_0_1.eContents().get(1);
		private final RuleCall cQUOTED_IDTerminalRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//QualifiedName hidden():
		//	ID ("." ID)* | QUOTED_ID;
		@Override public ParserRule getRule() { return rule; }
		
		//ID ("." ID)* | QUOTED_ID
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//ID ("." ID)*
		public Group getGroup_0() { return cGroup_0; }
		
		//ID
		public RuleCall getIDTerminalRuleCall_0_0() { return cIDTerminalRuleCall_0_0; }
		
		//("." ID)*
		public Group getGroup_0_1() { return cGroup_0_1; }
		
		//"."
		public Keyword getFullStopKeyword_0_1_0() { return cFullStopKeyword_0_1_0; }
		
		//ID
		public RuleCall getIDTerminalRuleCall_0_1_1() { return cIDTerminalRuleCall_0_1_1; }
		
		//QUOTED_ID
		public RuleCall getQUOTED_IDTerminalRuleCall_1() { return cQUOTED_IDTerminalRuleCall_1; }
	}
	public class NamedElementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.viatra.solver.language.SolverLanguage.NamedElement");
		private final Assignment cNameAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cNameQualifiedNameParserRuleCall_0 = (RuleCall)cNameAssignment.eContents().get(0);
		
		//NamedElement:
		//	name=QualifiedName;
		@Override public ParserRule getRule() { return rule; }
		
		//name=QualifiedName
		public Assignment getNameAssignment() { return cNameAssignment; }
		
		//QualifiedName
		public RuleCall getNameQualifiedNameParserRuleCall_0() { return cNameQualifiedNameParserRuleCall_0; }
	}
	
	public class MetricTypeElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.viatra.solver.language.SolverLanguage.MetricType");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cINTEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cINTIntKeyword_0_0 = (Keyword)cINTEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cREALEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cREALRealKeyword_1_0 = (Keyword)cREALEnumLiteralDeclaration_1.eContents().get(0);
		
		//enum MetricType:
		//	INT="int" | REAL="real";
		public EnumRule getRule() { return rule; }
		
		//INT="int" | REAL="real"
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//INT="int"
		public EnumLiteralDeclaration getINTEnumLiteralDeclaration_0() { return cINTEnumLiteralDeclaration_0; }
		
		//"int"
		public Keyword getINTIntKeyword_0_0() { return cINTIntKeyword_0_0; }
		
		//REAL="real"
		public EnumLiteralDeclaration getREALEnumLiteralDeclaration_1() { return cREALEnumLiteralDeclaration_1; }
		
		//"real"
		public Keyword getREALRealKeyword_1_0() { return cREALRealKeyword_1_0; }
	}
	public class BinaryOperatorElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.viatra.solver.language.SolverLanguage.BinaryOperator");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cEQEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cEQEQKeyword_0_0 = (Keyword)cEQEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cNOT_EQEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cNOT_EQNOT_EQKeyword_1_0 = (Keyword)cNOT_EQEnumLiteralDeclaration_1.eContents().get(0);
		private final EnumLiteralDeclaration cLESSEnumLiteralDeclaration_2 = (EnumLiteralDeclaration)cAlternatives.eContents().get(2);
		private final Keyword cLESSLESSKeyword_2_0 = (Keyword)cLESSEnumLiteralDeclaration_2.eContents().get(0);
		private final EnumLiteralDeclaration cLESS_EQEnumLiteralDeclaration_3 = (EnumLiteralDeclaration)cAlternatives.eContents().get(3);
		private final Keyword cLESS_EQLESS_EQKeyword_3_0 = (Keyword)cLESS_EQEnumLiteralDeclaration_3.eContents().get(0);
		private final EnumLiteralDeclaration cGREATEREnumLiteralDeclaration_4 = (EnumLiteralDeclaration)cAlternatives.eContents().get(4);
		private final Keyword cGREATERGREATERKeyword_4_0 = (Keyword)cGREATEREnumLiteralDeclaration_4.eContents().get(0);
		private final EnumLiteralDeclaration cGREATER_EQEnumLiteralDeclaration_5 = (EnumLiteralDeclaration)cAlternatives.eContents().get(5);
		private final Keyword cGREATER_EQGREATER_EQKeyword_5_0 = (Keyword)cGREATER_EQEnumLiteralDeclaration_5.eContents().get(0);
		private final EnumLiteralDeclaration cINEnumLiteralDeclaration_6 = (EnumLiteralDeclaration)cAlternatives.eContents().get(6);
		private final Keyword cININKeyword_6_0 = (Keyword)cINEnumLiteralDeclaration_6.eContents().get(0);
		private final EnumLiteralDeclaration cADDEnumLiteralDeclaration_7 = (EnumLiteralDeclaration)cAlternatives.eContents().get(7);
		private final Keyword cADDADDKeyword_7_0 = (Keyword)cADDEnumLiteralDeclaration_7.eContents().get(0);
		private final EnumLiteralDeclaration cSUBEnumLiteralDeclaration_8 = (EnumLiteralDeclaration)cAlternatives.eContents().get(8);
		private final Keyword cSUBSUBKeyword_8_0 = (Keyword)cSUBEnumLiteralDeclaration_8.eContents().get(0);
		private final EnumLiteralDeclaration cMULEnumLiteralDeclaration_9 = (EnumLiteralDeclaration)cAlternatives.eContents().get(9);
		private final Keyword cMULMULKeyword_9_0 = (Keyword)cMULEnumLiteralDeclaration_9.eContents().get(0);
		private final EnumLiteralDeclaration cDIVEnumLiteralDeclaration_10 = (EnumLiteralDeclaration)cAlternatives.eContents().get(10);
		private final Keyword cDIVDIVKeyword_10_0 = (Keyword)cDIVEnumLiteralDeclaration_10.eContents().get(0);
		private final EnumLiteralDeclaration cPOWEnumLiteralDeclaration_11 = (EnumLiteralDeclaration)cAlternatives.eContents().get(11);
		private final Keyword cPOWPOWKeyword_11_0 = (Keyword)cPOWEnumLiteralDeclaration_11.eContents().get(0);
		
		//enum BinaryOperator:
		//	EQ | NOT_EQ | LESS | LESS_EQ | GREATER | GREATER_EQ | IN | ADD | SUB | MUL | DIV | POW;
		public EnumRule getRule() { return rule; }
		
		//EQ | NOT_EQ | LESS | LESS_EQ | GREATER | GREATER_EQ | IN | ADD | SUB | MUL | DIV | POW
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//EQ
		public EnumLiteralDeclaration getEQEnumLiteralDeclaration_0() { return cEQEnumLiteralDeclaration_0; }
		
		//"EQ"
		public Keyword getEQEQKeyword_0_0() { return cEQEQKeyword_0_0; }
		
		//NOT_EQ
		public EnumLiteralDeclaration getNOT_EQEnumLiteralDeclaration_1() { return cNOT_EQEnumLiteralDeclaration_1; }
		
		//"NOT_EQ"
		public Keyword getNOT_EQNOT_EQKeyword_1_0() { return cNOT_EQNOT_EQKeyword_1_0; }
		
		//LESS
		public EnumLiteralDeclaration getLESSEnumLiteralDeclaration_2() { return cLESSEnumLiteralDeclaration_2; }
		
		//"LESS"
		public Keyword getLESSLESSKeyword_2_0() { return cLESSLESSKeyword_2_0; }
		
		//LESS_EQ
		public EnumLiteralDeclaration getLESS_EQEnumLiteralDeclaration_3() { return cLESS_EQEnumLiteralDeclaration_3; }
		
		//"LESS_EQ"
		public Keyword getLESS_EQLESS_EQKeyword_3_0() { return cLESS_EQLESS_EQKeyword_3_0; }
		
		//GREATER
		public EnumLiteralDeclaration getGREATEREnumLiteralDeclaration_4() { return cGREATEREnumLiteralDeclaration_4; }
		
		//"GREATER"
		public Keyword getGREATERGREATERKeyword_4_0() { return cGREATERGREATERKeyword_4_0; }
		
		//GREATER_EQ
		public EnumLiteralDeclaration getGREATER_EQEnumLiteralDeclaration_5() { return cGREATER_EQEnumLiteralDeclaration_5; }
		
		//"GREATER_EQ"
		public Keyword getGREATER_EQGREATER_EQKeyword_5_0() { return cGREATER_EQGREATER_EQKeyword_5_0; }
		
		//IN
		public EnumLiteralDeclaration getINEnumLiteralDeclaration_6() { return cINEnumLiteralDeclaration_6; }
		
		//"IN"
		public Keyword getININKeyword_6_0() { return cININKeyword_6_0; }
		
		//ADD
		public EnumLiteralDeclaration getADDEnumLiteralDeclaration_7() { return cADDEnumLiteralDeclaration_7; }
		
		//"ADD"
		public Keyword getADDADDKeyword_7_0() { return cADDADDKeyword_7_0; }
		
		//SUB
		public EnumLiteralDeclaration getSUBEnumLiteralDeclaration_8() { return cSUBEnumLiteralDeclaration_8; }
		
		//"SUB"
		public Keyword getSUBSUBKeyword_8_0() { return cSUBSUBKeyword_8_0; }
		
		//MUL
		public EnumLiteralDeclaration getMULEnumLiteralDeclaration_9() { return cMULEnumLiteralDeclaration_9; }
		
		//"MUL"
		public Keyword getMULMULKeyword_9_0() { return cMULMULKeyword_9_0; }
		
		//DIV
		public EnumLiteralDeclaration getDIVEnumLiteralDeclaration_10() { return cDIVEnumLiteralDeclaration_10; }
		
		//"DIV"
		public Keyword getDIVDIVKeyword_10_0() { return cDIVDIVKeyword_10_0; }
		
		//POW
		public EnumLiteralDeclaration getPOWEnumLiteralDeclaration_11() { return cPOWEnumLiteralDeclaration_11; }
		
		//"POW"
		public Keyword getPOWPOWKeyword_11_0() { return cPOWPOWKeyword_11_0; }
	}
	public class ComparisonOperatorElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.viatra.solver.language.SolverLanguage.ComparisonOperator");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cEQEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cEQEqualsSignEqualsSignKeyword_0_0 = (Keyword)cEQEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cNOT_EQEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cNOT_EQExclamationMarkEqualsSignKeyword_1_0 = (Keyword)cNOT_EQEnumLiteralDeclaration_1.eContents().get(0);
		private final EnumLiteralDeclaration cLESSEnumLiteralDeclaration_2 = (EnumLiteralDeclaration)cAlternatives.eContents().get(2);
		private final Keyword cLESSLessThanSignKeyword_2_0 = (Keyword)cLESSEnumLiteralDeclaration_2.eContents().get(0);
		private final EnumLiteralDeclaration cLESS_EQEnumLiteralDeclaration_3 = (EnumLiteralDeclaration)cAlternatives.eContents().get(3);
		private final Keyword cLESS_EQLessThanSignEqualsSignKeyword_3_0 = (Keyword)cLESS_EQEnumLiteralDeclaration_3.eContents().get(0);
		private final EnumLiteralDeclaration cGREATEREnumLiteralDeclaration_4 = (EnumLiteralDeclaration)cAlternatives.eContents().get(4);
		private final Keyword cGREATERGreaterThanSignKeyword_4_0 = (Keyword)cGREATEREnumLiteralDeclaration_4.eContents().get(0);
		private final EnumLiteralDeclaration cGREATER_EQEnumLiteralDeclaration_5 = (EnumLiteralDeclaration)cAlternatives.eContents().get(5);
		private final Keyword cGREATER_EQGreaterThanSignEqualsSignKeyword_5_0 = (Keyword)cGREATER_EQEnumLiteralDeclaration_5.eContents().get(0);
		private final EnumLiteralDeclaration cINEnumLiteralDeclaration_6 = (EnumLiteralDeclaration)cAlternatives.eContents().get(6);
		private final Keyword cINInKeyword_6_0 = (Keyword)cINEnumLiteralDeclaration_6.eContents().get(0);
		
		//enum ComparisonOperator returns BinaryOperator:
		//	EQ="==" | NOT_EQ="!=" | LESS="<" | LESS_EQ="<=" | GREATER=">" | GREATER_EQ=">=" | IN="in";
		public EnumRule getRule() { return rule; }
		
		//EQ="==" | NOT_EQ="!=" | LESS="<" | LESS_EQ="<=" | GREATER=">" | GREATER_EQ=">=" | IN="in"
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//EQ="=="
		public EnumLiteralDeclaration getEQEnumLiteralDeclaration_0() { return cEQEnumLiteralDeclaration_0; }
		
		//"=="
		public Keyword getEQEqualsSignEqualsSignKeyword_0_0() { return cEQEqualsSignEqualsSignKeyword_0_0; }
		
		//NOT_EQ="!="
		public EnumLiteralDeclaration getNOT_EQEnumLiteralDeclaration_1() { return cNOT_EQEnumLiteralDeclaration_1; }
		
		//"!="
		public Keyword getNOT_EQExclamationMarkEqualsSignKeyword_1_0() { return cNOT_EQExclamationMarkEqualsSignKeyword_1_0; }
		
		//LESS="<"
		public EnumLiteralDeclaration getLESSEnumLiteralDeclaration_2() { return cLESSEnumLiteralDeclaration_2; }
		
		//"<"
		public Keyword getLESSLessThanSignKeyword_2_0() { return cLESSLessThanSignKeyword_2_0; }
		
		//LESS_EQ="<="
		public EnumLiteralDeclaration getLESS_EQEnumLiteralDeclaration_3() { return cLESS_EQEnumLiteralDeclaration_3; }
		
		//"<="
		public Keyword getLESS_EQLessThanSignEqualsSignKeyword_3_0() { return cLESS_EQLessThanSignEqualsSignKeyword_3_0; }
		
		//GREATER=">"
		public EnumLiteralDeclaration getGREATEREnumLiteralDeclaration_4() { return cGREATEREnumLiteralDeclaration_4; }
		
		//">"
		public Keyword getGREATERGreaterThanSignKeyword_4_0() { return cGREATERGreaterThanSignKeyword_4_0; }
		
		//GREATER_EQ=">="
		public EnumLiteralDeclaration getGREATER_EQEnumLiteralDeclaration_5() { return cGREATER_EQEnumLiteralDeclaration_5; }
		
		//">="
		public Keyword getGREATER_EQGreaterThanSignEqualsSignKeyword_5_0() { return cGREATER_EQGreaterThanSignEqualsSignKeyword_5_0; }
		
		//IN="in"
		public EnumLiteralDeclaration getINEnumLiteralDeclaration_6() { return cINEnumLiteralDeclaration_6; }
		
		//"in"
		public Keyword getINInKeyword_6_0() { return cINInKeyword_6_0; }
	}
	public class AdditiveBinaryOperatorElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.viatra.solver.language.SolverLanguage.AdditiveBinaryOperator");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cADDEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cADDPlusSignKeyword_0_0 = (Keyword)cADDEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cSUBEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cSUBHyphenMinusKeyword_1_0 = (Keyword)cSUBEnumLiteralDeclaration_1.eContents().get(0);
		
		//enum AdditiveBinaryOperator returns BinaryOperator:
		//	ADD="+" | SUB="-";
		public EnumRule getRule() { return rule; }
		
		//ADD="+" | SUB="-"
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//ADD="+"
		public EnumLiteralDeclaration getADDEnumLiteralDeclaration_0() { return cADDEnumLiteralDeclaration_0; }
		
		//"+"
		public Keyword getADDPlusSignKeyword_0_0() { return cADDPlusSignKeyword_0_0; }
		
		//SUB="-"
		public EnumLiteralDeclaration getSUBEnumLiteralDeclaration_1() { return cSUBEnumLiteralDeclaration_1; }
		
		//"-"
		public Keyword getSUBHyphenMinusKeyword_1_0() { return cSUBHyphenMinusKeyword_1_0; }
	}
	public class MultiplicativeBinaryOperatorElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.viatra.solver.language.SolverLanguage.MultiplicativeBinaryOperator");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cMULEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cMULAsteriskKeyword_0_0 = (Keyword)cMULEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cDIVEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cDIVSolidusKeyword_1_0 = (Keyword)cDIVEnumLiteralDeclaration_1.eContents().get(0);
		
		//enum MultiplicativeBinaryOperator returns BinaryOperator:
		//	MUL="*" | DIV="/";
		public EnumRule getRule() { return rule; }
		
		//MUL="*" | DIV="/"
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//MUL="*"
		public EnumLiteralDeclaration getMULEnumLiteralDeclaration_0() { return cMULEnumLiteralDeclaration_0; }
		
		//"*"
		public Keyword getMULAsteriskKeyword_0_0() { return cMULAsteriskKeyword_0_0; }
		
		//DIV="/"
		public EnumLiteralDeclaration getDIVEnumLiteralDeclaration_1() { return cDIVEnumLiteralDeclaration_1; }
		
		//"/"
		public Keyword getDIVSolidusKeyword_1_0() { return cDIVSolidusKeyword_1_0; }
	}
	public class ExponentialOpElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.viatra.solver.language.SolverLanguage.ExponentialOp");
		private final EnumLiteralDeclaration cPOWEnumLiteralDeclaration = (EnumLiteralDeclaration)rule.eContents().get(1);
		private final Keyword cPOWCircumflexAccentKeyword_0 = (Keyword)cPOWEnumLiteralDeclaration.eContents().get(0);
		
		//enum ExponentialOp returns BinaryOperator:
		//	POW="^";
		public EnumRule getRule() { return rule; }
		
		//POW="^"
		public EnumLiteralDeclaration getPOWEnumLiteralDeclaration() { return cPOWEnumLiteralDeclaration; }
		
		//"^"
		public Keyword getPOWCircumflexAccentKeyword_0() { return cPOWCircumflexAccentKeyword_0; }
	}
	public class UnaryOpElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.viatra.solver.language.SolverLanguage.UnaryOp");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cNEGEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cNEGExclamationMarkKeyword_0_0 = (Keyword)cNEGEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cPLUSEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cPLUSPlusSignKeyword_1_0 = (Keyword)cPLUSEnumLiteralDeclaration_1.eContents().get(0);
		private final EnumLiteralDeclaration cMINUSEnumLiteralDeclaration_2 = (EnumLiteralDeclaration)cAlternatives.eContents().get(2);
		private final Keyword cMINUSHyphenMinusKeyword_2_0 = (Keyword)cMINUSEnumLiteralDeclaration_2.eContents().get(0);
		private final EnumLiteralDeclaration cMAYEnumLiteralDeclaration_3 = (EnumLiteralDeclaration)cAlternatives.eContents().get(3);
		private final Keyword cMAYMayKeyword_3_0 = (Keyword)cMAYEnumLiteralDeclaration_3.eContents().get(0);
		private final EnumLiteralDeclaration cMUSTEnumLiteralDeclaration_4 = (EnumLiteralDeclaration)cAlternatives.eContents().get(4);
		private final Keyword cMUSTMustKeyword_4_0 = (Keyword)cMUSTEnumLiteralDeclaration_4.eContents().get(0);
		private final EnumLiteralDeclaration cCURRENTEnumLiteralDeclaration_5 = (EnumLiteralDeclaration)cAlternatives.eContents().get(5);
		private final Keyword cCURRENTCurrentKeyword_5_0 = (Keyword)cCURRENTEnumLiteralDeclaration_5.eContents().get(0);
		
		//enum UnaryOp:
		//	NEG="!" | PLUS="+" | MINUS="-" | MAY="may" | MUST="must" | CURRENT="current";
		public EnumRule getRule() { return rule; }
		
		//NEG="!" | PLUS="+" | MINUS="-" | MAY="may" | MUST="must" | CURRENT="current"
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//NEG="!"
		public EnumLiteralDeclaration getNEGEnumLiteralDeclaration_0() { return cNEGEnumLiteralDeclaration_0; }
		
		//"!"
		public Keyword getNEGExclamationMarkKeyword_0_0() { return cNEGExclamationMarkKeyword_0_0; }
		
		//PLUS="+"
		public EnumLiteralDeclaration getPLUSEnumLiteralDeclaration_1() { return cPLUSEnumLiteralDeclaration_1; }
		
		//"+"
		public Keyword getPLUSPlusSignKeyword_1_0() { return cPLUSPlusSignKeyword_1_0; }
		
		//MINUS="-"
		public EnumLiteralDeclaration getMINUSEnumLiteralDeclaration_2() { return cMINUSEnumLiteralDeclaration_2; }
		
		//"-"
		public Keyword getMINUSHyphenMinusKeyword_2_0() { return cMINUSHyphenMinusKeyword_2_0; }
		
		//MAY="may"
		public EnumLiteralDeclaration getMAYEnumLiteralDeclaration_3() { return cMAYEnumLiteralDeclaration_3; }
		
		//"may"
		public Keyword getMAYMayKeyword_3_0() { return cMAYMayKeyword_3_0; }
		
		//MUST="must"
		public EnumLiteralDeclaration getMUSTEnumLiteralDeclaration_4() { return cMUSTEnumLiteralDeclaration_4; }
		
		//"must"
		public Keyword getMUSTMustKeyword_4_0() { return cMUSTMustKeyword_4_0; }
		
		//CURRENT="current"
		public EnumLiteralDeclaration getCURRENTEnumLiteralDeclaration_5() { return cCURRENTEnumLiteralDeclaration_5; }
		
		//"current"
		public Keyword getCURRENTCurrentKeyword_5_0() { return cCURRENTCurrentKeyword_5_0; }
	}
	public class AggregationOpElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.viatra.solver.language.SolverLanguage.AggregationOp");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cONLYEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cONLYOnlyKeyword_0_0 = (Keyword)cONLYEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cSUMEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cSUMSumKeyword_1_0 = (Keyword)cSUMEnumLiteralDeclaration_1.eContents().get(0);
		private final EnumLiteralDeclaration cPRODEnumLiteralDeclaration_2 = (EnumLiteralDeclaration)cAlternatives.eContents().get(2);
		private final Keyword cPRODProdKeyword_2_0 = (Keyword)cPRODEnumLiteralDeclaration_2.eContents().get(0);
		private final EnumLiteralDeclaration cAVGEnumLiteralDeclaration_3 = (EnumLiteralDeclaration)cAlternatives.eContents().get(3);
		private final Keyword cAVGAvgKeyword_3_0 = (Keyword)cAVGEnumLiteralDeclaration_3.eContents().get(0);
		private final EnumLiteralDeclaration cMINEnumLiteralDeclaration_4 = (EnumLiteralDeclaration)cAlternatives.eContents().get(4);
		private final Keyword cMINMinKeyword_4_0 = (Keyword)cMINEnumLiteralDeclaration_4.eContents().get(0);
		private final EnumLiteralDeclaration cMAXEnumLiteralDeclaration_5 = (EnumLiteralDeclaration)cAlternatives.eContents().get(5);
		private final Keyword cMAXMaxKeyword_5_0 = (Keyword)cMAXEnumLiteralDeclaration_5.eContents().get(0);
		
		//enum AggregationOp:
		//	ONLY="only" | SUM="sum" | PROD="prod" | AVG="avg" | MIN="min" | MAX="max";
		public EnumRule getRule() { return rule; }
		
		//ONLY="only" | SUM="sum" | PROD="prod" | AVG="avg" | MIN="min" | MAX="max"
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//ONLY="only"
		public EnumLiteralDeclaration getONLYEnumLiteralDeclaration_0() { return cONLYEnumLiteralDeclaration_0; }
		
		//"only"
		public Keyword getONLYOnlyKeyword_0_0() { return cONLYOnlyKeyword_0_0; }
		
		//SUM="sum"
		public EnumLiteralDeclaration getSUMEnumLiteralDeclaration_1() { return cSUMEnumLiteralDeclaration_1; }
		
		//"sum"
		public Keyword getSUMSumKeyword_1_0() { return cSUMSumKeyword_1_0; }
		
		//PROD="prod"
		public EnumLiteralDeclaration getPRODEnumLiteralDeclaration_2() { return cPRODEnumLiteralDeclaration_2; }
		
		//"prod"
		public Keyword getPRODProdKeyword_2_0() { return cPRODProdKeyword_2_0; }
		
		//AVG="avg"
		public EnumLiteralDeclaration getAVGEnumLiteralDeclaration_3() { return cAVGEnumLiteralDeclaration_3; }
		
		//"avg"
		public Keyword getAVGAvgKeyword_3_0() { return cAVGAvgKeyword_3_0; }
		
		//MIN="min"
		public EnumLiteralDeclaration getMINEnumLiteralDeclaration_4() { return cMINEnumLiteralDeclaration_4; }
		
		//"min"
		public Keyword getMINMinKeyword_4_0() { return cMINMinKeyword_4_0; }
		
		//MAX="max"
		public EnumLiteralDeclaration getMAXEnumLiteralDeclaration_5() { return cMAXEnumLiteralDeclaration_5; }
		
		//"max"
		public Keyword getMAXMaxKeyword_5_0() { return cMAXMaxKeyword_5_0; }
	}
	public class LogicValueElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.viatra.solver.language.SolverLanguage.LogicValue");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cTRUEEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cTRUETrueKeyword_0_0 = (Keyword)cTRUEEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cFALSEEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cFALSEFalseKeyword_1_0 = (Keyword)cFALSEEnumLiteralDeclaration_1.eContents().get(0);
		private final EnumLiteralDeclaration cUNKNOWNEnumLiteralDeclaration_2 = (EnumLiteralDeclaration)cAlternatives.eContents().get(2);
		private final Keyword cUNKNOWNUnknownKeyword_2_0 = (Keyword)cUNKNOWNEnumLiteralDeclaration_2.eContents().get(0);
		private final EnumLiteralDeclaration cERROREnumLiteralDeclaration_3 = (EnumLiteralDeclaration)cAlternatives.eContents().get(3);
		private final Keyword cERRORErrorKeyword_3_0 = (Keyword)cERROREnumLiteralDeclaration_3.eContents().get(0);
		
		//enum LogicValue:
		//	TRUE="true" | FALSE="false" | UNKNOWN="unknown" | ERROR="error";
		public EnumRule getRule() { return rule; }
		
		//TRUE="true" | FALSE="false" | UNKNOWN="unknown" | ERROR="error"
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//TRUE="true"
		public EnumLiteralDeclaration getTRUEEnumLiteralDeclaration_0() { return cTRUEEnumLiteralDeclaration_0; }
		
		//"true"
		public Keyword getTRUETrueKeyword_0_0() { return cTRUETrueKeyword_0_0; }
		
		//FALSE="false"
		public EnumLiteralDeclaration getFALSEEnumLiteralDeclaration_1() { return cFALSEEnumLiteralDeclaration_1; }
		
		//"false"
		public Keyword getFALSEFalseKeyword_1_0() { return cFALSEFalseKeyword_1_0; }
		
		//UNKNOWN="unknown"
		public EnumLiteralDeclaration getUNKNOWNEnumLiteralDeclaration_2() { return cUNKNOWNEnumLiteralDeclaration_2; }
		
		//"unknown"
		public Keyword getUNKNOWNUnknownKeyword_2_0() { return cUNKNOWNUnknownKeyword_2_0; }
		
		//ERROR="error"
		public EnumLiteralDeclaration getERROREnumLiteralDeclaration_3() { return cERROREnumLiteralDeclaration_3; }
		
		//"error"
		public Keyword getERRORErrorKeyword_3_0() { return cERRORErrorKeyword_3_0; }
	}
	public class ObjectiveKindElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.viatra.solver.language.SolverLanguage.ObjectiveKind");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cMINIMIZEEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cMINIMIZEMinimizeKeyword_0_0 = (Keyword)cMINIMIZEEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cMAXIMIZEEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cMAXIMIZEMaximizeKeyword_1_0 = (Keyword)cMAXIMIZEEnumLiteralDeclaration_1.eContents().get(0);
		
		//enum ObjectiveKind:
		//	MINIMIZE="minimize" | MAXIMIZE="maximize";
		public EnumRule getRule() { return rule; }
		
		//MINIMIZE="minimize" | MAXIMIZE="maximize"
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//MINIMIZE="minimize"
		public EnumLiteralDeclaration getMINIMIZEEnumLiteralDeclaration_0() { return cMINIMIZEEnumLiteralDeclaration_0; }
		
		//"minimize"
		public Keyword getMINIMIZEMinimizeKeyword_0_0() { return cMINIMIZEMinimizeKeyword_0_0; }
		
		//MAXIMIZE="maximize"
		public EnumLiteralDeclaration getMAXIMIZEEnumLiteralDeclaration_1() { return cMAXIMIZEEnumLiteralDeclaration_1; }
		
		//"maximize"
		public Keyword getMAXIMIZEMaximizeKeyword_1_0() { return cMAXIMIZEMaximizeKeyword_1_0; }
	}
	
	private final ProblemElements pProblem;
	private final StatementElements pStatement;
	private final AssertionOrDefinitionElements pAssertionOrDefinition;
	private final PredicateDefinitionElements pPredicateDefinition;
	private final UnnamedErrorPrediateDefinitionElements pUnnamedErrorPrediateDefinition;
	private final DefaultDefinitionElements pDefaultDefinition;
	private final ExternPredicateDefinitionElements pExternPredicateDefinition;
	private final MetricTypeElements eMetricType;
	private final MetricDefinitionElements pMetricDefinition;
	private final ExternMetricDefinitionElements pExternMetricDefinition;
	private final ExpressionElements pExpression;
	private final IfElseElements pIfElse;
	private final DisjunctiveExpressionElements pDisjunctiveExpression;
	private final CaseElements pCase;
	private final ConjunctiveExpressionElements pConjunctiveExpression;
	private final BinaryOperatorElements eBinaryOperator;
	private final ComparisonOperatorElements eComparisonOperator;
	private final ComparisonExpressionElements pComparisonExpression;
	private final AdditiveBinaryOperatorElements eAdditiveBinaryOperator;
	private final AdditiveExpressionElements pAdditiveExpression;
	private final MultiplicativeBinaryOperatorElements eMultiplicativeBinaryOperator;
	private final MultiplicativeExpressionElements pMultiplicativeExpression;
	private final ExponentialOpElements eExponentialOp;
	private final ExponentialExpressionElements pExponentialExpression;
	private final UnaryOpElements eUnaryOp;
	private final UnaryExpressionElements pUnaryExpression;
	private final AggregationExpressionElements pAggregationExpression;
	private final CountElements pCount;
	private final AggregationOpElements eAggregationOp;
	private final AggregationElements pAggregation;
	private final AtomicExpressionElements pAtomicExpression;
	private final CallElements pCall;
	private final ArgumentListElements pArgumentList;
	private final ArgumentElements pArgument;
	private final ExpressionArgumentElements pExpressionArgument;
	private final StarArgumentElements pStarArgument;
	private final TypedArgumentElements pTypedArgument;
	private final TypedStarArgumentElements pTypedStarArgument;
	private final ReferenceElements pReference;
	private final IntervalElements pInterval;
	private final LiteralElements pLiteral;
	private final LogicValueElements eLogicValue;
	private final LogicLiteralElements pLogicLiteral;
	private final NumericLiteralElements pNumericLiteral;
	private final InfinityLiteralElements pInfinityLiteral;
	private final EmptyIntervalLiteralElements pEmptyIntervalLiteral;
	private final StringLiteralElements pStringLiteral;
	private final ClassDefinitionElements pClassDefinition;
	private final MemberDefinitionElements pMemberDefinition;
	private final MultiplicityElements pMultiplicity;
	private final ManyMultiplicityElements pManyMultiplicity;
	private final ExactMultiplicityElements pExactMultiplicity;
	private final BoundedMultiplicityElements pBoundedMultiplicity;
	private final ScopeDefinitionElements pScopeDefinition;
	private final ExactScopeDefinitionElements pExactScopeDefinition;
	private final BoundedScopeDefinitionElements pBoundedScopeDefinition;
	private final LowerBoundedScopeDefinitionElements pLowerBoundedScopeDefinition;
	private final ObjectiveKindElements eObjectiveKind;
	private final ObjectiveDefinitionElements pObjectiveDefinition;
	private final UpperMultiplictyElements pUpperMultiplicty;
	private final RealElements pReal;
	private final QualifiedNameElements pQualifiedName;
	private final TerminalRule tSTRING;
	private final TerminalRule tQUOTED_ID;
	private final TerminalRule tSL_COMMENT;
	private final TerminalRule tTRANSITIVE_CLOSURE;
	private final TerminalRule tREFLEXIVE_TRANSITIVE_CLOSURE;
	private final TerminalRule tFULL_STOP;
	private final NamedElementElements pNamedElement;
	
	private final Grammar grammar;
	
	private final TerminalsGrammarAccess gaTerminals;

	@Inject
	public SolverLanguageGrammarAccess(GrammarProvider grammarProvider,
			TerminalsGrammarAccess gaTerminals) {
		this.grammar = internalFindGrammar(grammarProvider);
		this.gaTerminals = gaTerminals;
		this.pProblem = new ProblemElements();
		this.pStatement = new StatementElements();
		this.pAssertionOrDefinition = new AssertionOrDefinitionElements();
		this.pPredicateDefinition = new PredicateDefinitionElements();
		this.pUnnamedErrorPrediateDefinition = new UnnamedErrorPrediateDefinitionElements();
		this.pDefaultDefinition = new DefaultDefinitionElements();
		this.pExternPredicateDefinition = new ExternPredicateDefinitionElements();
		this.eMetricType = new MetricTypeElements();
		this.pMetricDefinition = new MetricDefinitionElements();
		this.pExternMetricDefinition = new ExternMetricDefinitionElements();
		this.pExpression = new ExpressionElements();
		this.pIfElse = new IfElseElements();
		this.pDisjunctiveExpression = new DisjunctiveExpressionElements();
		this.pCase = new CaseElements();
		this.pConjunctiveExpression = new ConjunctiveExpressionElements();
		this.eBinaryOperator = new BinaryOperatorElements();
		this.eComparisonOperator = new ComparisonOperatorElements();
		this.pComparisonExpression = new ComparisonExpressionElements();
		this.eAdditiveBinaryOperator = new AdditiveBinaryOperatorElements();
		this.pAdditiveExpression = new AdditiveExpressionElements();
		this.eMultiplicativeBinaryOperator = new MultiplicativeBinaryOperatorElements();
		this.pMultiplicativeExpression = new MultiplicativeExpressionElements();
		this.eExponentialOp = new ExponentialOpElements();
		this.pExponentialExpression = new ExponentialExpressionElements();
		this.eUnaryOp = new UnaryOpElements();
		this.pUnaryExpression = new UnaryExpressionElements();
		this.pAggregationExpression = new AggregationExpressionElements();
		this.pCount = new CountElements();
		this.eAggregationOp = new AggregationOpElements();
		this.pAggregation = new AggregationElements();
		this.pAtomicExpression = new AtomicExpressionElements();
		this.pCall = new CallElements();
		this.pArgumentList = new ArgumentListElements();
		this.pArgument = new ArgumentElements();
		this.pExpressionArgument = new ExpressionArgumentElements();
		this.pStarArgument = new StarArgumentElements();
		this.pTypedArgument = new TypedArgumentElements();
		this.pTypedStarArgument = new TypedStarArgumentElements();
		this.pReference = new ReferenceElements();
		this.pInterval = new IntervalElements();
		this.pLiteral = new LiteralElements();
		this.eLogicValue = new LogicValueElements();
		this.pLogicLiteral = new LogicLiteralElements();
		this.pNumericLiteral = new NumericLiteralElements();
		this.pInfinityLiteral = new InfinityLiteralElements();
		this.pEmptyIntervalLiteral = new EmptyIntervalLiteralElements();
		this.pStringLiteral = new StringLiteralElements();
		this.pClassDefinition = new ClassDefinitionElements();
		this.pMemberDefinition = new MemberDefinitionElements();
		this.pMultiplicity = new MultiplicityElements();
		this.pManyMultiplicity = new ManyMultiplicityElements();
		this.pExactMultiplicity = new ExactMultiplicityElements();
		this.pBoundedMultiplicity = new BoundedMultiplicityElements();
		this.pScopeDefinition = new ScopeDefinitionElements();
		this.pExactScopeDefinition = new ExactScopeDefinitionElements();
		this.pBoundedScopeDefinition = new BoundedScopeDefinitionElements();
		this.pLowerBoundedScopeDefinition = new LowerBoundedScopeDefinitionElements();
		this.eObjectiveKind = new ObjectiveKindElements();
		this.pObjectiveDefinition = new ObjectiveDefinitionElements();
		this.pUpperMultiplicty = new UpperMultiplictyElements();
		this.pReal = new RealElements();
		this.pQualifiedName = new QualifiedNameElements();
		this.tSTRING = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.viatra.solver.language.SolverLanguage.STRING");
		this.tQUOTED_ID = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.viatra.solver.language.SolverLanguage.QUOTED_ID");
		this.tSL_COMMENT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.viatra.solver.language.SolverLanguage.SL_COMMENT");
		this.tTRANSITIVE_CLOSURE = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.viatra.solver.language.SolverLanguage.TRANSITIVE_CLOSURE");
		this.tREFLEXIVE_TRANSITIVE_CLOSURE = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.viatra.solver.language.SolverLanguage.REFLEXIVE_TRANSITIVE_CLOSURE");
		this.tFULL_STOP = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.viatra.solver.language.SolverLanguage.FULL_STOP");
		this.pNamedElement = new NamedElementElements();
	}
	
	protected Grammar internalFindGrammar(GrammarProvider grammarProvider) {
		Grammar grammar = grammarProvider.getGrammar(this);
		while (grammar != null) {
			if ("org.eclipse.viatra.solver.language.SolverLanguage".equals(grammar.getName())) {
				return grammar;
			}
			List<Grammar> grammars = grammar.getUsedGrammars();
			if (!grammars.isEmpty()) {
				grammar = grammars.iterator().next();
			} else {
				return null;
			}
		}
		return grammar;
	}
	
	@Override
	public Grammar getGrammar() {
		return grammar;
	}
	
	
	public TerminalsGrammarAccess getTerminalsGrammarAccess() {
		return gaTerminals;
	}

	
	//Problem:
	//	statements+=Statement*;
	public ProblemElements getProblemAccess() {
		return pProblem;
	}
	
	public ParserRule getProblemRule() {
		return getProblemAccess().getRule();
	}
	
	//Statement:
	//	(AssertionOrDefinition | PredicateDefinition | UnnamedErrorPrediateDefinition | DefaultDefinition |
	//	ExternPredicateDefinition | MetricDefinition | ExternMetricDefinition | ClassDefinition | ScopeDefinition |
	//	ObjectiveDefinition) FULL_STOP;
	public StatementElements getStatementAccess() {
		return pStatement;
	}
	
	public ParserRule getStatementRule() {
		return getStatementAccess().getRule();
	}
	
	//AssertionOrDefinition Statement:
	//	Expression ({Assertion.body=current} (":" range=Expression)? | {PredicateDefinition.head=current} ":-"
	//	body=Expression | {MetricDefinition.head=current} "=" body=Expression);
	public AssertionOrDefinitionElements getAssertionOrDefinitionAccess() {
		return pAssertionOrDefinition;
	}
	
	public ParserRule getAssertionOrDefinitionRule() {
		return getAssertionOrDefinitionAccess().getRule();
	}
	
	//PredicateDefinition:
	//	(functional?="functional" error?="error"? | error?="error" functional?="functional"?) head=Call ":-" body=Expression;
	public PredicateDefinitionElements getPredicateDefinitionAccess() {
		return pPredicateDefinition;
	}
	
	public ParserRule getPredicateDefinitionRule() {
		return getPredicateDefinitionAccess().getRule();
	}
	
	//UnnamedErrorPrediateDefinition:
	//	"error" argumentList=ArgumentList ":-" body=Expression;
	public UnnamedErrorPrediateDefinitionElements getUnnamedErrorPrediateDefinitionAccess() {
		return pUnnamedErrorPrediateDefinition;
	}
	
	public ParserRule getUnnamedErrorPrediateDefinitionRule() {
		return getUnnamedErrorPrediateDefinitionAccess().getRule();
	}
	
	//DefaultDefinition:
	//	"default" head=Call ":" range=Expression;
	public DefaultDefinitionElements getDefaultDefinitionAccess() {
		return pDefaultDefinition;
	}
	
	public ParserRule getDefaultDefinitionRule() {
		return getDefaultDefinitionAccess().getRule();
	}
	
	//ExternPredicateDefinition:
	//	"extern" head=Call;
	public ExternPredicateDefinitionElements getExternPredicateDefinitionAccess() {
		return pExternPredicateDefinition;
	}
	
	public ParserRule getExternPredicateDefinitionRule() {
		return getExternPredicateDefinitionAccess().getRule();
	}
	
	//enum MetricType:
	//	INT="int" | REAL="real";
	public MetricTypeElements getMetricTypeAccess() {
		return eMetricType;
	}
	
	public EnumRule getMetricTypeRule() {
		return getMetricTypeAccess().getRule();
	}
	
	//MetricDefinition:
	//	type=MetricType head=Expression "=" body=Expression;
	public MetricDefinitionElements getMetricDefinitionAccess() {
		return pMetricDefinition;
	}
	
	public ParserRule getMetricDefinitionRule() {
		return getMetricDefinitionAccess().getRule();
	}
	
	//ExternMetricDefinition:
	//	"extern" type=MetricType head=Call;
	public ExternMetricDefinitionElements getExternMetricDefinitionAccess() {
		return pExternMetricDefinition;
	}
	
	public ParserRule getExternMetricDefinitionRule() {
		return getExternMetricDefinitionAccess().getRule();
	}
	
	//Expression:
	//	IfElse | DisjunctiveExpression;
	public ExpressionElements getExpressionAccess() {
		return pExpression;
	}
	
	public ParserRule getExpressionRule() {
		return getExpressionAccess().getRule();
	}
	
	//IfElse:
	//	"if" condition=Expression "then" then=Expression "else" else=Expression;
	public IfElseElements getIfElseAccess() {
		return pIfElse;
	}
	
	public ParserRule getIfElseRule() {
		return getIfElseAccess().getRule();
	}
	
	//DisjunctiveExpression Expression:
	//	ConjunctiveExpression ({Disjunction.children+=current} (";" children+=ConjunctiveExpression)+ |
	//	{Case.condition=current} "->" body=ConjunctiveExpression {Switch.cases+=current} (";" cases+=Case)*)?;
	public DisjunctiveExpressionElements getDisjunctiveExpressionAccess() {
		return pDisjunctiveExpression;
	}
	
	public ParserRule getDisjunctiveExpressionRule() {
		return getDisjunctiveExpressionAccess().getRule();
	}
	
	//Case:
	//	condition=ConjunctiveExpression "->" body=ConjunctiveExpression;
	public CaseElements getCaseAccess() {
		return pCase;
	}
	
	public ParserRule getCaseRule() {
		return getCaseAccess().getRule();
	}
	
	//ConjunctiveExpression Expression:
	//	ComparisonExpression ({Conjunction.children+=current} ("," children+=ComparisonExpression)+)?;
	public ConjunctiveExpressionElements getConjunctiveExpressionAccess() {
		return pConjunctiveExpression;
	}
	
	public ParserRule getConjunctiveExpressionRule() {
		return getConjunctiveExpressionAccess().getRule();
	}
	
	//enum BinaryOperator:
	//	EQ | NOT_EQ | LESS | LESS_EQ | GREATER | GREATER_EQ | IN | ADD | SUB | MUL | DIV | POW;
	public BinaryOperatorElements getBinaryOperatorAccess() {
		return eBinaryOperator;
	}
	
	public EnumRule getBinaryOperatorRule() {
		return getBinaryOperatorAccess().getRule();
	}
	
	//enum ComparisonOperator returns BinaryOperator:
	//	EQ="==" | NOT_EQ="!=" | LESS="<" | LESS_EQ="<=" | GREATER=">" | GREATER_EQ=">=" | IN="in";
	public ComparisonOperatorElements getComparisonOperatorAccess() {
		return eComparisonOperator;
	}
	
	public EnumRule getComparisonOperatorRule() {
		return getComparisonOperatorAccess().getRule();
	}
	
	//ComparisonExpression Expression:
	//	AdditiveExpression ({Comparison.left=current} op=ComparisonOperator right=AdditiveExpression)?;
	public ComparisonExpressionElements getComparisonExpressionAccess() {
		return pComparisonExpression;
	}
	
	public ParserRule getComparisonExpressionRule() {
		return getComparisonExpressionAccess().getRule();
	}
	
	//enum AdditiveBinaryOperator returns BinaryOperator:
	//	ADD="+" | SUB="-";
	public AdditiveBinaryOperatorElements getAdditiveBinaryOperatorAccess() {
		return eAdditiveBinaryOperator;
	}
	
	public EnumRule getAdditiveBinaryOperatorRule() {
		return getAdditiveBinaryOperatorAccess().getRule();
	}
	
	//AdditiveExpression Expression:
	//	MultiplicativeExpression ({BinaryExpression.left=current} op=AdditiveBinaryOperator right=MultiplicativeExpression)*;
	public AdditiveExpressionElements getAdditiveExpressionAccess() {
		return pAdditiveExpression;
	}
	
	public ParserRule getAdditiveExpressionRule() {
		return getAdditiveExpressionAccess().getRule();
	}
	
	//enum MultiplicativeBinaryOperator returns BinaryOperator:
	//	MUL="*" | DIV="/";
	public MultiplicativeBinaryOperatorElements getMultiplicativeBinaryOperatorAccess() {
		return eMultiplicativeBinaryOperator;
	}
	
	public EnumRule getMultiplicativeBinaryOperatorRule() {
		return getMultiplicativeBinaryOperatorAccess().getRule();
	}
	
	//MultiplicativeExpression Expression:
	//	ExponentialExpression ({BinaryExpression.left=current} op=MultiplicativeBinaryOperator right=ExponentialExpression)*;
	public MultiplicativeExpressionElements getMultiplicativeExpressionAccess() {
		return pMultiplicativeExpression;
	}
	
	public ParserRule getMultiplicativeExpressionRule() {
		return getMultiplicativeExpressionAccess().getRule();
	}
	
	//enum ExponentialOp returns BinaryOperator:
	//	POW="^";
	public ExponentialOpElements getExponentialOpAccess() {
		return eExponentialOp;
	}
	
	public EnumRule getExponentialOpRule() {
		return getExponentialOpAccess().getRule();
	}
	
	//ExponentialExpression Expression:
	//	UnaryExpression ({BinaryExpression.left=current} op=ExponentialOp right=ExponentialExpression)?;
	public ExponentialExpressionElements getExponentialExpressionAccess() {
		return pExponentialExpression;
	}
	
	public ParserRule getExponentialExpressionRule() {
		return getExponentialExpressionAccess().getRule();
	}
	
	//enum UnaryOp:
	//	NEG="!" | PLUS="+" | MINUS="-" | MAY="may" | MUST="must" | CURRENT="current";
	public UnaryOpElements getUnaryOpAccess() {
		return eUnaryOp;
	}
	
	public EnumRule getUnaryOpRule() {
		return getUnaryOpAccess().getRule();
	}
	
	//UnaryExpression Expression:
	//	AggregationExpression | {UnaryExpression} op=UnaryOp body=AggregationExpression;
	public UnaryExpressionElements getUnaryExpressionAccess() {
		return pUnaryExpression;
	}
	
	public ParserRule getUnaryExpressionRule() {
		return getUnaryExpressionAccess().getRule();
	}
	
	//AggregationExpression Expression:
	//	AtomicExpression | Count | Aggregation;
	public AggregationExpressionElements getAggregationExpressionAccess() {
		return pAggregationExpression;
	}
	
	public ParserRule getAggregationExpressionRule() {
		return getAggregationExpressionAccess().getRule();
	}
	
	//Count:
	//	"count" "{" body=Expression "}";
	public CountElements getCountAccess() {
		return pCount;
	}
	
	public ParserRule getCountRule() {
		return getCountAccess().getRule();
	}
	
	//enum AggregationOp:
	//	ONLY="only" | SUM="sum" | PROD="prod" | AVG="avg" | MIN="min" | MAX="max";
	public AggregationOpElements getAggregationOpAccess() {
		return eAggregationOp;
	}
	
	public EnumRule getAggregationOpRule() {
		return getAggregationOpAccess().getRule();
	}
	
	//Aggregation:
	//	op=AggregationOp "{" body=Expression "|" condition=Expression "}";
	public AggregationElements getAggregationAccess() {
		return pAggregation;
	}
	
	public ParserRule getAggregationRule() {
		return getAggregationAccess().getRule();
	}
	
	//AtomicExpression Expression:
	//	Reference | Call | Interval | Literal | "(" Expression ")";
	public AtomicExpressionElements getAtomicExpressionAccess() {
		return pAtomicExpression;
	}
	
	public ParserRule getAtomicExpressionRule() {
		return getAtomicExpressionAccess().getRule();
	}
	
	//Call:
	//	functor=Reference (transitiveClosure?=TRANSITIVE_CLOSURE | reflexiveTransitiveClosure?=REFLEXIVE_TRANSITIVE_CLOSURE)?
	//	argumentList=ArgumentList;
	public CallElements getCallAccess() {
		return pCall;
	}
	
	public ParserRule getCallRule() {
		return getCallAccess().getRule();
	}
	
	//ArgumentList:
	//	{ArgumentList} "(" (arguments+=Argument ("," arguments+=Argument)*)? ")";
	public ArgumentListElements getArgumentListAccess() {
		return pArgumentList;
	}
	
	public ParserRule getArgumentListRule() {
		return getArgumentListAccess().getRule();
	}
	
	//Argument:
	//	ExpressionArgument | StarArgument | TypedArgument | TypedStarArgument;
	public ArgumentElements getArgumentAccess() {
		return pArgument;
	}
	
	public ParserRule getArgumentRule() {
		return getArgumentAccess().getRule();
	}
	
	//ExpressionArgument:
	//	body=ComparisonExpression;
	public ExpressionArgumentElements getExpressionArgumentAccess() {
		return pExpressionArgument;
	}
	
	public ParserRule getExpressionArgumentRule() {
		return getExpressionArgumentAccess().getRule();
	}
	
	//StarArgument:
	//	{StarArgument} "*";
	public StarArgumentElements getStarArgumentAccess() {
		return pStarArgument;
	}
	
	public ParserRule getStarArgumentRule() {
		return getStarArgumentAccess().getRule();
	}
	
	//TypedArgument:
	//	type=[NamedElement|QualifiedName] variable=[NamedElement|QualifiedName];
	public TypedArgumentElements getTypedArgumentAccess() {
		return pTypedArgument;
	}
	
	public ParserRule getTypedArgumentRule() {
		return getTypedArgumentAccess().getRule();
	}
	
	//TypedStarArgument:
	//	type=[NamedElement|QualifiedName] "*";
	public TypedStarArgumentElements getTypedStarArgumentAccess() {
		return pTypedStarArgument;
	}
	
	public ParserRule getTypedStarArgumentRule() {
		return getTypedStarArgumentAccess().getRule();
	}
	
	//Reference:
	//	referred=[NamedElement|QualifiedName];
	public ReferenceElements getReferenceAccess() {
		return pReference;
	}
	
	public ParserRule getReferenceRule() {
		return getReferenceAccess().getRule();
	}
	
	//Interval:
	//	"[" lowerBound=Expression ".." upperBound=Expression "]";
	public IntervalElements getIntervalAccess() {
		return pInterval;
	}
	
	public ParserRule getIntervalRule() {
		return getIntervalAccess().getRule();
	}
	
	//Literal:
	//	LogicLiteral | NumericLiteral | InfinityLiteral | EmptyIntervalLiteral | StringLiteral;
	public LiteralElements getLiteralAccess() {
		return pLiteral;
	}
	
	public ParserRule getLiteralRule() {
		return getLiteralAccess().getRule();
	}
	
	//enum LogicValue:
	//	TRUE="true" | FALSE="false" | UNKNOWN="unknown" | ERROR="error";
	public LogicValueElements getLogicValueAccess() {
		return eLogicValue;
	}
	
	public EnumRule getLogicValueRule() {
		return getLogicValueAccess().getRule();
	}
	
	//LogicLiteral:
	//	value=LogicValue;
	public LogicLiteralElements getLogicLiteralAccess() {
		return pLogicLiteral;
	}
	
	public ParserRule getLogicLiteralRule() {
		return getLogicLiteralAccess().getRule();
	}
	
	//NumericLiteral:
	//	value=Real;
	public NumericLiteralElements getNumericLiteralAccess() {
		return pNumericLiteral;
	}
	
	public ParserRule getNumericLiteralRule() {
		return getNumericLiteralAccess().getRule();
	}
	
	//InfinityLiteral:
	//	{InfinityLiteral} "inf";
	public InfinityLiteralElements getInfinityLiteralAccess() {
		return pInfinityLiteral;
	}
	
	public ParserRule getInfinityLiteralRule() {
		return getInfinityLiteralAccess().getRule();
	}
	
	//EmptyIntervalLiteral:
	//	{EmptyIntervalLiteral} "empty";
	public EmptyIntervalLiteralElements getEmptyIntervalLiteralAccess() {
		return pEmptyIntervalLiteral;
	}
	
	public ParserRule getEmptyIntervalLiteralRule() {
		return getEmptyIntervalLiteralAccess().getRule();
	}
	
	//StringLiteral:
	//	value=STRING;
	public StringLiteralElements getStringLiteralAccess() {
		return pStringLiteral;
	}
	
	public ParserRule getStringLiteralRule() {
		return getStringLiteralAccess().getRule();
	}
	
	//ClassDefinition:
	//	abstract?="abstract"? "class" name=ID ("extends" superclasses+=[NamedElement|QualifiedName] (","
	//	superclasses+=[NamedElement|QualifiedName])*)?
	//	"{" members+=MemberDefinition* "}";
	public ClassDefinitionElements getClassDefinitionAccess() {
		return pClassDefinition;
	}
	
	public ParserRule getClassDefinitionRule() {
		return getClassDefinitionAccess().getRule();
	}
	
	//MemberDefinition:
	//	containment?="contains"? type=[NamedElement|QualifiedName] multiplicity=Multiplicity? name=ID ("opposite"
	//	opposite=[NamedElement|QualifiedName])? ";"?;
	public MemberDefinitionElements getMemberDefinitionAccess() {
		return pMemberDefinition;
	}
	
	public ParserRule getMemberDefinitionRule() {
		return getMemberDefinitionAccess().getRule();
	}
	
	//Multiplicity:
	//	ManyMultiplicity | ExactMultiplicity | BoundedMultiplicity;
	public MultiplicityElements getMultiplicityAccess() {
		return pMultiplicity;
	}
	
	public ParserRule getMultiplicityRule() {
		return getMultiplicityAccess().getRule();
	}
	
	//ManyMultiplicity:
	//	{ManyMultiplicity} "[" "]";
	public ManyMultiplicityElements getManyMultiplicityAccess() {
		return pManyMultiplicity;
	}
	
	public ParserRule getManyMultiplicityRule() {
		return getManyMultiplicityAccess().getRule();
	}
	
	//ExactMultiplicity:
	//	"[" multiplicity=UpperMultiplicty "]";
	public ExactMultiplicityElements getExactMultiplicityAccess() {
		return pExactMultiplicity;
	}
	
	public ParserRule getExactMultiplicityRule() {
		return getExactMultiplicityAccess().getRule();
	}
	
	//BoundedMultiplicity:
	//	"[" lowerBound=INT ".." upperBound=UpperMultiplicty "]";
	public BoundedMultiplicityElements getBoundedMultiplicityAccess() {
		return pBoundedMultiplicity;
	}
	
	public ParserRule getBoundedMultiplicityRule() {
		return getBoundedMultiplicityAccess().getRule();
	}
	
	//ScopeDefinition:
	//	ExactScopeDefinition | BoundedScopeDefinition | LowerBoundedScopeDefinition;
	public ScopeDefinitionElements getScopeDefinitionAccess() {
		return pScopeDefinition;
	}
	
	public ParserRule getScopeDefinitionRule() {
		return getScopeDefinitionAccess().getRule();
	}
	
	//ExactScopeDefinition:
	//	"scope" type=[NamedElement|QualifiedName] "==" exactScope=INT;
	public ExactScopeDefinitionElements getExactScopeDefinitionAccess() {
		return pExactScopeDefinition;
	}
	
	public ParserRule getExactScopeDefinitionRule() {
		return getExactScopeDefinitionAccess().getRule();
	}
	
	//BoundedScopeDefinition:
	//	"scope" ((lowerBound=INT "<=")? type=[NamedElement|QualifiedName] "<=" upperBound=INT | upperBound=INT ">="
	//	type=[NamedElement|QualifiedName] (">=" lowerBound=INT)?);
	public BoundedScopeDefinitionElements getBoundedScopeDefinitionAccess() {
		return pBoundedScopeDefinition;
	}
	
	public ParserRule getBoundedScopeDefinitionRule() {
		return getBoundedScopeDefinitionAccess().getRule();
	}
	
	//LowerBoundedScopeDefinition:
	//	"scope" (lowerBound=INT "<=" type=[NamedElement|QualifiedName] | type=[NamedElement|QualifiedName] ">="
	//	lowerBound=INT);
	public LowerBoundedScopeDefinitionElements getLowerBoundedScopeDefinitionAccess() {
		return pLowerBoundedScopeDefinition;
	}
	
	public ParserRule getLowerBoundedScopeDefinitionRule() {
		return getLowerBoundedScopeDefinitionAccess().getRule();
	}
	
	//enum ObjectiveKind:
	//	MINIMIZE="minimize" | MAXIMIZE="maximize";
	public ObjectiveKindElements getObjectiveKindAccess() {
		return eObjectiveKind;
	}
	
	public EnumRule getObjectiveKindRule() {
		return getObjectiveKindAccess().getRule();
	}
	
	//ObjectiveDefinition:
	//	kind=ObjectiveKind objective=Expression;
	public ObjectiveDefinitionElements getObjectiveDefinitionAccess() {
		return pObjectiveDefinition;
	}
	
	public ParserRule getObjectiveDefinitionRule() {
		return getObjectiveDefinitionAccess().getRule();
	}
	
	//UpperMultiplicty ecore::EInt:
	//	INT | "*";
	public UpperMultiplictyElements getUpperMultiplictyAccess() {
		return pUpperMultiplicty;
	}
	
	public ParserRule getUpperMultiplictyRule() {
		return getUpperMultiplictyAccess().getRule();
	}
	
	//Real ecore::EBigDecimal hidden():
	//	INT ("." INT)?;
	public RealElements getRealAccess() {
		return pReal;
	}
	
	public ParserRule getRealRule() {
		return getRealAccess().getRule();
	}
	
	//QualifiedName hidden():
	//	ID ("." ID)* | QUOTED_ID;
	public QualifiedNameElements getQualifiedNameAccess() {
		return pQualifiedName;
	}
	
	public ParserRule getQualifiedNameRule() {
		return getQualifiedNameAccess().getRule();
	}
	
	//@Override
	//terminal STRING:
	//	'"' ('\\' . | !('\\' | '"'))* '"';
	public TerminalRule getSTRINGRule() {
		return tSTRING;
	}
	
	//terminal QUOTED_ID:
	//	'\'' ('\\' . | !('\\' | '\''))* '\'';
	public TerminalRule getQUOTED_IDRule() {
		return tQUOTED_ID;
	}
	
	//@Override
	//terminal SL_COMMENT:
	//	('%' | '//') !('\n' | '\r')* ('\r'? '\n')?;
	public TerminalRule getSL_COMMENTRule() {
		return tSL_COMMENT;
	}
	
	//terminal TRANSITIVE_CLOSURE:
	//	"synthetic:TRANSITIVE_CLOSURE";
	public TerminalRule getTRANSITIVE_CLOSURERule() {
		return tTRANSITIVE_CLOSURE;
	}
	
	//terminal REFLEXIVE_TRANSITIVE_CLOSURE:
	//	"synthetic:REFLEXIVE_TRANSITIVE_CLOSURE";
	public TerminalRule getREFLEXIVE_TRANSITIVE_CLOSURERule() {
		return tREFLEXIVE_TRANSITIVE_CLOSURE;
	}
	
	//terminal FULL_STOP:
	//	"synthetic:FULL_STOP";
	public TerminalRule getFULL_STOPRule() {
		return tFULL_STOP;
	}
	
	//NamedElement:
	//	name=QualifiedName;
	public NamedElementElements getNamedElementAccess() {
		return pNamedElement;
	}
	
	public ParserRule getNamedElementRule() {
		return getNamedElementAccess().getRule();
	}
	
	//terminal ID:
	//	'^'? ('a'..'z' | 'A'..'Z' | '_') ('a'..'z' | 'A'..'Z' | '_' | '0'..'9')*;
	public TerminalRule getIDRule() {
		return gaTerminals.getIDRule();
	}
	
	//terminal INT returns ecore::EInt:
	//	'0'..'9'+;
	public TerminalRule getINTRule() {
		return gaTerminals.getINTRule();
	}
	
	//terminal ML_COMMENT:
	//	'/*'->'*/';
	public TerminalRule getML_COMMENTRule() {
		return gaTerminals.getML_COMMENTRule();
	}
	
	//terminal WS:
	//	' ' | '\t' | '\r' | '\n'+;
	public TerminalRule getWSRule() {
		return gaTerminals.getWSRule();
	}
	
	//terminal ANY_OTHER:
	//	.;
	public TerminalRule getANY_OTHERRule() {
		return gaTerminals.getANY_OTHERRule();
	}
}
