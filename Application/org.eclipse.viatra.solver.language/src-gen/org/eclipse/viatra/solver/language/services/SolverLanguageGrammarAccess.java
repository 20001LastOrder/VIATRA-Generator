/*
 * generated by Xtext 2.18.0.M3
 */
package org.eclipse.viatra.solver.language.services;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import java.util.List;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Alternatives;
import org.eclipse.xtext.Assignment;
import org.eclipse.xtext.Grammar;
import org.eclipse.xtext.GrammarUtil;
import org.eclipse.xtext.Group;
import org.eclipse.xtext.Keyword;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.RuleCall;
import org.eclipse.xtext.TerminalRule;
import org.eclipse.xtext.common.services.TerminalsGrammarAccess;
import org.eclipse.xtext.service.AbstractElementFinder.AbstractGrammarElementFinder;
import org.eclipse.xtext.service.GrammarProvider;

@Singleton
public class SolverLanguageGrammarAccess extends AbstractGrammarElementFinder {
	
	public class ProblemElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.viatra.solver.language.SolverLanguage.Problem");
		private final Assignment cStatementsAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cStatementsStatementParserRuleCall_0 = (RuleCall)cStatementsAssignment.eContents().get(0);
		
		//Problem:
		//	statements+=Statement*;
		@Override public ParserRule getRule() { return rule; }
		
		//statements+=Statement*
		public Assignment getStatementsAssignment() { return cStatementsAssignment; }
		
		//Statement
		public RuleCall getStatementsStatementParserRuleCall_0() { return cStatementsStatementParserRuleCall_0; }
	}
	public class StatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.viatra.solver.language.SolverLanguage.Statement");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cInterpretationParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cPredicateParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//Statement:
		//	Interpretation | Predicate;
		@Override public ParserRule getRule() { return rule; }
		
		//Interpretation | Predicate
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//Interpretation
		public RuleCall getInterpretationParserRuleCall_0() { return cInterpretationParserRuleCall_0; }
		
		//Predicate
		public RuleCall getPredicateParserRuleCall_1() { return cPredicateParserRuleCall_1; }
	}
	public class REALLiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.viatra.solver.language.SolverLanguage.REALLiteral");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cHyphenMinusKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final RuleCall cINTTerminalRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final Keyword cFullStopKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final RuleCall cINTTerminalRuleCall_3 = (RuleCall)cGroup.eContents().get(3);
		
		//REALLiteral ecore::EBigDecimal:
		//	'-'? INT '.' INT;
		@Override public ParserRule getRule() { return rule; }
		
		//'-'? INT '.' INT
		public Group getGroup() { return cGroup; }
		
		//'-'?
		public Keyword getHyphenMinusKeyword_0() { return cHyphenMinusKeyword_0; }
		
		//INT
		public RuleCall getINTTerminalRuleCall_1() { return cINTTerminalRuleCall_1; }
		
		//'.'
		public Keyword getFullStopKeyword_2() { return cFullStopKeyword_2; }
		
		//INT
		public RuleCall getINTTerminalRuleCall_3() { return cINTTerminalRuleCall_3; }
	}
	public class INTLiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.viatra.solver.language.SolverLanguage.INTLiteral");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cHyphenMinusKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final RuleCall cINTTerminalRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		
		//INTLiteral ecore::EInt:
		//	'-'? INT;
		@Override public ParserRule getRule() { return rule; }
		
		//'-'? INT
		public Group getGroup() { return cGroup; }
		
		//'-'?
		public Keyword getHyphenMinusKeyword_0() { return cHyphenMinusKeyword_0; }
		
		//INT
		public RuleCall getINTTerminalRuleCall_1() { return cINTTerminalRuleCall_1; }
	}
	public class BooleanValueElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.viatra.solver.language.SolverLanguage.BooleanValue");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Action cBooleanTrueAction_0_0 = (Action)cGroup_0.eContents().get(0);
		private final Keyword cTrueKeyword_0_1 = (Keyword)cGroup_0.eContents().get(1);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Keyword cFalseKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Action cBooleanFalseAction_1_1 = (Action)cGroup_1.eContents().get(1);
		
		//BooleanValue:
		//	{BooleanTrue} 'true' | 'false' {BooleanFalse};
		@Override public ParserRule getRule() { return rule; }
		
		//{BooleanTrue} 'true' | 'false' {BooleanFalse}
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//{BooleanTrue} 'true'
		public Group getGroup_0() { return cGroup_0; }
		
		//{BooleanTrue}
		public Action getBooleanTrueAction_0_0() { return cBooleanTrueAction_0_0; }
		
		//'true'
		public Keyword getTrueKeyword_0_1() { return cTrueKeyword_0_1; }
		
		//'false' {BooleanFalse}
		public Group getGroup_1() { return cGroup_1; }
		
		//'false'
		public Keyword getFalseKeyword_1_0() { return cFalseKeyword_1_0; }
		
		//{BooleanFalse}
		public Action getBooleanFalseAction_1_1() { return cBooleanFalseAction_1_1; }
	}
	public class TruthValueElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.viatra.solver.language.SolverLanguage.TruthValue");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Action cTrueAction_0_0 = (Action)cGroup_0.eContents().get(0);
		private final Keyword cTrueKeyword_0_1 = (Keyword)cGroup_0.eContents().get(1);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Action cFalseAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cFalseKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Group cGroup_2 = (Group)cAlternatives.eContents().get(2);
		private final Action cUnknownAction_2_0 = (Action)cGroup_2.eContents().get(0);
		private final Keyword cUnknownKeyword_2_1 = (Keyword)cGroup_2.eContents().get(1);
		private final Group cGroup_3 = (Group)cAlternatives.eContents().get(3);
		private final Action cErrorAction_3_0 = (Action)cGroup_3.eContents().get(0);
		private final Keyword cErrorKeyword_3_1 = (Keyword)cGroup_3.eContents().get(1);
		
		//TruthValue:
		//	{True} 'true' | {False} 'false' | {Unknown} 'unknown' | {Error} 'error';
		@Override public ParserRule getRule() { return rule; }
		
		//{True} 'true' | {False} 'false' | {Unknown} 'unknown' | {Error} 'error'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//{True} 'true'
		public Group getGroup_0() { return cGroup_0; }
		
		//{True}
		public Action getTrueAction_0_0() { return cTrueAction_0_0; }
		
		//'true'
		public Keyword getTrueKeyword_0_1() { return cTrueKeyword_0_1; }
		
		//{False} 'false'
		public Group getGroup_1() { return cGroup_1; }
		
		//{False}
		public Action getFalseAction_1_0() { return cFalseAction_1_0; }
		
		//'false'
		public Keyword getFalseKeyword_1_1() { return cFalseKeyword_1_1; }
		
		//{Unknown} 'unknown'
		public Group getGroup_2() { return cGroup_2; }
		
		//{Unknown}
		public Action getUnknownAction_2_0() { return cUnknownAction_2_0; }
		
		//'unknown'
		public Keyword getUnknownKeyword_2_1() { return cUnknownKeyword_2_1; }
		
		//{Error} 'error'
		public Group getGroup_3() { return cGroup_3; }
		
		//{Error}
		public Action getErrorAction_3_0() { return cErrorAction_3_0; }
		
		//'error'
		public Keyword getErrorKeyword_3_1() { return cErrorKeyword_3_1; }
	}
	public class InterpretationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.viatra.solver.language.SolverLanguage.Interpretation");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cBasicInterpretationParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cDefaultInterpretationParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cCDInterpretationParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		
		/////////////////////
		//// Core grammar
		// ///////////////////
		//Interpretation:
		//	BasicInterpretation | DefaultInterpretation | CDInterpretation;
		@Override public ParserRule getRule() { return rule; }
		
		//BasicInterpretation | DefaultInterpretation | CDInterpretation
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//BasicInterpretation
		public RuleCall getBasicInterpretationParserRuleCall_0() { return cBasicInterpretationParserRuleCall_0; }
		
		//DefaultInterpretation
		public RuleCall getDefaultInterpretationParserRuleCall_1() { return cDefaultInterpretationParserRuleCall_1; }
		
		//CDInterpretation
		public RuleCall getCDInterpretationParserRuleCall_2() { return cCDInterpretationParserRuleCall_2; }
	}
	public class BasicInterpretationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.viatra.solver.language.SolverLanguage.BasicInterpretation");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cSymbolAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cSymbolSymbolParserRuleCall_0_0 = (RuleCall)cSymbolAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Group cGroup_1_1 = (Group)cGroup_1.eContents().get(1);
		private final Assignment cObjectsAssignment_1_1_0 = (Assignment)cGroup_1_1.eContents().get(0);
		private final RuleCall cObjectsComplexObjectParserRuleCall_1_1_0_0 = (RuleCall)cObjectsAssignment_1_1_0.eContents().get(0);
		private final Group cGroup_1_1_1 = (Group)cGroup_1_1.eContents().get(1);
		private final Keyword cCommaKeyword_1_1_1_0 = (Keyword)cGroup_1_1_1.eContents().get(0);
		private final Assignment cObjectsAssignment_1_1_1_1 = (Assignment)cGroup_1_1_1.eContents().get(1);
		private final RuleCall cObjectsComplexObjectParserRuleCall_1_1_1_1_0 = (RuleCall)cObjectsAssignment_1_1_1_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_1_2 = (Keyword)cGroup_1.eContents().get(2);
		private final Keyword cColonKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cValueAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cValueTruthValueParserRuleCall_3_0 = (RuleCall)cValueAssignment_3.eContents().get(0);
		
		//BasicInterpretation:
		//	symbol=Symbol ('(' (objects+=ComplexObject (',' objects+=ComplexObject)*)? ')')? ':' value=TruthValue;
		@Override public ParserRule getRule() { return rule; }
		
		//symbol=Symbol ('(' (objects+=ComplexObject (',' objects+=ComplexObject)*)? ')')? ':' value=TruthValue
		public Group getGroup() { return cGroup; }
		
		//symbol=Symbol
		public Assignment getSymbolAssignment_0() { return cSymbolAssignment_0; }
		
		//Symbol
		public RuleCall getSymbolSymbolParserRuleCall_0_0() { return cSymbolSymbolParserRuleCall_0_0; }
		
		//('(' (objects+=ComplexObject (',' objects+=ComplexObject)*)? ')')?
		public Group getGroup_1() { return cGroup_1; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_1_0() { return cLeftParenthesisKeyword_1_0; }
		
		//(objects+=ComplexObject (',' objects+=ComplexObject)*)?
		public Group getGroup_1_1() { return cGroup_1_1; }
		
		//objects+=ComplexObject
		public Assignment getObjectsAssignment_1_1_0() { return cObjectsAssignment_1_1_0; }
		
		//ComplexObject
		public RuleCall getObjectsComplexObjectParserRuleCall_1_1_0_0() { return cObjectsComplexObjectParserRuleCall_1_1_0_0; }
		
		//(',' objects+=ComplexObject)*
		public Group getGroup_1_1_1() { return cGroup_1_1_1; }
		
		//','
		public Keyword getCommaKeyword_1_1_1_0() { return cCommaKeyword_1_1_1_0; }
		
		//objects+=ComplexObject
		public Assignment getObjectsAssignment_1_1_1_1() { return cObjectsAssignment_1_1_1_1; }
		
		//ComplexObject
		public RuleCall getObjectsComplexObjectParserRuleCall_1_1_1_1_0() { return cObjectsComplexObjectParserRuleCall_1_1_1_1_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_1_2() { return cRightParenthesisKeyword_1_2; }
		
		//':'
		public Keyword getColonKeyword_2() { return cColonKeyword_2; }
		
		//value=TruthValue
		public Assignment getValueAssignment_3() { return cValueAssignment_3; }
		
		//TruthValue
		public RuleCall getValueTruthValueParserRuleCall_3_0() { return cValueTruthValueParserRuleCall_3_0; }
	}
	public class SymbolElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.viatra.solver.language.SolverLanguage.Symbol");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cModelSymbolParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cPartialitySymbolParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cDataSymbolParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		
		//Symbol:
		//	ModelSymbol | PartialitySymbol | DataSymbol;
		@Override public ParserRule getRule() { return rule; }
		
		//ModelSymbol | PartialitySymbol | DataSymbol
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//ModelSymbol
		public RuleCall getModelSymbolParserRuleCall_0() { return cModelSymbolParserRuleCall_0; }
		
		//PartialitySymbol
		public RuleCall getPartialitySymbolParserRuleCall_1() { return cPartialitySymbolParserRuleCall_1; }
		
		//DataSymbol
		public RuleCall getDataSymbolParserRuleCall_2() { return cDataSymbolParserRuleCall_2; }
	}
	public class ModelSymbolElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.viatra.solver.language.SolverLanguage.ModelSymbol");
		private final Assignment cNameAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_0 = (RuleCall)cNameAssignment.eContents().get(0);
		
		//ModelSymbol:
		//	name=ID;
		@Override public ParserRule getRule() { return rule; }
		
		//name=ID
		public Assignment getNameAssignment() { return cNameAssignment; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_0() { return cNameIDTerminalRuleCall_0; }
	}
	public class PartialitySymbolElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.viatra.solver.language.SolverLanguage.PartialitySymbol");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cExistSymbolParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cEqualsSymbolParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//PartialitySymbol:
		//	ExistSymbol | EqualsSymbol;
		@Override public ParserRule getRule() { return rule; }
		
		//ExistSymbol | EqualsSymbol
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//ExistSymbol
		public RuleCall getExistSymbolParserRuleCall_0() { return cExistSymbolParserRuleCall_0; }
		
		//EqualsSymbol
		public RuleCall getEqualsSymbolParserRuleCall_1() { return cEqualsSymbolParserRuleCall_1; }
	}
	public class ExistSymbolElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.viatra.solver.language.SolverLanguage.ExistSymbol");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cExistsKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Action cExistSymbolAction_1 = (Action)cGroup.eContents().get(1);
		
		//ExistSymbol:
		//	'exists' {ExistSymbol};
		@Override public ParserRule getRule() { return rule; }
		
		//'exists' {ExistSymbol}
		public Group getGroup() { return cGroup; }
		
		//'exists'
		public Keyword getExistsKeyword_0() { return cExistsKeyword_0; }
		
		//{ExistSymbol}
		public Action getExistSymbolAction_1() { return cExistSymbolAction_1; }
	}
	public class EqualsSymbolElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.viatra.solver.language.SolverLanguage.EqualsSymbol");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cEqualsKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Action cEqualsSymbolAction_1 = (Action)cGroup.eContents().get(1);
		
		//EqualsSymbol:
		//	'equals' {EqualsSymbol};
		@Override public ParserRule getRule() { return rule; }
		
		//'equals' {EqualsSymbol}
		public Group getGroup() { return cGroup; }
		
		//'equals'
		public Keyword getEqualsKeyword_0() { return cEqualsKeyword_0; }
		
		//{EqualsSymbol}
		public Action getEqualsSymbolAction_1() { return cEqualsSymbolAction_1; }
	}
	public class DataSymbolElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.viatra.solver.language.SolverLanguage.DataSymbol");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cBooleanSymbolParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cIntegerSymbolParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cRealSymbolParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cStringSymbolParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		
		//DataSymbol:
		//	BooleanSymbol | IntegerSymbol | RealSymbol | StringSymbol;
		@Override public ParserRule getRule() { return rule; }
		
		//BooleanSymbol | IntegerSymbol | RealSymbol | StringSymbol
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//BooleanSymbol
		public RuleCall getBooleanSymbolParserRuleCall_0() { return cBooleanSymbolParserRuleCall_0; }
		
		//IntegerSymbol
		public RuleCall getIntegerSymbolParserRuleCall_1() { return cIntegerSymbolParserRuleCall_1; }
		
		//RealSymbol
		public RuleCall getRealSymbolParserRuleCall_2() { return cRealSymbolParserRuleCall_2; }
		
		//StringSymbol
		public RuleCall getStringSymbolParserRuleCall_3() { return cStringSymbolParserRuleCall_3; }
	}
	public class BooleanSymbolElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.viatra.solver.language.SolverLanguage.BooleanSymbol");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cBoolKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Action cBooleanSymbolAction_1 = (Action)cGroup.eContents().get(1);
		
		//BooleanSymbol:
		//	'bool' {BooleanSymbol};
		@Override public ParserRule getRule() { return rule; }
		
		//'bool' {BooleanSymbol}
		public Group getGroup() { return cGroup; }
		
		//'bool'
		public Keyword getBoolKeyword_0() { return cBoolKeyword_0; }
		
		//{BooleanSymbol}
		public Action getBooleanSymbolAction_1() { return cBooleanSymbolAction_1; }
	}
	public class IntegerSymbolElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.viatra.solver.language.SolverLanguage.IntegerSymbol");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cIntKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Action cIntegerSymbolAction_1 = (Action)cGroup.eContents().get(1);
		
		//IntegerSymbol:
		//	'int' {IntegerSymbol};
		@Override public ParserRule getRule() { return rule; }
		
		//'int' {IntegerSymbol}
		public Group getGroup() { return cGroup; }
		
		//'int'
		public Keyword getIntKeyword_0() { return cIntKeyword_0; }
		
		//{IntegerSymbol}
		public Action getIntegerSymbolAction_1() { return cIntegerSymbolAction_1; }
	}
	public class RealSymbolElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.viatra.solver.language.SolverLanguage.RealSymbol");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cRealKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Action cRealSymbolAction_1 = (Action)cGroup.eContents().get(1);
		
		//RealSymbol:
		//	'real' {RealSymbol};
		@Override public ParserRule getRule() { return rule; }
		
		//'real' {RealSymbol}
		public Group getGroup() { return cGroup; }
		
		//'real'
		public Keyword getRealKeyword_0() { return cRealKeyword_0; }
		
		//{RealSymbol}
		public Action getRealSymbolAction_1() { return cRealSymbolAction_1; }
	}
	public class StringSymbolElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.viatra.solver.language.SolverLanguage.StringSymbol");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cStringKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Action cStringSymbolAction_1 = (Action)cGroup.eContents().get(1);
		
		//StringSymbol:
		//	'string' {StringSymbol};
		@Override public ParserRule getRule() { return rule; }
		
		//'string' {StringSymbol}
		public Group getGroup() { return cGroup; }
		
		//'string'
		public Keyword getStringKeyword_0() { return cStringKeyword_0; }
		
		//{StringSymbol}
		public Action getStringSymbolAction_1() { return cStringSymbolAction_1; }
	}
	public class ComplexObjectElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.viatra.solver.language.SolverLanguage.ComplexObject");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cObjectParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cAllInstancesParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cAllObjectsParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		
		//ComplexObject:
		//	Object | AllInstances | AllObjects;
		@Override public ParserRule getRule() { return rule; }
		
		//Object | AllInstances | AllObjects
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//Object
		public RuleCall getObjectParserRuleCall_0() { return cObjectParserRuleCall_0; }
		
		//AllInstances
		public RuleCall getAllInstancesParserRuleCall_1() { return cAllInstancesParserRuleCall_1; }
		
		//AllObjects
		public RuleCall getAllObjectsParserRuleCall_2() { return cAllObjectsParserRuleCall_2; }
	}
	public class ObjectElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.viatra.solver.language.SolverLanguage.Object");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cNamedObjectParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cUnnamedObjectParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cDataObjectParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		
		//Object:
		//	NamedObject | UnnamedObject | DataObject;
		@Override public ParserRule getRule() { return rule; }
		
		//NamedObject | UnnamedObject | DataObject
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//NamedObject
		public RuleCall getNamedObjectParserRuleCall_0() { return cNamedObjectParserRuleCall_0; }
		
		//UnnamedObject
		public RuleCall getUnnamedObjectParserRuleCall_1() { return cUnnamedObjectParserRuleCall_1; }
		
		//DataObject
		public RuleCall getDataObjectParserRuleCall_2() { return cDataObjectParserRuleCall_2; }
	}
	public class NamedObjectElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.viatra.solver.language.SolverLanguage.NamedObject");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cApostropheKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Keyword cApostropheKeyword_2 = (Keyword)cGroup.eContents().get(2);
		
		//NamedObject:
		//	"'" name=ID "'";
		@Override public ParserRule getRule() { return rule; }
		
		//"'" name=ID "'"
		public Group getGroup() { return cGroup; }
		
		//"'"
		public Keyword getApostropheKeyword_0() { return cApostropheKeyword_0; }
		
		//name=ID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_1_0() { return cNameIDTerminalRuleCall_1_0; }
		
		//"'"
		public Keyword getApostropheKeyword_2() { return cApostropheKeyword_2; }
	}
	public class UnnamedObjectElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.viatra.solver.language.SolverLanguage.UnnamedObject");
		private final Assignment cNameAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_0 = (RuleCall)cNameAssignment.eContents().get(0);
		
		//UnnamedObject:
		//	name=ID;
		@Override public ParserRule getRule() { return rule; }
		
		//name=ID
		public Assignment getNameAssignment() { return cNameAssignment; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_0() { return cNameIDTerminalRuleCall_0; }
	}
	public class DataObjectElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.viatra.solver.language.SolverLanguage.DataObject");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cBooleanObjectParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cIntObjectParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cRealObjectParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cStringObjectParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		
		//DataObject:
		//	BooleanObject | IntObject | RealObject | StringObject;
		@Override public ParserRule getRule() { return rule; }
		
		//BooleanObject | IntObject | RealObject | StringObject
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//BooleanObject
		public RuleCall getBooleanObjectParserRuleCall_0() { return cBooleanObjectParserRuleCall_0; }
		
		//IntObject
		public RuleCall getIntObjectParserRuleCall_1() { return cIntObjectParserRuleCall_1; }
		
		//RealObject
		public RuleCall getRealObjectParserRuleCall_2() { return cRealObjectParserRuleCall_2; }
		
		//StringObject
		public RuleCall getStringObjectParserRuleCall_3() { return cStringObjectParserRuleCall_3; }
	}
	public class BooleanObjectElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.viatra.solver.language.SolverLanguage.BooleanObject");
		private final Assignment cValueAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cValueBooleanValueParserRuleCall_0 = (RuleCall)cValueAssignment.eContents().get(0);
		
		//BooleanObject:
		//	value=BooleanValue;
		@Override public ParserRule getRule() { return rule; }
		
		//value=BooleanValue
		public Assignment getValueAssignment() { return cValueAssignment; }
		
		//BooleanValue
		public RuleCall getValueBooleanValueParserRuleCall_0() { return cValueBooleanValueParserRuleCall_0; }
	}
	public class IntObjectElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.viatra.solver.language.SolverLanguage.IntObject");
		private final Assignment cValueAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cValueINTLiteralParserRuleCall_0 = (RuleCall)cValueAssignment.eContents().get(0);
		
		//IntObject:
		//	value=INTLiteral;
		@Override public ParserRule getRule() { return rule; }
		
		//value=INTLiteral
		public Assignment getValueAssignment() { return cValueAssignment; }
		
		//INTLiteral
		public RuleCall getValueINTLiteralParserRuleCall_0() { return cValueINTLiteralParserRuleCall_0; }
	}
	public class RealObjectElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.viatra.solver.language.SolverLanguage.RealObject");
		private final Assignment cValueAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cValueREALLiteralParserRuleCall_0 = (RuleCall)cValueAssignment.eContents().get(0);
		
		//RealObject:
		//	value=REALLiteral;
		@Override public ParserRule getRule() { return rule; }
		
		//value=REALLiteral
		public Assignment getValueAssignment() { return cValueAssignment; }
		
		//REALLiteral
		public RuleCall getValueREALLiteralParserRuleCall_0() { return cValueREALLiteralParserRuleCall_0; }
	}
	public class StringObjectElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.viatra.solver.language.SolverLanguage.StringObject");
		private final Assignment cValueAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cValueSTRINGTerminalRuleCall_0 = (RuleCall)cValueAssignment.eContents().get(0);
		
		//StringObject:
		//	value=STRING;
		@Override public ParserRule getRule() { return rule; }
		
		//value=STRING
		public Assignment getValueAssignment() { return cValueAssignment; }
		
		//STRING
		public RuleCall getValueSTRINGTerminalRuleCall_0() { return cValueSTRINGTerminalRuleCall_0; }
	}
	public class PredicateElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.viatra.solver.language.SolverLanguage.Predicate");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cIsErrorAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Keyword cIsErrorErrorKeyword_0_0 = (Keyword)cIsErrorAssignment_0.eContents().get(0);
		private final Assignment cSymbolAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cSymbolModelSymbolParserRuleCall_1_0 = (RuleCall)cSymbolAssignment_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cLeftParenthesisKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Group cGroup_2_1 = (Group)cGroup_2.eContents().get(1);
		private final Assignment cParametersAssignment_2_1_0 = (Assignment)cGroup_2_1.eContents().get(0);
		private final RuleCall cParametersParameterParserRuleCall_2_1_0_0 = (RuleCall)cParametersAssignment_2_1_0.eContents().get(0);
		private final Group cGroup_2_1_1 = (Group)cGroup_2_1.eContents().get(1);
		private final Keyword cCommaKeyword_2_1_1_0 = (Keyword)cGroup_2_1_1.eContents().get(0);
		private final Assignment cParametersAssignment_2_1_1_1 = (Assignment)cGroup_2_1_1.eContents().get(1);
		private final RuleCall cParametersParameterParserRuleCall_2_1_1_1_0 = (RuleCall)cParametersAssignment_2_1_1_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_2_2 = (Keyword)cGroup_2.eContents().get(2);
		private final Keyword cColonHyphenMinusKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Alternatives cAlternatives_4 = (Alternatives)cGroup.eContents().get(4);
		private final Keyword cFalseKeyword_4_0 = (Keyword)cAlternatives_4.eContents().get(0);
		private final Group cGroup_4_1 = (Group)cAlternatives_4.eContents().get(1);
		private final Assignment cBodiesAssignment_4_1_0 = (Assignment)cGroup_4_1.eContents().get(0);
		private final RuleCall cBodiesPatternBodyParserRuleCall_4_1_0_0 = (RuleCall)cBodiesAssignment_4_1_0.eContents().get(0);
		private final Group cGroup_4_1_1 = (Group)cGroup_4_1.eContents().get(1);
		private final Keyword cVerticalLineKeyword_4_1_1_0 = (Keyword)cGroup_4_1_1.eContents().get(0);
		private final Assignment cBodiesAssignment_4_1_1_1 = (Assignment)cGroup_4_1_1.eContents().get(1);
		private final RuleCall cBodiesPatternBodyParserRuleCall_4_1_1_1_0 = (RuleCall)cBodiesAssignment_4_1_1_1.eContents().get(0);
		private final Keyword cFullStopKeyword_5 = (Keyword)cGroup.eContents().get(5);
		
		/////////////////////
		//// Predicte grammar
		/////////////////////
		//Predicate:
		//	isError?='error'? symbol=ModelSymbol ('(' (parameters+=Parameter (',' parameters+=Parameter)*)? ')')? ':-' ('false' |
		//	bodies+=PatternBody ('|' bodies+=PatternBody)*) '.';
		@Override public ParserRule getRule() { return rule; }
		
		//isError?='error'? symbol=ModelSymbol ('(' (parameters+=Parameter (',' parameters+=Parameter)*)? ')')? ':-' ('false' |
		//bodies+=PatternBody ('|' bodies+=PatternBody)*) '.'
		public Group getGroup() { return cGroup; }
		
		//isError?='error'?
		public Assignment getIsErrorAssignment_0() { return cIsErrorAssignment_0; }
		
		//'error'
		public Keyword getIsErrorErrorKeyword_0_0() { return cIsErrorErrorKeyword_0_0; }
		
		//symbol=ModelSymbol
		public Assignment getSymbolAssignment_1() { return cSymbolAssignment_1; }
		
		//ModelSymbol
		public RuleCall getSymbolModelSymbolParserRuleCall_1_0() { return cSymbolModelSymbolParserRuleCall_1_0; }
		
		//('(' (parameters+=Parameter (',' parameters+=Parameter)*)? ')')?
		public Group getGroup_2() { return cGroup_2; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_2_0() { return cLeftParenthesisKeyword_2_0; }
		
		//(parameters+=Parameter (',' parameters+=Parameter)*)?
		public Group getGroup_2_1() { return cGroup_2_1; }
		
		//parameters+=Parameter
		public Assignment getParametersAssignment_2_1_0() { return cParametersAssignment_2_1_0; }
		
		//Parameter
		public RuleCall getParametersParameterParserRuleCall_2_1_0_0() { return cParametersParameterParserRuleCall_2_1_0_0; }
		
		//(',' parameters+=Parameter)*
		public Group getGroup_2_1_1() { return cGroup_2_1_1; }
		
		//','
		public Keyword getCommaKeyword_2_1_1_0() { return cCommaKeyword_2_1_1_0; }
		
		//parameters+=Parameter
		public Assignment getParametersAssignment_2_1_1_1() { return cParametersAssignment_2_1_1_1; }
		
		//Parameter
		public RuleCall getParametersParameterParserRuleCall_2_1_1_1_0() { return cParametersParameterParserRuleCall_2_1_1_1_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_2_2() { return cRightParenthesisKeyword_2_2; }
		
		//':-'
		public Keyword getColonHyphenMinusKeyword_3() { return cColonHyphenMinusKeyword_3; }
		
		//'false' | bodies+=PatternBody ('|' bodies+=PatternBody)*
		public Alternatives getAlternatives_4() { return cAlternatives_4; }
		
		//'false'
		public Keyword getFalseKeyword_4_0() { return cFalseKeyword_4_0; }
		
		//bodies+=PatternBody ('|' bodies+=PatternBody)*
		public Group getGroup_4_1() { return cGroup_4_1; }
		
		//bodies+=PatternBody
		public Assignment getBodiesAssignment_4_1_0() { return cBodiesAssignment_4_1_0; }
		
		//PatternBody
		public RuleCall getBodiesPatternBodyParserRuleCall_4_1_0_0() { return cBodiesPatternBodyParserRuleCall_4_1_0_0; }
		
		//('|' bodies+=PatternBody)*
		public Group getGroup_4_1_1() { return cGroup_4_1_1; }
		
		//'|'
		public Keyword getVerticalLineKeyword_4_1_1_0() { return cVerticalLineKeyword_4_1_1_0; }
		
		//bodies+=PatternBody
		public Assignment getBodiesAssignment_4_1_1_1() { return cBodiesAssignment_4_1_1_1; }
		
		//PatternBody
		public RuleCall getBodiesPatternBodyParserRuleCall_4_1_1_1_0() { return cBodiesPatternBodyParserRuleCall_4_1_1_1_0; }
		
		//'.'
		public Keyword getFullStopKeyword_5() { return cFullStopKeyword_5; }
	}
	public class ParameterElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.viatra.solver.language.SolverLanguage.Parameter");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cVariableAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cVariableVariableParserRuleCall_0_0 = (RuleCall)cVariableAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cColonKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cTypeAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cTypeSymbolParserRuleCall_1_1_0 = (RuleCall)cTypeAssignment_1_1.eContents().get(0);
		
		//Parameter:
		//	variable=Variable (':' type=Symbol)?;
		@Override public ParserRule getRule() { return rule; }
		
		//variable=Variable (':' type=Symbol)?
		public Group getGroup() { return cGroup; }
		
		//variable=Variable
		public Assignment getVariableAssignment_0() { return cVariableAssignment_0; }
		
		//Variable
		public RuleCall getVariableVariableParserRuleCall_0_0() { return cVariableVariableParserRuleCall_0_0; }
		
		//(':' type=Symbol)?
		public Group getGroup_1() { return cGroup_1; }
		
		//':'
		public Keyword getColonKeyword_1_0() { return cColonKeyword_1_0; }
		
		//type=Symbol
		public Assignment getTypeAssignment_1_1() { return cTypeAssignment_1_1; }
		
		//Symbol
		public RuleCall getTypeSymbolParserRuleCall_1_1_0() { return cTypeSymbolParserRuleCall_1_1_0; }
	}
	public class PatternBodyElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.viatra.solver.language.SolverLanguage.PatternBody");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cPatternBodyAction_0 = (Action)cGroup.eContents().get(0);
		private final Alternatives cAlternatives_1 = (Alternatives)cGroup.eContents().get(1);
		private final Keyword cTrueKeyword_1_0 = (Keyword)cAlternatives_1.eContents().get(0);
		private final Assignment cConstraintsAssignment_1_1 = (Assignment)cAlternatives_1.eContents().get(1);
		private final RuleCall cConstraintsConstraintParserRuleCall_1_1_0 = (RuleCall)cConstraintsAssignment_1_1.eContents().get(0);
		
		//PatternBody:
		//	{PatternBody} ('true' | constraints+=Constraint*);
		@Override public ParserRule getRule() { return rule; }
		
		//{PatternBody} ('true' | constraints+=Constraint*)
		public Group getGroup() { return cGroup; }
		
		//{PatternBody}
		public Action getPatternBodyAction_0() { return cPatternBodyAction_0; }
		
		//'true' | constraints+=Constraint*
		public Alternatives getAlternatives_1() { return cAlternatives_1; }
		
		//'true'
		public Keyword getTrueKeyword_1_0() { return cTrueKeyword_1_0; }
		
		//constraints+=Constraint*
		public Assignment getConstraintsAssignment_1_1() { return cConstraintsAssignment_1_1; }
		
		//Constraint
		public RuleCall getConstraintsConstraintParserRuleCall_1_1_0() { return cConstraintsConstraintParserRuleCall_1_1_0; }
	}
	public class PolarityElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.viatra.solver.language.SolverLanguage.Polarity");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Action cPositiveAction_0_0 = (Action)cGroup_0.eContents().get(0);
		private final Keyword cPlusSignKeyword_0_1 = (Keyword)cGroup_0.eContents().get(1);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Action cNegativeAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cHyphenMinusKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		
		//Polarity:
		//	{Positive} '+' | {Negative} '-';
		@Override public ParserRule getRule() { return rule; }
		
		//{Positive} '+' | {Negative} '-'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//{Positive} '+'
		public Group getGroup_0() { return cGroup_0; }
		
		//{Positive}
		public Action getPositiveAction_0_0() { return cPositiveAction_0_0; }
		
		//'+'
		public Keyword getPlusSignKeyword_0_1() { return cPlusSignKeyword_0_1; }
		
		//{Negative} '-'
		public Group getGroup_1() { return cGroup_1; }
		
		//{Negative}
		public Action getNegativeAction_1_0() { return cNegativeAction_1_0; }
		
		//'-'
		public Keyword getHyphenMinusKeyword_1_1() { return cHyphenMinusKeyword_1_1; }
	}
	public class ConstraintElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.viatra.solver.language.SolverLanguage.Constraint");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Assignment cPolarityAssignment_0_0 = (Assignment)cGroup_0.eContents().get(0);
		private final RuleCall cPolarityPolarityParserRuleCall_0_0_0 = (RuleCall)cPolarityAssignment_0_0.eContents().get(0);
		private final Assignment cSymbolAssignment_0_1 = (Assignment)cGroup_0.eContents().get(1);
		private final RuleCall cSymbolModelSymbolParserRuleCall_0_1_0 = (RuleCall)cSymbolAssignment_0_1.eContents().get(0);
		private final Group cGroup_0_2 = (Group)cGroup_0.eContents().get(2);
		private final Keyword cLeftParenthesisKeyword_0_2_0 = (Keyword)cGroup_0_2.eContents().get(0);
		private final Assignment cParamsAssignment_0_2_1 = (Assignment)cGroup_0_2.eContents().get(1);
		private final RuleCall cParamsLiteralParserRuleCall_0_2_1_0 = (RuleCall)cParamsAssignment_0_2_1.eContents().get(0);
		private final Group cGroup_0_2_2 = (Group)cGroup_0_2.eContents().get(2);
		private final Keyword cCommaKeyword_0_2_2_0 = (Keyword)cGroup_0_2_2.eContents().get(0);
		private final Assignment cParamsAssignment_0_2_2_1 = (Assignment)cGroup_0_2_2.eContents().get(1);
		private final RuleCall cParamsLiteralParserRuleCall_0_2_2_1_0 = (RuleCall)cParamsAssignment_0_2_2_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_0_2_3 = (Keyword)cGroup_0_2.eContents().get(3);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Assignment cClosureTypeAssignment_1_0 = (Assignment)cGroup_1.eContents().get(0);
		private final RuleCall cClosureTypeClosureTypeParserRuleCall_1_0_0 = (RuleCall)cClosureTypeAssignment_1_0.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cParamsAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cParamsLiteralParserRuleCall_1_2_0 = (RuleCall)cParamsAssignment_1_2.eContents().get(0);
		private final Group cGroup_1_3 = (Group)cGroup_1.eContents().get(3);
		private final Keyword cCommaKeyword_1_3_0 = (Keyword)cGroup_1_3.eContents().get(0);
		private final Assignment cParamsAssignment_1_3_1 = (Assignment)cGroup_1_3.eContents().get(1);
		private final RuleCall cParamsLiteralParserRuleCall_1_3_1_0 = (RuleCall)cParamsAssignment_1_3_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_1_4 = (Keyword)cGroup_1.eContents().get(4);
		
		//Constraint:
		//	polarity=Polarity? symbol=ModelSymbol ('(' params+=Literal? (',' params+=Literal)* ')')? | closureType=ClosureType
		//	'(' params+=Literal? (',' params+=Literal)* ')';
		@Override public ParserRule getRule() { return rule; }
		
		//polarity=Polarity? symbol=ModelSymbol ('(' params+=Literal? (',' params+=Literal)* ')')? | closureType=ClosureType '('
		//params+=Literal? (',' params+=Literal)* ')'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//polarity=Polarity? symbol=ModelSymbol ('(' params+=Literal? (',' params+=Literal)* ')')?
		public Group getGroup_0() { return cGroup_0; }
		
		//polarity=Polarity?
		public Assignment getPolarityAssignment_0_0() { return cPolarityAssignment_0_0; }
		
		//Polarity
		public RuleCall getPolarityPolarityParserRuleCall_0_0_0() { return cPolarityPolarityParserRuleCall_0_0_0; }
		
		//symbol=ModelSymbol
		public Assignment getSymbolAssignment_0_1() { return cSymbolAssignment_0_1; }
		
		//ModelSymbol
		public RuleCall getSymbolModelSymbolParserRuleCall_0_1_0() { return cSymbolModelSymbolParserRuleCall_0_1_0; }
		
		//('(' params+=Literal? (',' params+=Literal)* ')')?
		public Group getGroup_0_2() { return cGroup_0_2; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_0_2_0() { return cLeftParenthesisKeyword_0_2_0; }
		
		//params+=Literal?
		public Assignment getParamsAssignment_0_2_1() { return cParamsAssignment_0_2_1; }
		
		//Literal
		public RuleCall getParamsLiteralParserRuleCall_0_2_1_0() { return cParamsLiteralParserRuleCall_0_2_1_0; }
		
		//(',' params+=Literal)*
		public Group getGroup_0_2_2() { return cGroup_0_2_2; }
		
		//','
		public Keyword getCommaKeyword_0_2_2_0() { return cCommaKeyword_0_2_2_0; }
		
		//params+=Literal
		public Assignment getParamsAssignment_0_2_2_1() { return cParamsAssignment_0_2_2_1; }
		
		//Literal
		public RuleCall getParamsLiteralParserRuleCall_0_2_2_1_0() { return cParamsLiteralParserRuleCall_0_2_2_1_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_0_2_3() { return cRightParenthesisKeyword_0_2_3; }
		
		//closureType=ClosureType '(' params+=Literal? (',' params+=Literal)* ')'
		public Group getGroup_1() { return cGroup_1; }
		
		//closureType=ClosureType
		public Assignment getClosureTypeAssignment_1_0() { return cClosureTypeAssignment_1_0; }
		
		//ClosureType
		public RuleCall getClosureTypeClosureTypeParserRuleCall_1_0_0() { return cClosureTypeClosureTypeParserRuleCall_1_0_0; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_1_1() { return cLeftParenthesisKeyword_1_1; }
		
		//params+=Literal?
		public Assignment getParamsAssignment_1_2() { return cParamsAssignment_1_2; }
		
		//Literal
		public RuleCall getParamsLiteralParserRuleCall_1_2_0() { return cParamsLiteralParserRuleCall_1_2_0; }
		
		//(',' params+=Literal)*
		public Group getGroup_1_3() { return cGroup_1_3; }
		
		//','
		public Keyword getCommaKeyword_1_3_0() { return cCommaKeyword_1_3_0; }
		
		//params+=Literal
		public Assignment getParamsAssignment_1_3_1() { return cParamsAssignment_1_3_1; }
		
		//Literal
		public RuleCall getParamsLiteralParserRuleCall_1_3_1_0() { return cParamsLiteralParserRuleCall_1_3_1_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_1_4() { return cRightParenthesisKeyword_1_4; }
	}
	public class ClosureTypeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.viatra.solver.language.SolverLanguage.ClosureType");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Action cReflexiveClosureAction_0_0 = (Action)cGroup_0.eContents().get(0);
		private final Keyword cAsteriskKeyword_0_1 = (Keyword)cGroup_0.eContents().get(1);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Action cIrreflexiveClosureAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cPlusSignKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		
		//ClosureType:
		//	{ReflexiveClosure} '*' | {IrreflexiveClosure} '+';
		@Override public ParserRule getRule() { return rule; }
		
		//{ReflexiveClosure} '*' | {IrreflexiveClosure} '+'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//{ReflexiveClosure} '*'
		public Group getGroup_0() { return cGroup_0; }
		
		//{ReflexiveClosure}
		public Action getReflexiveClosureAction_0_0() { return cReflexiveClosureAction_0_0; }
		
		//'*'
		public Keyword getAsteriskKeyword_0_1() { return cAsteriskKeyword_0_1; }
		
		//{IrreflexiveClosure} '+'
		public Group getGroup_1() { return cGroup_1; }
		
		//{IrreflexiveClosure}
		public Action getIrreflexiveClosureAction_1_0() { return cIrreflexiveClosureAction_1_0; }
		
		//'+'
		public Keyword getPlusSignKeyword_1_1() { return cPlusSignKeyword_1_1; }
	}
	public class LiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.viatra.solver.language.SolverLanguage.Literal");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cVariableParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cDataObjectParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cNamedObjectParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		
		//Literal:
		//	Variable | DataObject | NamedObject;
		@Override public ParserRule getRule() { return rule; }
		
		//Variable | DataObject | NamedObject
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//Variable
		public RuleCall getVariableParserRuleCall_0() { return cVariableParserRuleCall_0; }
		
		//DataObject
		public RuleCall getDataObjectParserRuleCall_1() { return cDataObjectParserRuleCall_1; }
		
		//NamedObject
		public RuleCall getNamedObjectParserRuleCall_2() { return cNamedObjectParserRuleCall_2; }
	}
	public class VariableElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.viatra.solver.language.SolverLanguage.Variable");
		private final Assignment cNameAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_0 = (RuleCall)cNameAssignment.eContents().get(0);
		
		//Variable:
		//	name=ID;
		@Override public ParserRule getRule() { return rule; }
		
		//name=ID
		public Assignment getNameAssignment() { return cNameAssignment; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_0() { return cNameIDTerminalRuleCall_0; }
	}
	public class AllInstancesElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.viatra.solver.language.SolverLanguage.AllInstances");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cColonKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cSymbolAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cSymbolSymbolParserRuleCall_1_0 = (RuleCall)cSymbolAssignment_1.eContents().get(0);
		
		/////////////////////
		//// Complex Interpretation grammar
		/////////////////////
		//AllInstances:
		//	':' symbol=Symbol;
		@Override public ParserRule getRule() { return rule; }
		
		//':' symbol=Symbol
		public Group getGroup() { return cGroup; }
		
		//':'
		public Keyword getColonKeyword_0() { return cColonKeyword_0; }
		
		//symbol=Symbol
		public Assignment getSymbolAssignment_1() { return cSymbolAssignment_1; }
		
		//Symbol
		public RuleCall getSymbolSymbolParserRuleCall_1_0() { return cSymbolSymbolParserRuleCall_1_0; }
	}
	public class AllObjectsElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.viatra.solver.language.SolverLanguage.AllObjects");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cAllObjectsAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cAsteriskKeyword_1 = (Keyword)cGroup.eContents().get(1);
		
		//AllObjects:
		//	{AllObjects} '*';
		@Override public ParserRule getRule() { return rule; }
		
		//{AllObjects} '*'
		public Group getGroup() { return cGroup; }
		
		//{AllObjects}
		public Action getAllObjectsAction_0() { return cAllObjectsAction_0; }
		
		//'*'
		public Keyword getAsteriskKeyword_1() { return cAsteriskKeyword_1; }
	}
	public class DefaultInterpretationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.viatra.solver.language.SolverLanguage.DefaultInterpretation");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cDefaultKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cInterpretationAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cInterpretationBasicInterpretationParserRuleCall_1_0 = (RuleCall)cInterpretationAssignment_1.eContents().get(0);
		
		/////////////////////
		//// Defaul Interpretation grammar
		/////////////////////
		//DefaultInterpretation:
		//	'default' interpretation=BasicInterpretation;
		@Override public ParserRule getRule() { return rule; }
		
		//'default' interpretation=BasicInterpretation
		public Group getGroup() { return cGroup; }
		
		//'default'
		public Keyword getDefaultKeyword_0() { return cDefaultKeyword_0; }
		
		//interpretation=BasicInterpretation
		public Assignment getInterpretationAssignment_1() { return cInterpretationAssignment_1; }
		
		//BasicInterpretation
		public RuleCall getInterpretationBasicInterpretationParserRuleCall_1_0() { return cInterpretationBasicInterpretationParserRuleCall_1_0; }
	}
	public class CDInterpretationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.viatra.solver.language.SolverLanguage.CDInterpretation");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cClassInterpretationParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cEnumInterpretationParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cGlobalRelationInterpretationParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		
		/////////////////////
		//// Advanced Class-Diagram interpretations
		/////////////////////
		//CDInterpretation:
		//	ClassInterpretation | EnumInterpretation | GlobalRelationInterpretation;
		@Override public ParserRule getRule() { return rule; }
		
		//ClassInterpretation | EnumInterpretation | GlobalRelationInterpretation
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//ClassInterpretation
		public RuleCall getClassInterpretationParserRuleCall_0() { return cClassInterpretationParserRuleCall_0; }
		
		//EnumInterpretation
		public RuleCall getEnumInterpretationParserRuleCall_1() { return cEnumInterpretationParserRuleCall_1; }
		
		//GlobalRelationInterpretation
		public RuleCall getGlobalRelationInterpretationParserRuleCall_2() { return cGlobalRelationInterpretationParserRuleCall_2; }
	}
	public class ClassInterpretationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.viatra.solver.language.SolverLanguage.ClassInterpretation");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cAbstractAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Keyword cAbstractAbstractKeyword_0_0 = (Keyword)cAbstractAssignment_0.eContents().get(0);
		private final Keyword cClassKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cSymbolAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cSymbolModelSymbolParserRuleCall_2_0 = (RuleCall)cSymbolAssignment_2.eContents().get(0);
		private final Group cGroup_3 = (Group)cGroup.eContents().get(3);
		private final Keyword cExtendsKeyword_3_0 = (Keyword)cGroup_3.eContents().get(0);
		private final Assignment cSupertypesAssignment_3_1 = (Assignment)cGroup_3.eContents().get(1);
		private final RuleCall cSupertypesModelSymbolParserRuleCall_3_1_0 = (RuleCall)cSupertypesAssignment_3_1.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Assignment cFieltAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final RuleCall cFieltFieldRelationInterpretationParserRuleCall_5_0 = (RuleCall)cFieltAssignment_5.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_6 = (Keyword)cGroup.eContents().get(6);
		
		//ClassInterpretation:
		//	abstract?='abstract'? 'class' symbol=ModelSymbol ('extends' supertypes+=ModelSymbol+)? '{'
		//	fielt+=FieldRelationInterpretation*
		//	'}';
		@Override public ParserRule getRule() { return rule; }
		
		//abstract?='abstract'? 'class' symbol=ModelSymbol ('extends' supertypes+=ModelSymbol+)? '{'
		//fielt+=FieldRelationInterpretation* '}'
		public Group getGroup() { return cGroup; }
		
		//abstract?='abstract'?
		public Assignment getAbstractAssignment_0() { return cAbstractAssignment_0; }
		
		//'abstract'
		public Keyword getAbstractAbstractKeyword_0_0() { return cAbstractAbstractKeyword_0_0; }
		
		//'class'
		public Keyword getClassKeyword_1() { return cClassKeyword_1; }
		
		//symbol=ModelSymbol
		public Assignment getSymbolAssignment_2() { return cSymbolAssignment_2; }
		
		//ModelSymbol
		public RuleCall getSymbolModelSymbolParserRuleCall_2_0() { return cSymbolModelSymbolParserRuleCall_2_0; }
		
		//('extends' supertypes+=ModelSymbol+)?
		public Group getGroup_3() { return cGroup_3; }
		
		//'extends'
		public Keyword getExtendsKeyword_3_0() { return cExtendsKeyword_3_0; }
		
		//supertypes+=ModelSymbol+
		public Assignment getSupertypesAssignment_3_1() { return cSupertypesAssignment_3_1; }
		
		//ModelSymbol
		public RuleCall getSupertypesModelSymbolParserRuleCall_3_1_0() { return cSupertypesModelSymbolParserRuleCall_3_1_0; }
		
		//'{'
		public Keyword getLeftCurlyBracketKeyword_4() { return cLeftCurlyBracketKeyword_4; }
		
		//fielt+=FieldRelationInterpretation*
		public Assignment getFieltAssignment_5() { return cFieltAssignment_5; }
		
		//FieldRelationInterpretation
		public RuleCall getFieltFieldRelationInterpretationParserRuleCall_5_0() { return cFieltFieldRelationInterpretationParserRuleCall_5_0; }
		
		//'}'
		public Keyword getRightCurlyBracketKeyword_6() { return cRightCurlyBracketKeyword_6; }
	}
	public class EnumInterpretationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.viatra.solver.language.SolverLanguage.EnumInterpretation");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cEnumKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cSymbolAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cSymbolModelSymbolParserRuleCall_1_0 = (RuleCall)cSymbolAssignment_1.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cObjectsAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cObjectsNamedObjectParserRuleCall_3_0 = (RuleCall)cObjectsAssignment_3.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//EnumInterpretation:
		//	'enum' Symbol=ModelSymbol '{' objects+=NamedObject+ '}';
		@Override public ParserRule getRule() { return rule; }
		
		//'enum' Symbol=ModelSymbol '{' objects+=NamedObject+ '}'
		public Group getGroup() { return cGroup; }
		
		//'enum'
		public Keyword getEnumKeyword_0() { return cEnumKeyword_0; }
		
		//Symbol=ModelSymbol
		public Assignment getSymbolAssignment_1() { return cSymbolAssignment_1; }
		
		//ModelSymbol
		public RuleCall getSymbolModelSymbolParserRuleCall_1_0() { return cSymbolModelSymbolParserRuleCall_1_0; }
		
		//'{'
		public Keyword getLeftCurlyBracketKeyword_2() { return cLeftCurlyBracketKeyword_2; }
		
		//objects+=NamedObject+
		public Assignment getObjectsAssignment_3() { return cObjectsAssignment_3; }
		
		//NamedObject
		public RuleCall getObjectsNamedObjectParserRuleCall_3_0() { return cObjectsNamedObjectParserRuleCall_3_0; }
		
		//'}'
		public Keyword getRightCurlyBracketKeyword_4() { return cRightCurlyBracketKeyword_4; }
	}
	public class FieldRelationInterpretationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.viatra.solver.language.SolverLanguage.FieldRelationInterpretation");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cContainmentAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Keyword cContainmentContainmentKeyword_0_0 = (Keyword)cContainmentAssignment_0.eContents().get(0);
		private final Assignment cSymbolAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cSymbolModelSymbolParserRuleCall_1_0 = (RuleCall)cSymbolAssignment_1.eContents().get(0);
		private final Keyword cColonKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cMultiplicityAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cMultiplicityMultiplicityDefinitionParserRuleCall_3_0 = (RuleCall)cMultiplicityAssignment_3.eContents().get(0);
		private final Assignment cTargetAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cTargetSymbolParserRuleCall_4_0 = (RuleCall)cTargetAssignment_4.eContents().get(0);
		
		//FieldRelationInterpretation:
		//	containment?='containment'? symbol=ModelSymbol ':' multiplicity=MultiplicityDefinition? target=Symbol;
		@Override public ParserRule getRule() { return rule; }
		
		//containment?='containment'? symbol=ModelSymbol ':' multiplicity=MultiplicityDefinition? target=Symbol
		public Group getGroup() { return cGroup; }
		
		//containment?='containment'?
		public Assignment getContainmentAssignment_0() { return cContainmentAssignment_0; }
		
		//'containment'
		public Keyword getContainmentContainmentKeyword_0_0() { return cContainmentContainmentKeyword_0_0; }
		
		//symbol=ModelSymbol
		public Assignment getSymbolAssignment_1() { return cSymbolAssignment_1; }
		
		//ModelSymbol
		public RuleCall getSymbolModelSymbolParserRuleCall_1_0() { return cSymbolModelSymbolParserRuleCall_1_0; }
		
		//':'
		public Keyword getColonKeyword_2() { return cColonKeyword_2; }
		
		//multiplicity=MultiplicityDefinition?
		public Assignment getMultiplicityAssignment_3() { return cMultiplicityAssignment_3; }
		
		//MultiplicityDefinition
		public RuleCall getMultiplicityMultiplicityDefinitionParserRuleCall_3_0() { return cMultiplicityMultiplicityDefinitionParserRuleCall_3_0; }
		
		//target=Symbol
		public Assignment getTargetAssignment_4() { return cTargetAssignment_4; }
		
		//Symbol
		public RuleCall getTargetSymbolParserRuleCall_4_0() { return cTargetSymbolParserRuleCall_4_0; }
	}
	public class GlobalRelationInterpretationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.viatra.solver.language.SolverLanguage.GlobalRelationInterpretation");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cContainmentAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Keyword cContainmentContainmentKeyword_0_0 = (Keyword)cContainmentAssignment_0.eContents().get(0);
		private final Keyword cRelationKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cSymbolAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cSymbolModelSymbolParserRuleCall_2_0 = (RuleCall)cSymbolAssignment_2.eContents().get(0);
		private final Keyword cColonKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cSourceMultiplicityAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cSourceMultiplicityMultiplicityDefinitionParserRuleCall_4_0 = (RuleCall)cSourceMultiplicityAssignment_4.eContents().get(0);
		private final Assignment cSourceAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final RuleCall cSourceSymbolParserRuleCall_5_0 = (RuleCall)cSourceAssignment_5.eContents().get(0);
		private final Assignment cTargetMultiplicityAssignment_6 = (Assignment)cGroup.eContents().get(6);
		private final RuleCall cTargetMultiplicityMultiplicityDefinitionParserRuleCall_6_0 = (RuleCall)cTargetMultiplicityAssignment_6.eContents().get(0);
		private final Assignment cTargetAssignment_7 = (Assignment)cGroup.eContents().get(7);
		private final RuleCall cTargetSymbolParserRuleCall_7_0 = (RuleCall)cTargetAssignment_7.eContents().get(0);
		
		//GlobalRelationInterpretation:
		//	containment?='containment'? 'relation' symbol=ModelSymbol ':' sourceMultiplicity=MultiplicityDefinition?
		//	source=Symbol targetMultiplicity=MultiplicityDefinition? target=Symbol;
		@Override public ParserRule getRule() { return rule; }
		
		//containment?='containment'? 'relation' symbol=ModelSymbol ':' sourceMultiplicity=MultiplicityDefinition? source=Symbol
		//targetMultiplicity=MultiplicityDefinition? target=Symbol
		public Group getGroup() { return cGroup; }
		
		//containment?='containment'?
		public Assignment getContainmentAssignment_0() { return cContainmentAssignment_0; }
		
		//'containment'
		public Keyword getContainmentContainmentKeyword_0_0() { return cContainmentContainmentKeyword_0_0; }
		
		//'relation'
		public Keyword getRelationKeyword_1() { return cRelationKeyword_1; }
		
		//symbol=ModelSymbol
		public Assignment getSymbolAssignment_2() { return cSymbolAssignment_2; }
		
		//ModelSymbol
		public RuleCall getSymbolModelSymbolParserRuleCall_2_0() { return cSymbolModelSymbolParserRuleCall_2_0; }
		
		//':'
		public Keyword getColonKeyword_3() { return cColonKeyword_3; }
		
		//sourceMultiplicity=MultiplicityDefinition?
		public Assignment getSourceMultiplicityAssignment_4() { return cSourceMultiplicityAssignment_4; }
		
		//MultiplicityDefinition
		public RuleCall getSourceMultiplicityMultiplicityDefinitionParserRuleCall_4_0() { return cSourceMultiplicityMultiplicityDefinitionParserRuleCall_4_0; }
		
		//source=Symbol
		public Assignment getSourceAssignment_5() { return cSourceAssignment_5; }
		
		//Symbol
		public RuleCall getSourceSymbolParserRuleCall_5_0() { return cSourceSymbolParserRuleCall_5_0; }
		
		//targetMultiplicity=MultiplicityDefinition?
		public Assignment getTargetMultiplicityAssignment_6() { return cTargetMultiplicityAssignment_6; }
		
		//MultiplicityDefinition
		public RuleCall getTargetMultiplicityMultiplicityDefinitionParserRuleCall_6_0() { return cTargetMultiplicityMultiplicityDefinitionParserRuleCall_6_0; }
		
		//target=Symbol
		public Assignment getTargetAssignment_7() { return cTargetAssignment_7; }
		
		//Symbol
		public RuleCall getTargetSymbolParserRuleCall_7_0() { return cTargetSymbolParserRuleCall_7_0; }
	}
	public class MultiplicityDefinitionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.viatra.solver.language.SolverLanguage.MultiplicityDefinition");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cLowerAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cLowerINTTerminalRuleCall_0_0 = (RuleCall)cLowerAssignment_0.eContents().get(0);
		private final Keyword cFullStopFullStopKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Alternatives cAlternatives_2 = (Alternatives)cGroup.eContents().get(2);
		private final Assignment cUpperAssignment_2_0 = (Assignment)cAlternatives_2.eContents().get(0);
		private final RuleCall cUpperINTTerminalRuleCall_2_0_0 = (RuleCall)cUpperAssignment_2_0.eContents().get(0);
		private final Assignment cUnlimitedUpperAssignment_2_1 = (Assignment)cAlternatives_2.eContents().get(1);
		private final Keyword cUnlimitedUpperAsteriskKeyword_2_1_0 = (Keyword)cUnlimitedUpperAssignment_2_1.eContents().get(0);
		
		//MultiplicityDefinition:
		//	lower=INT '..' (upper=INT | unlimitedUpper?='*');
		@Override public ParserRule getRule() { return rule; }
		
		//lower=INT '..' (upper=INT | unlimitedUpper?='*')
		public Group getGroup() { return cGroup; }
		
		//lower=INT
		public Assignment getLowerAssignment_0() { return cLowerAssignment_0; }
		
		//INT
		public RuleCall getLowerINTTerminalRuleCall_0_0() { return cLowerINTTerminalRuleCall_0_0; }
		
		//'..'
		public Keyword getFullStopFullStopKeyword_1() { return cFullStopFullStopKeyword_1; }
		
		//upper=INT | unlimitedUpper?='*'
		public Alternatives getAlternatives_2() { return cAlternatives_2; }
		
		//upper=INT
		public Assignment getUpperAssignment_2_0() { return cUpperAssignment_2_0; }
		
		//INT
		public RuleCall getUpperINTTerminalRuleCall_2_0_0() { return cUpperINTTerminalRuleCall_2_0_0; }
		
		//unlimitedUpper?='*'
		public Assignment getUnlimitedUpperAssignment_2_1() { return cUnlimitedUpperAssignment_2_1; }
		
		//'*'
		public Keyword getUnlimitedUpperAsteriskKeyword_2_1_0() { return cUnlimitedUpperAsteriskKeyword_2_1_0; }
	}
	
	
	private final ProblemElements pProblem;
	private final StatementElements pStatement;
	private final TerminalRule tSTRING;
	private final REALLiteralElements pREALLiteral;
	private final INTLiteralElements pINTLiteral;
	private final BooleanValueElements pBooleanValue;
	private final TruthValueElements pTruthValue;
	private final InterpretationElements pInterpretation;
	private final BasicInterpretationElements pBasicInterpretation;
	private final SymbolElements pSymbol;
	private final ModelSymbolElements pModelSymbol;
	private final PartialitySymbolElements pPartialitySymbol;
	private final ExistSymbolElements pExistSymbol;
	private final EqualsSymbolElements pEqualsSymbol;
	private final DataSymbolElements pDataSymbol;
	private final BooleanSymbolElements pBooleanSymbol;
	private final IntegerSymbolElements pIntegerSymbol;
	private final RealSymbolElements pRealSymbol;
	private final StringSymbolElements pStringSymbol;
	private final ComplexObjectElements pComplexObject;
	private final ObjectElements pObject;
	private final NamedObjectElements pNamedObject;
	private final UnnamedObjectElements pUnnamedObject;
	private final DataObjectElements pDataObject;
	private final BooleanObjectElements pBooleanObject;
	private final IntObjectElements pIntObject;
	private final RealObjectElements pRealObject;
	private final StringObjectElements pStringObject;
	private final PredicateElements pPredicate;
	private final ParameterElements pParameter;
	private final PatternBodyElements pPatternBody;
	private final PolarityElements pPolarity;
	private final ConstraintElements pConstraint;
	private final ClosureTypeElements pClosureType;
	private final LiteralElements pLiteral;
	private final VariableElements pVariable;
	private final AllInstancesElements pAllInstances;
	private final AllObjectsElements pAllObjects;
	private final DefaultInterpretationElements pDefaultInterpretation;
	private final CDInterpretationElements pCDInterpretation;
	private final ClassInterpretationElements pClassInterpretation;
	private final EnumInterpretationElements pEnumInterpretation;
	private final FieldRelationInterpretationElements pFieldRelationInterpretation;
	private final GlobalRelationInterpretationElements pGlobalRelationInterpretation;
	private final MultiplicityDefinitionElements pMultiplicityDefinition;
	
	private final Grammar grammar;
	
	private final TerminalsGrammarAccess gaTerminals;

	@Inject
	public SolverLanguageGrammarAccess(GrammarProvider grammarProvider,
			TerminalsGrammarAccess gaTerminals) {
		this.grammar = internalFindGrammar(grammarProvider);
		this.gaTerminals = gaTerminals;
		this.pProblem = new ProblemElements();
		this.pStatement = new StatementElements();
		this.tSTRING = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.viatra.solver.language.SolverLanguage.STRING");
		this.pREALLiteral = new REALLiteralElements();
		this.pINTLiteral = new INTLiteralElements();
		this.pBooleanValue = new BooleanValueElements();
		this.pTruthValue = new TruthValueElements();
		this.pInterpretation = new InterpretationElements();
		this.pBasicInterpretation = new BasicInterpretationElements();
		this.pSymbol = new SymbolElements();
		this.pModelSymbol = new ModelSymbolElements();
		this.pPartialitySymbol = new PartialitySymbolElements();
		this.pExistSymbol = new ExistSymbolElements();
		this.pEqualsSymbol = new EqualsSymbolElements();
		this.pDataSymbol = new DataSymbolElements();
		this.pBooleanSymbol = new BooleanSymbolElements();
		this.pIntegerSymbol = new IntegerSymbolElements();
		this.pRealSymbol = new RealSymbolElements();
		this.pStringSymbol = new StringSymbolElements();
		this.pComplexObject = new ComplexObjectElements();
		this.pObject = new ObjectElements();
		this.pNamedObject = new NamedObjectElements();
		this.pUnnamedObject = new UnnamedObjectElements();
		this.pDataObject = new DataObjectElements();
		this.pBooleanObject = new BooleanObjectElements();
		this.pIntObject = new IntObjectElements();
		this.pRealObject = new RealObjectElements();
		this.pStringObject = new StringObjectElements();
		this.pPredicate = new PredicateElements();
		this.pParameter = new ParameterElements();
		this.pPatternBody = new PatternBodyElements();
		this.pPolarity = new PolarityElements();
		this.pConstraint = new ConstraintElements();
		this.pClosureType = new ClosureTypeElements();
		this.pLiteral = new LiteralElements();
		this.pVariable = new VariableElements();
		this.pAllInstances = new AllInstancesElements();
		this.pAllObjects = new AllObjectsElements();
		this.pDefaultInterpretation = new DefaultInterpretationElements();
		this.pCDInterpretation = new CDInterpretationElements();
		this.pClassInterpretation = new ClassInterpretationElements();
		this.pEnumInterpretation = new EnumInterpretationElements();
		this.pFieldRelationInterpretation = new FieldRelationInterpretationElements();
		this.pGlobalRelationInterpretation = new GlobalRelationInterpretationElements();
		this.pMultiplicityDefinition = new MultiplicityDefinitionElements();
	}
	
	protected Grammar internalFindGrammar(GrammarProvider grammarProvider) {
		Grammar grammar = grammarProvider.getGrammar(this);
		while (grammar != null) {
			if ("org.eclipse.viatra.solver.language.SolverLanguage".equals(grammar.getName())) {
				return grammar;
			}
			List<Grammar> grammars = grammar.getUsedGrammars();
			if (!grammars.isEmpty()) {
				grammar = grammars.iterator().next();
			} else {
				return null;
			}
		}
		return grammar;
	}
	
	@Override
	public Grammar getGrammar() {
		return grammar;
	}
	
	
	public TerminalsGrammarAccess getTerminalsGrammarAccess() {
		return gaTerminals;
	}

	
	//Problem:
	//	statements+=Statement*;
	public ProblemElements getProblemAccess() {
		return pProblem;
	}
	
	public ParserRule getProblemRule() {
		return getProblemAccess().getRule();
	}
	
	//Statement:
	//	Interpretation | Predicate;
	public StatementElements getStatementAccess() {
		return pStatement;
	}
	
	public ParserRule getStatementRule() {
		return getStatementAccess().getRule();
	}
	
	//@Override
	//terminal STRING:
	//	'"' ('\\' . | !('\\' | '"'))* '"';
	public TerminalRule getSTRINGRule() {
		return tSTRING;
	}
	
	//REALLiteral ecore::EBigDecimal:
	//	'-'? INT '.' INT;
	public REALLiteralElements getREALLiteralAccess() {
		return pREALLiteral;
	}
	
	public ParserRule getREALLiteralRule() {
		return getREALLiteralAccess().getRule();
	}
	
	//INTLiteral ecore::EInt:
	//	'-'? INT;
	public INTLiteralElements getINTLiteralAccess() {
		return pINTLiteral;
	}
	
	public ParserRule getINTLiteralRule() {
		return getINTLiteralAccess().getRule();
	}
	
	//BooleanValue:
	//	{BooleanTrue} 'true' | 'false' {BooleanFalse};
	public BooleanValueElements getBooleanValueAccess() {
		return pBooleanValue;
	}
	
	public ParserRule getBooleanValueRule() {
		return getBooleanValueAccess().getRule();
	}
	
	//TruthValue:
	//	{True} 'true' | {False} 'false' | {Unknown} 'unknown' | {Error} 'error';
	public TruthValueElements getTruthValueAccess() {
		return pTruthValue;
	}
	
	public ParserRule getTruthValueRule() {
		return getTruthValueAccess().getRule();
	}
	
	/////////////////////
	//// Core grammar
	// ///////////////////
	//Interpretation:
	//	BasicInterpretation | DefaultInterpretation | CDInterpretation;
	public InterpretationElements getInterpretationAccess() {
		return pInterpretation;
	}
	
	public ParserRule getInterpretationRule() {
		return getInterpretationAccess().getRule();
	}
	
	//BasicInterpretation:
	//	symbol=Symbol ('(' (objects+=ComplexObject (',' objects+=ComplexObject)*)? ')')? ':' value=TruthValue;
	public BasicInterpretationElements getBasicInterpretationAccess() {
		return pBasicInterpretation;
	}
	
	public ParserRule getBasicInterpretationRule() {
		return getBasicInterpretationAccess().getRule();
	}
	
	//Symbol:
	//	ModelSymbol | PartialitySymbol | DataSymbol;
	public SymbolElements getSymbolAccess() {
		return pSymbol;
	}
	
	public ParserRule getSymbolRule() {
		return getSymbolAccess().getRule();
	}
	
	//ModelSymbol:
	//	name=ID;
	public ModelSymbolElements getModelSymbolAccess() {
		return pModelSymbol;
	}
	
	public ParserRule getModelSymbolRule() {
		return getModelSymbolAccess().getRule();
	}
	
	//PartialitySymbol:
	//	ExistSymbol | EqualsSymbol;
	public PartialitySymbolElements getPartialitySymbolAccess() {
		return pPartialitySymbol;
	}
	
	public ParserRule getPartialitySymbolRule() {
		return getPartialitySymbolAccess().getRule();
	}
	
	//ExistSymbol:
	//	'exists' {ExistSymbol};
	public ExistSymbolElements getExistSymbolAccess() {
		return pExistSymbol;
	}
	
	public ParserRule getExistSymbolRule() {
		return getExistSymbolAccess().getRule();
	}
	
	//EqualsSymbol:
	//	'equals' {EqualsSymbol};
	public EqualsSymbolElements getEqualsSymbolAccess() {
		return pEqualsSymbol;
	}
	
	public ParserRule getEqualsSymbolRule() {
		return getEqualsSymbolAccess().getRule();
	}
	
	//DataSymbol:
	//	BooleanSymbol | IntegerSymbol | RealSymbol | StringSymbol;
	public DataSymbolElements getDataSymbolAccess() {
		return pDataSymbol;
	}
	
	public ParserRule getDataSymbolRule() {
		return getDataSymbolAccess().getRule();
	}
	
	//BooleanSymbol:
	//	'bool' {BooleanSymbol};
	public BooleanSymbolElements getBooleanSymbolAccess() {
		return pBooleanSymbol;
	}
	
	public ParserRule getBooleanSymbolRule() {
		return getBooleanSymbolAccess().getRule();
	}
	
	//IntegerSymbol:
	//	'int' {IntegerSymbol};
	public IntegerSymbolElements getIntegerSymbolAccess() {
		return pIntegerSymbol;
	}
	
	public ParserRule getIntegerSymbolRule() {
		return getIntegerSymbolAccess().getRule();
	}
	
	//RealSymbol:
	//	'real' {RealSymbol};
	public RealSymbolElements getRealSymbolAccess() {
		return pRealSymbol;
	}
	
	public ParserRule getRealSymbolRule() {
		return getRealSymbolAccess().getRule();
	}
	
	//StringSymbol:
	//	'string' {StringSymbol};
	public StringSymbolElements getStringSymbolAccess() {
		return pStringSymbol;
	}
	
	public ParserRule getStringSymbolRule() {
		return getStringSymbolAccess().getRule();
	}
	
	//ComplexObject:
	//	Object | AllInstances | AllObjects;
	public ComplexObjectElements getComplexObjectAccess() {
		return pComplexObject;
	}
	
	public ParserRule getComplexObjectRule() {
		return getComplexObjectAccess().getRule();
	}
	
	//Object:
	//	NamedObject | UnnamedObject | DataObject;
	public ObjectElements getObjectAccess() {
		return pObject;
	}
	
	public ParserRule getObjectRule() {
		return getObjectAccess().getRule();
	}
	
	//NamedObject:
	//	"'" name=ID "'";
	public NamedObjectElements getNamedObjectAccess() {
		return pNamedObject;
	}
	
	public ParserRule getNamedObjectRule() {
		return getNamedObjectAccess().getRule();
	}
	
	//UnnamedObject:
	//	name=ID;
	public UnnamedObjectElements getUnnamedObjectAccess() {
		return pUnnamedObject;
	}
	
	public ParserRule getUnnamedObjectRule() {
		return getUnnamedObjectAccess().getRule();
	}
	
	//DataObject:
	//	BooleanObject | IntObject | RealObject | StringObject;
	public DataObjectElements getDataObjectAccess() {
		return pDataObject;
	}
	
	public ParserRule getDataObjectRule() {
		return getDataObjectAccess().getRule();
	}
	
	//BooleanObject:
	//	value=BooleanValue;
	public BooleanObjectElements getBooleanObjectAccess() {
		return pBooleanObject;
	}
	
	public ParserRule getBooleanObjectRule() {
		return getBooleanObjectAccess().getRule();
	}
	
	//IntObject:
	//	value=INTLiteral;
	public IntObjectElements getIntObjectAccess() {
		return pIntObject;
	}
	
	public ParserRule getIntObjectRule() {
		return getIntObjectAccess().getRule();
	}
	
	//RealObject:
	//	value=REALLiteral;
	public RealObjectElements getRealObjectAccess() {
		return pRealObject;
	}
	
	public ParserRule getRealObjectRule() {
		return getRealObjectAccess().getRule();
	}
	
	//StringObject:
	//	value=STRING;
	public StringObjectElements getStringObjectAccess() {
		return pStringObject;
	}
	
	public ParserRule getStringObjectRule() {
		return getStringObjectAccess().getRule();
	}
	
	/////////////////////
	//// Predicte grammar
	/////////////////////
	//Predicate:
	//	isError?='error'? symbol=ModelSymbol ('(' (parameters+=Parameter (',' parameters+=Parameter)*)? ')')? ':-' ('false' |
	//	bodies+=PatternBody ('|' bodies+=PatternBody)*) '.';
	public PredicateElements getPredicateAccess() {
		return pPredicate;
	}
	
	public ParserRule getPredicateRule() {
		return getPredicateAccess().getRule();
	}
	
	//Parameter:
	//	variable=Variable (':' type=Symbol)?;
	public ParameterElements getParameterAccess() {
		return pParameter;
	}
	
	public ParserRule getParameterRule() {
		return getParameterAccess().getRule();
	}
	
	//PatternBody:
	//	{PatternBody} ('true' | constraints+=Constraint*);
	public PatternBodyElements getPatternBodyAccess() {
		return pPatternBody;
	}
	
	public ParserRule getPatternBodyRule() {
		return getPatternBodyAccess().getRule();
	}
	
	//Polarity:
	//	{Positive} '+' | {Negative} '-';
	public PolarityElements getPolarityAccess() {
		return pPolarity;
	}
	
	public ParserRule getPolarityRule() {
		return getPolarityAccess().getRule();
	}
	
	//Constraint:
	//	polarity=Polarity? symbol=ModelSymbol ('(' params+=Literal? (',' params+=Literal)* ')')? | closureType=ClosureType
	//	'(' params+=Literal? (',' params+=Literal)* ')';
	public ConstraintElements getConstraintAccess() {
		return pConstraint;
	}
	
	public ParserRule getConstraintRule() {
		return getConstraintAccess().getRule();
	}
	
	//ClosureType:
	//	{ReflexiveClosure} '*' | {IrreflexiveClosure} '+';
	public ClosureTypeElements getClosureTypeAccess() {
		return pClosureType;
	}
	
	public ParserRule getClosureTypeRule() {
		return getClosureTypeAccess().getRule();
	}
	
	//Literal:
	//	Variable | DataObject | NamedObject;
	public LiteralElements getLiteralAccess() {
		return pLiteral;
	}
	
	public ParserRule getLiteralRule() {
		return getLiteralAccess().getRule();
	}
	
	//Variable:
	//	name=ID;
	public VariableElements getVariableAccess() {
		return pVariable;
	}
	
	public ParserRule getVariableRule() {
		return getVariableAccess().getRule();
	}
	
	/////////////////////
	//// Complex Interpretation grammar
	/////////////////////
	//AllInstances:
	//	':' symbol=Symbol;
	public AllInstancesElements getAllInstancesAccess() {
		return pAllInstances;
	}
	
	public ParserRule getAllInstancesRule() {
		return getAllInstancesAccess().getRule();
	}
	
	//AllObjects:
	//	{AllObjects} '*';
	public AllObjectsElements getAllObjectsAccess() {
		return pAllObjects;
	}
	
	public ParserRule getAllObjectsRule() {
		return getAllObjectsAccess().getRule();
	}
	
	/////////////////////
	//// Defaul Interpretation grammar
	/////////////////////
	//DefaultInterpretation:
	//	'default' interpretation=BasicInterpretation;
	public DefaultInterpretationElements getDefaultInterpretationAccess() {
		return pDefaultInterpretation;
	}
	
	public ParserRule getDefaultInterpretationRule() {
		return getDefaultInterpretationAccess().getRule();
	}
	
	/////////////////////
	//// Advanced Class-Diagram interpretations
	/////////////////////
	//CDInterpretation:
	//	ClassInterpretation | EnumInterpretation | GlobalRelationInterpretation;
	public CDInterpretationElements getCDInterpretationAccess() {
		return pCDInterpretation;
	}
	
	public ParserRule getCDInterpretationRule() {
		return getCDInterpretationAccess().getRule();
	}
	
	//ClassInterpretation:
	//	abstract?='abstract'? 'class' symbol=ModelSymbol ('extends' supertypes+=ModelSymbol+)? '{'
	//	fielt+=FieldRelationInterpretation*
	//	'}';
	public ClassInterpretationElements getClassInterpretationAccess() {
		return pClassInterpretation;
	}
	
	public ParserRule getClassInterpretationRule() {
		return getClassInterpretationAccess().getRule();
	}
	
	//EnumInterpretation:
	//	'enum' Symbol=ModelSymbol '{' objects+=NamedObject+ '}';
	public EnumInterpretationElements getEnumInterpretationAccess() {
		return pEnumInterpretation;
	}
	
	public ParserRule getEnumInterpretationRule() {
		return getEnumInterpretationAccess().getRule();
	}
	
	//FieldRelationInterpretation:
	//	containment?='containment'? symbol=ModelSymbol ':' multiplicity=MultiplicityDefinition? target=Symbol;
	public FieldRelationInterpretationElements getFieldRelationInterpretationAccess() {
		return pFieldRelationInterpretation;
	}
	
	public ParserRule getFieldRelationInterpretationRule() {
		return getFieldRelationInterpretationAccess().getRule();
	}
	
	//GlobalRelationInterpretation:
	//	containment?='containment'? 'relation' symbol=ModelSymbol ':' sourceMultiplicity=MultiplicityDefinition?
	//	source=Symbol targetMultiplicity=MultiplicityDefinition? target=Symbol;
	public GlobalRelationInterpretationElements getGlobalRelationInterpretationAccess() {
		return pGlobalRelationInterpretation;
	}
	
	public ParserRule getGlobalRelationInterpretationRule() {
		return getGlobalRelationInterpretationAccess().getRule();
	}
	
	//MultiplicityDefinition:
	//	lower=INT '..' (upper=INT | unlimitedUpper?='*');
	public MultiplicityDefinitionElements getMultiplicityDefinitionAccess() {
		return pMultiplicityDefinition;
	}
	
	public ParserRule getMultiplicityDefinitionRule() {
		return getMultiplicityDefinitionAccess().getRule();
	}
	
	//terminal ID:
	//	'^'? ('a'..'z' | 'A'..'Z' | '_') ('a'..'z' | 'A'..'Z' | '_' | '0'..'9')*;
	public TerminalRule getIDRule() {
		return gaTerminals.getIDRule();
	}
	
	//terminal INT returns ecore::EInt:
	//	'0'..'9'+;
	public TerminalRule getINTRule() {
		return gaTerminals.getINTRule();
	}
	
	//terminal ML_COMMENT:
	//	'/*'->'*/';
	public TerminalRule getML_COMMENTRule() {
		return gaTerminals.getML_COMMENTRule();
	}
	
	//terminal SL_COMMENT:
	//	'//' !('\n' | '\r')* ('\r'? '\n')?;
	public TerminalRule getSL_COMMENTRule() {
		return gaTerminals.getSL_COMMENTRule();
	}
	
	//terminal WS:
	//	' ' | '\t' | '\r' | '\n'+;
	public TerminalRule getWSRule() {
		return gaTerminals.getWSRule();
	}
	
	//terminal ANY_OTHER:
	//	.;
	public TerminalRule getANY_OTHERRule() {
		return gaTerminals.getANY_OTHERRule();
	}
}
