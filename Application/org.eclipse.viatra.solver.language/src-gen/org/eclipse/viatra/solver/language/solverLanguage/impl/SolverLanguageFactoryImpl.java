/**
 * generated by Xtext 2.18.0.M3
 */
package org.eclipse.viatra.solver.language.solverLanguage.impl;

import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;

import org.eclipse.emf.ecore.impl.EFactoryImpl;

import org.eclipse.emf.ecore.plugin.EcorePlugin;

import org.eclipse.viatra.solver.language.solverLanguage.AllInstances;
import org.eclipse.viatra.solver.language.solverLanguage.AllObjects;
import org.eclipse.viatra.solver.language.solverLanguage.BasicInterpretation;
import org.eclipse.viatra.solver.language.solverLanguage.BooleanFalse;
import org.eclipse.viatra.solver.language.solverLanguage.BooleanObject;
import org.eclipse.viatra.solver.language.solverLanguage.BooleanSymbol;
import org.eclipse.viatra.solver.language.solverLanguage.BooleanTrue;
import org.eclipse.viatra.solver.language.solverLanguage.BooleanValue;
import org.eclipse.viatra.solver.language.solverLanguage.CDInterpretation;
import org.eclipse.viatra.solver.language.solverLanguage.ClassInterpretation;
import org.eclipse.viatra.solver.language.solverLanguage.ClosureType;
import org.eclipse.viatra.solver.language.solverLanguage.ComplexObject;
import org.eclipse.viatra.solver.language.solverLanguage.Constraint;
import org.eclipse.viatra.solver.language.solverLanguage.DataObject;
import org.eclipse.viatra.solver.language.solverLanguage.DataSymbol;
import org.eclipse.viatra.solver.language.solverLanguage.DefaultInterpretation;
import org.eclipse.viatra.solver.language.solverLanguage.EnumInterpretation;
import org.eclipse.viatra.solver.language.solverLanguage.EqualsSymbol;
import org.eclipse.viatra.solver.language.solverLanguage.ErrorPredicate;
import org.eclipse.viatra.solver.language.solverLanguage.ExistSymbol;
import org.eclipse.viatra.solver.language.solverLanguage.False;
import org.eclipse.viatra.solver.language.solverLanguage.FieldRelationInterpretation;
import org.eclipse.viatra.solver.language.solverLanguage.GlobalRelationInterpretation;
import org.eclipse.viatra.solver.language.solverLanguage.IntObject;
import org.eclipse.viatra.solver.language.solverLanguage.IntegerSymbol;
import org.eclipse.viatra.solver.language.solverLanguage.Interpretation;
import org.eclipse.viatra.solver.language.solverLanguage.IrreflexiveClosure;
import org.eclipse.viatra.solver.language.solverLanguage.Literal;
import org.eclipse.viatra.solver.language.solverLanguage.ModelSymbol;
import org.eclipse.viatra.solver.language.solverLanguage.MultiplicityDefinition;
import org.eclipse.viatra.solver.language.solverLanguage.NamedObject;
import org.eclipse.viatra.solver.language.solverLanguage.Negative;
import org.eclipse.viatra.solver.language.solverLanguage.Parameter;
import org.eclipse.viatra.solver.language.solverLanguage.PartialitySymbol;
import org.eclipse.viatra.solver.language.solverLanguage.PatternBody;
import org.eclipse.viatra.solver.language.solverLanguage.Polarity;
import org.eclipse.viatra.solver.language.solverLanguage.Positive;
import org.eclipse.viatra.solver.language.solverLanguage.Predicate;
import org.eclipse.viatra.solver.language.solverLanguage.PredicateSymbol;
import org.eclipse.viatra.solver.language.solverLanguage.Problem;
import org.eclipse.viatra.solver.language.solverLanguage.RealObject;
import org.eclipse.viatra.solver.language.solverLanguage.RealSymbol;
import org.eclipse.viatra.solver.language.solverLanguage.ReflexiveClosure;
import org.eclipse.viatra.solver.language.solverLanguage.SolverLanguageFactory;
import org.eclipse.viatra.solver.language.solverLanguage.SolverLanguagePackage;
import org.eclipse.viatra.solver.language.solverLanguage.Statement;
import org.eclipse.viatra.solver.language.solverLanguage.StringObject;
import org.eclipse.viatra.solver.language.solverLanguage.StringSymbol;
import org.eclipse.viatra.solver.language.solverLanguage.Symbol;
import org.eclipse.viatra.solver.language.solverLanguage.True;
import org.eclipse.viatra.solver.language.solverLanguage.TruthValue;
import org.eclipse.viatra.solver.language.solverLanguage.Unknown;
import org.eclipse.viatra.solver.language.solverLanguage.UnnamedObject;
import org.eclipse.viatra.solver.language.solverLanguage.Variable;

/**
 * <!-- begin-user-doc -->
 * An implementation of the model <b>Factory</b>.
 * <!-- end-user-doc -->
 * @generated
 */
public class SolverLanguageFactoryImpl extends EFactoryImpl implements SolverLanguageFactory
{
  /**
   * Creates the default factory implementation.
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  public static SolverLanguageFactory init()
  {
    try
    {
      SolverLanguageFactory theSolverLanguageFactory = (SolverLanguageFactory)EPackage.Registry.INSTANCE.getEFactory(SolverLanguagePackage.eNS_URI);
      if (theSolverLanguageFactory != null)
      {
        return theSolverLanguageFactory;
      }
    }
    catch (Exception exception)
    {
      EcorePlugin.INSTANCE.log(exception);
    }
    return new SolverLanguageFactoryImpl();
  }

  /**
   * Creates an instance of the factory.
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  public SolverLanguageFactoryImpl()
  {
    super();
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  @Override
  public EObject create(EClass eClass)
  {
    switch (eClass.getClassifierID())
    {
      case SolverLanguagePackage.PROBLEM: return createProblem();
      case SolverLanguagePackage.STATEMENT: return createStatement();
      case SolverLanguagePackage.BOOLEAN_VALUE: return createBooleanValue();
      case SolverLanguagePackage.TRUTH_VALUE: return createTruthValue();
      case SolverLanguagePackage.INTERPRETATION: return createInterpretation();
      case SolverLanguagePackage.BASIC_INTERPRETATION: return createBasicInterpretation();
      case SolverLanguagePackage.SYMBOL: return createSymbol();
      case SolverLanguagePackage.MODEL_SYMBOL: return createModelSymbol();
      case SolverLanguagePackage.PARTIALITY_SYMBOL: return createPartialitySymbol();
      case SolverLanguagePackage.EXIST_SYMBOL: return createExistSymbol();
      case SolverLanguagePackage.EQUALS_SYMBOL: return createEqualsSymbol();
      case SolverLanguagePackage.DATA_SYMBOL: return createDataSymbol();
      case SolverLanguagePackage.BOOLEAN_SYMBOL: return createBooleanSymbol();
      case SolverLanguagePackage.INTEGER_SYMBOL: return createIntegerSymbol();
      case SolverLanguagePackage.REAL_SYMBOL: return createRealSymbol();
      case SolverLanguagePackage.STRING_SYMBOL: return createStringSymbol();
      case SolverLanguagePackage.COMPLEX_OBJECT: return createComplexObject();
      case SolverLanguagePackage.OBJECT: return createObject();
      case SolverLanguagePackage.NAMED_OBJECT: return createNamedObject();
      case SolverLanguagePackage.UNNAMED_OBJECT: return createUnnamedObject();
      case SolverLanguagePackage.DATA_OBJECT: return createDataObject();
      case SolverLanguagePackage.BOOLEAN_OBJECT: return createBooleanObject();
      case SolverLanguagePackage.INT_OBJECT: return createIntObject();
      case SolverLanguagePackage.REAL_OBJECT: return createRealObject();
      case SolverLanguagePackage.STRING_OBJECT: return createStringObject();
      case SolverLanguagePackage.PREDICATE: return createPredicate();
      case SolverLanguagePackage.PREDICATE_SYMBOL: return createPredicateSymbol();
      case SolverLanguagePackage.ERROR_PREDICATE: return createErrorPredicate();
      case SolverLanguagePackage.PARAMETER: return createParameter();
      case SolverLanguagePackage.PATTERN_BODY: return createPatternBody();
      case SolverLanguagePackage.POLARITY: return createPolarity();
      case SolverLanguagePackage.CONSTRAINT: return createConstraint();
      case SolverLanguagePackage.CLOSURE_TYPE: return createClosureType();
      case SolverLanguagePackage.LITERAL: return createLiteral();
      case SolverLanguagePackage.VARIABLE: return createVariable();
      case SolverLanguagePackage.ALL_INSTANCES: return createAllInstances();
      case SolverLanguagePackage.ALL_OBJECTS: return createAllObjects();
      case SolverLanguagePackage.DEFAULT_INTERPRETATION: return createDefaultInterpretation();
      case SolverLanguagePackage.CD_INTERPRETATION: return createCDInterpretation();
      case SolverLanguagePackage.CLASS_INTERPRETATION: return createClassInterpretation();
      case SolverLanguagePackage.ENUM_INTERPRETATION: return createEnumInterpretation();
      case SolverLanguagePackage.FIELD_RELATION_INTERPRETATION: return createFieldRelationInterpretation();
      case SolverLanguagePackage.GLOBAL_RELATION_INTERPRETATION: return createGlobalRelationInterpretation();
      case SolverLanguagePackage.MULTIPLICITY_DEFINITION: return createMultiplicityDefinition();
      case SolverLanguagePackage.BOOLEAN_TRUE: return createBooleanTrue();
      case SolverLanguagePackage.BOOLEAN_FALSE: return createBooleanFalse();
      case SolverLanguagePackage.TRUE: return createTrue();
      case SolverLanguagePackage.FALSE: return createFalse();
      case SolverLanguagePackage.UNKNOWN: return createUnknown();
      case SolverLanguagePackage.ERROR: return createError();
      case SolverLanguagePackage.POSITIVE: return createPositive();
      case SolverLanguagePackage.NEGATIVE: return createNegative();
      case SolverLanguagePackage.REFLEXIVE_CLOSURE: return createReflexiveClosure();
      case SolverLanguagePackage.IRREFLEXIVE_CLOSURE: return createIrreflexiveClosure();
      default:
        throw new IllegalArgumentException("The class '" + eClass.getName() + "' is not a valid classifier");
    }
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  @Override
  public Problem createProblem()
  {
    ProblemImpl problem = new ProblemImpl();
    return problem;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  @Override
  public Statement createStatement()
  {
    StatementImpl statement = new StatementImpl();
    return statement;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  @Override
  public BooleanValue createBooleanValue()
  {
    BooleanValueImpl booleanValue = new BooleanValueImpl();
    return booleanValue;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  @Override
  public TruthValue createTruthValue()
  {
    TruthValueImpl truthValue = new TruthValueImpl();
    return truthValue;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  @Override
  public Interpretation createInterpretation()
  {
    InterpretationImpl interpretation = new InterpretationImpl();
    return interpretation;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  @Override
  public BasicInterpretation createBasicInterpretation()
  {
    BasicInterpretationImpl basicInterpretation = new BasicInterpretationImpl();
    return basicInterpretation;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  @Override
  public Symbol createSymbol()
  {
    SymbolImpl symbol = new SymbolImpl();
    return symbol;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  @Override
  public ModelSymbol createModelSymbol()
  {
    ModelSymbolImpl modelSymbol = new ModelSymbolImpl();
    return modelSymbol;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  @Override
  public PartialitySymbol createPartialitySymbol()
  {
    PartialitySymbolImpl partialitySymbol = new PartialitySymbolImpl();
    return partialitySymbol;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  @Override
  public ExistSymbol createExistSymbol()
  {
    ExistSymbolImpl existSymbol = new ExistSymbolImpl();
    return existSymbol;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  @Override
  public EqualsSymbol createEqualsSymbol()
  {
    EqualsSymbolImpl equalsSymbol = new EqualsSymbolImpl();
    return equalsSymbol;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  @Override
  public DataSymbol createDataSymbol()
  {
    DataSymbolImpl dataSymbol = new DataSymbolImpl();
    return dataSymbol;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  @Override
  public BooleanSymbol createBooleanSymbol()
  {
    BooleanSymbolImpl booleanSymbol = new BooleanSymbolImpl();
    return booleanSymbol;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  @Override
  public IntegerSymbol createIntegerSymbol()
  {
    IntegerSymbolImpl integerSymbol = new IntegerSymbolImpl();
    return integerSymbol;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  @Override
  public RealSymbol createRealSymbol()
  {
    RealSymbolImpl realSymbol = new RealSymbolImpl();
    return realSymbol;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  @Override
  public StringSymbol createStringSymbol()
  {
    StringSymbolImpl stringSymbol = new StringSymbolImpl();
    return stringSymbol;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  @Override
  public ComplexObject createComplexObject()
  {
    ComplexObjectImpl complexObject = new ComplexObjectImpl();
    return complexObject;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  @Override
  public org.eclipse.viatra.solver.language.solverLanguage.Object createObject()
  {
    ObjectImpl object = new ObjectImpl();
    return object;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  @Override
  public NamedObject createNamedObject()
  {
    NamedObjectImpl namedObject = new NamedObjectImpl();
    return namedObject;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  @Override
  public UnnamedObject createUnnamedObject()
  {
    UnnamedObjectImpl unnamedObject = new UnnamedObjectImpl();
    return unnamedObject;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  @Override
  public DataObject createDataObject()
  {
    DataObjectImpl dataObject = new DataObjectImpl();
    return dataObject;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  @Override
  public BooleanObject createBooleanObject()
  {
    BooleanObjectImpl booleanObject = new BooleanObjectImpl();
    return booleanObject;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  @Override
  public IntObject createIntObject()
  {
    IntObjectImpl intObject = new IntObjectImpl();
    return intObject;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  @Override
  public RealObject createRealObject()
  {
    RealObjectImpl realObject = new RealObjectImpl();
    return realObject;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  @Override
  public StringObject createStringObject()
  {
    StringObjectImpl stringObject = new StringObjectImpl();
    return stringObject;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  @Override
  public Predicate createPredicate()
  {
    PredicateImpl predicate = new PredicateImpl();
    return predicate;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  @Override
  public PredicateSymbol createPredicateSymbol()
  {
    PredicateSymbolImpl predicateSymbol = new PredicateSymbolImpl();
    return predicateSymbol;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  @Override
  public ErrorPredicate createErrorPredicate()
  {
    ErrorPredicateImpl errorPredicate = new ErrorPredicateImpl();
    return errorPredicate;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  @Override
  public Parameter createParameter()
  {
    ParameterImpl parameter = new ParameterImpl();
    return parameter;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  @Override
  public PatternBody createPatternBody()
  {
    PatternBodyImpl patternBody = new PatternBodyImpl();
    return patternBody;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  @Override
  public Polarity createPolarity()
  {
    PolarityImpl polarity = new PolarityImpl();
    return polarity;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  @Override
  public Constraint createConstraint()
  {
    ConstraintImpl constraint = new ConstraintImpl();
    return constraint;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  @Override
  public ClosureType createClosureType()
  {
    ClosureTypeImpl closureType = new ClosureTypeImpl();
    return closureType;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  @Override
  public Literal createLiteral()
  {
    LiteralImpl literal = new LiteralImpl();
    return literal;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  @Override
  public Variable createVariable()
  {
    VariableImpl variable = new VariableImpl();
    return variable;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  @Override
  public AllInstances createAllInstances()
  {
    AllInstancesImpl allInstances = new AllInstancesImpl();
    return allInstances;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  @Override
  public AllObjects createAllObjects()
  {
    AllObjectsImpl allObjects = new AllObjectsImpl();
    return allObjects;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  @Override
  public DefaultInterpretation createDefaultInterpretation()
  {
    DefaultInterpretationImpl defaultInterpretation = new DefaultInterpretationImpl();
    return defaultInterpretation;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  @Override
  public CDInterpretation createCDInterpretation()
  {
    CDInterpretationImpl cdInterpretation = new CDInterpretationImpl();
    return cdInterpretation;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  @Override
  public ClassInterpretation createClassInterpretation()
  {
    ClassInterpretationImpl classInterpretation = new ClassInterpretationImpl();
    return classInterpretation;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  @Override
  public EnumInterpretation createEnumInterpretation()
  {
    EnumInterpretationImpl enumInterpretation = new EnumInterpretationImpl();
    return enumInterpretation;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  @Override
  public FieldRelationInterpretation createFieldRelationInterpretation()
  {
    FieldRelationInterpretationImpl fieldRelationInterpretation = new FieldRelationInterpretationImpl();
    return fieldRelationInterpretation;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  @Override
  public GlobalRelationInterpretation createGlobalRelationInterpretation()
  {
    GlobalRelationInterpretationImpl globalRelationInterpretation = new GlobalRelationInterpretationImpl();
    return globalRelationInterpretation;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  @Override
  public MultiplicityDefinition createMultiplicityDefinition()
  {
    MultiplicityDefinitionImpl multiplicityDefinition = new MultiplicityDefinitionImpl();
    return multiplicityDefinition;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  @Override
  public BooleanTrue createBooleanTrue()
  {
    BooleanTrueImpl booleanTrue = new BooleanTrueImpl();
    return booleanTrue;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  @Override
  public BooleanFalse createBooleanFalse()
  {
    BooleanFalseImpl booleanFalse = new BooleanFalseImpl();
    return booleanFalse;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  @Override
  public True createTrue()
  {
    TrueImpl true_ = new TrueImpl();
    return true_;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  @Override
  public False createFalse()
  {
    FalseImpl false_ = new FalseImpl();
    return false_;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  @Override
  public Unknown createUnknown()
  {
    UnknownImpl unknown = new UnknownImpl();
    return unknown;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  @Override
  public org.eclipse.viatra.solver.language.solverLanguage.Error createError()
  {
    ErrorImpl error = new ErrorImpl();
    return error;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  @Override
  public Positive createPositive()
  {
    PositiveImpl positive = new PositiveImpl();
    return positive;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  @Override
  public Negative createNegative()
  {
    NegativeImpl negative = new NegativeImpl();
    return negative;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  @Override
  public ReflexiveClosure createReflexiveClosure()
  {
    ReflexiveClosureImpl reflexiveClosure = new ReflexiveClosureImpl();
    return reflexiveClosure;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  @Override
  public IrreflexiveClosure createIrreflexiveClosure()
  {
    IrreflexiveClosureImpl irreflexiveClosure = new IrreflexiveClosureImpl();
    return irreflexiveClosure;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  @Override
  public SolverLanguagePackage getSolverLanguagePackage()
  {
    return (SolverLanguagePackage)getEPackage();
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @deprecated
   * @generated
   */
  @Deprecated
  public static SolverLanguagePackage getPackage()
  {
    return SolverLanguagePackage.eINSTANCE;
  }

} //SolverLanguageFactoryImpl
