/**
 * generated by Xtext 2.18.0.M3
 */
package org.eclipse.viatra.solver.language.solverLanguage.util;

import org.eclipse.emf.common.notify.Adapter;
import org.eclipse.emf.common.notify.Notifier;

import org.eclipse.emf.common.notify.impl.AdapterFactoryImpl;

import org.eclipse.emf.ecore.EObject;

import org.eclipse.viatra.solver.language.solverLanguage.AllInstances;
import org.eclipse.viatra.solver.language.solverLanguage.AllObjects;
import org.eclipse.viatra.solver.language.solverLanguage.BasicInterpretation;
import org.eclipse.viatra.solver.language.solverLanguage.BooleanFalse;
import org.eclipse.viatra.solver.language.solverLanguage.BooleanObject;
import org.eclipse.viatra.solver.language.solverLanguage.BooleanSymbol;
import org.eclipse.viatra.solver.language.solverLanguage.BooleanTrue;
import org.eclipse.viatra.solver.language.solverLanguage.BooleanValue;
import org.eclipse.viatra.solver.language.solverLanguage.CDInterpretation;
import org.eclipse.viatra.solver.language.solverLanguage.ClassInterpretation;
import org.eclipse.viatra.solver.language.solverLanguage.ClosureType;
import org.eclipse.viatra.solver.language.solverLanguage.ComplexObject;
import org.eclipse.viatra.solver.language.solverLanguage.Constraint;
import org.eclipse.viatra.solver.language.solverLanguage.DataObject;
import org.eclipse.viatra.solver.language.solverLanguage.DataSymbol;
import org.eclipse.viatra.solver.language.solverLanguage.DefaultInterpretation;
import org.eclipse.viatra.solver.language.solverLanguage.EnumInterpretation;
import org.eclipse.viatra.solver.language.solverLanguage.EqualsSymbol;
import org.eclipse.viatra.solver.language.solverLanguage.ExistSymbol;
import org.eclipse.viatra.solver.language.solverLanguage.False;
import org.eclipse.viatra.solver.language.solverLanguage.FieldRelationInterpretation;
import org.eclipse.viatra.solver.language.solverLanguage.GlobalRelationInterpretation;
import org.eclipse.viatra.solver.language.solverLanguage.IntObject;
import org.eclipse.viatra.solver.language.solverLanguage.IntegerSymbol;
import org.eclipse.viatra.solver.language.solverLanguage.Interpretation;
import org.eclipse.viatra.solver.language.solverLanguage.IrreflexiveClosure;
import org.eclipse.viatra.solver.language.solverLanguage.Literal;
import org.eclipse.viatra.solver.language.solverLanguage.ModelSymbol;
import org.eclipse.viatra.solver.language.solverLanguage.MultiplicityDefinition;
import org.eclipse.viatra.solver.language.solverLanguage.NamedObject;
import org.eclipse.viatra.solver.language.solverLanguage.Negative;
import org.eclipse.viatra.solver.language.solverLanguage.Parameter;
import org.eclipse.viatra.solver.language.solverLanguage.PartialitySymbol;
import org.eclipse.viatra.solver.language.solverLanguage.PatternBody;
import org.eclipse.viatra.solver.language.solverLanguage.Polarity;
import org.eclipse.viatra.solver.language.solverLanguage.Positive;
import org.eclipse.viatra.solver.language.solverLanguage.Predicate;
import org.eclipse.viatra.solver.language.solverLanguage.Problem;
import org.eclipse.viatra.solver.language.solverLanguage.RealObject;
import org.eclipse.viatra.solver.language.solverLanguage.RealSymbol;
import org.eclipse.viatra.solver.language.solverLanguage.ReflexiveClosure;
import org.eclipse.viatra.solver.language.solverLanguage.SolverLanguagePackage;
import org.eclipse.viatra.solver.language.solverLanguage.Statement;
import org.eclipse.viatra.solver.language.solverLanguage.StringObject;
import org.eclipse.viatra.solver.language.solverLanguage.StringSymbol;
import org.eclipse.viatra.solver.language.solverLanguage.Symbol;
import org.eclipse.viatra.solver.language.solverLanguage.True;
import org.eclipse.viatra.solver.language.solverLanguage.TruthValue;
import org.eclipse.viatra.solver.language.solverLanguage.Unknown;
import org.eclipse.viatra.solver.language.solverLanguage.UnnamedObject;
import org.eclipse.viatra.solver.language.solverLanguage.Variable;

/**
 * <!-- begin-user-doc -->
 * The <b>Adapter Factory</b> for the model.
 * It provides an adapter <code>createXXX</code> method for each class of the model.
 * <!-- end-user-doc -->
 * @see org.eclipse.viatra.solver.language.solverLanguage.SolverLanguagePackage
 * @generated
 */
public class SolverLanguageAdapterFactory extends AdapterFactoryImpl
{
  /**
   * The cached model package.
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  protected static SolverLanguagePackage modelPackage;

  /**
   * Creates an instance of the adapter factory.
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  public SolverLanguageAdapterFactory()
  {
    if (modelPackage == null)
    {
      modelPackage = SolverLanguagePackage.eINSTANCE;
    }
  }

  /**
   * Returns whether this factory is applicable for the type of the object.
   * <!-- begin-user-doc -->
   * This implementation returns <code>true</code> if the object is either the model's package or is an instance object of the model.
   * <!-- end-user-doc -->
   * @return whether this factory is applicable for the type of the object.
   * @generated
   */
  @Override
  public boolean isFactoryForType(Object object)
  {
    if (object == modelPackage)
    {
      return true;
    }
    if (object instanceof EObject)
    {
      return ((EObject)object).eClass().getEPackage() == modelPackage;
    }
    return false;
  }

  /**
   * The switch that delegates to the <code>createXXX</code> methods.
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  protected SolverLanguageSwitch<Adapter> modelSwitch =
    new SolverLanguageSwitch<Adapter>()
    {
      @Override
      public Adapter caseProblem(Problem object)
      {
        return createProblemAdapter();
      }
      @Override
      public Adapter caseStatement(Statement object)
      {
        return createStatementAdapter();
      }
      @Override
      public Adapter caseBooleanValue(BooleanValue object)
      {
        return createBooleanValueAdapter();
      }
      @Override
      public Adapter caseTruthValue(TruthValue object)
      {
        return createTruthValueAdapter();
      }
      @Override
      public Adapter caseInterpretation(Interpretation object)
      {
        return createInterpretationAdapter();
      }
      @Override
      public Adapter caseBasicInterpretation(BasicInterpretation object)
      {
        return createBasicInterpretationAdapter();
      }
      @Override
      public Adapter caseSymbol(Symbol object)
      {
        return createSymbolAdapter();
      }
      @Override
      public Adapter caseModelSymbol(ModelSymbol object)
      {
        return createModelSymbolAdapter();
      }
      @Override
      public Adapter casePartialitySymbol(PartialitySymbol object)
      {
        return createPartialitySymbolAdapter();
      }
      @Override
      public Adapter caseExistSymbol(ExistSymbol object)
      {
        return createExistSymbolAdapter();
      }
      @Override
      public Adapter caseEqualsSymbol(EqualsSymbol object)
      {
        return createEqualsSymbolAdapter();
      }
      @Override
      public Adapter caseDataSymbol(DataSymbol object)
      {
        return createDataSymbolAdapter();
      }
      @Override
      public Adapter caseBooleanSymbol(BooleanSymbol object)
      {
        return createBooleanSymbolAdapter();
      }
      @Override
      public Adapter caseIntegerSymbol(IntegerSymbol object)
      {
        return createIntegerSymbolAdapter();
      }
      @Override
      public Adapter caseRealSymbol(RealSymbol object)
      {
        return createRealSymbolAdapter();
      }
      @Override
      public Adapter caseStringSymbol(StringSymbol object)
      {
        return createStringSymbolAdapter();
      }
      @Override
      public Adapter caseComplexObject(ComplexObject object)
      {
        return createComplexObjectAdapter();
      }
      @Override
      public Adapter caseObject(org.eclipse.viatra.solver.language.solverLanguage.Object object)
      {
        return createObjectAdapter();
      }
      @Override
      public Adapter caseNamedObject(NamedObject object)
      {
        return createNamedObjectAdapter();
      }
      @Override
      public Adapter caseUnnamedObject(UnnamedObject object)
      {
        return createUnnamedObjectAdapter();
      }
      @Override
      public Adapter caseDataObject(DataObject object)
      {
        return createDataObjectAdapter();
      }
      @Override
      public Adapter caseBooleanObject(BooleanObject object)
      {
        return createBooleanObjectAdapter();
      }
      @Override
      public Adapter caseIntObject(IntObject object)
      {
        return createIntObjectAdapter();
      }
      @Override
      public Adapter caseRealObject(RealObject object)
      {
        return createRealObjectAdapter();
      }
      @Override
      public Adapter caseStringObject(StringObject object)
      {
        return createStringObjectAdapter();
      }
      @Override
      public Adapter casePredicate(Predicate object)
      {
        return createPredicateAdapter();
      }
      @Override
      public Adapter caseParameter(Parameter object)
      {
        return createParameterAdapter();
      }
      @Override
      public Adapter casePatternBody(PatternBody object)
      {
        return createPatternBodyAdapter();
      }
      @Override
      public Adapter casePolarity(Polarity object)
      {
        return createPolarityAdapter();
      }
      @Override
      public Adapter caseConstraint(Constraint object)
      {
        return createConstraintAdapter();
      }
      @Override
      public Adapter caseClosureType(ClosureType object)
      {
        return createClosureTypeAdapter();
      }
      @Override
      public Adapter caseLiteral(Literal object)
      {
        return createLiteralAdapter();
      }
      @Override
      public Adapter caseVariable(Variable object)
      {
        return createVariableAdapter();
      }
      @Override
      public Adapter caseAllInstances(AllInstances object)
      {
        return createAllInstancesAdapter();
      }
      @Override
      public Adapter caseAllObjects(AllObjects object)
      {
        return createAllObjectsAdapter();
      }
      @Override
      public Adapter caseDefaultInterpretation(DefaultInterpretation object)
      {
        return createDefaultInterpretationAdapter();
      }
      @Override
      public Adapter caseCDInterpretation(CDInterpretation object)
      {
        return createCDInterpretationAdapter();
      }
      @Override
      public Adapter caseClassInterpretation(ClassInterpretation object)
      {
        return createClassInterpretationAdapter();
      }
      @Override
      public Adapter caseEnumInterpretation(EnumInterpretation object)
      {
        return createEnumInterpretationAdapter();
      }
      @Override
      public Adapter caseFieldRelationInterpretation(FieldRelationInterpretation object)
      {
        return createFieldRelationInterpretationAdapter();
      }
      @Override
      public Adapter caseGlobalRelationInterpretation(GlobalRelationInterpretation object)
      {
        return createGlobalRelationInterpretationAdapter();
      }
      @Override
      public Adapter caseMultiplicityDefinition(MultiplicityDefinition object)
      {
        return createMultiplicityDefinitionAdapter();
      }
      @Override
      public Adapter caseBooleanTrue(BooleanTrue object)
      {
        return createBooleanTrueAdapter();
      }
      @Override
      public Adapter caseBooleanFalse(BooleanFalse object)
      {
        return createBooleanFalseAdapter();
      }
      @Override
      public Adapter caseTrue(True object)
      {
        return createTrueAdapter();
      }
      @Override
      public Adapter caseFalse(False object)
      {
        return createFalseAdapter();
      }
      @Override
      public Adapter caseUnknown(Unknown object)
      {
        return createUnknownAdapter();
      }
      @Override
      public Adapter caseError(org.eclipse.viatra.solver.language.solverLanguage.Error object)
      {
        return createErrorAdapter();
      }
      @Override
      public Adapter casePositive(Positive object)
      {
        return createPositiveAdapter();
      }
      @Override
      public Adapter caseNegative(Negative object)
      {
        return createNegativeAdapter();
      }
      @Override
      public Adapter caseReflexiveClosure(ReflexiveClosure object)
      {
        return createReflexiveClosureAdapter();
      }
      @Override
      public Adapter caseIrreflexiveClosure(IrreflexiveClosure object)
      {
        return createIrreflexiveClosureAdapter();
      }
      @Override
      public Adapter defaultCase(EObject object)
      {
        return createEObjectAdapter();
      }
    };

  /**
   * Creates an adapter for the <code>target</code>.
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @param target the object to adapt.
   * @return the adapter for the <code>target</code>.
   * @generated
   */
  @Override
  public Adapter createAdapter(Notifier target)
  {
    return modelSwitch.doSwitch((EObject)target);
  }


  /**
   * Creates a new adapter for an object of class '{@link org.eclipse.viatra.solver.language.solverLanguage.Problem <em>Problem</em>}'.
   * <!-- begin-user-doc -->
   * This default implementation returns null so that we can easily ignore cases;
   * it's useful to ignore a case when inheritance will catch all the cases anyway.
   * <!-- end-user-doc -->
   * @return the new adapter.
   * @see org.eclipse.viatra.solver.language.solverLanguage.Problem
   * @generated
   */
  public Adapter createProblemAdapter()
  {
    return null;
  }

  /**
   * Creates a new adapter for an object of class '{@link org.eclipse.viatra.solver.language.solverLanguage.Statement <em>Statement</em>}'.
   * <!-- begin-user-doc -->
   * This default implementation returns null so that we can easily ignore cases;
   * it's useful to ignore a case when inheritance will catch all the cases anyway.
   * <!-- end-user-doc -->
   * @return the new adapter.
   * @see org.eclipse.viatra.solver.language.solverLanguage.Statement
   * @generated
   */
  public Adapter createStatementAdapter()
  {
    return null;
  }

  /**
   * Creates a new adapter for an object of class '{@link org.eclipse.viatra.solver.language.solverLanguage.BooleanValue <em>Boolean Value</em>}'.
   * <!-- begin-user-doc -->
   * This default implementation returns null so that we can easily ignore cases;
   * it's useful to ignore a case when inheritance will catch all the cases anyway.
   * <!-- end-user-doc -->
   * @return the new adapter.
   * @see org.eclipse.viatra.solver.language.solverLanguage.BooleanValue
   * @generated
   */
  public Adapter createBooleanValueAdapter()
  {
    return null;
  }

  /**
   * Creates a new adapter for an object of class '{@link org.eclipse.viatra.solver.language.solverLanguage.TruthValue <em>Truth Value</em>}'.
   * <!-- begin-user-doc -->
   * This default implementation returns null so that we can easily ignore cases;
   * it's useful to ignore a case when inheritance will catch all the cases anyway.
   * <!-- end-user-doc -->
   * @return the new adapter.
   * @see org.eclipse.viatra.solver.language.solverLanguage.TruthValue
   * @generated
   */
  public Adapter createTruthValueAdapter()
  {
    return null;
  }

  /**
   * Creates a new adapter for an object of class '{@link org.eclipse.viatra.solver.language.solverLanguage.Interpretation <em>Interpretation</em>}'.
   * <!-- begin-user-doc -->
   * This default implementation returns null so that we can easily ignore cases;
   * it's useful to ignore a case when inheritance will catch all the cases anyway.
   * <!-- end-user-doc -->
   * @return the new adapter.
   * @see org.eclipse.viatra.solver.language.solverLanguage.Interpretation
   * @generated
   */
  public Adapter createInterpretationAdapter()
  {
    return null;
  }

  /**
   * Creates a new adapter for an object of class '{@link org.eclipse.viatra.solver.language.solverLanguage.BasicInterpretation <em>Basic Interpretation</em>}'.
   * <!-- begin-user-doc -->
   * This default implementation returns null so that we can easily ignore cases;
   * it's useful to ignore a case when inheritance will catch all the cases anyway.
   * <!-- end-user-doc -->
   * @return the new adapter.
   * @see org.eclipse.viatra.solver.language.solverLanguage.BasicInterpretation
   * @generated
   */
  public Adapter createBasicInterpretationAdapter()
  {
    return null;
  }

  /**
   * Creates a new adapter for an object of class '{@link org.eclipse.viatra.solver.language.solverLanguage.Symbol <em>Symbol</em>}'.
   * <!-- begin-user-doc -->
   * This default implementation returns null so that we can easily ignore cases;
   * it's useful to ignore a case when inheritance will catch all the cases anyway.
   * <!-- end-user-doc -->
   * @return the new adapter.
   * @see org.eclipse.viatra.solver.language.solverLanguage.Symbol
   * @generated
   */
  public Adapter createSymbolAdapter()
  {
    return null;
  }

  /**
   * Creates a new adapter for an object of class '{@link org.eclipse.viatra.solver.language.solverLanguage.ModelSymbol <em>Model Symbol</em>}'.
   * <!-- begin-user-doc -->
   * This default implementation returns null so that we can easily ignore cases;
   * it's useful to ignore a case when inheritance will catch all the cases anyway.
   * <!-- end-user-doc -->
   * @return the new adapter.
   * @see org.eclipse.viatra.solver.language.solverLanguage.ModelSymbol
   * @generated
   */
  public Adapter createModelSymbolAdapter()
  {
    return null;
  }

  /**
   * Creates a new adapter for an object of class '{@link org.eclipse.viatra.solver.language.solverLanguage.PartialitySymbol <em>Partiality Symbol</em>}'.
   * <!-- begin-user-doc -->
   * This default implementation returns null so that we can easily ignore cases;
   * it's useful to ignore a case when inheritance will catch all the cases anyway.
   * <!-- end-user-doc -->
   * @return the new adapter.
   * @see org.eclipse.viatra.solver.language.solverLanguage.PartialitySymbol
   * @generated
   */
  public Adapter createPartialitySymbolAdapter()
  {
    return null;
  }

  /**
   * Creates a new adapter for an object of class '{@link org.eclipse.viatra.solver.language.solverLanguage.ExistSymbol <em>Exist Symbol</em>}'.
   * <!-- begin-user-doc -->
   * This default implementation returns null so that we can easily ignore cases;
   * it's useful to ignore a case when inheritance will catch all the cases anyway.
   * <!-- end-user-doc -->
   * @return the new adapter.
   * @see org.eclipse.viatra.solver.language.solverLanguage.ExistSymbol
   * @generated
   */
  public Adapter createExistSymbolAdapter()
  {
    return null;
  }

  /**
   * Creates a new adapter for an object of class '{@link org.eclipse.viatra.solver.language.solverLanguage.EqualsSymbol <em>Equals Symbol</em>}'.
   * <!-- begin-user-doc -->
   * This default implementation returns null so that we can easily ignore cases;
   * it's useful to ignore a case when inheritance will catch all the cases anyway.
   * <!-- end-user-doc -->
   * @return the new adapter.
   * @see org.eclipse.viatra.solver.language.solverLanguage.EqualsSymbol
   * @generated
   */
  public Adapter createEqualsSymbolAdapter()
  {
    return null;
  }

  /**
   * Creates a new adapter for an object of class '{@link org.eclipse.viatra.solver.language.solverLanguage.DataSymbol <em>Data Symbol</em>}'.
   * <!-- begin-user-doc -->
   * This default implementation returns null so that we can easily ignore cases;
   * it's useful to ignore a case when inheritance will catch all the cases anyway.
   * <!-- end-user-doc -->
   * @return the new adapter.
   * @see org.eclipse.viatra.solver.language.solverLanguage.DataSymbol
   * @generated
   */
  public Adapter createDataSymbolAdapter()
  {
    return null;
  }

  /**
   * Creates a new adapter for an object of class '{@link org.eclipse.viatra.solver.language.solverLanguage.BooleanSymbol <em>Boolean Symbol</em>}'.
   * <!-- begin-user-doc -->
   * This default implementation returns null so that we can easily ignore cases;
   * it's useful to ignore a case when inheritance will catch all the cases anyway.
   * <!-- end-user-doc -->
   * @return the new adapter.
   * @see org.eclipse.viatra.solver.language.solverLanguage.BooleanSymbol
   * @generated
   */
  public Adapter createBooleanSymbolAdapter()
  {
    return null;
  }

  /**
   * Creates a new adapter for an object of class '{@link org.eclipse.viatra.solver.language.solverLanguage.IntegerSymbol <em>Integer Symbol</em>}'.
   * <!-- begin-user-doc -->
   * This default implementation returns null so that we can easily ignore cases;
   * it's useful to ignore a case when inheritance will catch all the cases anyway.
   * <!-- end-user-doc -->
   * @return the new adapter.
   * @see org.eclipse.viatra.solver.language.solverLanguage.IntegerSymbol
   * @generated
   */
  public Adapter createIntegerSymbolAdapter()
  {
    return null;
  }

  /**
   * Creates a new adapter for an object of class '{@link org.eclipse.viatra.solver.language.solverLanguage.RealSymbol <em>Real Symbol</em>}'.
   * <!-- begin-user-doc -->
   * This default implementation returns null so that we can easily ignore cases;
   * it's useful to ignore a case when inheritance will catch all the cases anyway.
   * <!-- end-user-doc -->
   * @return the new adapter.
   * @see org.eclipse.viatra.solver.language.solverLanguage.RealSymbol
   * @generated
   */
  public Adapter createRealSymbolAdapter()
  {
    return null;
  }

  /**
   * Creates a new adapter for an object of class '{@link org.eclipse.viatra.solver.language.solverLanguage.StringSymbol <em>String Symbol</em>}'.
   * <!-- begin-user-doc -->
   * This default implementation returns null so that we can easily ignore cases;
   * it's useful to ignore a case when inheritance will catch all the cases anyway.
   * <!-- end-user-doc -->
   * @return the new adapter.
   * @see org.eclipse.viatra.solver.language.solverLanguage.StringSymbol
   * @generated
   */
  public Adapter createStringSymbolAdapter()
  {
    return null;
  }

  /**
   * Creates a new adapter for an object of class '{@link org.eclipse.viatra.solver.language.solverLanguage.ComplexObject <em>Complex Object</em>}'.
   * <!-- begin-user-doc -->
   * This default implementation returns null so that we can easily ignore cases;
   * it's useful to ignore a case when inheritance will catch all the cases anyway.
   * <!-- end-user-doc -->
   * @return the new adapter.
   * @see org.eclipse.viatra.solver.language.solverLanguage.ComplexObject
   * @generated
   */
  public Adapter createComplexObjectAdapter()
  {
    return null;
  }

  /**
   * Creates a new adapter for an object of class '{@link org.eclipse.viatra.solver.language.solverLanguage.Object <em>Object</em>}'.
   * <!-- begin-user-doc -->
   * This default implementation returns null so that we can easily ignore cases;
   * it's useful to ignore a case when inheritance will catch all the cases anyway.
   * <!-- end-user-doc -->
   * @return the new adapter.
   * @see org.eclipse.viatra.solver.language.solverLanguage.Object
   * @generated
   */
  public Adapter createObjectAdapter()
  {
    return null;
  }

  /**
   * Creates a new adapter for an object of class '{@link org.eclipse.viatra.solver.language.solverLanguage.NamedObject <em>Named Object</em>}'.
   * <!-- begin-user-doc -->
   * This default implementation returns null so that we can easily ignore cases;
   * it's useful to ignore a case when inheritance will catch all the cases anyway.
   * <!-- end-user-doc -->
   * @return the new adapter.
   * @see org.eclipse.viatra.solver.language.solverLanguage.NamedObject
   * @generated
   */
  public Adapter createNamedObjectAdapter()
  {
    return null;
  }

  /**
   * Creates a new adapter for an object of class '{@link org.eclipse.viatra.solver.language.solverLanguage.UnnamedObject <em>Unnamed Object</em>}'.
   * <!-- begin-user-doc -->
   * This default implementation returns null so that we can easily ignore cases;
   * it's useful to ignore a case when inheritance will catch all the cases anyway.
   * <!-- end-user-doc -->
   * @return the new adapter.
   * @see org.eclipse.viatra.solver.language.solverLanguage.UnnamedObject
   * @generated
   */
  public Adapter createUnnamedObjectAdapter()
  {
    return null;
  }

  /**
   * Creates a new adapter for an object of class '{@link org.eclipse.viatra.solver.language.solverLanguage.DataObject <em>Data Object</em>}'.
   * <!-- begin-user-doc -->
   * This default implementation returns null so that we can easily ignore cases;
   * it's useful to ignore a case when inheritance will catch all the cases anyway.
   * <!-- end-user-doc -->
   * @return the new adapter.
   * @see org.eclipse.viatra.solver.language.solverLanguage.DataObject
   * @generated
   */
  public Adapter createDataObjectAdapter()
  {
    return null;
  }

  /**
   * Creates a new adapter for an object of class '{@link org.eclipse.viatra.solver.language.solverLanguage.BooleanObject <em>Boolean Object</em>}'.
   * <!-- begin-user-doc -->
   * This default implementation returns null so that we can easily ignore cases;
   * it's useful to ignore a case when inheritance will catch all the cases anyway.
   * <!-- end-user-doc -->
   * @return the new adapter.
   * @see org.eclipse.viatra.solver.language.solverLanguage.BooleanObject
   * @generated
   */
  public Adapter createBooleanObjectAdapter()
  {
    return null;
  }

  /**
   * Creates a new adapter for an object of class '{@link org.eclipse.viatra.solver.language.solverLanguage.IntObject <em>Int Object</em>}'.
   * <!-- begin-user-doc -->
   * This default implementation returns null so that we can easily ignore cases;
   * it's useful to ignore a case when inheritance will catch all the cases anyway.
   * <!-- end-user-doc -->
   * @return the new adapter.
   * @see org.eclipse.viatra.solver.language.solverLanguage.IntObject
   * @generated
   */
  public Adapter createIntObjectAdapter()
  {
    return null;
  }

  /**
   * Creates a new adapter for an object of class '{@link org.eclipse.viatra.solver.language.solverLanguage.RealObject <em>Real Object</em>}'.
   * <!-- begin-user-doc -->
   * This default implementation returns null so that we can easily ignore cases;
   * it's useful to ignore a case when inheritance will catch all the cases anyway.
   * <!-- end-user-doc -->
   * @return the new adapter.
   * @see org.eclipse.viatra.solver.language.solverLanguage.RealObject
   * @generated
   */
  public Adapter createRealObjectAdapter()
  {
    return null;
  }

  /**
   * Creates a new adapter for an object of class '{@link org.eclipse.viatra.solver.language.solverLanguage.StringObject <em>String Object</em>}'.
   * <!-- begin-user-doc -->
   * This default implementation returns null so that we can easily ignore cases;
   * it's useful to ignore a case when inheritance will catch all the cases anyway.
   * <!-- end-user-doc -->
   * @return the new adapter.
   * @see org.eclipse.viatra.solver.language.solverLanguage.StringObject
   * @generated
   */
  public Adapter createStringObjectAdapter()
  {
    return null;
  }

  /**
   * Creates a new adapter for an object of class '{@link org.eclipse.viatra.solver.language.solverLanguage.Predicate <em>Predicate</em>}'.
   * <!-- begin-user-doc -->
   * This default implementation returns null so that we can easily ignore cases;
   * it's useful to ignore a case when inheritance will catch all the cases anyway.
   * <!-- end-user-doc -->
   * @return the new adapter.
   * @see org.eclipse.viatra.solver.language.solverLanguage.Predicate
   * @generated
   */
  public Adapter createPredicateAdapter()
  {
    return null;
  }

  /**
   * Creates a new adapter for an object of class '{@link org.eclipse.viatra.solver.language.solverLanguage.Parameter <em>Parameter</em>}'.
   * <!-- begin-user-doc -->
   * This default implementation returns null so that we can easily ignore cases;
   * it's useful to ignore a case when inheritance will catch all the cases anyway.
   * <!-- end-user-doc -->
   * @return the new adapter.
   * @see org.eclipse.viatra.solver.language.solverLanguage.Parameter
   * @generated
   */
  public Adapter createParameterAdapter()
  {
    return null;
  }

  /**
   * Creates a new adapter for an object of class '{@link org.eclipse.viatra.solver.language.solverLanguage.PatternBody <em>Pattern Body</em>}'.
   * <!-- begin-user-doc -->
   * This default implementation returns null so that we can easily ignore cases;
   * it's useful to ignore a case when inheritance will catch all the cases anyway.
   * <!-- end-user-doc -->
   * @return the new adapter.
   * @see org.eclipse.viatra.solver.language.solverLanguage.PatternBody
   * @generated
   */
  public Adapter createPatternBodyAdapter()
  {
    return null;
  }

  /**
   * Creates a new adapter for an object of class '{@link org.eclipse.viatra.solver.language.solverLanguage.Polarity <em>Polarity</em>}'.
   * <!-- begin-user-doc -->
   * This default implementation returns null so that we can easily ignore cases;
   * it's useful to ignore a case when inheritance will catch all the cases anyway.
   * <!-- end-user-doc -->
   * @return the new adapter.
   * @see org.eclipse.viatra.solver.language.solverLanguage.Polarity
   * @generated
   */
  public Adapter createPolarityAdapter()
  {
    return null;
  }

  /**
   * Creates a new adapter for an object of class '{@link org.eclipse.viatra.solver.language.solverLanguage.Constraint <em>Constraint</em>}'.
   * <!-- begin-user-doc -->
   * This default implementation returns null so that we can easily ignore cases;
   * it's useful to ignore a case when inheritance will catch all the cases anyway.
   * <!-- end-user-doc -->
   * @return the new adapter.
   * @see org.eclipse.viatra.solver.language.solverLanguage.Constraint
   * @generated
   */
  public Adapter createConstraintAdapter()
  {
    return null;
  }

  /**
   * Creates a new adapter for an object of class '{@link org.eclipse.viatra.solver.language.solverLanguage.ClosureType <em>Closure Type</em>}'.
   * <!-- begin-user-doc -->
   * This default implementation returns null so that we can easily ignore cases;
   * it's useful to ignore a case when inheritance will catch all the cases anyway.
   * <!-- end-user-doc -->
   * @return the new adapter.
   * @see org.eclipse.viatra.solver.language.solverLanguage.ClosureType
   * @generated
   */
  public Adapter createClosureTypeAdapter()
  {
    return null;
  }

  /**
   * Creates a new adapter for an object of class '{@link org.eclipse.viatra.solver.language.solverLanguage.Literal <em>Literal</em>}'.
   * <!-- begin-user-doc -->
   * This default implementation returns null so that we can easily ignore cases;
   * it's useful to ignore a case when inheritance will catch all the cases anyway.
   * <!-- end-user-doc -->
   * @return the new adapter.
   * @see org.eclipse.viatra.solver.language.solverLanguage.Literal
   * @generated
   */
  public Adapter createLiteralAdapter()
  {
    return null;
  }

  /**
   * Creates a new adapter for an object of class '{@link org.eclipse.viatra.solver.language.solverLanguage.Variable <em>Variable</em>}'.
   * <!-- begin-user-doc -->
   * This default implementation returns null so that we can easily ignore cases;
   * it's useful to ignore a case when inheritance will catch all the cases anyway.
   * <!-- end-user-doc -->
   * @return the new adapter.
   * @see org.eclipse.viatra.solver.language.solverLanguage.Variable
   * @generated
   */
  public Adapter createVariableAdapter()
  {
    return null;
  }

  /**
   * Creates a new adapter for an object of class '{@link org.eclipse.viatra.solver.language.solverLanguage.AllInstances <em>All Instances</em>}'.
   * <!-- begin-user-doc -->
   * This default implementation returns null so that we can easily ignore cases;
   * it's useful to ignore a case when inheritance will catch all the cases anyway.
   * <!-- end-user-doc -->
   * @return the new adapter.
   * @see org.eclipse.viatra.solver.language.solverLanguage.AllInstances
   * @generated
   */
  public Adapter createAllInstancesAdapter()
  {
    return null;
  }

  /**
   * Creates a new adapter for an object of class '{@link org.eclipse.viatra.solver.language.solverLanguage.AllObjects <em>All Objects</em>}'.
   * <!-- begin-user-doc -->
   * This default implementation returns null so that we can easily ignore cases;
   * it's useful to ignore a case when inheritance will catch all the cases anyway.
   * <!-- end-user-doc -->
   * @return the new adapter.
   * @see org.eclipse.viatra.solver.language.solverLanguage.AllObjects
   * @generated
   */
  public Adapter createAllObjectsAdapter()
  {
    return null;
  }

  /**
   * Creates a new adapter for an object of class '{@link org.eclipse.viatra.solver.language.solverLanguage.DefaultInterpretation <em>Default Interpretation</em>}'.
   * <!-- begin-user-doc -->
   * This default implementation returns null so that we can easily ignore cases;
   * it's useful to ignore a case when inheritance will catch all the cases anyway.
   * <!-- end-user-doc -->
   * @return the new adapter.
   * @see org.eclipse.viatra.solver.language.solverLanguage.DefaultInterpretation
   * @generated
   */
  public Adapter createDefaultInterpretationAdapter()
  {
    return null;
  }

  /**
   * Creates a new adapter for an object of class '{@link org.eclipse.viatra.solver.language.solverLanguage.CDInterpretation <em>CD Interpretation</em>}'.
   * <!-- begin-user-doc -->
   * This default implementation returns null so that we can easily ignore cases;
   * it's useful to ignore a case when inheritance will catch all the cases anyway.
   * <!-- end-user-doc -->
   * @return the new adapter.
   * @see org.eclipse.viatra.solver.language.solverLanguage.CDInterpretation
   * @generated
   */
  public Adapter createCDInterpretationAdapter()
  {
    return null;
  }

  /**
   * Creates a new adapter for an object of class '{@link org.eclipse.viatra.solver.language.solverLanguage.ClassInterpretation <em>Class Interpretation</em>}'.
   * <!-- begin-user-doc -->
   * This default implementation returns null so that we can easily ignore cases;
   * it's useful to ignore a case when inheritance will catch all the cases anyway.
   * <!-- end-user-doc -->
   * @return the new adapter.
   * @see org.eclipse.viatra.solver.language.solverLanguage.ClassInterpretation
   * @generated
   */
  public Adapter createClassInterpretationAdapter()
  {
    return null;
  }

  /**
   * Creates a new adapter for an object of class '{@link org.eclipse.viatra.solver.language.solverLanguage.EnumInterpretation <em>Enum Interpretation</em>}'.
   * <!-- begin-user-doc -->
   * This default implementation returns null so that we can easily ignore cases;
   * it's useful to ignore a case when inheritance will catch all the cases anyway.
   * <!-- end-user-doc -->
   * @return the new adapter.
   * @see org.eclipse.viatra.solver.language.solverLanguage.EnumInterpretation
   * @generated
   */
  public Adapter createEnumInterpretationAdapter()
  {
    return null;
  }

  /**
   * Creates a new adapter for an object of class '{@link org.eclipse.viatra.solver.language.solverLanguage.FieldRelationInterpretation <em>Field Relation Interpretation</em>}'.
   * <!-- begin-user-doc -->
   * This default implementation returns null so that we can easily ignore cases;
   * it's useful to ignore a case when inheritance will catch all the cases anyway.
   * <!-- end-user-doc -->
   * @return the new adapter.
   * @see org.eclipse.viatra.solver.language.solverLanguage.FieldRelationInterpretation
   * @generated
   */
  public Adapter createFieldRelationInterpretationAdapter()
  {
    return null;
  }

  /**
   * Creates a new adapter for an object of class '{@link org.eclipse.viatra.solver.language.solverLanguage.GlobalRelationInterpretation <em>Global Relation Interpretation</em>}'.
   * <!-- begin-user-doc -->
   * This default implementation returns null so that we can easily ignore cases;
   * it's useful to ignore a case when inheritance will catch all the cases anyway.
   * <!-- end-user-doc -->
   * @return the new adapter.
   * @see org.eclipse.viatra.solver.language.solverLanguage.GlobalRelationInterpretation
   * @generated
   */
  public Adapter createGlobalRelationInterpretationAdapter()
  {
    return null;
  }

  /**
   * Creates a new adapter for an object of class '{@link org.eclipse.viatra.solver.language.solverLanguage.MultiplicityDefinition <em>Multiplicity Definition</em>}'.
   * <!-- begin-user-doc -->
   * This default implementation returns null so that we can easily ignore cases;
   * it's useful to ignore a case when inheritance will catch all the cases anyway.
   * <!-- end-user-doc -->
   * @return the new adapter.
   * @see org.eclipse.viatra.solver.language.solverLanguage.MultiplicityDefinition
   * @generated
   */
  public Adapter createMultiplicityDefinitionAdapter()
  {
    return null;
  }

  /**
   * Creates a new adapter for an object of class '{@link org.eclipse.viatra.solver.language.solverLanguage.BooleanTrue <em>Boolean True</em>}'.
   * <!-- begin-user-doc -->
   * This default implementation returns null so that we can easily ignore cases;
   * it's useful to ignore a case when inheritance will catch all the cases anyway.
   * <!-- end-user-doc -->
   * @return the new adapter.
   * @see org.eclipse.viatra.solver.language.solverLanguage.BooleanTrue
   * @generated
   */
  public Adapter createBooleanTrueAdapter()
  {
    return null;
  }

  /**
   * Creates a new adapter for an object of class '{@link org.eclipse.viatra.solver.language.solverLanguage.BooleanFalse <em>Boolean False</em>}'.
   * <!-- begin-user-doc -->
   * This default implementation returns null so that we can easily ignore cases;
   * it's useful to ignore a case when inheritance will catch all the cases anyway.
   * <!-- end-user-doc -->
   * @return the new adapter.
   * @see org.eclipse.viatra.solver.language.solverLanguage.BooleanFalse
   * @generated
   */
  public Adapter createBooleanFalseAdapter()
  {
    return null;
  }

  /**
   * Creates a new adapter for an object of class '{@link org.eclipse.viatra.solver.language.solverLanguage.True <em>True</em>}'.
   * <!-- begin-user-doc -->
   * This default implementation returns null so that we can easily ignore cases;
   * it's useful to ignore a case when inheritance will catch all the cases anyway.
   * <!-- end-user-doc -->
   * @return the new adapter.
   * @see org.eclipse.viatra.solver.language.solverLanguage.True
   * @generated
   */
  public Adapter createTrueAdapter()
  {
    return null;
  }

  /**
   * Creates a new adapter for an object of class '{@link org.eclipse.viatra.solver.language.solverLanguage.False <em>False</em>}'.
   * <!-- begin-user-doc -->
   * This default implementation returns null so that we can easily ignore cases;
   * it's useful to ignore a case when inheritance will catch all the cases anyway.
   * <!-- end-user-doc -->
   * @return the new adapter.
   * @see org.eclipse.viatra.solver.language.solverLanguage.False
   * @generated
   */
  public Adapter createFalseAdapter()
  {
    return null;
  }

  /**
   * Creates a new adapter for an object of class '{@link org.eclipse.viatra.solver.language.solverLanguage.Unknown <em>Unknown</em>}'.
   * <!-- begin-user-doc -->
   * This default implementation returns null so that we can easily ignore cases;
   * it's useful to ignore a case when inheritance will catch all the cases anyway.
   * <!-- end-user-doc -->
   * @return the new adapter.
   * @see org.eclipse.viatra.solver.language.solverLanguage.Unknown
   * @generated
   */
  public Adapter createUnknownAdapter()
  {
    return null;
  }

  /**
   * Creates a new adapter for an object of class '{@link org.eclipse.viatra.solver.language.solverLanguage.Error <em>Error</em>}'.
   * <!-- begin-user-doc -->
   * This default implementation returns null so that we can easily ignore cases;
   * it's useful to ignore a case when inheritance will catch all the cases anyway.
   * <!-- end-user-doc -->
   * @return the new adapter.
   * @see org.eclipse.viatra.solver.language.solverLanguage.Error
   * @generated
   */
  public Adapter createErrorAdapter()
  {
    return null;
  }

  /**
   * Creates a new adapter for an object of class '{@link org.eclipse.viatra.solver.language.solverLanguage.Positive <em>Positive</em>}'.
   * <!-- begin-user-doc -->
   * This default implementation returns null so that we can easily ignore cases;
   * it's useful to ignore a case when inheritance will catch all the cases anyway.
   * <!-- end-user-doc -->
   * @return the new adapter.
   * @see org.eclipse.viatra.solver.language.solverLanguage.Positive
   * @generated
   */
  public Adapter createPositiveAdapter()
  {
    return null;
  }

  /**
   * Creates a new adapter for an object of class '{@link org.eclipse.viatra.solver.language.solverLanguage.Negative <em>Negative</em>}'.
   * <!-- begin-user-doc -->
   * This default implementation returns null so that we can easily ignore cases;
   * it's useful to ignore a case when inheritance will catch all the cases anyway.
   * <!-- end-user-doc -->
   * @return the new adapter.
   * @see org.eclipse.viatra.solver.language.solverLanguage.Negative
   * @generated
   */
  public Adapter createNegativeAdapter()
  {
    return null;
  }

  /**
   * Creates a new adapter for an object of class '{@link org.eclipse.viatra.solver.language.solverLanguage.ReflexiveClosure <em>Reflexive Closure</em>}'.
   * <!-- begin-user-doc -->
   * This default implementation returns null so that we can easily ignore cases;
   * it's useful to ignore a case when inheritance will catch all the cases anyway.
   * <!-- end-user-doc -->
   * @return the new adapter.
   * @see org.eclipse.viatra.solver.language.solverLanguage.ReflexiveClosure
   * @generated
   */
  public Adapter createReflexiveClosureAdapter()
  {
    return null;
  }

  /**
   * Creates a new adapter for an object of class '{@link org.eclipse.viatra.solver.language.solverLanguage.IrreflexiveClosure <em>Irreflexive Closure</em>}'.
   * <!-- begin-user-doc -->
   * This default implementation returns null so that we can easily ignore cases;
   * it's useful to ignore a case when inheritance will catch all the cases anyway.
   * <!-- end-user-doc -->
   * @return the new adapter.
   * @see org.eclipse.viatra.solver.language.solverLanguage.IrreflexiveClosure
   * @generated
   */
  public Adapter createIrreflexiveClosureAdapter()
  {
    return null;
  }

  /**
   * Creates a new adapter for the default case.
   * <!-- begin-user-doc -->
   * This default implementation returns null.
   * <!-- end-user-doc -->
   * @return the new adapter.
   * @generated
   */
  public Adapter createEObjectAdapter()
  {
    return null;
  }

} //SolverLanguageAdapterFactory
