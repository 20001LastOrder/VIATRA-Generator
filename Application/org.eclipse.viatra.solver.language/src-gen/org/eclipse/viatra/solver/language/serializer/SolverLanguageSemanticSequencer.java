/*
 * generated by Xtext 2.21.0
 */
package org.eclipse.viatra.solver.language.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.viatra.solver.language.services.SolverLanguageGrammarAccess;
import org.eclipse.viatra.solver.language.solverLanguage.Aggregation;
import org.eclipse.viatra.solver.language.solverLanguage.ArgumentList;
import org.eclipse.viatra.solver.language.solverLanguage.BinaryExpression;
import org.eclipse.viatra.solver.language.solverLanguage.BoundedMultiplicity;
import org.eclipse.viatra.solver.language.solverLanguage.BoundedScopeDefinition;
import org.eclipse.viatra.solver.language.solverLanguage.Call;
import org.eclipse.viatra.solver.language.solverLanguage.Case;
import org.eclipse.viatra.solver.language.solverLanguage.CastExpression;
import org.eclipse.viatra.solver.language.solverLanguage.ClassDefinition;
import org.eclipse.viatra.solver.language.solverLanguage.Comparison;
import org.eclipse.viatra.solver.language.solverLanguage.Conjunction;
import org.eclipse.viatra.solver.language.solverLanguage.DefaultDefinition;
import org.eclipse.viatra.solver.language.solverLanguage.Disjunction;
import org.eclipse.viatra.solver.language.solverLanguage.EmptyIntervalLiteral;
import org.eclipse.viatra.solver.language.solverLanguage.ExactMultiplicity;
import org.eclipse.viatra.solver.language.solverLanguage.ExactScopeDefinition;
import org.eclipse.viatra.solver.language.solverLanguage.ExpressionArgument;
import org.eclipse.viatra.solver.language.solverLanguage.ExternAggregatorDefinition;
import org.eclipse.viatra.solver.language.solverLanguage.ExternDatatypeDefinition;
import org.eclipse.viatra.solver.language.solverLanguage.ExternMetricDefinition;
import org.eclipse.viatra.solver.language.solverLanguage.ExternPredicateDefinition;
import org.eclipse.viatra.solver.language.solverLanguage.IfElse;
import org.eclipse.viatra.solver.language.solverLanguage.InfinityLiteral;
import org.eclipse.viatra.solver.language.solverLanguage.Interpretation;
import org.eclipse.viatra.solver.language.solverLanguage.Interval;
import org.eclipse.viatra.solver.language.solverLanguage.Let;
import org.eclipse.viatra.solver.language.solverLanguage.LetBinding;
import org.eclipse.viatra.solver.language.solverLanguage.LocalVariables;
import org.eclipse.viatra.solver.language.solverLanguage.LogicLiteral;
import org.eclipse.viatra.solver.language.solverLanguage.LowerBoundedScopeDefinition;
import org.eclipse.viatra.solver.language.solverLanguage.ManyMultiplicity;
import org.eclipse.viatra.solver.language.solverLanguage.MemberDefinition;
import org.eclipse.viatra.solver.language.solverLanguage.MetricDefinition;
import org.eclipse.viatra.solver.language.solverLanguage.NumericLiteral;
import org.eclipse.viatra.solver.language.solverLanguage.ObjectiveDefinition;
import org.eclipse.viatra.solver.language.solverLanguage.PredicateDefinition;
import org.eclipse.viatra.solver.language.solverLanguage.Problem;
import org.eclipse.viatra.solver.language.solverLanguage.QuantifiedExpression;
import org.eclipse.viatra.solver.language.solverLanguage.Reference;
import org.eclipse.viatra.solver.language.solverLanguage.SolverLanguagePackage;
import org.eclipse.viatra.solver.language.solverLanguage.StarArgument;
import org.eclipse.viatra.solver.language.solverLanguage.StringLiteral;
import org.eclipse.viatra.solver.language.solverLanguage.Switch;
import org.eclipse.viatra.solver.language.solverLanguage.TypedArgument;
import org.eclipse.viatra.solver.language.solverLanguage.TypedStarArgument;
import org.eclipse.viatra.solver.language.solverLanguage.UnaryExpression;
import org.eclipse.viatra.solver.language.solverLanguage.UnnamedErrorPrediateDefinition;
import org.eclipse.viatra.solver.language.solverLanguage.Variable;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class SolverLanguageSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private SolverLanguageGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == SolverLanguagePackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case SolverLanguagePackage.AGGREGATION:
				sequence_Aggregation(context, (Aggregation) semanticObject); 
				return; 
			case SolverLanguagePackage.ARGUMENT_LIST:
				sequence_ArgumentList(context, (ArgumentList) semanticObject); 
				return; 
			case SolverLanguagePackage.BINARY_EXPRESSION:
				sequence_AdditiveExpression_ExponentialExpression_ImplicationExpression_MultiplicativeExpression(context, (BinaryExpression) semanticObject); 
				return; 
			case SolverLanguagePackage.BOUNDED_MULTIPLICITY:
				sequence_BoundedMultiplicity(context, (BoundedMultiplicity) semanticObject); 
				return; 
			case SolverLanguagePackage.BOUNDED_SCOPE_DEFINITION:
				sequence_BoundedScopeDefinition(context, (BoundedScopeDefinition) semanticObject); 
				return; 
			case SolverLanguagePackage.CALL:
				sequence_Call(context, (Call) semanticObject); 
				return; 
			case SolverLanguagePackage.CASE:
				if (rule == grammarAccess.getCaseRule()) {
					sequence_Case(context, (Case) semanticObject); 
					return; 
				}
				else if (action == grammarAccess.getDisjunctiveExpressionAccess().getSwitchCasesAction_1_1_3()) {
					sequence_DisjunctiveExpression_Switch_1_1_3(context, (Case) semanticObject); 
					return; 
				}
				else break;
			case SolverLanguagePackage.CAST_EXPRESSION:
				sequence_CastExpression(context, (CastExpression) semanticObject); 
				return; 
			case SolverLanguagePackage.CLASS_DEFINITION:
				sequence_ClassDefinition(context, (ClassDefinition) semanticObject); 
				return; 
			case SolverLanguagePackage.COMPARISON:
				sequence_ComparisonExpression(context, (Comparison) semanticObject); 
				return; 
			case SolverLanguagePackage.CONJUNCTION:
				sequence_ConjunctiveExpression(context, (Conjunction) semanticObject); 
				return; 
			case SolverLanguagePackage.DEFAULT_DEFINITION:
				sequence_DefaultDefinition(context, (DefaultDefinition) semanticObject); 
				return; 
			case SolverLanguagePackage.DISJUNCTION:
				sequence_DisjunctiveExpression(context, (Disjunction) semanticObject); 
				return; 
			case SolverLanguagePackage.EMPTY_INTERVAL_LITERAL:
				sequence_EmptyIntervalLiteral(context, (EmptyIntervalLiteral) semanticObject); 
				return; 
			case SolverLanguagePackage.EXACT_MULTIPLICITY:
				sequence_ExactMultiplicity(context, (ExactMultiplicity) semanticObject); 
				return; 
			case SolverLanguagePackage.EXACT_SCOPE_DEFINITION:
				sequence_ExactScopeDefinition(context, (ExactScopeDefinition) semanticObject); 
				return; 
			case SolverLanguagePackage.EXPRESSION_ARGUMENT:
				sequence_ExpressionArgument(context, (ExpressionArgument) semanticObject); 
				return; 
			case SolverLanguagePackage.EXTERN_AGGREGATOR_DEFINITION:
				sequence_ExternAggregatorDefinition(context, (ExternAggregatorDefinition) semanticObject); 
				return; 
			case SolverLanguagePackage.EXTERN_DATATYPE_DEFINITION:
				sequence_ExternDatatypeDefinition(context, (ExternDatatypeDefinition) semanticObject); 
				return; 
			case SolverLanguagePackage.EXTERN_METRIC_DEFINITION:
				sequence_ExternMetricDefinition(context, (ExternMetricDefinition) semanticObject); 
				return; 
			case SolverLanguagePackage.EXTERN_PREDICATE_DEFINITION:
				sequence_ExternPredicateDefinition(context, (ExternPredicateDefinition) semanticObject); 
				return; 
			case SolverLanguagePackage.IF_ELSE:
				sequence_IfElse(context, (IfElse) semanticObject); 
				return; 
			case SolverLanguagePackage.INFINITY_LITERAL:
				sequence_InfinityLiteral(context, (InfinityLiteral) semanticObject); 
				return; 
			case SolverLanguagePackage.INTERPRETATION:
				sequence_AssertionOrDefinition(context, (Interpretation) semanticObject); 
				return; 
			case SolverLanguagePackage.INTERVAL:
				sequence_Interval(context, (Interval) semanticObject); 
				return; 
			case SolverLanguagePackage.LET:
				sequence_Let(context, (Let) semanticObject); 
				return; 
			case SolverLanguagePackage.LET_BINDING:
				sequence_LetBinding(context, (LetBinding) semanticObject); 
				return; 
			case SolverLanguagePackage.LOCAL_VARIABLES:
				sequence_LocalVariables(context, (LocalVariables) semanticObject); 
				return; 
			case SolverLanguagePackage.LOGIC_LITERAL:
				sequence_LogicLiteral(context, (LogicLiteral) semanticObject); 
				return; 
			case SolverLanguagePackage.LOWER_BOUNDED_SCOPE_DEFINITION:
				sequence_LowerBoundedScopeDefinition(context, (LowerBoundedScopeDefinition) semanticObject); 
				return; 
			case SolverLanguagePackage.MANY_MULTIPLICITY:
				sequence_ManyMultiplicity(context, (ManyMultiplicity) semanticObject); 
				return; 
			case SolverLanguagePackage.MEMBER_DEFINITION:
				sequence_MemberDefinition(context, (MemberDefinition) semanticObject); 
				return; 
			case SolverLanguagePackage.METRIC_DEFINITION:
				if (rule == grammarAccess.getAssertionOrDefinitionRule()) {
					sequence_AssertionOrDefinition(context, (MetricDefinition) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getStatementRule()) {
					sequence_AssertionOrDefinition_MetricDefinition(context, (MetricDefinition) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getMetricDefinitionRule()) {
					sequence_MetricDefinition(context, (MetricDefinition) semanticObject); 
					return; 
				}
				else break;
			case SolverLanguagePackage.NUMERIC_LITERAL:
				sequence_NumericLiteral(context, (NumericLiteral) semanticObject); 
				return; 
			case SolverLanguagePackage.OBJECTIVE_DEFINITION:
				sequence_ObjectiveDefinition(context, (ObjectiveDefinition) semanticObject); 
				return; 
			case SolverLanguagePackage.PREDICATE_DEFINITION:
				if (rule == grammarAccess.getAssertionOrDefinitionRule()) {
					sequence_AssertionOrDefinition(context, (PredicateDefinition) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getStatementRule()) {
					sequence_AssertionOrDefinition_PredicateDefinition(context, (PredicateDefinition) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getPredicateDefinitionRule()) {
					sequence_PredicateDefinition(context, (PredicateDefinition) semanticObject); 
					return; 
				}
				else break;
			case SolverLanguagePackage.PROBLEM:
				sequence_Problem(context, (Problem) semanticObject); 
				return; 
			case SolverLanguagePackage.QUANTIFIED_EXPRESSION:
				sequence_QuantifiedExpression(context, (QuantifiedExpression) semanticObject); 
				return; 
			case SolverLanguagePackage.REFERENCE:
				sequence_Reference(context, (Reference) semanticObject); 
				return; 
			case SolverLanguagePackage.STAR_ARGUMENT:
				sequence_StarArgument(context, (StarArgument) semanticObject); 
				return; 
			case SolverLanguagePackage.STRING_LITERAL:
				sequence_StringLiteral(context, (StringLiteral) semanticObject); 
				return; 
			case SolverLanguagePackage.SWITCH:
				sequence_DisjunctiveExpression(context, (Switch) semanticObject); 
				return; 
			case SolverLanguagePackage.TYPED_ARGUMENT:
				sequence_TypedArgument(context, (TypedArgument) semanticObject); 
				return; 
			case SolverLanguagePackage.TYPED_STAR_ARGUMENT:
				sequence_TypedStarArgument(context, (TypedStarArgument) semanticObject); 
				return; 
			case SolverLanguagePackage.UNARY_EXPRESSION:
				sequence_UnaryExpression(context, (UnaryExpression) semanticObject); 
				return; 
			case SolverLanguagePackage.UNNAMED_ERROR_PREDIATE_DEFINITION:
				sequence_UnnamedErrorPrediateDefinition(context, (UnnamedErrorPrediateDefinition) semanticObject); 
				return; 
			case SolverLanguagePackage.VARIABLE:
				sequence_Variable(context, (Variable) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Statement returns BinaryExpression
	 *     AssertionOrDefinition returns BinaryExpression
	 *     AssertionOrDefinition.Interpretation_1_0_0 returns BinaryExpression
	 *     AssertionOrDefinition.PredicateDefinition_1_1_0 returns BinaryExpression
	 *     AssertionOrDefinition.MetricDefinition_1_2_0 returns BinaryExpression
	 *     Expression returns BinaryExpression
	 *     ImplicationExpression returns BinaryExpression
	 *     ImplicationExpression.BinaryExpression_1_0 returns BinaryExpression
	 *     DisjunctiveExpression returns BinaryExpression
	 *     DisjunctiveExpression.Disjunction_1_0_0 returns BinaryExpression
	 *     DisjunctiveExpression.Case_1_1_0 returns BinaryExpression
	 *     ConjunctiveExpression returns BinaryExpression
	 *     ConjunctiveExpression.Conjunction_1_0 returns BinaryExpression
	 *     ComparisonExpression returns BinaryExpression
	 *     ComparisonExpression.Comparison_1_0 returns BinaryExpression
	 *     AdditiveExpression returns BinaryExpression
	 *     AdditiveExpression.BinaryExpression_1_0 returns BinaryExpression
	 *     MultiplicativeExpression returns BinaryExpression
	 *     MultiplicativeExpression.BinaryExpression_1_0 returns BinaryExpression
	 *     ExponentialExpression returns BinaryExpression
	 *     ExponentialExpression.BinaryExpression_1_0 returns BinaryExpression
	 *     CastExpression returns BinaryExpression
	 *     CastExpression.CastExpression_1_0 returns BinaryExpression
	 *     UnaryExpression returns BinaryExpression
	 *     AggregationExpression returns BinaryExpression
	 *     AtomicExpression returns BinaryExpression
	 *
	 * Constraint:
	 *     (
	 *         (left=ImplicationExpression_BinaryExpression_1_0 op=ImplicationOperator right=ImplicationExpression) | 
	 *         (left=AdditiveExpression_BinaryExpression_1_0 op=AdditiveBinaryOperator right=MultiplicativeExpression) | 
	 *         (left=MultiplicativeExpression_BinaryExpression_1_0 op=MultiplicativeBinaryOperator right=ExponentialExpression) | 
	 *         (left=ExponentialExpression_BinaryExpression_1_0 op=ExponentialOp right=CastExpression)
	 *     )
	 */
	protected void sequence_AdditiveExpression_ExponentialExpression_ImplicationExpression_MultiplicativeExpression(ISerializationContext context, BinaryExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns Aggregation
	 *     AssertionOrDefinition returns Aggregation
	 *     AssertionOrDefinition.Interpretation_1_0_0 returns Aggregation
	 *     AssertionOrDefinition.PredicateDefinition_1_1_0 returns Aggregation
	 *     AssertionOrDefinition.MetricDefinition_1_2_0 returns Aggregation
	 *     Expression returns Aggregation
	 *     ImplicationExpression returns Aggregation
	 *     ImplicationExpression.BinaryExpression_1_0 returns Aggregation
	 *     DisjunctiveExpression returns Aggregation
	 *     DisjunctiveExpression.Disjunction_1_0_0 returns Aggregation
	 *     DisjunctiveExpression.Case_1_1_0 returns Aggregation
	 *     ConjunctiveExpression returns Aggregation
	 *     ConjunctiveExpression.Conjunction_1_0 returns Aggregation
	 *     ComparisonExpression returns Aggregation
	 *     ComparisonExpression.Comparison_1_0 returns Aggregation
	 *     AdditiveExpression returns Aggregation
	 *     AdditiveExpression.BinaryExpression_1_0 returns Aggregation
	 *     MultiplicativeExpression returns Aggregation
	 *     MultiplicativeExpression.BinaryExpression_1_0 returns Aggregation
	 *     ExponentialExpression returns Aggregation
	 *     ExponentialExpression.BinaryExpression_1_0 returns Aggregation
	 *     CastExpression returns Aggregation
	 *     CastExpression.CastExpression_1_0 returns Aggregation
	 *     UnaryExpression returns Aggregation
	 *     AggregationExpression returns Aggregation
	 *     Aggregation returns Aggregation
	 *     AtomicExpression returns Aggregation
	 *
	 * Constraint:
	 *     (op=[NamedElement|QualifiedName] localVariables=LocalVariables? body=Expression condition=Expression?)
	 */
	protected void sequence_Aggregation(ISerializationContext context, Aggregation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ArgumentList returns ArgumentList
	 *
	 * Constraint:
	 *     (arguments+=Argument arguments+=Argument*)?
	 */
	protected void sequence_ArgumentList(ISerializationContext context, ArgumentList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns Interpretation
	 *     AssertionOrDefinition returns Interpretation
	 *
	 * Constraint:
	 *     (body=AssertionOrDefinition_Interpretation_1_0_0 range=Expression)
	 */
	protected void sequence_AssertionOrDefinition(ISerializationContext context, Interpretation semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SolverLanguagePackage.Literals.INTERPRETATION__BODY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SolverLanguagePackage.Literals.INTERPRETATION__BODY));
			if (transientValues.isValueTransient(semanticObject, SolverLanguagePackage.Literals.INTERPRETATION__RANGE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SolverLanguagePackage.Literals.INTERPRETATION__RANGE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAssertionOrDefinitionAccess().getInterpretationBodyAction_1_0_0(), semanticObject.getBody());
		feeder.accept(grammarAccess.getAssertionOrDefinitionAccess().getRangeExpressionParserRuleCall_1_0_2_0(), semanticObject.getRange());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     AssertionOrDefinition returns MetricDefinition
	 *
	 * Constraint:
	 *     (head=AssertionOrDefinition_MetricDefinition_1_2_0 body=Expression)
	 */
	protected void sequence_AssertionOrDefinition(ISerializationContext context, MetricDefinition semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SolverLanguagePackage.Literals.METRIC_DEFINITION__HEAD) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SolverLanguagePackage.Literals.METRIC_DEFINITION__HEAD));
			if (transientValues.isValueTransient(semanticObject, SolverLanguagePackage.Literals.METRIC_DEFINITION__BODY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SolverLanguagePackage.Literals.METRIC_DEFINITION__BODY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAssertionOrDefinitionAccess().getMetricDefinitionHeadAction_1_2_0(), semanticObject.getHead());
		feeder.accept(grammarAccess.getAssertionOrDefinitionAccess().getBodyExpressionParserRuleCall_1_2_2_0(), semanticObject.getBody());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns MetricDefinition
	 *
	 * Constraint:
	 *     ((head=AssertionOrDefinition_MetricDefinition_1_2_0 body=Expression) | (type=[NamedElement|QualifiedName] head=Call body=Expression))
	 */
	protected void sequence_AssertionOrDefinition_MetricDefinition(ISerializationContext context, MetricDefinition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AssertionOrDefinition returns PredicateDefinition
	 *
	 * Constraint:
	 *     (head=AssertionOrDefinition_PredicateDefinition_1_1_0 body=Expression)
	 */
	protected void sequence_AssertionOrDefinition(ISerializationContext context, PredicateDefinition semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SolverLanguagePackage.Literals.PREDICATE_DEFINITION__HEAD) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SolverLanguagePackage.Literals.PREDICATE_DEFINITION__HEAD));
			if (transientValues.isValueTransient(semanticObject, SolverLanguagePackage.Literals.PREDICATE_DEFINITION__BODY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SolverLanguagePackage.Literals.PREDICATE_DEFINITION__BODY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAssertionOrDefinitionAccess().getPredicateDefinitionHeadAction_1_1_0(), semanticObject.getHead());
		feeder.accept(grammarAccess.getAssertionOrDefinitionAccess().getBodyExpressionParserRuleCall_1_1_2_0(), semanticObject.getBody());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns PredicateDefinition
	 *
	 * Constraint:
	 *     (
	 *         (head=AssertionOrDefinition_PredicateDefinition_1_1_0 body=Expression) | 
	 *         (((functional?='functional' error?='error'?) | (error?='error' functional?='functional'?)) head=Call body=Expression)
	 *     )
	 */
	protected void sequence_AssertionOrDefinition_PredicateDefinition(ISerializationContext context, PredicateDefinition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Multiplicity returns BoundedMultiplicity
	 *     BoundedMultiplicity returns BoundedMultiplicity
	 *
	 * Constraint:
	 *     (lowerBound=INT upperBound=UpperMultiplicty)
	 */
	protected void sequence_BoundedMultiplicity(ISerializationContext context, BoundedMultiplicity semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SolverLanguagePackage.Literals.BOUNDED_MULTIPLICITY__LOWER_BOUND) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SolverLanguagePackage.Literals.BOUNDED_MULTIPLICITY__LOWER_BOUND));
			if (transientValues.isValueTransient(semanticObject, SolverLanguagePackage.Literals.BOUNDED_MULTIPLICITY__UPPER_BOUND) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SolverLanguagePackage.Literals.BOUNDED_MULTIPLICITY__UPPER_BOUND));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBoundedMultiplicityAccess().getLowerBoundINTTerminalRuleCall_1_0(), semanticObject.getLowerBound());
		feeder.accept(grammarAccess.getBoundedMultiplicityAccess().getUpperBoundUpperMultiplictyParserRuleCall_3_0(), semanticObject.getUpperBound());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns BoundedScopeDefinition
	 *     ScopeDefinition returns BoundedScopeDefinition
	 *     BoundedScopeDefinition returns BoundedScopeDefinition
	 *
	 * Constraint:
	 *     ((lowerBound=INT? type=[NamedElement|QualifiedName] upperBound=INT) | (upperBound=INT type=[NamedElement|QualifiedName] lowerBound=INT?))
	 */
	protected void sequence_BoundedScopeDefinition(ISerializationContext context, BoundedScopeDefinition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns Call
	 *     AssertionOrDefinition returns Call
	 *     AssertionOrDefinition.Interpretation_1_0_0 returns Call
	 *     AssertionOrDefinition.PredicateDefinition_1_1_0 returns Call
	 *     AssertionOrDefinition.MetricDefinition_1_2_0 returns Call
	 *     Expression returns Call
	 *     ImplicationExpression returns Call
	 *     ImplicationExpression.BinaryExpression_1_0 returns Call
	 *     DisjunctiveExpression returns Call
	 *     DisjunctiveExpression.Disjunction_1_0_0 returns Call
	 *     DisjunctiveExpression.Case_1_1_0 returns Call
	 *     ConjunctiveExpression returns Call
	 *     ConjunctiveExpression.Conjunction_1_0 returns Call
	 *     ComparisonExpression returns Call
	 *     ComparisonExpression.Comparison_1_0 returns Call
	 *     AdditiveExpression returns Call
	 *     AdditiveExpression.BinaryExpression_1_0 returns Call
	 *     MultiplicativeExpression returns Call
	 *     MultiplicativeExpression.BinaryExpression_1_0 returns Call
	 *     ExponentialExpression returns Call
	 *     ExponentialExpression.BinaryExpression_1_0 returns Call
	 *     CastExpression returns Call
	 *     CastExpression.CastExpression_1_0 returns Call
	 *     UnaryExpression returns Call
	 *     AggregationExpression returns Call
	 *     AtomicExpression returns Call
	 *     Call returns Call
	 *
	 * Constraint:
	 *     (
	 *         functor=Reference 
	 *         (transitiveClosure?=TRANSITIVE_CLOSURE | reflexiveTransitiveClosure?=REFLEXIVE_TRANSITIVE_CLOSURE)? 
	 *         argumentList=ArgumentList
	 *     )
	 */
	protected void sequence_Call(ISerializationContext context, Call semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Case returns Case
	 *
	 * Constraint:
	 *     (condition=ConjunctiveExpression body=ConjunctiveExpression)
	 */
	protected void sequence_Case(ISerializationContext context, Case semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SolverLanguagePackage.Literals.CASE__CONDITION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SolverLanguagePackage.Literals.CASE__CONDITION));
			if (transientValues.isValueTransient(semanticObject, SolverLanguagePackage.Literals.CASE__BODY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SolverLanguagePackage.Literals.CASE__BODY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCaseAccess().getConditionConjunctiveExpressionParserRuleCall_0_0(), semanticObject.getCondition());
		feeder.accept(grammarAccess.getCaseAccess().getBodyConjunctiveExpressionParserRuleCall_2_0(), semanticObject.getBody());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns CastExpression
	 *     AssertionOrDefinition returns CastExpression
	 *     AssertionOrDefinition.Interpretation_1_0_0 returns CastExpression
	 *     AssertionOrDefinition.PredicateDefinition_1_1_0 returns CastExpression
	 *     AssertionOrDefinition.MetricDefinition_1_2_0 returns CastExpression
	 *     Expression returns CastExpression
	 *     ImplicationExpression returns CastExpression
	 *     ImplicationExpression.BinaryExpression_1_0 returns CastExpression
	 *     DisjunctiveExpression returns CastExpression
	 *     DisjunctiveExpression.Disjunction_1_0_0 returns CastExpression
	 *     DisjunctiveExpression.Case_1_1_0 returns CastExpression
	 *     ConjunctiveExpression returns CastExpression
	 *     ConjunctiveExpression.Conjunction_1_0 returns CastExpression
	 *     ComparisonExpression returns CastExpression
	 *     ComparisonExpression.Comparison_1_0 returns CastExpression
	 *     AdditiveExpression returns CastExpression
	 *     AdditiveExpression.BinaryExpression_1_0 returns CastExpression
	 *     MultiplicativeExpression returns CastExpression
	 *     MultiplicativeExpression.BinaryExpression_1_0 returns CastExpression
	 *     ExponentialExpression returns CastExpression
	 *     ExponentialExpression.BinaryExpression_1_0 returns CastExpression
	 *     CastExpression returns CastExpression
	 *     CastExpression.CastExpression_1_0 returns CastExpression
	 *     UnaryExpression returns CastExpression
	 *     AggregationExpression returns CastExpression
	 *     AtomicExpression returns CastExpression
	 *
	 * Constraint:
	 *     (body=CastExpression_CastExpression_1_0 type=[NamedElement|QualifiedName])
	 */
	protected void sequence_CastExpression(ISerializationContext context, CastExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SolverLanguagePackage.Literals.CAST_EXPRESSION__BODY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SolverLanguagePackage.Literals.CAST_EXPRESSION__BODY));
			if (transientValues.isValueTransient(semanticObject, SolverLanguagePackage.Literals.CAST_EXPRESSION__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SolverLanguagePackage.Literals.CAST_EXPRESSION__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCastExpressionAccess().getCastExpressionBodyAction_1_0(), semanticObject.getBody());
		feeder.accept(grammarAccess.getCastExpressionAccess().getTypeNamedElementQualifiedNameParserRuleCall_1_2_0_1(), semanticObject.eGet(SolverLanguagePackage.Literals.CAST_EXPRESSION__TYPE, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns ClassDefinition
	 *     ClassDefinition returns ClassDefinition
	 *
	 * Constraint:
	 *     (
	 *         abstract?='abstract'? 
	 *         name=ID 
	 *         (superclasses+=[NamedElement|QualifiedName] superclasses+=[NamedElement|QualifiedName]*)? 
	 *         members+=MemberDefinition*
	 *     )
	 */
	protected void sequence_ClassDefinition(ISerializationContext context, ClassDefinition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns Comparison
	 *     AssertionOrDefinition returns Comparison
	 *     AssertionOrDefinition.Interpretation_1_0_0 returns Comparison
	 *     AssertionOrDefinition.PredicateDefinition_1_1_0 returns Comparison
	 *     AssertionOrDefinition.MetricDefinition_1_2_0 returns Comparison
	 *     Expression returns Comparison
	 *     ImplicationExpression returns Comparison
	 *     ImplicationExpression.BinaryExpression_1_0 returns Comparison
	 *     DisjunctiveExpression returns Comparison
	 *     DisjunctiveExpression.Disjunction_1_0_0 returns Comparison
	 *     DisjunctiveExpression.Case_1_1_0 returns Comparison
	 *     ConjunctiveExpression returns Comparison
	 *     ConjunctiveExpression.Conjunction_1_0 returns Comparison
	 *     ComparisonExpression returns Comparison
	 *     ComparisonExpression.Comparison_1_0 returns Comparison
	 *     AdditiveExpression returns Comparison
	 *     AdditiveExpression.BinaryExpression_1_0 returns Comparison
	 *     MultiplicativeExpression returns Comparison
	 *     MultiplicativeExpression.BinaryExpression_1_0 returns Comparison
	 *     ExponentialExpression returns Comparison
	 *     ExponentialExpression.BinaryExpression_1_0 returns Comparison
	 *     CastExpression returns Comparison
	 *     CastExpression.CastExpression_1_0 returns Comparison
	 *     UnaryExpression returns Comparison
	 *     AggregationExpression returns Comparison
	 *     AtomicExpression returns Comparison
	 *
	 * Constraint:
	 *     (left=ComparisonExpression_Comparison_1_0 op=ComparisonOperator right=AdditiveExpression)
	 */
	protected void sequence_ComparisonExpression(ISerializationContext context, Comparison semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SolverLanguagePackage.Literals.COMPARISON__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SolverLanguagePackage.Literals.COMPARISON__LEFT));
			if (transientValues.isValueTransient(semanticObject, SolverLanguagePackage.Literals.COMPARISON__OP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SolverLanguagePackage.Literals.COMPARISON__OP));
			if (transientValues.isValueTransient(semanticObject, SolverLanguagePackage.Literals.COMPARISON__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SolverLanguagePackage.Literals.COMPARISON__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getComparisonExpressionAccess().getComparisonLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getComparisonExpressionAccess().getOpComparisonOperatorEnumRuleCall_1_1_0(), semanticObject.getOp());
		feeder.accept(grammarAccess.getComparisonExpressionAccess().getRightAdditiveExpressionParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns Conjunction
	 *     AssertionOrDefinition returns Conjunction
	 *     AssertionOrDefinition.Interpretation_1_0_0 returns Conjunction
	 *     AssertionOrDefinition.PredicateDefinition_1_1_0 returns Conjunction
	 *     AssertionOrDefinition.MetricDefinition_1_2_0 returns Conjunction
	 *     Expression returns Conjunction
	 *     ImplicationExpression returns Conjunction
	 *     ImplicationExpression.BinaryExpression_1_0 returns Conjunction
	 *     DisjunctiveExpression returns Conjunction
	 *     DisjunctiveExpression.Disjunction_1_0_0 returns Conjunction
	 *     DisjunctiveExpression.Case_1_1_0 returns Conjunction
	 *     ConjunctiveExpression returns Conjunction
	 *     ConjunctiveExpression.Conjunction_1_0 returns Conjunction
	 *     ComparisonExpression returns Conjunction
	 *     ComparisonExpression.Comparison_1_0 returns Conjunction
	 *     AdditiveExpression returns Conjunction
	 *     AdditiveExpression.BinaryExpression_1_0 returns Conjunction
	 *     MultiplicativeExpression returns Conjunction
	 *     MultiplicativeExpression.BinaryExpression_1_0 returns Conjunction
	 *     ExponentialExpression returns Conjunction
	 *     ExponentialExpression.BinaryExpression_1_0 returns Conjunction
	 *     CastExpression returns Conjunction
	 *     CastExpression.CastExpression_1_0 returns Conjunction
	 *     UnaryExpression returns Conjunction
	 *     AggregationExpression returns Conjunction
	 *     AtomicExpression returns Conjunction
	 *
	 * Constraint:
	 *     (children+=ConjunctiveExpression_Conjunction_1_0 children+=ComparisonExpression+)
	 */
	protected void sequence_ConjunctiveExpression(ISerializationContext context, Conjunction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns DefaultDefinition
	 *     DefaultDefinition returns DefaultDefinition
	 *
	 * Constraint:
	 *     (head=Call range=Expression)
	 */
	protected void sequence_DefaultDefinition(ISerializationContext context, DefaultDefinition semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SolverLanguagePackage.Literals.DEFAULT_DEFINITION__HEAD) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SolverLanguagePackage.Literals.DEFAULT_DEFINITION__HEAD));
			if (transientValues.isValueTransient(semanticObject, SolverLanguagePackage.Literals.DEFAULT_DEFINITION__RANGE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SolverLanguagePackage.Literals.DEFAULT_DEFINITION__RANGE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDefaultDefinitionAccess().getHeadCallParserRuleCall_1_0(), semanticObject.getHead());
		feeder.accept(grammarAccess.getDefaultDefinitionAccess().getRangeExpressionParserRuleCall_3_0(), semanticObject.getRange());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns Disjunction
	 *     AssertionOrDefinition returns Disjunction
	 *     AssertionOrDefinition.Interpretation_1_0_0 returns Disjunction
	 *     AssertionOrDefinition.PredicateDefinition_1_1_0 returns Disjunction
	 *     AssertionOrDefinition.MetricDefinition_1_2_0 returns Disjunction
	 *     Expression returns Disjunction
	 *     ImplicationExpression returns Disjunction
	 *     ImplicationExpression.BinaryExpression_1_0 returns Disjunction
	 *     DisjunctiveExpression returns Disjunction
	 *     DisjunctiveExpression.Disjunction_1_0_0 returns Disjunction
	 *     DisjunctiveExpression.Case_1_1_0 returns Disjunction
	 *     ConjunctiveExpression returns Disjunction
	 *     ConjunctiveExpression.Conjunction_1_0 returns Disjunction
	 *     ComparisonExpression returns Disjunction
	 *     ComparisonExpression.Comparison_1_0 returns Disjunction
	 *     AdditiveExpression returns Disjunction
	 *     AdditiveExpression.BinaryExpression_1_0 returns Disjunction
	 *     MultiplicativeExpression returns Disjunction
	 *     MultiplicativeExpression.BinaryExpression_1_0 returns Disjunction
	 *     ExponentialExpression returns Disjunction
	 *     ExponentialExpression.BinaryExpression_1_0 returns Disjunction
	 *     CastExpression returns Disjunction
	 *     CastExpression.CastExpression_1_0 returns Disjunction
	 *     UnaryExpression returns Disjunction
	 *     AggregationExpression returns Disjunction
	 *     AtomicExpression returns Disjunction
	 *
	 * Constraint:
	 *     (children+=DisjunctiveExpression_Disjunction_1_0_0 children+=ConjunctiveExpression+)
	 */
	protected void sequence_DisjunctiveExpression(ISerializationContext context, Disjunction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns Switch
	 *     AssertionOrDefinition returns Switch
	 *     AssertionOrDefinition.Interpretation_1_0_0 returns Switch
	 *     AssertionOrDefinition.PredicateDefinition_1_1_0 returns Switch
	 *     AssertionOrDefinition.MetricDefinition_1_2_0 returns Switch
	 *     Expression returns Switch
	 *     ImplicationExpression returns Switch
	 *     ImplicationExpression.BinaryExpression_1_0 returns Switch
	 *     DisjunctiveExpression returns Switch
	 *     DisjunctiveExpression.Disjunction_1_0_0 returns Switch
	 *     DisjunctiveExpression.Case_1_1_0 returns Switch
	 *     ConjunctiveExpression returns Switch
	 *     ConjunctiveExpression.Conjunction_1_0 returns Switch
	 *     ComparisonExpression returns Switch
	 *     ComparisonExpression.Comparison_1_0 returns Switch
	 *     AdditiveExpression returns Switch
	 *     AdditiveExpression.BinaryExpression_1_0 returns Switch
	 *     MultiplicativeExpression returns Switch
	 *     MultiplicativeExpression.BinaryExpression_1_0 returns Switch
	 *     ExponentialExpression returns Switch
	 *     ExponentialExpression.BinaryExpression_1_0 returns Switch
	 *     CastExpression returns Switch
	 *     CastExpression.CastExpression_1_0 returns Switch
	 *     UnaryExpression returns Switch
	 *     AggregationExpression returns Switch
	 *     AtomicExpression returns Switch
	 *
	 * Constraint:
	 *     (cases+=DisjunctiveExpression_Switch_1_1_3 cases+=Case*)
	 */
	protected void sequence_DisjunctiveExpression(ISerializationContext context, Switch semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DisjunctiveExpression.Switch_1_1_3 returns Case
	 *
	 * Constraint:
	 *     (condition=DisjunctiveExpression_Case_1_1_0 body=ConjunctiveExpression)
	 */
	protected void sequence_DisjunctiveExpression_Switch_1_1_3(ISerializationContext context, Case semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SolverLanguagePackage.Literals.CASE__CONDITION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SolverLanguagePackage.Literals.CASE__CONDITION));
			if (transientValues.isValueTransient(semanticObject, SolverLanguagePackage.Literals.CASE__BODY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SolverLanguagePackage.Literals.CASE__BODY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDisjunctiveExpressionAccess().getCaseConditionAction_1_1_0(), semanticObject.getCondition());
		feeder.accept(grammarAccess.getDisjunctiveExpressionAccess().getBodyConjunctiveExpressionParserRuleCall_1_1_2_0(), semanticObject.getBody());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns EmptyIntervalLiteral
	 *     AssertionOrDefinition returns EmptyIntervalLiteral
	 *     AssertionOrDefinition.Interpretation_1_0_0 returns EmptyIntervalLiteral
	 *     AssertionOrDefinition.PredicateDefinition_1_1_0 returns EmptyIntervalLiteral
	 *     AssertionOrDefinition.MetricDefinition_1_2_0 returns EmptyIntervalLiteral
	 *     Expression returns EmptyIntervalLiteral
	 *     ImplicationExpression returns EmptyIntervalLiteral
	 *     ImplicationExpression.BinaryExpression_1_0 returns EmptyIntervalLiteral
	 *     DisjunctiveExpression returns EmptyIntervalLiteral
	 *     DisjunctiveExpression.Disjunction_1_0_0 returns EmptyIntervalLiteral
	 *     DisjunctiveExpression.Case_1_1_0 returns EmptyIntervalLiteral
	 *     ConjunctiveExpression returns EmptyIntervalLiteral
	 *     ConjunctiveExpression.Conjunction_1_0 returns EmptyIntervalLiteral
	 *     ComparisonExpression returns EmptyIntervalLiteral
	 *     ComparisonExpression.Comparison_1_0 returns EmptyIntervalLiteral
	 *     AdditiveExpression returns EmptyIntervalLiteral
	 *     AdditiveExpression.BinaryExpression_1_0 returns EmptyIntervalLiteral
	 *     MultiplicativeExpression returns EmptyIntervalLiteral
	 *     MultiplicativeExpression.BinaryExpression_1_0 returns EmptyIntervalLiteral
	 *     ExponentialExpression returns EmptyIntervalLiteral
	 *     ExponentialExpression.BinaryExpression_1_0 returns EmptyIntervalLiteral
	 *     CastExpression returns EmptyIntervalLiteral
	 *     CastExpression.CastExpression_1_0 returns EmptyIntervalLiteral
	 *     UnaryExpression returns EmptyIntervalLiteral
	 *     AggregationExpression returns EmptyIntervalLiteral
	 *     AtomicExpression returns EmptyIntervalLiteral
	 *     Literal returns EmptyIntervalLiteral
	 *     EmptyIntervalLiteral returns EmptyIntervalLiteral
	 *
	 * Constraint:
	 *     {EmptyIntervalLiteral}
	 */
	protected void sequence_EmptyIntervalLiteral(ISerializationContext context, EmptyIntervalLiteral semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Multiplicity returns ExactMultiplicity
	 *     ExactMultiplicity returns ExactMultiplicity
	 *
	 * Constraint:
	 *     multiplicity=UpperMultiplicty
	 */
	protected void sequence_ExactMultiplicity(ISerializationContext context, ExactMultiplicity semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SolverLanguagePackage.Literals.EXACT_MULTIPLICITY__MULTIPLICITY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SolverLanguagePackage.Literals.EXACT_MULTIPLICITY__MULTIPLICITY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExactMultiplicityAccess().getMultiplicityUpperMultiplictyParserRuleCall_1_0(), semanticObject.getMultiplicity());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns ExactScopeDefinition
	 *     ScopeDefinition returns ExactScopeDefinition
	 *     ExactScopeDefinition returns ExactScopeDefinition
	 *
	 * Constraint:
	 *     (type=[NamedElement|QualifiedName] exactScope=INT)
	 */
	protected void sequence_ExactScopeDefinition(ISerializationContext context, ExactScopeDefinition semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SolverLanguagePackage.Literals.SCOPE_DEFINITION__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SolverLanguagePackage.Literals.SCOPE_DEFINITION__TYPE));
			if (transientValues.isValueTransient(semanticObject, SolverLanguagePackage.Literals.EXACT_SCOPE_DEFINITION__EXACT_SCOPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SolverLanguagePackage.Literals.EXACT_SCOPE_DEFINITION__EXACT_SCOPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExactScopeDefinitionAccess().getTypeNamedElementQualifiedNameParserRuleCall_1_0_1(), semanticObject.eGet(SolverLanguagePackage.Literals.SCOPE_DEFINITION__TYPE, false));
		feeder.accept(grammarAccess.getExactScopeDefinitionAccess().getExactScopeINTTerminalRuleCall_3_0(), semanticObject.getExactScope());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Argument returns ExpressionArgument
	 *     ExpressionArgument returns ExpressionArgument
	 *
	 * Constraint:
	 *     body=ComparisonExpression
	 */
	protected void sequence_ExpressionArgument(ISerializationContext context, ExpressionArgument semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SolverLanguagePackage.Literals.EXPRESSION_ARGUMENT__BODY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SolverLanguagePackage.Literals.EXPRESSION_ARGUMENT__BODY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExpressionArgumentAccess().getBodyComparisonExpressionParserRuleCall_0(), semanticObject.getBody());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns ExternAggregatorDefinition
	 *     ExternAggregatorDefinition returns ExternAggregatorDefinition
	 *
	 * Constraint:
	 *     (type=[NamedElement|QualifiedName] name=QualifiedName inputType=[NamedElement|QualifiedName])
	 */
	protected void sequence_ExternAggregatorDefinition(ISerializationContext context, ExternAggregatorDefinition semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SolverLanguagePackage.Literals.EXTERN_AGGREGATOR_DEFINITION__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SolverLanguagePackage.Literals.EXTERN_AGGREGATOR_DEFINITION__TYPE));
			if (transientValues.isValueTransient(semanticObject, SolverLanguagePackage.Literals.EXTERN_AGGREGATOR_DEFINITION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SolverLanguagePackage.Literals.EXTERN_AGGREGATOR_DEFINITION__NAME));
			if (transientValues.isValueTransient(semanticObject, SolverLanguagePackage.Literals.EXTERN_AGGREGATOR_DEFINITION__INPUT_TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SolverLanguagePackage.Literals.EXTERN_AGGREGATOR_DEFINITION__INPUT_TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExternAggregatorDefinitionAccess().getTypeNamedElementQualifiedNameParserRuleCall_1_0_1(), semanticObject.eGet(SolverLanguagePackage.Literals.EXTERN_AGGREGATOR_DEFINITION__TYPE, false));
		feeder.accept(grammarAccess.getExternAggregatorDefinitionAccess().getNameQualifiedNameParserRuleCall_2_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getExternAggregatorDefinitionAccess().getInputTypeNamedElementQualifiedNameParserRuleCall_4_0_1(), semanticObject.eGet(SolverLanguagePackage.Literals.EXTERN_AGGREGATOR_DEFINITION__INPUT_TYPE, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns ExternDatatypeDefinition
	 *     ExternDatatypeDefinition returns ExternDatatypeDefinition
	 *
	 * Constraint:
	 *     (name=QualifiedName supertypes+=[NamedElement|QualifiedName] supertypes+=[NamedElement|QualifiedName]*)
	 */
	protected void sequence_ExternDatatypeDefinition(ISerializationContext context, ExternDatatypeDefinition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns ExternMetricDefinition
	 *     ExternMetricDefinition returns ExternMetricDefinition
	 *
	 * Constraint:
	 *     (type=[NamedElement|QualifiedName] name=QualifiedName argumentList=ArgumentList)
	 */
	protected void sequence_ExternMetricDefinition(ISerializationContext context, ExternMetricDefinition semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SolverLanguagePackage.Literals.EXTERN_METRIC_DEFINITION__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SolverLanguagePackage.Literals.EXTERN_METRIC_DEFINITION__TYPE));
			if (transientValues.isValueTransient(semanticObject, SolverLanguagePackage.Literals.EXTERN_METRIC_DEFINITION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SolverLanguagePackage.Literals.EXTERN_METRIC_DEFINITION__NAME));
			if (transientValues.isValueTransient(semanticObject, SolverLanguagePackage.Literals.EXTERN_METRIC_DEFINITION__ARGUMENT_LIST) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SolverLanguagePackage.Literals.EXTERN_METRIC_DEFINITION__ARGUMENT_LIST));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExternMetricDefinitionAccess().getTypeNamedElementQualifiedNameParserRuleCall_1_0_1(), semanticObject.eGet(SolverLanguagePackage.Literals.EXTERN_METRIC_DEFINITION__TYPE, false));
		feeder.accept(grammarAccess.getExternMetricDefinitionAccess().getNameQualifiedNameParserRuleCall_2_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getExternMetricDefinitionAccess().getArgumentListArgumentListParserRuleCall_3_0(), semanticObject.getArgumentList());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns ExternPredicateDefinition
	 *     ExternPredicateDefinition returns ExternPredicateDefinition
	 *
	 * Constraint:
	 *     (name=QualifiedName argumentList=ArgumentList)
	 */
	protected void sequence_ExternPredicateDefinition(ISerializationContext context, ExternPredicateDefinition semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SolverLanguagePackage.Literals.EXTERN_PREDICATE_DEFINITION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SolverLanguagePackage.Literals.EXTERN_PREDICATE_DEFINITION__NAME));
			if (transientValues.isValueTransient(semanticObject, SolverLanguagePackage.Literals.EXTERN_PREDICATE_DEFINITION__ARGUMENT_LIST) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SolverLanguagePackage.Literals.EXTERN_PREDICATE_DEFINITION__ARGUMENT_LIST));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExternPredicateDefinitionAccess().getNameQualifiedNameParserRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getExternPredicateDefinitionAccess().getArgumentListArgumentListParserRuleCall_2_0(), semanticObject.getArgumentList());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns IfElse
	 *     AssertionOrDefinition returns IfElse
	 *     AssertionOrDefinition.Interpretation_1_0_0 returns IfElse
	 *     AssertionOrDefinition.PredicateDefinition_1_1_0 returns IfElse
	 *     AssertionOrDefinition.MetricDefinition_1_2_0 returns IfElse
	 *     Expression returns IfElse
	 *     IfElse returns IfElse
	 *     ImplicationExpression returns IfElse
	 *     ImplicationExpression.BinaryExpression_1_0 returns IfElse
	 *     DisjunctiveExpression returns IfElse
	 *     DisjunctiveExpression.Disjunction_1_0_0 returns IfElse
	 *     DisjunctiveExpression.Case_1_1_0 returns IfElse
	 *     ConjunctiveExpression returns IfElse
	 *     ConjunctiveExpression.Conjunction_1_0 returns IfElse
	 *     ComparisonExpression returns IfElse
	 *     ComparisonExpression.Comparison_1_0 returns IfElse
	 *     AdditiveExpression returns IfElse
	 *     AdditiveExpression.BinaryExpression_1_0 returns IfElse
	 *     MultiplicativeExpression returns IfElse
	 *     MultiplicativeExpression.BinaryExpression_1_0 returns IfElse
	 *     ExponentialExpression returns IfElse
	 *     ExponentialExpression.BinaryExpression_1_0 returns IfElse
	 *     CastExpression returns IfElse
	 *     CastExpression.CastExpression_1_0 returns IfElse
	 *     UnaryExpression returns IfElse
	 *     AggregationExpression returns IfElse
	 *     AtomicExpression returns IfElse
	 *
	 * Constraint:
	 *     (condition=Expression then=Expression else=Expression)
	 */
	protected void sequence_IfElse(ISerializationContext context, IfElse semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SolverLanguagePackage.Literals.IF_ELSE__CONDITION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SolverLanguagePackage.Literals.IF_ELSE__CONDITION));
			if (transientValues.isValueTransient(semanticObject, SolverLanguagePackage.Literals.IF_ELSE__THEN) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SolverLanguagePackage.Literals.IF_ELSE__THEN));
			if (transientValues.isValueTransient(semanticObject, SolverLanguagePackage.Literals.IF_ELSE__ELSE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SolverLanguagePackage.Literals.IF_ELSE__ELSE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getIfElseAccess().getConditionExpressionParserRuleCall_1_0(), semanticObject.getCondition());
		feeder.accept(grammarAccess.getIfElseAccess().getThenExpressionParserRuleCall_3_0(), semanticObject.getThen());
		feeder.accept(grammarAccess.getIfElseAccess().getElseExpressionParserRuleCall_5_0(), semanticObject.getElse());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns InfinityLiteral
	 *     AssertionOrDefinition returns InfinityLiteral
	 *     AssertionOrDefinition.Interpretation_1_0_0 returns InfinityLiteral
	 *     AssertionOrDefinition.PredicateDefinition_1_1_0 returns InfinityLiteral
	 *     AssertionOrDefinition.MetricDefinition_1_2_0 returns InfinityLiteral
	 *     Expression returns InfinityLiteral
	 *     ImplicationExpression returns InfinityLiteral
	 *     ImplicationExpression.BinaryExpression_1_0 returns InfinityLiteral
	 *     DisjunctiveExpression returns InfinityLiteral
	 *     DisjunctiveExpression.Disjunction_1_0_0 returns InfinityLiteral
	 *     DisjunctiveExpression.Case_1_1_0 returns InfinityLiteral
	 *     ConjunctiveExpression returns InfinityLiteral
	 *     ConjunctiveExpression.Conjunction_1_0 returns InfinityLiteral
	 *     ComparisonExpression returns InfinityLiteral
	 *     ComparisonExpression.Comparison_1_0 returns InfinityLiteral
	 *     AdditiveExpression returns InfinityLiteral
	 *     AdditiveExpression.BinaryExpression_1_0 returns InfinityLiteral
	 *     MultiplicativeExpression returns InfinityLiteral
	 *     MultiplicativeExpression.BinaryExpression_1_0 returns InfinityLiteral
	 *     ExponentialExpression returns InfinityLiteral
	 *     ExponentialExpression.BinaryExpression_1_0 returns InfinityLiteral
	 *     CastExpression returns InfinityLiteral
	 *     CastExpression.CastExpression_1_0 returns InfinityLiteral
	 *     UnaryExpression returns InfinityLiteral
	 *     AggregationExpression returns InfinityLiteral
	 *     AtomicExpression returns InfinityLiteral
	 *     Literal returns InfinityLiteral
	 *     InfinityLiteral returns InfinityLiteral
	 *
	 * Constraint:
	 *     {InfinityLiteral}
	 */
	protected void sequence_InfinityLiteral(ISerializationContext context, InfinityLiteral semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns Interval
	 *     AssertionOrDefinition returns Interval
	 *     AssertionOrDefinition.Interpretation_1_0_0 returns Interval
	 *     AssertionOrDefinition.PredicateDefinition_1_1_0 returns Interval
	 *     AssertionOrDefinition.MetricDefinition_1_2_0 returns Interval
	 *     Expression returns Interval
	 *     ImplicationExpression returns Interval
	 *     ImplicationExpression.BinaryExpression_1_0 returns Interval
	 *     DisjunctiveExpression returns Interval
	 *     DisjunctiveExpression.Disjunction_1_0_0 returns Interval
	 *     DisjunctiveExpression.Case_1_1_0 returns Interval
	 *     ConjunctiveExpression returns Interval
	 *     ConjunctiveExpression.Conjunction_1_0 returns Interval
	 *     ComparisonExpression returns Interval
	 *     ComparisonExpression.Comparison_1_0 returns Interval
	 *     AdditiveExpression returns Interval
	 *     AdditiveExpression.BinaryExpression_1_0 returns Interval
	 *     MultiplicativeExpression returns Interval
	 *     MultiplicativeExpression.BinaryExpression_1_0 returns Interval
	 *     ExponentialExpression returns Interval
	 *     ExponentialExpression.BinaryExpression_1_0 returns Interval
	 *     CastExpression returns Interval
	 *     CastExpression.CastExpression_1_0 returns Interval
	 *     UnaryExpression returns Interval
	 *     AggregationExpression returns Interval
	 *     AtomicExpression returns Interval
	 *     Interval returns Interval
	 *
	 * Constraint:
	 *     (lowerBound=Expression upperBound=Expression)
	 */
	protected void sequence_Interval(ISerializationContext context, Interval semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SolverLanguagePackage.Literals.INTERVAL__LOWER_BOUND) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SolverLanguagePackage.Literals.INTERVAL__LOWER_BOUND));
			if (transientValues.isValueTransient(semanticObject, SolverLanguagePackage.Literals.INTERVAL__UPPER_BOUND) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SolverLanguagePackage.Literals.INTERVAL__UPPER_BOUND));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getIntervalAccess().getLowerBoundExpressionParserRuleCall_1_0(), semanticObject.getLowerBound());
		feeder.accept(grammarAccess.getIntervalAccess().getUpperBoundExpressionParserRuleCall_3_0(), semanticObject.getUpperBound());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     LetBinding returns LetBinding
	 *
	 * Constraint:
	 *     (variable=Variable value=AdditiveExpression)
	 */
	protected void sequence_LetBinding(ISerializationContext context, LetBinding semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SolverLanguagePackage.Literals.LET_BINDING__VARIABLE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SolverLanguagePackage.Literals.LET_BINDING__VARIABLE));
			if (transientValues.isValueTransient(semanticObject, SolverLanguagePackage.Literals.LET_BINDING__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SolverLanguagePackage.Literals.LET_BINDING__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLetBindingAccess().getVariableVariableParserRuleCall_0_0(), semanticObject.getVariable());
		feeder.accept(grammarAccess.getLetBindingAccess().getValueAdditiveExpressionParserRuleCall_2_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns Let
	 *     AssertionOrDefinition returns Let
	 *     AssertionOrDefinition.Interpretation_1_0_0 returns Let
	 *     AssertionOrDefinition.PredicateDefinition_1_1_0 returns Let
	 *     AssertionOrDefinition.MetricDefinition_1_2_0 returns Let
	 *     Expression returns Let
	 *     Let returns Let
	 *     ImplicationExpression returns Let
	 *     ImplicationExpression.BinaryExpression_1_0 returns Let
	 *     DisjunctiveExpression returns Let
	 *     DisjunctiveExpression.Disjunction_1_0_0 returns Let
	 *     DisjunctiveExpression.Case_1_1_0 returns Let
	 *     ConjunctiveExpression returns Let
	 *     ConjunctiveExpression.Conjunction_1_0 returns Let
	 *     ComparisonExpression returns Let
	 *     ComparisonExpression.Comparison_1_0 returns Let
	 *     AdditiveExpression returns Let
	 *     AdditiveExpression.BinaryExpression_1_0 returns Let
	 *     MultiplicativeExpression returns Let
	 *     MultiplicativeExpression.BinaryExpression_1_0 returns Let
	 *     ExponentialExpression returns Let
	 *     ExponentialExpression.BinaryExpression_1_0 returns Let
	 *     CastExpression returns Let
	 *     CastExpression.CastExpression_1_0 returns Let
	 *     UnaryExpression returns Let
	 *     AggregationExpression returns Let
	 *     AtomicExpression returns Let
	 *
	 * Constraint:
	 *     (bindings+=LetBinding bindings+=LetBinding* body=Expression)
	 */
	protected void sequence_Let(ISerializationContext context, Let semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     LocalVariables returns LocalVariables
	 *
	 * Constraint:
	 *     (variables+=Variable variables+=Variable*)?
	 */
	protected void sequence_LocalVariables(ISerializationContext context, LocalVariables semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns LogicLiteral
	 *     AssertionOrDefinition returns LogicLiteral
	 *     AssertionOrDefinition.Interpretation_1_0_0 returns LogicLiteral
	 *     AssertionOrDefinition.PredicateDefinition_1_1_0 returns LogicLiteral
	 *     AssertionOrDefinition.MetricDefinition_1_2_0 returns LogicLiteral
	 *     Expression returns LogicLiteral
	 *     ImplicationExpression returns LogicLiteral
	 *     ImplicationExpression.BinaryExpression_1_0 returns LogicLiteral
	 *     DisjunctiveExpression returns LogicLiteral
	 *     DisjunctiveExpression.Disjunction_1_0_0 returns LogicLiteral
	 *     DisjunctiveExpression.Case_1_1_0 returns LogicLiteral
	 *     ConjunctiveExpression returns LogicLiteral
	 *     ConjunctiveExpression.Conjunction_1_0 returns LogicLiteral
	 *     ComparisonExpression returns LogicLiteral
	 *     ComparisonExpression.Comparison_1_0 returns LogicLiteral
	 *     AdditiveExpression returns LogicLiteral
	 *     AdditiveExpression.BinaryExpression_1_0 returns LogicLiteral
	 *     MultiplicativeExpression returns LogicLiteral
	 *     MultiplicativeExpression.BinaryExpression_1_0 returns LogicLiteral
	 *     ExponentialExpression returns LogicLiteral
	 *     ExponentialExpression.BinaryExpression_1_0 returns LogicLiteral
	 *     CastExpression returns LogicLiteral
	 *     CastExpression.CastExpression_1_0 returns LogicLiteral
	 *     UnaryExpression returns LogicLiteral
	 *     AggregationExpression returns LogicLiteral
	 *     AtomicExpression returns LogicLiteral
	 *     Literal returns LogicLiteral
	 *     LogicLiteral returns LogicLiteral
	 *
	 * Constraint:
	 *     value=LogicValue
	 */
	protected void sequence_LogicLiteral(ISerializationContext context, LogicLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SolverLanguagePackage.Literals.LOGIC_LITERAL__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SolverLanguagePackage.Literals.LOGIC_LITERAL__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLogicLiteralAccess().getValueLogicValueEnumRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns LowerBoundedScopeDefinition
	 *     ScopeDefinition returns LowerBoundedScopeDefinition
	 *     LowerBoundedScopeDefinition returns LowerBoundedScopeDefinition
	 *
	 * Constraint:
	 *     ((lowerBound=INT type=[NamedElement|QualifiedName]) | (type=[NamedElement|QualifiedName] lowerBound=INT))
	 */
	protected void sequence_LowerBoundedScopeDefinition(ISerializationContext context, LowerBoundedScopeDefinition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Multiplicity returns ManyMultiplicity
	 *     ManyMultiplicity returns ManyMultiplicity
	 *
	 * Constraint:
	 *     {ManyMultiplicity}
	 */
	protected void sequence_ManyMultiplicity(ISerializationContext context, ManyMultiplicity semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MemberDefinition returns MemberDefinition
	 *
	 * Constraint:
	 *     (containment?='contains'? type=[NamedElement|QualifiedName] multiplicity=Multiplicity? name=ID opposite=[NamedElement|QualifiedName]?)
	 */
	protected void sequence_MemberDefinition(ISerializationContext context, MemberDefinition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MetricDefinition returns MetricDefinition
	 *
	 * Constraint:
	 *     (type=[NamedElement|QualifiedName] head=Call body=Expression)
	 */
	protected void sequence_MetricDefinition(ISerializationContext context, MetricDefinition semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SolverLanguagePackage.Literals.METRIC_DEFINITION__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SolverLanguagePackage.Literals.METRIC_DEFINITION__TYPE));
			if (transientValues.isValueTransient(semanticObject, SolverLanguagePackage.Literals.METRIC_DEFINITION__HEAD) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SolverLanguagePackage.Literals.METRIC_DEFINITION__HEAD));
			if (transientValues.isValueTransient(semanticObject, SolverLanguagePackage.Literals.METRIC_DEFINITION__BODY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SolverLanguagePackage.Literals.METRIC_DEFINITION__BODY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMetricDefinitionAccess().getTypeNamedElementQualifiedNameParserRuleCall_0_0_1(), semanticObject.eGet(SolverLanguagePackage.Literals.METRIC_DEFINITION__TYPE, false));
		feeder.accept(grammarAccess.getMetricDefinitionAccess().getHeadCallParserRuleCall_1_0(), semanticObject.getHead());
		feeder.accept(grammarAccess.getMetricDefinitionAccess().getBodyExpressionParserRuleCall_3_0(), semanticObject.getBody());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns NumericLiteral
	 *     AssertionOrDefinition returns NumericLiteral
	 *     AssertionOrDefinition.Interpretation_1_0_0 returns NumericLiteral
	 *     AssertionOrDefinition.PredicateDefinition_1_1_0 returns NumericLiteral
	 *     AssertionOrDefinition.MetricDefinition_1_2_0 returns NumericLiteral
	 *     Expression returns NumericLiteral
	 *     ImplicationExpression returns NumericLiteral
	 *     ImplicationExpression.BinaryExpression_1_0 returns NumericLiteral
	 *     DisjunctiveExpression returns NumericLiteral
	 *     DisjunctiveExpression.Disjunction_1_0_0 returns NumericLiteral
	 *     DisjunctiveExpression.Case_1_1_0 returns NumericLiteral
	 *     ConjunctiveExpression returns NumericLiteral
	 *     ConjunctiveExpression.Conjunction_1_0 returns NumericLiteral
	 *     ComparisonExpression returns NumericLiteral
	 *     ComparisonExpression.Comparison_1_0 returns NumericLiteral
	 *     AdditiveExpression returns NumericLiteral
	 *     AdditiveExpression.BinaryExpression_1_0 returns NumericLiteral
	 *     MultiplicativeExpression returns NumericLiteral
	 *     MultiplicativeExpression.BinaryExpression_1_0 returns NumericLiteral
	 *     ExponentialExpression returns NumericLiteral
	 *     ExponentialExpression.BinaryExpression_1_0 returns NumericLiteral
	 *     CastExpression returns NumericLiteral
	 *     CastExpression.CastExpression_1_0 returns NumericLiteral
	 *     UnaryExpression returns NumericLiteral
	 *     AggregationExpression returns NumericLiteral
	 *     AtomicExpression returns NumericLiteral
	 *     Literal returns NumericLiteral
	 *     NumericLiteral returns NumericLiteral
	 *
	 * Constraint:
	 *     value=Real
	 */
	protected void sequence_NumericLiteral(ISerializationContext context, NumericLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SolverLanguagePackage.Literals.NUMERIC_LITERAL__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SolverLanguagePackage.Literals.NUMERIC_LITERAL__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNumericLiteralAccess().getValueRealParserRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns ObjectiveDefinition
	 *     ObjectiveDefinition returns ObjectiveDefinition
	 *
	 * Constraint:
	 *     (kind=ObjectiveKind objective=Expression)
	 */
	protected void sequence_ObjectiveDefinition(ISerializationContext context, ObjectiveDefinition semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SolverLanguagePackage.Literals.OBJECTIVE_DEFINITION__KIND) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SolverLanguagePackage.Literals.OBJECTIVE_DEFINITION__KIND));
			if (transientValues.isValueTransient(semanticObject, SolverLanguagePackage.Literals.OBJECTIVE_DEFINITION__OBJECTIVE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SolverLanguagePackage.Literals.OBJECTIVE_DEFINITION__OBJECTIVE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getObjectiveDefinitionAccess().getKindObjectiveKindEnumRuleCall_0_0(), semanticObject.getKind());
		feeder.accept(grammarAccess.getObjectiveDefinitionAccess().getObjectiveExpressionParserRuleCall_1_0(), semanticObject.getObjective());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     PredicateDefinition returns PredicateDefinition
	 *
	 * Constraint:
	 *     (((functional?='functional' error?='error'?) | (error?='error' functional?='functional'?)) head=Call body=Expression)
	 */
	protected void sequence_PredicateDefinition(ISerializationContext context, PredicateDefinition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Problem returns Problem
	 *
	 * Constraint:
	 *     statements+=Statement+
	 */
	protected void sequence_Problem(ISerializationContext context, Problem semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns QuantifiedExpression
	 *     AssertionOrDefinition returns QuantifiedExpression
	 *     AssertionOrDefinition.Interpretation_1_0_0 returns QuantifiedExpression
	 *     AssertionOrDefinition.PredicateDefinition_1_1_0 returns QuantifiedExpression
	 *     AssertionOrDefinition.MetricDefinition_1_2_0 returns QuantifiedExpression
	 *     Expression returns QuantifiedExpression
	 *     ImplicationExpression returns QuantifiedExpression
	 *     ImplicationExpression.BinaryExpression_1_0 returns QuantifiedExpression
	 *     DisjunctiveExpression returns QuantifiedExpression
	 *     DisjunctiveExpression.Disjunction_1_0_0 returns QuantifiedExpression
	 *     DisjunctiveExpression.Case_1_1_0 returns QuantifiedExpression
	 *     ConjunctiveExpression returns QuantifiedExpression
	 *     ConjunctiveExpression.Conjunction_1_0 returns QuantifiedExpression
	 *     ComparisonExpression returns QuantifiedExpression
	 *     ComparisonExpression.Comparison_1_0 returns QuantifiedExpression
	 *     AdditiveExpression returns QuantifiedExpression
	 *     AdditiveExpression.BinaryExpression_1_0 returns QuantifiedExpression
	 *     MultiplicativeExpression returns QuantifiedExpression
	 *     MultiplicativeExpression.BinaryExpression_1_0 returns QuantifiedExpression
	 *     ExponentialExpression returns QuantifiedExpression
	 *     ExponentialExpression.BinaryExpression_1_0 returns QuantifiedExpression
	 *     CastExpression returns QuantifiedExpression
	 *     CastExpression.CastExpression_1_0 returns QuantifiedExpression
	 *     UnaryExpression returns QuantifiedExpression
	 *     AggregationExpression returns QuantifiedExpression
	 *     QuantifiedExpression returns QuantifiedExpression
	 *     AtomicExpression returns QuantifiedExpression
	 *
	 * Constraint:
	 *     (quantifier=Quantifier localVariables=LocalVariables? body=Expression)
	 */
	protected void sequence_QuantifiedExpression(ISerializationContext context, QuantifiedExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns Reference
	 *     AssertionOrDefinition returns Reference
	 *     AssertionOrDefinition.Interpretation_1_0_0 returns Reference
	 *     AssertionOrDefinition.PredicateDefinition_1_1_0 returns Reference
	 *     AssertionOrDefinition.MetricDefinition_1_2_0 returns Reference
	 *     Expression returns Reference
	 *     ImplicationExpression returns Reference
	 *     ImplicationExpression.BinaryExpression_1_0 returns Reference
	 *     DisjunctiveExpression returns Reference
	 *     DisjunctiveExpression.Disjunction_1_0_0 returns Reference
	 *     DisjunctiveExpression.Case_1_1_0 returns Reference
	 *     ConjunctiveExpression returns Reference
	 *     ConjunctiveExpression.Conjunction_1_0 returns Reference
	 *     ComparisonExpression returns Reference
	 *     ComparisonExpression.Comparison_1_0 returns Reference
	 *     AdditiveExpression returns Reference
	 *     AdditiveExpression.BinaryExpression_1_0 returns Reference
	 *     MultiplicativeExpression returns Reference
	 *     MultiplicativeExpression.BinaryExpression_1_0 returns Reference
	 *     ExponentialExpression returns Reference
	 *     ExponentialExpression.BinaryExpression_1_0 returns Reference
	 *     CastExpression returns Reference
	 *     CastExpression.CastExpression_1_0 returns Reference
	 *     UnaryExpression returns Reference
	 *     AggregationExpression returns Reference
	 *     AtomicExpression returns Reference
	 *     Reference returns Reference
	 *
	 * Constraint:
	 *     referred=[NamedElement|QualifiedName]
	 */
	protected void sequence_Reference(ISerializationContext context, Reference semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SolverLanguagePackage.Literals.REFERENCE__REFERRED) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SolverLanguagePackage.Literals.REFERENCE__REFERRED));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getReferenceAccess().getReferredNamedElementQualifiedNameParserRuleCall_0_1(), semanticObject.eGet(SolverLanguagePackage.Literals.REFERENCE__REFERRED, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Argument returns StarArgument
	 *     StarArgument returns StarArgument
	 *
	 * Constraint:
	 *     {StarArgument}
	 */
	protected void sequence_StarArgument(ISerializationContext context, StarArgument semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns StringLiteral
	 *     AssertionOrDefinition returns StringLiteral
	 *     AssertionOrDefinition.Interpretation_1_0_0 returns StringLiteral
	 *     AssertionOrDefinition.PredicateDefinition_1_1_0 returns StringLiteral
	 *     AssertionOrDefinition.MetricDefinition_1_2_0 returns StringLiteral
	 *     Expression returns StringLiteral
	 *     ImplicationExpression returns StringLiteral
	 *     ImplicationExpression.BinaryExpression_1_0 returns StringLiteral
	 *     DisjunctiveExpression returns StringLiteral
	 *     DisjunctiveExpression.Disjunction_1_0_0 returns StringLiteral
	 *     DisjunctiveExpression.Case_1_1_0 returns StringLiteral
	 *     ConjunctiveExpression returns StringLiteral
	 *     ConjunctiveExpression.Conjunction_1_0 returns StringLiteral
	 *     ComparisonExpression returns StringLiteral
	 *     ComparisonExpression.Comparison_1_0 returns StringLiteral
	 *     AdditiveExpression returns StringLiteral
	 *     AdditiveExpression.BinaryExpression_1_0 returns StringLiteral
	 *     MultiplicativeExpression returns StringLiteral
	 *     MultiplicativeExpression.BinaryExpression_1_0 returns StringLiteral
	 *     ExponentialExpression returns StringLiteral
	 *     ExponentialExpression.BinaryExpression_1_0 returns StringLiteral
	 *     CastExpression returns StringLiteral
	 *     CastExpression.CastExpression_1_0 returns StringLiteral
	 *     UnaryExpression returns StringLiteral
	 *     AggregationExpression returns StringLiteral
	 *     AtomicExpression returns StringLiteral
	 *     Literal returns StringLiteral
	 *     StringLiteral returns StringLiteral
	 *
	 * Constraint:
	 *     value=STRING
	 */
	protected void sequence_StringLiteral(ISerializationContext context, StringLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SolverLanguagePackage.Literals.STRING_LITERAL__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SolverLanguagePackage.Literals.STRING_LITERAL__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getStringLiteralAccess().getValueSTRINGTerminalRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Argument returns TypedArgument
	 *     TypedArgument returns TypedArgument
	 *
	 * Constraint:
	 *     (type=[NamedElement|QualifiedName] variable=[NamedElement|QualifiedName])
	 */
	protected void sequence_TypedArgument(ISerializationContext context, TypedArgument semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SolverLanguagePackage.Literals.TYPED_ARGUMENT__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SolverLanguagePackage.Literals.TYPED_ARGUMENT__TYPE));
			if (transientValues.isValueTransient(semanticObject, SolverLanguagePackage.Literals.TYPED_ARGUMENT__VARIABLE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SolverLanguagePackage.Literals.TYPED_ARGUMENT__VARIABLE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTypedArgumentAccess().getTypeNamedElementQualifiedNameParserRuleCall_0_0_1(), semanticObject.eGet(SolverLanguagePackage.Literals.TYPED_ARGUMENT__TYPE, false));
		feeder.accept(grammarAccess.getTypedArgumentAccess().getVariableNamedElementQualifiedNameParserRuleCall_1_0_1(), semanticObject.eGet(SolverLanguagePackage.Literals.TYPED_ARGUMENT__VARIABLE, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Argument returns TypedStarArgument
	 *     TypedStarArgument returns TypedStarArgument
	 *
	 * Constraint:
	 *     type=[NamedElement|QualifiedName]
	 */
	protected void sequence_TypedStarArgument(ISerializationContext context, TypedStarArgument semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SolverLanguagePackage.Literals.TYPED_STAR_ARGUMENT__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SolverLanguagePackage.Literals.TYPED_STAR_ARGUMENT__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTypedStarArgumentAccess().getTypeNamedElementQualifiedNameParserRuleCall_0_0_1(), semanticObject.eGet(SolverLanguagePackage.Literals.TYPED_STAR_ARGUMENT__TYPE, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns UnaryExpression
	 *     AssertionOrDefinition returns UnaryExpression
	 *     AssertionOrDefinition.Interpretation_1_0_0 returns UnaryExpression
	 *     AssertionOrDefinition.PredicateDefinition_1_1_0 returns UnaryExpression
	 *     AssertionOrDefinition.MetricDefinition_1_2_0 returns UnaryExpression
	 *     Expression returns UnaryExpression
	 *     ImplicationExpression returns UnaryExpression
	 *     ImplicationExpression.BinaryExpression_1_0 returns UnaryExpression
	 *     DisjunctiveExpression returns UnaryExpression
	 *     DisjunctiveExpression.Disjunction_1_0_0 returns UnaryExpression
	 *     DisjunctiveExpression.Case_1_1_0 returns UnaryExpression
	 *     ConjunctiveExpression returns UnaryExpression
	 *     ConjunctiveExpression.Conjunction_1_0 returns UnaryExpression
	 *     ComparisonExpression returns UnaryExpression
	 *     ComparisonExpression.Comparison_1_0 returns UnaryExpression
	 *     AdditiveExpression returns UnaryExpression
	 *     AdditiveExpression.BinaryExpression_1_0 returns UnaryExpression
	 *     MultiplicativeExpression returns UnaryExpression
	 *     MultiplicativeExpression.BinaryExpression_1_0 returns UnaryExpression
	 *     ExponentialExpression returns UnaryExpression
	 *     ExponentialExpression.BinaryExpression_1_0 returns UnaryExpression
	 *     CastExpression returns UnaryExpression
	 *     CastExpression.CastExpression_1_0 returns UnaryExpression
	 *     UnaryExpression returns UnaryExpression
	 *     AggregationExpression returns UnaryExpression
	 *     AtomicExpression returns UnaryExpression
	 *
	 * Constraint:
	 *     (op=UnaryOp body=AggregationExpression)
	 */
	protected void sequence_UnaryExpression(ISerializationContext context, UnaryExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SolverLanguagePackage.Literals.UNARY_EXPRESSION__OP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SolverLanguagePackage.Literals.UNARY_EXPRESSION__OP));
			if (transientValues.isValueTransient(semanticObject, SolverLanguagePackage.Literals.UNARY_EXPRESSION__BODY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SolverLanguagePackage.Literals.UNARY_EXPRESSION__BODY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getUnaryExpressionAccess().getOpUnaryOpEnumRuleCall_1_1_0(), semanticObject.getOp());
		feeder.accept(grammarAccess.getUnaryExpressionAccess().getBodyAggregationExpressionParserRuleCall_1_2_0(), semanticObject.getBody());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns UnnamedErrorPrediateDefinition
	 *     UnnamedErrorPrediateDefinition returns UnnamedErrorPrediateDefinition
	 *
	 * Constraint:
	 *     (argumentList=ArgumentList body=Expression)
	 */
	protected void sequence_UnnamedErrorPrediateDefinition(ISerializationContext context, UnnamedErrorPrediateDefinition semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SolverLanguagePackage.Literals.UNNAMED_ERROR_PREDIATE_DEFINITION__ARGUMENT_LIST) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SolverLanguagePackage.Literals.UNNAMED_ERROR_PREDIATE_DEFINITION__ARGUMENT_LIST));
			if (transientValues.isValueTransient(semanticObject, SolverLanguagePackage.Literals.UNNAMED_ERROR_PREDIATE_DEFINITION__BODY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SolverLanguagePackage.Literals.UNNAMED_ERROR_PREDIATE_DEFINITION__BODY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getUnnamedErrorPrediateDefinitionAccess().getArgumentListArgumentListParserRuleCall_1_0(), semanticObject.getArgumentList());
		feeder.accept(grammarAccess.getUnnamedErrorPrediateDefinitionAccess().getBodyExpressionParserRuleCall_3_0(), semanticObject.getBody());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Variable returns Variable
	 *
	 * Constraint:
	 *     (type=[NamedElement|QualifiedName]? name=ID)
	 */
	protected void sequence_Variable(ISerializationContext context, Variable semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
