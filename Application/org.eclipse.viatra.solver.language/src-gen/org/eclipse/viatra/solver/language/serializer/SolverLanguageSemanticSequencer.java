/*
 * generated by Xtext 2.18.0.M3
 */
package org.eclipse.viatra.solver.language.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.viatra.solver.language.services.SolverLanguageGrammarAccess;
import org.eclipse.viatra.solver.language.solverLanguage.AllInstances;
import org.eclipse.viatra.solver.language.solverLanguage.AllObjects;
import org.eclipse.viatra.solver.language.solverLanguage.BasicInterpretation;
import org.eclipse.viatra.solver.language.solverLanguage.BooleanFalse;
import org.eclipse.viatra.solver.language.solverLanguage.BooleanObject;
import org.eclipse.viatra.solver.language.solverLanguage.BooleanSymbol;
import org.eclipse.viatra.solver.language.solverLanguage.BooleanTrue;
import org.eclipse.viatra.solver.language.solverLanguage.ClassInterpretation;
import org.eclipse.viatra.solver.language.solverLanguage.Constraint;
import org.eclipse.viatra.solver.language.solverLanguage.DefaultInterpretation;
import org.eclipse.viatra.solver.language.solverLanguage.EnumInterpretation;
import org.eclipse.viatra.solver.language.solverLanguage.EqualsSymbol;
import org.eclipse.viatra.solver.language.solverLanguage.ExistSymbol;
import org.eclipse.viatra.solver.language.solverLanguage.False;
import org.eclipse.viatra.solver.language.solverLanguage.FieldRelationInterpretation;
import org.eclipse.viatra.solver.language.solverLanguage.GlobalRelationInterpretation;
import org.eclipse.viatra.solver.language.solverLanguage.IntObject;
import org.eclipse.viatra.solver.language.solverLanguage.IntegerSymbol;
import org.eclipse.viatra.solver.language.solverLanguage.IrreflexiveClosure;
import org.eclipse.viatra.solver.language.solverLanguage.ModelSymbol;
import org.eclipse.viatra.solver.language.solverLanguage.MultiplicityDefinition;
import org.eclipse.viatra.solver.language.solverLanguage.NamedObject;
import org.eclipse.viatra.solver.language.solverLanguage.Negative;
import org.eclipse.viatra.solver.language.solverLanguage.PatternBody;
import org.eclipse.viatra.solver.language.solverLanguage.Positive;
import org.eclipse.viatra.solver.language.solverLanguage.Predicate;
import org.eclipse.viatra.solver.language.solverLanguage.Problem;
import org.eclipse.viatra.solver.language.solverLanguage.RealObject;
import org.eclipse.viatra.solver.language.solverLanguage.RealSymbol;
import org.eclipse.viatra.solver.language.solverLanguage.ReflexiveClosure;
import org.eclipse.viatra.solver.language.solverLanguage.SolverLanguagePackage;
import org.eclipse.viatra.solver.language.solverLanguage.StringObject;
import org.eclipse.viatra.solver.language.solverLanguage.StringSymbol;
import org.eclipse.viatra.solver.language.solverLanguage.True;
import org.eclipse.viatra.solver.language.solverLanguage.Unknown;
import org.eclipse.viatra.solver.language.solverLanguage.UnnamedObject;
import org.eclipse.viatra.solver.language.solverLanguage.Variable;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class SolverLanguageSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private SolverLanguageGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == SolverLanguagePackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case SolverLanguagePackage.ALL_INSTANCES:
				sequence_AllInstances(context, (AllInstances) semanticObject); 
				return; 
			case SolverLanguagePackage.ALL_OBJECTS:
				sequence_AllObjects(context, (AllObjects) semanticObject); 
				return; 
			case SolverLanguagePackage.BASIC_INTERPRETATION:
				sequence_BasicInterpretation(context, (BasicInterpretation) semanticObject); 
				return; 
			case SolverLanguagePackage.BOOLEAN_FALSE:
				sequence_BooleanValue(context, (BooleanFalse) semanticObject); 
				return; 
			case SolverLanguagePackage.BOOLEAN_OBJECT:
				sequence_BooleanObject(context, (BooleanObject) semanticObject); 
				return; 
			case SolverLanguagePackage.BOOLEAN_SYMBOL:
				sequence_BooleanSymbol(context, (BooleanSymbol) semanticObject); 
				return; 
			case SolverLanguagePackage.BOOLEAN_TRUE:
				sequence_BooleanValue(context, (BooleanTrue) semanticObject); 
				return; 
			case SolverLanguagePackage.CLASS_INTERPRETATION:
				sequence_ClassInterpretation(context, (ClassInterpretation) semanticObject); 
				return; 
			case SolverLanguagePackage.CONSTRAINT:
				sequence_Constraint(context, (Constraint) semanticObject); 
				return; 
			case SolverLanguagePackage.DEFAULT_INTERPRETATION:
				sequence_DefaultInterpretation(context, (DefaultInterpretation) semanticObject); 
				return; 
			case SolverLanguagePackage.ENUM_INTERPRETATION:
				sequence_EnumInterpretation(context, (EnumInterpretation) semanticObject); 
				return; 
			case SolverLanguagePackage.EQUALS_SYMBOL:
				sequence_EqualsSymbol(context, (EqualsSymbol) semanticObject); 
				return; 
			case SolverLanguagePackage.ERROR:
				sequence_TruthValue(context, (org.eclipse.viatra.solver.language.solverLanguage.Error) semanticObject); 
				return; 
			case SolverLanguagePackage.EXIST_SYMBOL:
				sequence_ExistSymbol(context, (ExistSymbol) semanticObject); 
				return; 
			case SolverLanguagePackage.FALSE:
				sequence_TruthValue(context, (False) semanticObject); 
				return; 
			case SolverLanguagePackage.FIELD_RELATION_INTERPRETATION:
				sequence_FieldRelationInterpretation(context, (FieldRelationInterpretation) semanticObject); 
				return; 
			case SolverLanguagePackage.GLOBAL_RELATION_INTERPRETATION:
				sequence_GlobalRelationInterpretation(context, (GlobalRelationInterpretation) semanticObject); 
				return; 
			case SolverLanguagePackage.INT_OBJECT:
				sequence_IntObject(context, (IntObject) semanticObject); 
				return; 
			case SolverLanguagePackage.INTEGER_SYMBOL:
				sequence_IntegerSymbol(context, (IntegerSymbol) semanticObject); 
				return; 
			case SolverLanguagePackage.IRREFLEXIVE_CLOSURE:
				sequence_ClosureType(context, (IrreflexiveClosure) semanticObject); 
				return; 
			case SolverLanguagePackage.MODEL_SYMBOL:
				sequence_ModelSymbol(context, (ModelSymbol) semanticObject); 
				return; 
			case SolverLanguagePackage.MULTIPLICITY_DEFINITION:
				sequence_MultiplicityDefinition(context, (MultiplicityDefinition) semanticObject); 
				return; 
			case SolverLanguagePackage.NAMED_OBJECT:
				sequence_NamedObject(context, (NamedObject) semanticObject); 
				return; 
			case SolverLanguagePackage.NEGATIVE:
				sequence_Polarity(context, (Negative) semanticObject); 
				return; 
			case SolverLanguagePackage.PARAMETER:
				sequence_Parameter(context, (org.eclipse.viatra.solver.language.solverLanguage.Parameter) semanticObject); 
				return; 
			case SolverLanguagePackage.PATTERN_BODY:
				sequence_PatternBody(context, (PatternBody) semanticObject); 
				return; 
			case SolverLanguagePackage.POSITIVE:
				sequence_Polarity(context, (Positive) semanticObject); 
				return; 
			case SolverLanguagePackage.PREDICATE:
				sequence_Predicate(context, (Predicate) semanticObject); 
				return; 
			case SolverLanguagePackage.PROBLEM:
				sequence_Problem(context, (Problem) semanticObject); 
				return; 
			case SolverLanguagePackage.REAL_OBJECT:
				sequence_RealObject(context, (RealObject) semanticObject); 
				return; 
			case SolverLanguagePackage.REAL_SYMBOL:
				sequence_RealSymbol(context, (RealSymbol) semanticObject); 
				return; 
			case SolverLanguagePackage.REFLEXIVE_CLOSURE:
				sequence_ClosureType(context, (ReflexiveClosure) semanticObject); 
				return; 
			case SolverLanguagePackage.STRING_OBJECT:
				sequence_StringObject(context, (StringObject) semanticObject); 
				return; 
			case SolverLanguagePackage.STRING_SYMBOL:
				sequence_StringSymbol(context, (StringSymbol) semanticObject); 
				return; 
			case SolverLanguagePackage.TRUE:
				sequence_TruthValue(context, (True) semanticObject); 
				return; 
			case SolverLanguagePackage.UNKNOWN:
				sequence_TruthValue(context, (Unknown) semanticObject); 
				return; 
			case SolverLanguagePackage.UNNAMED_OBJECT:
				sequence_UnnamedObject(context, (UnnamedObject) semanticObject); 
				return; 
			case SolverLanguagePackage.VARIABLE:
				sequence_Variable(context, (Variable) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     ComplexObject returns AllInstances
	 *     AllInstances returns AllInstances
	 *
	 * Constraint:
	 *     symbol=Symbol
	 */
	protected void sequence_AllInstances(ISerializationContext context, AllInstances semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SolverLanguagePackage.Literals.ALL_INSTANCES__SYMBOL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SolverLanguagePackage.Literals.ALL_INSTANCES__SYMBOL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAllInstancesAccess().getSymbolSymbolParserRuleCall_1_0(), semanticObject.getSymbol());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ComplexObject returns AllObjects
	 *     AllObjects returns AllObjects
	 *
	 * Constraint:
	 *     {AllObjects}
	 */
	protected void sequence_AllObjects(ISerializationContext context, AllObjects semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns BasicInterpretation
	 *     Interpretation returns BasicInterpretation
	 *     BasicInterpretation returns BasicInterpretation
	 *
	 * Constraint:
	 *     (symbol=Symbol (objects+=ComplexObject objects+=ComplexObject*)? value=TruthValue)
	 */
	protected void sequence_BasicInterpretation(ISerializationContext context, BasicInterpretation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ComplexObject returns BooleanObject
	 *     Object returns BooleanObject
	 *     DataObject returns BooleanObject
	 *     BooleanObject returns BooleanObject
	 *     Literal returns BooleanObject
	 *
	 * Constraint:
	 *     value=BooleanValue
	 */
	protected void sequence_BooleanObject(ISerializationContext context, BooleanObject semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SolverLanguagePackage.Literals.BOOLEAN_OBJECT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SolverLanguagePackage.Literals.BOOLEAN_OBJECT__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBooleanObjectAccess().getValueBooleanValueParserRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Symbol returns BooleanSymbol
	 *     DataSymbol returns BooleanSymbol
	 *     BooleanSymbol returns BooleanSymbol
	 *
	 * Constraint:
	 *     {BooleanSymbol}
	 */
	protected void sequence_BooleanSymbol(ISerializationContext context, BooleanSymbol semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     BooleanValue returns BooleanFalse
	 *
	 * Constraint:
	 *     {BooleanFalse}
	 */
	protected void sequence_BooleanValue(ISerializationContext context, BooleanFalse semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     BooleanValue returns BooleanTrue
	 *
	 * Constraint:
	 *     {BooleanTrue}
	 */
	protected void sequence_BooleanValue(ISerializationContext context, BooleanTrue semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns ClassInterpretation
	 *     Interpretation returns ClassInterpretation
	 *     CDInterpretation returns ClassInterpretation
	 *     ClassInterpretation returns ClassInterpretation
	 *
	 * Constraint:
	 *     (abstract?='abstract'? symbol=ModelSymbol supertypes+=ModelSymbol* fielt+=FieldRelationInterpretation*)
	 */
	protected void sequence_ClassInterpretation(ISerializationContext context, ClassInterpretation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ClosureType returns IrreflexiveClosure
	 *
	 * Constraint:
	 *     {IrreflexiveClosure}
	 */
	protected void sequence_ClosureType(ISerializationContext context, IrreflexiveClosure semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ClosureType returns ReflexiveClosure
	 *
	 * Constraint:
	 *     {ReflexiveClosure}
	 */
	protected void sequence_ClosureType(ISerializationContext context, ReflexiveClosure semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Constraint returns Constraint
	 *
	 * Constraint:
	 *     ((polarity=Polarity? symbol=ModelSymbol params+=Literal? params+=Literal*) | (closureType=ClosureType params+=Literal? params+=Literal*))
	 */
	protected void sequence_Constraint(ISerializationContext context, Constraint semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns DefaultInterpretation
	 *     Interpretation returns DefaultInterpretation
	 *     DefaultInterpretation returns DefaultInterpretation
	 *
	 * Constraint:
	 *     interpretation=BasicInterpretation
	 */
	protected void sequence_DefaultInterpretation(ISerializationContext context, DefaultInterpretation semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SolverLanguagePackage.Literals.DEFAULT_INTERPRETATION__INTERPRETATION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SolverLanguagePackage.Literals.DEFAULT_INTERPRETATION__INTERPRETATION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDefaultInterpretationAccess().getInterpretationBasicInterpretationParserRuleCall_1_0(), semanticObject.getInterpretation());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns EnumInterpretation
	 *     Interpretation returns EnumInterpretation
	 *     CDInterpretation returns EnumInterpretation
	 *     EnumInterpretation returns EnumInterpretation
	 *
	 * Constraint:
	 *     (Symbol=ModelSymbol objects+=NamedObject+)
	 */
	protected void sequence_EnumInterpretation(ISerializationContext context, EnumInterpretation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Symbol returns EqualsSymbol
	 *     PartialitySymbol returns EqualsSymbol
	 *     EqualsSymbol returns EqualsSymbol
	 *
	 * Constraint:
	 *     {EqualsSymbol}
	 */
	protected void sequence_EqualsSymbol(ISerializationContext context, EqualsSymbol semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Symbol returns ExistSymbol
	 *     PartialitySymbol returns ExistSymbol
	 *     ExistSymbol returns ExistSymbol
	 *
	 * Constraint:
	 *     {ExistSymbol}
	 */
	protected void sequence_ExistSymbol(ISerializationContext context, ExistSymbol semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     FieldRelationInterpretation returns FieldRelationInterpretation
	 *
	 * Constraint:
	 *     (containment?='containment'? symbol=ModelSymbol multiplicity=MultiplicityDefinition? target=Symbol)
	 */
	protected void sequence_FieldRelationInterpretation(ISerializationContext context, FieldRelationInterpretation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns GlobalRelationInterpretation
	 *     Interpretation returns GlobalRelationInterpretation
	 *     CDInterpretation returns GlobalRelationInterpretation
	 *     GlobalRelationInterpretation returns GlobalRelationInterpretation
	 *
	 * Constraint:
	 *     (
	 *         containment?='containment'? 
	 *         symbol=ModelSymbol 
	 *         sourceMultiplicity=MultiplicityDefinition? 
	 *         source=Symbol 
	 *         targetMultiplicity=MultiplicityDefinition? 
	 *         target=Symbol
	 *     )
	 */
	protected void sequence_GlobalRelationInterpretation(ISerializationContext context, GlobalRelationInterpretation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ComplexObject returns IntObject
	 *     Object returns IntObject
	 *     DataObject returns IntObject
	 *     IntObject returns IntObject
	 *     Literal returns IntObject
	 *
	 * Constraint:
	 *     value=INTLiteral
	 */
	protected void sequence_IntObject(ISerializationContext context, IntObject semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SolverLanguagePackage.Literals.INT_OBJECT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SolverLanguagePackage.Literals.INT_OBJECT__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getIntObjectAccess().getValueINTLiteralParserRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Symbol returns IntegerSymbol
	 *     DataSymbol returns IntegerSymbol
	 *     IntegerSymbol returns IntegerSymbol
	 *
	 * Constraint:
	 *     {IntegerSymbol}
	 */
	protected void sequence_IntegerSymbol(ISerializationContext context, IntegerSymbol semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Symbol returns ModelSymbol
	 *     ModelSymbol returns ModelSymbol
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_ModelSymbol(ISerializationContext context, ModelSymbol semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SolverLanguagePackage.Literals.MODEL_SYMBOL__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SolverLanguagePackage.Literals.MODEL_SYMBOL__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getModelSymbolAccess().getNameIDTerminalRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     MultiplicityDefinition returns MultiplicityDefinition
	 *
	 * Constraint:
	 *     (lower=INT (upper=INT | unlimitedUpper?='*'))
	 */
	protected void sequence_MultiplicityDefinition(ISerializationContext context, MultiplicityDefinition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ComplexObject returns NamedObject
	 *     Object returns NamedObject
	 *     NamedObject returns NamedObject
	 *     Literal returns NamedObject
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_NamedObject(ISerializationContext context, NamedObject semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SolverLanguagePackage.Literals.NAMED_OBJECT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SolverLanguagePackage.Literals.NAMED_OBJECT__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNamedObjectAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Parameter returns Parameter
	 *
	 * Constraint:
	 *     (variable=Variable type=Symbol?)
	 */
	protected void sequence_Parameter(ISerializationContext context, org.eclipse.viatra.solver.language.solverLanguage.Parameter semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PatternBody returns PatternBody
	 *
	 * Constraint:
	 *     constraints+=Constraint*
	 */
	protected void sequence_PatternBody(ISerializationContext context, PatternBody semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Polarity returns Negative
	 *
	 * Constraint:
	 *     {Negative}
	 */
	protected void sequence_Polarity(ISerializationContext context, Negative semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Polarity returns Positive
	 *
	 * Constraint:
	 *     {Positive}
	 */
	protected void sequence_Polarity(ISerializationContext context, Positive semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns Predicate
	 *     Predicate returns Predicate
	 *
	 * Constraint:
	 *     (isError?='error'? symbol=ModelSymbol (parameters+=Parameter parameters+=Parameter*)? (bodies+=PatternBody bodies+=PatternBody*)?)
	 */
	protected void sequence_Predicate(ISerializationContext context, Predicate semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Problem returns Problem
	 *
	 * Constraint:
	 *     statements+=Statement+
	 */
	protected void sequence_Problem(ISerializationContext context, Problem semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ComplexObject returns RealObject
	 *     Object returns RealObject
	 *     DataObject returns RealObject
	 *     RealObject returns RealObject
	 *     Literal returns RealObject
	 *
	 * Constraint:
	 *     value=REALLiteral
	 */
	protected void sequence_RealObject(ISerializationContext context, RealObject semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SolverLanguagePackage.Literals.REAL_OBJECT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SolverLanguagePackage.Literals.REAL_OBJECT__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRealObjectAccess().getValueREALLiteralParserRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Symbol returns RealSymbol
	 *     DataSymbol returns RealSymbol
	 *     RealSymbol returns RealSymbol
	 *
	 * Constraint:
	 *     {RealSymbol}
	 */
	protected void sequence_RealSymbol(ISerializationContext context, RealSymbol semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ComplexObject returns StringObject
	 *     Object returns StringObject
	 *     DataObject returns StringObject
	 *     StringObject returns StringObject
	 *     Literal returns StringObject
	 *
	 * Constraint:
	 *     value=STRING
	 */
	protected void sequence_StringObject(ISerializationContext context, StringObject semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SolverLanguagePackage.Literals.STRING_OBJECT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SolverLanguagePackage.Literals.STRING_OBJECT__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getStringObjectAccess().getValueSTRINGTerminalRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Symbol returns StringSymbol
	 *     DataSymbol returns StringSymbol
	 *     StringSymbol returns StringSymbol
	 *
	 * Constraint:
	 *     {StringSymbol}
	 */
	protected void sequence_StringSymbol(ISerializationContext context, StringSymbol semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TruthValue returns Error
	 *
	 * Constraint:
	 *     {Error}
	 */
	protected void sequence_TruthValue(ISerializationContext context, org.eclipse.viatra.solver.language.solverLanguage.Error semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TruthValue returns False
	 *
	 * Constraint:
	 *     {False}
	 */
	protected void sequence_TruthValue(ISerializationContext context, False semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TruthValue returns True
	 *
	 * Constraint:
	 *     {True}
	 */
	protected void sequence_TruthValue(ISerializationContext context, True semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TruthValue returns Unknown
	 *
	 * Constraint:
	 *     {Unknown}
	 */
	protected void sequence_TruthValue(ISerializationContext context, Unknown semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ComplexObject returns UnnamedObject
	 *     Object returns UnnamedObject
	 *     UnnamedObject returns UnnamedObject
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_UnnamedObject(ISerializationContext context, UnnamedObject semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SolverLanguagePackage.Literals.UNNAMED_OBJECT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SolverLanguagePackage.Literals.UNNAMED_OBJECT__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getUnnamedObjectAccess().getNameIDTerminalRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Literal returns Variable
	 *     Variable returns Variable
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_Variable(ISerializationContext context, Variable semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SolverLanguagePackage.Literals.VARIABLE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SolverLanguagePackage.Literals.VARIABLE__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVariableAccess().getNameIDTerminalRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
}
