/*
 * generated by Xtext 2.10.0
 */
package hu.bme.mit.inf.dslreasoner.application.serializer;

import com.google.inject.Inject;
import hu.bme.mit.inf.dslreasoner.application.applicationConfiguration.AllPackageEntry;
import hu.bme.mit.inf.dslreasoner.application.applicationConfiguration.ApplicationConfigurationPackage;
import hu.bme.mit.inf.dslreasoner.application.applicationConfiguration.ConfigurationScript;
import hu.bme.mit.inf.dslreasoner.application.applicationConfiguration.EPackageImport;
import hu.bme.mit.inf.dslreasoner.application.applicationConfiguration.MetamodelDeclaration;
import hu.bme.mit.inf.dslreasoner.application.applicationConfiguration.MetamodelElement;
import hu.bme.mit.inf.dslreasoner.application.applicationConfiguration.MetamodelReference;
import hu.bme.mit.inf.dslreasoner.application.applicationConfiguration.MetamodelSpecification;
import hu.bme.mit.inf.dslreasoner.application.applicationConfiguration.ViatraImport;
import hu.bme.mit.inf.dslreasoner.application.services.ApplicationConfigurationGrammarAccess;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class ApplicationConfigurationSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private ApplicationConfigurationGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == ApplicationConfigurationPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case ApplicationConfigurationPackage.ALL_PACKAGE_ENTRY:
				sequence_AllPackageEntry(context, (AllPackageEntry) semanticObject); 
				return; 
			case ApplicationConfigurationPackage.CONFIGURATION_SCRIPT:
				sequence_ConfigurationScript(context, (ConfigurationScript) semanticObject); 
				return; 
			case ApplicationConfigurationPackage.EPACKAGE_IMPORT:
				sequence_EPackageImport(context, (EPackageImport) semanticObject); 
				return; 
			case ApplicationConfigurationPackage.METAMODEL_DECLARATION:
				sequence_MetamodelDeclaration(context, (MetamodelDeclaration) semanticObject); 
				return; 
			case ApplicationConfigurationPackage.METAMODEL_ELEMENT:
				sequence_MetamodelElement(context, (MetamodelElement) semanticObject); 
				return; 
			case ApplicationConfigurationPackage.METAMODEL_REFERENCE:
				sequence_MetamodelReference(context, (MetamodelReference) semanticObject); 
				return; 
			case ApplicationConfigurationPackage.METAMODEL_SPECIFICATION:
				sequence_MetamodelSpecification(context, (MetamodelSpecification) semanticObject); 
				return; 
			case ApplicationConfigurationPackage.VIATRA_IMPORT:
				sequence_ViatraImport(context, (ViatraImport) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     MetamodelEntry returns AllPackageEntry
	 *     AllPackageEntry returns AllPackageEntry
	 *
	 * Constraint:
	 *     (package=[EPackage|ID] (exclusion+=MetamodelElement exclusion+=MetamodelElement*)?)
	 */
	protected void sequence_AllPackageEntry(ISerializationContext context, AllPackageEntry semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ConfigurationScript returns ConfigurationScript
	 *
	 * Constraint:
	 *     ((imports+=Import+ commands+=Command+) | commands+=Command+)?
	 */
	protected void sequence_ConfigurationScript(ISerializationContext context, ConfigurationScript semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Import returns EPackageImport
	 *     EPackageImport returns EPackageImport
	 *
	 * Constraint:
	 *     importedPackage=[EPackage|STRING]
	 */
	protected void sequence_EPackageImport(ISerializationContext context, EPackageImport semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ApplicationConfigurationPackage.Literals.EPACKAGE_IMPORT__IMPORTED_PACKAGE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ApplicationConfigurationPackage.Literals.EPACKAGE_IMPORT__IMPORTED_PACKAGE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEPackageImportAccess().getImportedPackageEPackageSTRINGTerminalRuleCall_2_0_1(), semanticObject.getImportedPackage());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Command returns MetamodelDeclaration
	 *     Declaration returns MetamodelDeclaration
	 *     MetamodelDeclaration returns MetamodelDeclaration
	 *
	 * Constraint:
	 *     (name=ID specification=MetamodelSpecification)
	 */
	protected void sequence_MetamodelDeclaration(ISerializationContext context, MetamodelDeclaration semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ApplicationConfigurationPackage.Literals.METAMODEL_DECLARATION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ApplicationConfigurationPackage.Literals.METAMODEL_DECLARATION__NAME));
			if (transientValues.isValueTransient(semanticObject, ApplicationConfigurationPackage.Literals.METAMODEL_DECLARATION__SPECIFICATION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ApplicationConfigurationPackage.Literals.METAMODEL_DECLARATION__SPECIFICATION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMetamodelDeclarationAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getMetamodelDeclarationAccess().getSpecificationMetamodelSpecificationParserRuleCall_2_0(), semanticObject.getSpecification());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     MetamodelEntry returns MetamodelElement
	 *     MetamodelElement returns MetamodelElement
	 *
	 * Constraint:
	 *     (package=[EPackage|ID]? classifier=[EClassifier|ID] feature=[ENamedElement|ID]?)
	 */
	protected void sequence_MetamodelElement(ISerializationContext context, MetamodelElement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MetamodelReference returns MetamodelReference
	 *     Metamodel returns MetamodelReference
	 *
	 * Constraint:
	 *     referred=[MetamodelDeclaration|ID]
	 */
	protected void sequence_MetamodelReference(ISerializationContext context, MetamodelReference semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ApplicationConfigurationPackage.Literals.METAMODEL_REFERENCE__REFERRED) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ApplicationConfigurationPackage.Literals.METAMODEL_REFERENCE__REFERRED));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMetamodelReferenceAccess().getReferredMetamodelDeclarationIDTerminalRuleCall_0_1(), semanticObject.getReferred());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     MetamodelSpecification returns MetamodelSpecification
	 *     Metamodel returns MetamodelSpecification
	 *
	 * Constraint:
	 *     (entries+=MetamodelEntry entries+=MetamodelEntry*)
	 */
	protected void sequence_MetamodelSpecification(ISerializationContext context, MetamodelSpecification semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Import returns ViatraImport
	 *     ViatraImport returns ViatraImport
	 *
	 * Constraint:
	 *     importedViatra=[PatternModel|STRING]
	 */
	protected void sequence_ViatraImport(ISerializationContext context, ViatraImport semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ApplicationConfigurationPackage.Literals.VIATRA_IMPORT__IMPORTED_VIATRA) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ApplicationConfigurationPackage.Literals.VIATRA_IMPORT__IMPORTED_VIATRA));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getViatraImportAccess().getImportedViatraPatternModelSTRINGTerminalRuleCall_2_0_1(), semanticObject.getImportedViatra());
		feeder.finish();
	}
	
	
}
