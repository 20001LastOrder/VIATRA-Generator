import epackage "http://www.bme.hu/mit/inf/dslreasoner/viatrasolver/partialinterpretationlanguage"
import epackage "http://www.bme.hu/mit/inf/dslreasoner/logic/model/problem"
import epackage "http://www.bme.hu/mit/inf/dslreasoner/logic/model/language"

//////////
// 0. Util
//////////
private pattern interpretation(problem:LogicProblem, interpretation:PartialInterpretation) {
	PartialInterpretation.problem(interpretation,problem);
}
	
/////////////////////////
// 0.1 Existence
/////////////////////////
private pattern mustExist(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	find interpretation(problem,interpretation);
	LogicProblem.elements(problem,element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
}

private pattern mayExist(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
    find mustExist(problem,interpretation,element);
} or {
    find interpretation(problem,interpretation);
    neg find elementCloseWorld(element);
    PartialInterpretation.openWorldElements(interpretation,element);
}

private pattern elementCloseWorld(element:DefinedElement) {
	PartialInterpretation.openWorldElements(i,element);
    PartialInterpretation.maxNewElements(i,0);
} or {
	Scope.targetTypeInterpretation(scope,interpretation);
	PartialTypeInterpratation.elements(interpretation,element);
	Scope.maxNewElements(scope,0);
}

////////////////////////
// 0.2 Equivalence
////////////////////////
pattern mayEquivalent(problem:LogicProblem, interpretation:PartialInterpretation, a: DefinedElement, b: DefinedElement) {
	find mayExist(problem,interpretation,a);
	find mayExist(problem,interpretation,b);
	a == b;
}

////////////////////////
// 0.3 Required Patterns by TypeIndexer
////////////////////////
private pattern typeInterpretation(problem:LogicProblem, interpretation:PartialInterpretation, type:TypeDeclaration, typeInterpretation:PartialComplexTypeInterpretation) {
	find interpretation(problem,interpretation);
	LogicProblem.types(problem,type);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
}

private pattern directInstanceOf(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement, type:Type) {
	find interpretation(problem,interpretation);
	LogicProblem.types(problem,type);
	TypeDefinition.elements(type,element);
} or {
	find interpretation(problem,interpretation);
	find typeInterpretation(problem,interpretation,type,typeInterpretation);
	PartialComplexTypeInterpretation.elements(typeInterpretation,element);
}

private pattern isPrimitive(element: PrimitiveElement) {
	PrimitiveElement(element);
}

//////////
// 1. Problem-Specific Base Indexers
//////////
// 1.1 Type Indexers
//////////
// 1.1.1 primitive Type Indexers
//////////

//////////
// 1.1.2 domain-specific Type Indexers
//////////
/**
 * An element must be an instance of type "FunctionalElement class".
 */
private pattern mustInstanceOfFunctionalElement_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalElement class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalElement_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalElement class");
}

/**
 * An element may be an instance of type "FunctionalElement class".
 */
private pattern mayInstanceOfFunctionalElement_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunction_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalElement_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunction_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalElement_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalElement_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalArchitectureModel class".
 */
private pattern mustInstanceOfFunctionalArchitectureModel_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalArchitectureModel class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalArchitectureModel_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalArchitectureModel class");
}

/**
 * An element may be an instance of type "FunctionalArchitectureModel class".
 */
private pattern mayInstanceOfFunctionalArchitectureModel_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalArchitectureModel_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalArchitectureModel_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Function class".
 */
private pattern mustInstanceOfFunction_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Function class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunction_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Function class");
}

/**
 * An element may be an instance of type "Function class".
 */
private pattern mayInstanceOfFunction_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunction_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunction_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunction_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FAMTerminator class".
 */
private pattern mustInstanceOfFAMTerminator_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FAMTerminator class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFAMTerminator_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FAMTerminator class");
}

/**
 * An element may be an instance of type "FAMTerminator class".
 */
private pattern mayInstanceOfFAMTerminator_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find scopeDisallowsNewFAMTerminator_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find scopeDisallowsNewFAMTerminator_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFAMTerminator_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "InformationLink class".
 */
private pattern mustInstanceOfInformationLink_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"InformationLink class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewInformationLink_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"InformationLink class");
}

/**
 * An element may be an instance of type "InformationLink class".
 */
private pattern mayInstanceOfInformationLink_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find scopeDisallowsNewInformationLink_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find scopeDisallowsNewInformationLink_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfInformationLink_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalInterface class".
 */
private pattern mustInstanceOfFunctionalInterface_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalInterface class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalInterface_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalInterface class");
}

/**
 * An element may be an instance of type "FunctionalInterface class".
 */
private pattern mayInstanceOfFunctionalInterface_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalInterface_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalInterface_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalInterface_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalInput class".
 */
private pattern mustInstanceOfFunctionalInput_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalInput class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalInput_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalInput class");
}

/**
 * An element may be an instance of type "FunctionalInput class".
 */
private pattern mayInstanceOfFunctionalInput_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalInput_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalInput_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalInput_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalOutput class".
 */
private pattern mustInstanceOfFunctionalOutput_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalOutput class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalOutput_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalOutput class");
}

/**
 * An element may be an instance of type "FunctionalOutput class".
 */
private pattern mayInstanceOfFunctionalOutput_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalOutput_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalOutput_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalOutput_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalData class".
 */
private pattern mustInstanceOfFunctionalData_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalData class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalData_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalData class");
}

/**
 * An element may be an instance of type "FunctionalData class".
 */
private pattern mayInstanceOfFunctionalData_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalData_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalData_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalData_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionType enum".
 */
private pattern mustInstanceOfFunctionType_enum(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionType enum");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionType_enum(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionType enum");
}

/**
 * An element may be an instance of type "FunctionType enum".
 */
private pattern mayInstanceOfFunctionType_enum(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfFunctionType_enum(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalArchitectureModel class DefinedPart".
 */
private pattern mustInstanceOfFunctionalArchitectureModel_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalArchitectureModel class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalArchitectureModel_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalArchitectureModel class DefinedPart");
}

/**
 * An element may be an instance of type "FunctionalArchitectureModel class DefinedPart".
 */
private pattern mayInstanceOfFunctionalArchitectureModel_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfFunctionalArchitectureModel_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalArchitectureModel class UndefinedPart".
 */
private pattern mustInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalArchitectureModel class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalArchitectureModel_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalArchitectureModel class UndefinedPart");
}

/**
 * An element may be an instance of type "FunctionalArchitectureModel class UndefinedPart".
 */
private pattern mayInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalArchitectureModel_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalArchitectureModel_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem,interpretation,element); }

//////////
// 1.2 Relation Declaration Indexers
//////////
/**
 * Matcher for detecting tuples t where []interface reference FunctionalElement(source,target)
 */
private pattern mustInRelationinterface_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"interface reference FunctionalElement");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>interface reference FunctionalElement(source,target)
 */
private pattern mayInRelationinterface_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalElement_class(problem,interpretation,source);
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationinterface_reference_FunctionalElement(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationelement_reference_FunctionalInterface(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationinterface_reference_FunctionalElement(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []model reference FunctionalElement(source,target)
 */
 private pattern mustInRelationmodel_reference_FunctionalElement(
 	problem:LogicProblem, interpretation:PartialInterpretation,
 	source: DefinedElement, target:DefinedElement)
 {
 	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_model(problem,interpretation,source,target);
 }
/**
 * Matcher for detecting tuples t where []model reference FunctionalElement(source,target)
 */
 private pattern mayInRelationmodel_reference_FunctionalElement(
 	problem:LogicProblem, interpretation:PartialInterpretation,
 	source: DefinedElement, target:DefinedElement)
 {
 	find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_model(problem,interpretation,source,target);
 }
/**
 * Matcher for detecting tuples t where []parent reference FunctionalElement(source,target)
 */
private pattern mustInRelationparent_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"parent reference FunctionalElement");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>parent reference FunctionalElement(source,target)
 */
private pattern mayInRelationparent_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalElement_class(problem,interpretation,source);
	find mayInstanceOfFunction_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationparent_reference_FunctionalElement(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationparent_reference_FunctionalElement(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []rootElements reference FunctionalArchitectureModel(source,target)
 */
private pattern mustInRelationrootElements_reference_FunctionalArchitectureModel(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"rootElements reference FunctionalArchitectureModel");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>rootElements reference FunctionalArchitectureModel(source,target)
 */
private pattern mayInRelationrootElements_reference_FunctionalArchitectureModel(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalArchitectureModel_class(problem,interpretation,source);
	find mayInstanceOfFunctionalElement_class(problem,interpretation,target);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationrootElements_reference_FunctionalArchitectureModel(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []subElements reference Function(source,target)
 */
private pattern mustInRelationsubElements_reference_Function(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"subElements reference Function");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>subElements reference Function(source,target)
 */
private pattern mayInRelationsubElements_reference_Function(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunction_class(problem,interpretation,source);
	find mayInstanceOfFunctionalElement_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationparent_reference_FunctionalElement(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationsubElements_reference_Function(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []data reference FAMTerminator(source,target)
 */
private pattern mustInRelationdata_reference_FAMTerminator(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"data reference FAMTerminator");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>data reference FAMTerminator(source,target)
 */
private pattern mayInRelationdata_reference_FAMTerminator(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFAMTerminator_class(problem,interpretation,source);
	find mayInstanceOfFunctionalData_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationdata_reference_FAMTerminator(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationterminator_reference_FunctionalData(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationdata_reference_FAMTerminator(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []from reference InformationLink(source,target)
 */
private pattern mustInRelationfrom_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"from reference InformationLink");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>from reference InformationLink(source,target)
 */
private pattern mayInRelationfrom_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfInformationLink_class(problem,interpretation,source);
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationfrom_reference_InformationLink(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationfrom_reference_InformationLink(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []to reference InformationLink(source,target)
 */
private pattern mustInRelationto_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"to reference InformationLink");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>to reference InformationLink(source,target)
 */
private pattern mayInRelationto_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfInformationLink_class(problem,interpretation,source);
	find mayInstanceOfFunctionalInput_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationto_reference_InformationLink(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationto_reference_InformationLink(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []data reference FunctionalInterface(source,target)
 */
private pattern mustInRelationdata_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"data reference FunctionalInterface");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>data reference FunctionalInterface(source,target)
 */
private pattern mayInRelationdata_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,source);
	find mayInstanceOfFunctionalData_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationinterface_reference_FunctionalData(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationdata_reference_FunctionalInterface(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []element reference FunctionalInterface(source,target)
 */
private pattern mustInRelationelement_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"element reference FunctionalInterface");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>element reference FunctionalInterface(source,target)
 */
private pattern mayInRelationelement_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,source);
	find mayInstanceOfFunctionalElement_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationelement_reference_FunctionalInterface(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationinterface_reference_FunctionalElement(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationelement_reference_FunctionalInterface(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []IncomingLinks reference FunctionalInput(source,target)
 */
private pattern mustInRelationIncomingLinks_reference_FunctionalInput(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"IncomingLinks reference FunctionalInput");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>IncomingLinks reference FunctionalInput(source,target)
 */
private pattern mayInRelationIncomingLinks_reference_FunctionalInput(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalInput_class(problem,interpretation,source);
	find mayInstanceOfInformationLink_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationto_reference_InformationLink(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
} or {
	find mustInRelationIncomingLinks_reference_FunctionalInput(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []outgoingLinks reference FunctionalOutput(source,target)
 */
private pattern mustInRelationoutgoingLinks_reference_FunctionalOutput(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"outgoingLinks reference FunctionalOutput");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>outgoingLinks reference FunctionalOutput(source,target)
 */
private pattern mayInRelationoutgoingLinks_reference_FunctionalOutput(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,source);
	find mayInstanceOfInformationLink_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationfrom_reference_InformationLink(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationoutgoingLinks_reference_FunctionalOutput(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []terminator reference FunctionalData(source,target)
 */
private pattern mustInRelationterminator_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"terminator reference FunctionalData");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>terminator reference FunctionalData(source,target)
 */
private pattern mayInRelationterminator_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalData_class(problem,interpretation,source);
	find mayInstanceOfFAMTerminator_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationterminator_reference_FunctionalData(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationdata_reference_FAMTerminator(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationterminator_reference_FunctionalData(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []interface reference FunctionalData(source,target)
 */
private pattern mustInRelationinterface_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"interface reference FunctionalData");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>interface reference FunctionalData(source,target)
 */
private pattern mayInRelationinterface_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalData_class(problem,interpretation,source);
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationinterface_reference_FunctionalData(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationinterface_reference_FunctionalData(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []type attribute Function(source,target)
 */
 private pattern mustInRelationtype_attribute_Function(
 	problem:LogicProblem, interpretation:PartialInterpretation,
 	source: DefinedElement, target:DefinedElement)
 {
 	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_type(problem,interpretation,source,target);
 }
/**
 * Matcher for detecting tuples t where []type attribute Function(source,target)
 */
 private pattern mayInRelationtype_attribute_Function(
 	problem:LogicProblem, interpretation:PartialInterpretation,
 	source: DefinedElement, target:DefinedElement)
 {
 	find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_type(problem,interpretation,source,target);
 }

//////////
// 1.3 Relation Definition Indexers
//////////
// Must, May and Current queries for pattern ca mcgill ecse dslreasoner standalone test fam terminatorAndInformation
private pattern mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_terminatorAndInformation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_T, var_I)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfFAMTerminator_class(problem,interpretation,var_T);
	find mustInstanceOfInformationLink_class(problem,interpretation,var_I);
	// T is exported
	// I is exported
	find mustInstanceOfFunctionalOutput_class(problem,interpretation,var_Out);
	find mustInRelationoutgoingLinks_reference_FunctionalOutput(problem,interpretation,var_Out,var_virtual0);
	find mustInstanceOfInformationLink_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_I;
	find mustInstanceOfFunctionalOutput_class(problem,interpretation,var_Out);
	find mustInRelationterminator_reference_FunctionalData(problem,interpretation,var_Out,var_virtual1);
	find mustInstanceOfFAMTerminator_class(problem,interpretation,var_virtual1);
	var_virtual1 == var_T;
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFAMTerminator_class(problem,interpretation,var_T);
	find mustInstanceOfInformationLink_class(problem,interpretation,var_I);
	// T is exported
	// I is exported
	find mustInstanceOfInformationLink_class(problem,interpretation,var_I);
	find mustInRelationto_reference_InformationLink(problem,interpretation,var_I,var_virtual0);
	find mustInstanceOfFunctionalInput_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_In;
	find mustInstanceOfFunctionalInput_class(problem,interpretation,var_In);
	find mustInRelationterminator_reference_FunctionalData(problem,interpretation,var_In,var_virtual1);
	find mustInstanceOfFAMTerminator_class(problem,interpretation,var_virtual1);
	var_virtual1 == var_T;
}
private pattern mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_terminatorAndInformation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_T, var_I)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfFAMTerminator_class(problem,interpretation,var_T);
	find mayInstanceOfInformationLink_class(problem,interpretation,var_I);
	// T is exported
	// I is exported
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,var_Out);
	find mayInRelationoutgoingLinks_reference_FunctionalOutput(problem,interpretation,var_Out,var_virtual0);
	find mayInstanceOfInformationLink_class(problem,interpretation,var_virtual0);
	find mayEquivalent(problem, interpretation, var_virtual0, var_I);
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,var_Out);
	find mayInRelationterminator_reference_FunctionalData(problem,interpretation,var_Out,var_virtual1);
	find mayInstanceOfFAMTerminator_class(problem,interpretation,var_virtual1);
	find mayEquivalent(problem, interpretation, var_virtual1, var_T);
}or{
	find interpretation(problem,interpretation);
	find mayInstanceOfFAMTerminator_class(problem,interpretation,var_T);
	find mayInstanceOfInformationLink_class(problem,interpretation,var_I);
	// T is exported
	// I is exported
	find mayInstanceOfInformationLink_class(problem,interpretation,var_I);
	find mayInRelationto_reference_InformationLink(problem,interpretation,var_I,var_virtual0);
	find mayInstanceOfFunctionalInput_class(problem,interpretation,var_virtual0);
	find mayEquivalent(problem, interpretation, var_virtual0, var_In);
	find mayInstanceOfFunctionalInput_class(problem,interpretation,var_In);
	find mayInRelationterminator_reference_FunctionalData(problem,interpretation,var_In,var_virtual1);
	find mayInstanceOfFAMTerminator_class(problem,interpretation,var_virtual1);
	find mayEquivalent(problem, interpretation, var_virtual1, var_T);
}
private pattern currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_terminatorAndInformation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_T, var_I)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfFAMTerminator_class(problem,interpretation,var_T);
	find mustInstanceOfInformationLink_class(problem,interpretation,var_I);
	// T is exported
	// I is exported
	find mustInstanceOfFunctionalOutput_class(problem,interpretation,var_Out);
	find mustInRelationoutgoingLinks_reference_FunctionalOutput(problem,interpretation,var_Out,var_virtual0);
	find mustInstanceOfInformationLink_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_I;
	find mustInstanceOfFunctionalOutput_class(problem,interpretation,var_Out);
	find mustInRelationterminator_reference_FunctionalData(problem,interpretation,var_Out,var_virtual1);
	find mustInstanceOfFAMTerminator_class(problem,interpretation,var_virtual1);
	var_virtual1 == var_T;
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFAMTerminator_class(problem,interpretation,var_T);
	find mustInstanceOfInformationLink_class(problem,interpretation,var_I);
	// T is exported
	// I is exported
	find mustInstanceOfInformationLink_class(problem,interpretation,var_I);
	find mustInRelationto_reference_InformationLink(problem,interpretation,var_I,var_virtual0);
	find mustInstanceOfFunctionalInput_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_In;
	find mustInstanceOfFunctionalInput_class(problem,interpretation,var_In);
	find mustInRelationterminator_reference_FunctionalData(problem,interpretation,var_In,var_virtual1);
	find mustInstanceOfFAMTerminator_class(problem,interpretation,var_virtual1);
	var_virtual1 == var_T;
}
// Must, May and Current queries for pattern ca mcgill ecse dslreasoner standalone test fam type
private pattern mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_type(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_This, var_Target)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunction_class(problem,interpretation,var_This);
	// type constraint is enforced by construction
	// This is exported
	// Target is exported
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_rootElements(problem,interpretation,_var__Model,var_This);
	var_virtual0 == const_Root_FunctionType;DefinedElement.name(const_Root_FunctionType,"Root FunctionType");  //LogicProblem.elements(problem,const_Root_FunctionType);
	var_Target == var_virtual0;
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunction_class(problem,interpretation,var_This);
	// type constraint is enforced by construction
	// This is exported
	// Target is exported
	neg find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_parent(problem,interpretation,_var__Child,var_This);
	neg find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_rootElements(problem,interpretation,_var__Model,var_This);
	var_virtual0 == const_Leaf_FunctionType;DefinedElement.name(const_Leaf_FunctionType,"Leaf FunctionType");  //LogicProblem.elements(problem,const_Leaf_FunctionType);
	var_Target == var_virtual0;
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunction_class(problem,interpretation,var_This);
	// type constraint is enforced by construction
	// This is exported
	// Target is exported
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_parent(problem,interpretation,var_This,_var__Par);
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_parent(problem,interpretation,_var__Child,var_This);
	var_virtual0 == const_Intermediate_FunctionType;DefinedElement.name(const_Intermediate_FunctionType,"Intermediate FunctionType");  //LogicProblem.elements(problem,const_Intermediate_FunctionType);
	var_Target == var_virtual0;
}
private pattern mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_type(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_This, var_Target)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfFunction_class(problem,interpretation,var_This);
	// type constraint is enforced by construction
	// This is exported
	// Target is exported
	find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_rootElements(problem,interpretation,_var__Model,var_This);
	var_virtual0 == const_Root_FunctionType;DefinedElement.name(const_Root_FunctionType,"Root FunctionType");  //LogicProblem.elements(problem,const_Root_FunctionType);
	find mayEquivalent(problem, interpretation, var_Target, var_virtual0);
}or{
	find interpretation(problem,interpretation);
	find mayInstanceOfFunction_class(problem,interpretation,var_This);
	// type constraint is enforced by construction
	// This is exported
	// Target is exported
	neg find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_parent(problem,interpretation,_var__Child,var_This);
	neg find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_rootElements(problem,interpretation,_var__Model,var_This);
	var_virtual0 == const_Leaf_FunctionType;DefinedElement.name(const_Leaf_FunctionType,"Leaf FunctionType");  //LogicProblem.elements(problem,const_Leaf_FunctionType);
	find mayEquivalent(problem, interpretation, var_Target, var_virtual0);
}or{
	find interpretation(problem,interpretation);
	find mayInstanceOfFunction_class(problem,interpretation,var_This);
	// type constraint is enforced by construction
	// This is exported
	// Target is exported
	find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_parent(problem,interpretation,var_This,_var__Par);
	find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_parent(problem,interpretation,_var__Child,var_This);
	var_virtual0 == const_Intermediate_FunctionType;DefinedElement.name(const_Intermediate_FunctionType,"Intermediate FunctionType");  //LogicProblem.elements(problem,const_Intermediate_FunctionType);
	find mayEquivalent(problem, interpretation, var_Target, var_virtual0);
}
private pattern currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_type(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_This, var_Target)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunction_class(problem,interpretation,var_This);
	// type constraint is enforced by construction
	// This is exported
	// Target is exported
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_rootElements(problem,interpretation,_var__Model,var_This);
	var_virtual0 == const_Root_FunctionType;DefinedElement.name(const_Root_FunctionType,"Root FunctionType");  //LogicProblem.elements(problem,const_Root_FunctionType);
	var_Target == var_virtual0;
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunction_class(problem,interpretation,var_This);
	// type constraint is enforced by construction
	// This is exported
	// Target is exported
	neg find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_parent(problem,interpretation,_var__Child,var_This);
	neg find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_rootElements(problem,interpretation,_var__Model,var_This);
	var_virtual0 == const_Leaf_FunctionType;DefinedElement.name(const_Leaf_FunctionType,"Leaf FunctionType");  //LogicProblem.elements(problem,const_Leaf_FunctionType);
	var_Target == var_virtual0;
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunction_class(problem,interpretation,var_This);
	// type constraint is enforced by construction
	// This is exported
	// Target is exported
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_parent(problem,interpretation,var_This,_var__Par);
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_parent(problem,interpretation,_var__Child,var_This);
	var_virtual0 == const_Intermediate_FunctionType;DefinedElement.name(const_Intermediate_FunctionType,"Intermediate FunctionType");  //LogicProblem.elements(problem,const_Intermediate_FunctionType);
	var_Target == var_virtual0;
}
// Must, May and Current queries for pattern ca mcgill ecse dslreasoner standalone test fam rootElements
private pattern mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_rootElements(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_Model, var_Root)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,var_Model);
	find mustInstanceOfFunction_class(problem,interpretation,var_Root);
	// Model is exported
	// Root is exported
	find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,var_Model);
	find mustInRelationrootElements_reference_FunctionalArchitectureModel(problem,interpretation,var_Model,var_virtual0);
	find mustInstanceOfFunctionalElement_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_Root;
}
private pattern mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_rootElements(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_Model, var_Root)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfFunctionalArchitectureModel_class(problem,interpretation,var_Model);
	find mayInstanceOfFunction_class(problem,interpretation,var_Root);
	// Model is exported
	// Root is exported
	find mayInstanceOfFunctionalArchitectureModel_class(problem,interpretation,var_Model);
	find mayInRelationrootElements_reference_FunctionalArchitectureModel(problem,interpretation,var_Model,var_virtual0);
	find mayInstanceOfFunctionalElement_class(problem,interpretation,var_virtual0);
	find mayEquivalent(problem, interpretation, var_virtual0, var_Root);
}
private pattern currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_rootElements(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_Model, var_Root)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,var_Model);
	find mustInstanceOfFunction_class(problem,interpretation,var_Root);
	// Model is exported
	// Root is exported
	find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,var_Model);
	find mustInRelationrootElements_reference_FunctionalArchitectureModel(problem,interpretation,var_Model,var_virtual0);
	find mustInstanceOfFunctionalElement_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_Root;
}
// Must, May and Current queries for pattern ca mcgill ecse dslreasoner standalone test fam parent
private pattern mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_parent(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_Func, var_Par)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunction_class(problem,interpretation,var_Func);
	find mustInstanceOfFunction_class(problem,interpretation,var_Par);
	// Func is exported
	// Par is exported
	find mustInstanceOfFunction_class(problem,interpretation,var_Func);
	find mustInRelationparent_reference_FunctionalElement(problem,interpretation,var_Func,var_virtual0);
	find mustInstanceOfFunction_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_Par;
}
private pattern mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_parent(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_Func, var_Par)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfFunction_class(problem,interpretation,var_Func);
	find mayInstanceOfFunction_class(problem,interpretation,var_Par);
	// Func is exported
	// Par is exported
	find mayInstanceOfFunction_class(problem,interpretation,var_Func);
	find mayInRelationparent_reference_FunctionalElement(problem,interpretation,var_Func,var_virtual0);
	find mayInstanceOfFunction_class(problem,interpretation,var_virtual0);
	find mayEquivalent(problem, interpretation, var_virtual0, var_Par);
}
private pattern currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_parent(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_Func, var_Par)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunction_class(problem,interpretation,var_Func);
	find mustInstanceOfFunction_class(problem,interpretation,var_Par);
	// Func is exported
	// Par is exported
	find mustInstanceOfFunction_class(problem,interpretation,var_Func);
	find mustInRelationparent_reference_FunctionalElement(problem,interpretation,var_Func,var_virtual0);
	find mustInstanceOfFunction_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_Par;
}
// Must, May and Current queries for pattern ca mcgill ecse dslreasoner standalone test fam model
private pattern mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_model(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_This, var_Target)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalElement_class(problem,interpretation,var_This);
	find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,var_Target);
	// This is exported
	// Target is exported
	find mustInstanceOfFunctionalElement_class(problem,interpretation,var_This);
	find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,var_Target);
}
private pattern mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_model(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_This, var_Target)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfFunctionalElement_class(problem,interpretation,var_This);
	find mayInstanceOfFunctionalArchitectureModel_class(problem,interpretation,var_Target);
	// This is exported
	// Target is exported
	find mayInstanceOfFunctionalElement_class(problem,interpretation,var_This);
	find mayInstanceOfFunctionalArchitectureModel_class(problem,interpretation,var_Target);
}
private pattern currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_model(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_This, var_Target)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalElement_class(problem,interpretation,var_This);
	find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,var_Target);
	// This is exported
	// Target is exported
	find mustInstanceOfFunctionalElement_class(problem,interpretation,var_This);
	find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,var_Target);
}

//////////
// 1.4 Containment Indexer
//////////
private pattern mustContains2(source: DefinedElement, target: DefinedElement) {
	find mustContains4(_,_,source,target);
}
	
private pattern mustContains4(problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target: DefinedElement)
	{ find mustInRelationinterface_reference_FunctionalElement(problem,interpretation,source,target); }or
	
	{ find mustInRelationrootElements_reference_FunctionalArchitectureModel(problem,interpretation,source,target); }or
	
	{ find mustInRelationsubElements_reference_Function(problem,interpretation,source,target); }or
	
	{ find mustInRelationdata_reference_FunctionalInterface(problem,interpretation,source,target); }or
	
	{ find mustInRelationoutgoingLinks_reference_FunctionalOutput(problem,interpretation,source,target); }or
	
	{ find mustInRelationterminator_reference_FunctionalData(problem,interpretation,source,target); }

private pattern mustTransitiveContains(source,target) {
	find mustContains2+(source,target);
}

//////////
// 2. Invalidation Indexers
//////////
// 2.1 Invalidated by WF Queries
//////////
pattern invalidatedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_terminatorAndInformation(problem:LogicProblem, interpretation:PartialInterpretation,
	var_T, var_I)
{
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_terminatorAndInformation(problem,interpretation,var_T,var_I);
}

//////////
// 3. Unfinishedness Indexers
//////////
// 3.1 Unfinishedness Measured by Multiplicity
//////////
pattern unfinishedLowerMultiplicity_to_reference_InformationLink(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"to reference InformationLink");
	find mustInstanceOfInformationLink_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationto_reference_InformationLink(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}

//////////
// 3.2 Unfinishedness Measured by WF Queries
//////////
pattern unfinishedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_terminatorAndInformation(problem:LogicProblem, interpretation:PartialInterpretation,
	var_T, var_I)
{
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_terminatorAndInformation(problem,interpretation,var_T,var_I);
}

//////////
// 4. Refinement Indexers
//////////
// 4.1 Object constructors
//////////
private pattern hasElementInContainment(problem:LogicProblem, interpretation:PartialInterpretation)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalElement_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalInput_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalOutput_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfInformationLink_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFAMTerminator_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalData_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunction_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalInterface_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalArchitectureModel_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}
pattern createObject_FAMTerminator_class_by_terminator_reference_FunctionalData_with_data_reference_FAMTerminator(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FAMTerminator class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"terminator reference FunctionalData");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"data reference FAMTerminator");
	find mustInstanceOfFunctionalData_class(problem,interpretation,container);
	find mayInstanceOfFAMTerminator_class(problem,interpretation,newObject);
	find mayInRelationterminator_reference_FunctionalData(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FAMTerminator_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FAMTerminator class");
	find mayInstanceOfFAMTerminator_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalInput_class_by_data_reference_FunctionalInterface_with_interface_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalInput class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"data reference FunctionalInterface");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"interface reference FunctionalData");
	find mustInstanceOfFunctionalInterface_class(problem,interpretation,container);
	find mayInstanceOfFunctionalInput_class(problem,interpretation,newObject);
	find mayInRelationdata_reference_FunctionalInterface(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalInput_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalInput class");
	find mayInstanceOfFunctionalInput_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalInterface_class_by_interface_reference_FunctionalElement_with_element_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalInterface class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"interface reference FunctionalElement");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"element reference FunctionalInterface");
	find mustInstanceOfFunctionalElement_class(problem,interpretation,container);
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,newObject);
	find mayInRelationinterface_reference_FunctionalElement(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalInterface_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalInterface class");
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalOutput_class_by_data_reference_FunctionalInterface_with_interface_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalOutput class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"data reference FunctionalInterface");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"interface reference FunctionalData");
	find mustInstanceOfFunctionalInterface_class(problem,interpretation,container);
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,newObject);
	find mayInRelationdata_reference_FunctionalInterface(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalOutput_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalOutput class");
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_InformationLink_class_by_outgoingLinks_reference_FunctionalOutput_with_from_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"InformationLink class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"outgoingLinks reference FunctionalOutput");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"from reference InformationLink");
	find mustInstanceOfFunctionalOutput_class(problem,interpretation,container);
	find mayInstanceOfInformationLink_class(problem,interpretation,newObject);
	find mayInRelationoutgoingLinks_reference_FunctionalOutput(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_InformationLink_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"InformationLink class");
	find mayInstanceOfInformationLink_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalArchitectureModel_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalArchitectureModel class UndefinedPart");
	find mayInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Function_class_by_rootElements_reference_FunctionalArchitectureModel(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Function class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"rootElements reference FunctionalArchitectureModel");
	find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,container);
	find mayInstanceOfFunction_class(problem,interpretation,newObject);
	find mayInRelationrootElements_reference_FunctionalArchitectureModel(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Function_class_by_subElements_reference_Function_with_parent_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Function class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"subElements reference Function");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"parent reference FunctionalElement");
	find mustInstanceOfFunction_class(problem,interpretation,container);
	find mayInstanceOfFunction_class(problem,interpretation,newObject);
	find mayInRelationsubElements_reference_Function(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Function_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Function class");
	find mayInstanceOfFunction_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}

//////////
// 4.2 Type refinement
//////////
pattern refineTypeTo_FAMTerminator_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
}
pattern refineTypeTo_FunctionalInput_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
}
pattern refineTypeTo_FunctionalInterface_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
}
pattern refineTypeTo_FunctionalOutput_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
}
pattern refineTypeTo_InformationLink_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
}
pattern refineTypeTo_FunctionalArchitectureModel_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem,interpretation,element);
}
pattern refineTypeTo_Function_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunction_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunction_class(problem,interpretation,element);
}

//////////
// 4.3 Relation refinement
//////////
pattern refineRelation_model_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"model reference FunctionalElement");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFunctionalElement_class(problem,interpretation,from);
	find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,to);
	find mayInRelationmodel_reference_FunctionalElement(problem,interpretation,from,to);
	neg find mustInRelationmodel_reference_FunctionalElement(problem,interpretation,from,to);
}
pattern refineRelation_IncomingLinks_reference_FunctionalInput_and_to_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation, oppositeInterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"IncomingLinks reference FunctionalInput");
	PartialInterpretation.partialrelationinterpretation(interpretation,oppositeInterpretation);
	PartialRelationInterpretation.interpretationOf.name(oppositeInterpretation,"to reference InformationLink");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFunctionalInput_class(problem,interpretation,from);
	find mustInstanceOfInformationLink_class(problem,interpretation,to);
	find mayInRelationIncomingLinks_reference_FunctionalInput(problem,interpretation,from,to);
	neg find mustInRelationIncomingLinks_reference_FunctionalInput(problem,interpretation,from,to);
}
pattern refineRelation_type_attribute_Function(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"type attribute Function");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFunction_class(problem,interpretation,from);
	find mustInstanceOfFunctionType_enum(problem,interpretation,to);
	find mayInRelationtype_attribute_Function(problem,interpretation,from,to);
	neg find mustInRelationtype_attribute_Function(problem,interpretation,from,to);
}import epackage "http://www.bme.hu/mit/inf/dslreasoner/viatrasolver/partialinterpretationlanguage"
import epackage "http://www.bme.hu/mit/inf/dslreasoner/logic/model/problem"
import epackage "http://www.bme.hu/mit/inf/dslreasoner/logic/model/language"

//////////
// 0. Util
//////////
private pattern interpretation(problem:LogicProblem, interpretation:PartialInterpretation) {
	PartialInterpretation.problem(interpretation,problem);
}
	
/////////////////////////
// 0.1 Existence
/////////////////////////
private pattern mustExist(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	find interpretation(problem,interpretation);
	LogicProblem.elements(problem,element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
}

private pattern mayExist(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
    find mustExist(problem,interpretation,element);
} or {
    find interpretation(problem,interpretation);
    neg find elementCloseWorld(element);
    PartialInterpretation.openWorldElements(interpretation,element);
}

private pattern elementCloseWorld(element:DefinedElement) {
	PartialInterpretation.openWorldElements(i,element);
    PartialInterpretation.maxNewElements(i,0);
} or {
	Scope.targetTypeInterpretation(scope,interpretation);
	PartialTypeInterpratation.elements(interpretation,element);
	Scope.maxNewElements(scope,0);
}

////////////////////////
// 0.2 Equivalence
////////////////////////
pattern mayEquivalent(problem:LogicProblem, interpretation:PartialInterpretation, a: DefinedElement, b: DefinedElement) {
	find mayExist(problem,interpretation,a);
	find mayExist(problem,interpretation,b);
	a == b;
}

////////////////////////
// 0.3 Required Patterns by TypeIndexer
////////////////////////
private pattern typeInterpretation(problem:LogicProblem, interpretation:PartialInterpretation, type:TypeDeclaration, typeInterpretation:PartialComplexTypeInterpretation) {
	find interpretation(problem,interpretation);
	LogicProblem.types(problem,type);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
}

private pattern directInstanceOf(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement, type:Type) {
	find interpretation(problem,interpretation);
	LogicProblem.types(problem,type);
	TypeDefinition.elements(type,element);
} or {
	find interpretation(problem,interpretation);
	find typeInterpretation(problem,interpretation,type,typeInterpretation);
	PartialComplexTypeInterpretation.elements(typeInterpretation,element);
}

private pattern isPrimitive(element: PrimitiveElement) {
	PrimitiveElement(element);
}

//////////
// 1. Problem-Specific Base Indexers
//////////
// 1.1 Type Indexers
//////////
// 1.1.1 primitive Type Indexers
//////////

//////////
// 1.1.2 domain-specific Type Indexers
//////////
/**
 * An element must be an instance of type "FunctionalElement class".
 */
private pattern mustInstanceOfFunctionalElement_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalElement class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalElement_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalElement class");
}

/**
 * An element may be an instance of type "FunctionalElement class".
 */
private pattern mayInstanceOfFunctionalElement_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunction_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalElement_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunction_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalElement_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalElement_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalArchitectureModel class".
 */
private pattern mustInstanceOfFunctionalArchitectureModel_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalArchitectureModel class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalArchitectureModel_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalArchitectureModel class");
}

/**
 * An element may be an instance of type "FunctionalArchitectureModel class".
 */
private pattern mayInstanceOfFunctionalArchitectureModel_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalArchitectureModel_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalArchitectureModel_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Function class".
 */
private pattern mustInstanceOfFunction_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Function class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunction_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Function class");
}

/**
 * An element may be an instance of type "Function class".
 */
private pattern mayInstanceOfFunction_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunction_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunction_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunction_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FAMTerminator class".
 */
private pattern mustInstanceOfFAMTerminator_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FAMTerminator class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFAMTerminator_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FAMTerminator class");
}

/**
 * An element may be an instance of type "FAMTerminator class".
 */
private pattern mayInstanceOfFAMTerminator_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find scopeDisallowsNewFAMTerminator_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find scopeDisallowsNewFAMTerminator_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFAMTerminator_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "InformationLink class".
 */
private pattern mustInstanceOfInformationLink_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"InformationLink class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewInformationLink_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"InformationLink class");
}

/**
 * An element may be an instance of type "InformationLink class".
 */
private pattern mayInstanceOfInformationLink_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find scopeDisallowsNewInformationLink_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find scopeDisallowsNewInformationLink_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfInformationLink_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalInterface class".
 */
private pattern mustInstanceOfFunctionalInterface_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalInterface class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalInterface_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalInterface class");
}

/**
 * An element may be an instance of type "FunctionalInterface class".
 */
private pattern mayInstanceOfFunctionalInterface_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalInterface_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalInterface_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalInterface_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalInput class".
 */
private pattern mustInstanceOfFunctionalInput_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalInput class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalInput_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalInput class");
}

/**
 * An element may be an instance of type "FunctionalInput class".
 */
private pattern mayInstanceOfFunctionalInput_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalInput_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalInput_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalInput_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalOutput class".
 */
private pattern mustInstanceOfFunctionalOutput_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalOutput class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalOutput_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalOutput class");
}

/**
 * An element may be an instance of type "FunctionalOutput class".
 */
private pattern mayInstanceOfFunctionalOutput_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalOutput_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalOutput_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalOutput_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalData class".
 */
private pattern mustInstanceOfFunctionalData_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalData class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalData_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalData class");
}

/**
 * An element may be an instance of type "FunctionalData class".
 */
private pattern mayInstanceOfFunctionalData_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalData_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalData_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalData_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionType enum".
 */
private pattern mustInstanceOfFunctionType_enum(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionType enum");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionType_enum(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionType enum");
}

/**
 * An element may be an instance of type "FunctionType enum".
 */
private pattern mayInstanceOfFunctionType_enum(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfFunctionType_enum(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalArchitectureModel class DefinedPart".
 */
private pattern mustInstanceOfFunctionalArchitectureModel_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalArchitectureModel class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalArchitectureModel_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalArchitectureModel class DefinedPart");
}

/**
 * An element may be an instance of type "FunctionalArchitectureModel class DefinedPart".
 */
private pattern mayInstanceOfFunctionalArchitectureModel_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfFunctionalArchitectureModel_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalArchitectureModel class UndefinedPart".
 */
private pattern mustInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalArchitectureModel class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalArchitectureModel_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalArchitectureModel class UndefinedPart");
}

/**
 * An element may be an instance of type "FunctionalArchitectureModel class UndefinedPart".
 */
private pattern mayInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalArchitectureModel_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalArchitectureModel_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem,interpretation,element); }

//////////
// 1.2 Relation Declaration Indexers
//////////
/**
 * Matcher for detecting tuples t where []interface reference FunctionalElement(source,target)
 */
private pattern mustInRelationinterface_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"interface reference FunctionalElement");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>interface reference FunctionalElement(source,target)
 */
private pattern mayInRelationinterface_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalElement_class(problem,interpretation,source);
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationinterface_reference_FunctionalElement(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationelement_reference_FunctionalInterface(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationinterface_reference_FunctionalElement(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []model reference FunctionalElement(source,target)
 */
 private pattern mustInRelationmodel_reference_FunctionalElement(
 	problem:LogicProblem, interpretation:PartialInterpretation,
 	source: DefinedElement, target:DefinedElement)
 {
 	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_model(problem,interpretation,source,target);
 }
/**
 * Matcher for detecting tuples t where []model reference FunctionalElement(source,target)
 */
 private pattern mayInRelationmodel_reference_FunctionalElement(
 	problem:LogicProblem, interpretation:PartialInterpretation,
 	source: DefinedElement, target:DefinedElement)
 {
 	find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_model(problem,interpretation,source,target);
 }
/**
 * Matcher for detecting tuples t where []parent reference FunctionalElement(source,target)
 */
private pattern mustInRelationparent_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"parent reference FunctionalElement");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>parent reference FunctionalElement(source,target)
 */
private pattern mayInRelationparent_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalElement_class(problem,interpretation,source);
	find mayInstanceOfFunction_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationparent_reference_FunctionalElement(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationparent_reference_FunctionalElement(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []rootElements reference FunctionalArchitectureModel(source,target)
 */
private pattern mustInRelationrootElements_reference_FunctionalArchitectureModel(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"rootElements reference FunctionalArchitectureModel");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>rootElements reference FunctionalArchitectureModel(source,target)
 */
private pattern mayInRelationrootElements_reference_FunctionalArchitectureModel(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalArchitectureModel_class(problem,interpretation,source);
	find mayInstanceOfFunctionalElement_class(problem,interpretation,target);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationrootElements_reference_FunctionalArchitectureModel(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []subElements reference Function(source,target)
 */
private pattern mustInRelationsubElements_reference_Function(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"subElements reference Function");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>subElements reference Function(source,target)
 */
private pattern mayInRelationsubElements_reference_Function(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunction_class(problem,interpretation,source);
	find mayInstanceOfFunctionalElement_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationparent_reference_FunctionalElement(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationsubElements_reference_Function(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []data reference FAMTerminator(source,target)
 */
private pattern mustInRelationdata_reference_FAMTerminator(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"data reference FAMTerminator");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>data reference FAMTerminator(source,target)
 */
private pattern mayInRelationdata_reference_FAMTerminator(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFAMTerminator_class(problem,interpretation,source);
	find mayInstanceOfFunctionalData_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationdata_reference_FAMTerminator(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationterminator_reference_FunctionalData(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationdata_reference_FAMTerminator(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []from reference InformationLink(source,target)
 */
private pattern mustInRelationfrom_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"from reference InformationLink");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>from reference InformationLink(source,target)
 */
private pattern mayInRelationfrom_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfInformationLink_class(problem,interpretation,source);
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationfrom_reference_InformationLink(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationfrom_reference_InformationLink(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []to reference InformationLink(source,target)
 */
private pattern mustInRelationto_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"to reference InformationLink");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>to reference InformationLink(source,target)
 */
private pattern mayInRelationto_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfInformationLink_class(problem,interpretation,source);
	find mayInstanceOfFunctionalInput_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationto_reference_InformationLink(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationto_reference_InformationLink(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []data reference FunctionalInterface(source,target)
 */
private pattern mustInRelationdata_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"data reference FunctionalInterface");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>data reference FunctionalInterface(source,target)
 */
private pattern mayInRelationdata_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,source);
	find mayInstanceOfFunctionalData_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationinterface_reference_FunctionalData(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationdata_reference_FunctionalInterface(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []element reference FunctionalInterface(source,target)
 */
private pattern mustInRelationelement_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"element reference FunctionalInterface");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>element reference FunctionalInterface(source,target)
 */
private pattern mayInRelationelement_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,source);
	find mayInstanceOfFunctionalElement_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationelement_reference_FunctionalInterface(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationinterface_reference_FunctionalElement(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationelement_reference_FunctionalInterface(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []IncomingLinks reference FunctionalInput(source,target)
 */
private pattern mustInRelationIncomingLinks_reference_FunctionalInput(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"IncomingLinks reference FunctionalInput");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>IncomingLinks reference FunctionalInput(source,target)
 */
private pattern mayInRelationIncomingLinks_reference_FunctionalInput(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalInput_class(problem,interpretation,source);
	find mayInstanceOfInformationLink_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationto_reference_InformationLink(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
} or {
	find mustInRelationIncomingLinks_reference_FunctionalInput(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []outgoingLinks reference FunctionalOutput(source,target)
 */
private pattern mustInRelationoutgoingLinks_reference_FunctionalOutput(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"outgoingLinks reference FunctionalOutput");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>outgoingLinks reference FunctionalOutput(source,target)
 */
private pattern mayInRelationoutgoingLinks_reference_FunctionalOutput(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,source);
	find mayInstanceOfInformationLink_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationfrom_reference_InformationLink(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationoutgoingLinks_reference_FunctionalOutput(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []terminator reference FunctionalData(source,target)
 */
private pattern mustInRelationterminator_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"terminator reference FunctionalData");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>terminator reference FunctionalData(source,target)
 */
private pattern mayInRelationterminator_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalData_class(problem,interpretation,source);
	find mayInstanceOfFAMTerminator_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationterminator_reference_FunctionalData(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationdata_reference_FAMTerminator(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationterminator_reference_FunctionalData(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []interface reference FunctionalData(source,target)
 */
private pattern mustInRelationinterface_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"interface reference FunctionalData");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>interface reference FunctionalData(source,target)
 */
private pattern mayInRelationinterface_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalData_class(problem,interpretation,source);
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationinterface_reference_FunctionalData(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationinterface_reference_FunctionalData(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []type attribute Function(source,target)
 */
 private pattern mustInRelationtype_attribute_Function(
 	problem:LogicProblem, interpretation:PartialInterpretation,
 	source: DefinedElement, target:DefinedElement)
 {
 	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_type(problem,interpretation,source,target);
 }
/**
 * Matcher for detecting tuples t where []type attribute Function(source,target)
 */
 private pattern mayInRelationtype_attribute_Function(
 	problem:LogicProblem, interpretation:PartialInterpretation,
 	source: DefinedElement, target:DefinedElement)
 {
 	find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_type(problem,interpretation,source,target);
 }

//////////
// 1.3 Relation Definition Indexers
//////////
// Must, May and Current queries for pattern ca mcgill ecse dslreasoner standalone test fam terminatorAndInformation
private pattern mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_terminatorAndInformation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_T, var_I)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfFAMTerminator_class(problem,interpretation,var_T);
	find mustInstanceOfInformationLink_class(problem,interpretation,var_I);
	// T is exported
	// I is exported
	find mustInstanceOfFunctionalOutput_class(problem,interpretation,var_Out);
	find mustInRelationoutgoingLinks_reference_FunctionalOutput(problem,interpretation,var_Out,var_virtual0);
	find mustInstanceOfInformationLink_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_I;
	find mustInstanceOfFunctionalOutput_class(problem,interpretation,var_Out);
	find mustInRelationterminator_reference_FunctionalData(problem,interpretation,var_Out,var_virtual1);
	find mustInstanceOfFAMTerminator_class(problem,interpretation,var_virtual1);
	var_virtual1 == var_T;
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFAMTerminator_class(problem,interpretation,var_T);
	find mustInstanceOfInformationLink_class(problem,interpretation,var_I);
	// T is exported
	// I is exported
	find mustInstanceOfInformationLink_class(problem,interpretation,var_I);
	find mustInRelationto_reference_InformationLink(problem,interpretation,var_I,var_virtual0);
	find mustInstanceOfFunctionalInput_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_In;
	find mustInstanceOfFunctionalInput_class(problem,interpretation,var_In);
	find mustInRelationterminator_reference_FunctionalData(problem,interpretation,var_In,var_virtual1);
	find mustInstanceOfFAMTerminator_class(problem,interpretation,var_virtual1);
	var_virtual1 == var_T;
}
private pattern mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_terminatorAndInformation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_T, var_I)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfFAMTerminator_class(problem,interpretation,var_T);
	find mayInstanceOfInformationLink_class(problem,interpretation,var_I);
	// T is exported
	// I is exported
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,var_Out);
	find mayInRelationoutgoingLinks_reference_FunctionalOutput(problem,interpretation,var_Out,var_virtual0);
	find mayInstanceOfInformationLink_class(problem,interpretation,var_virtual0);
	find mayEquivalent(problem, interpretation, var_virtual0, var_I);
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,var_Out);
	find mayInRelationterminator_reference_FunctionalData(problem,interpretation,var_Out,var_virtual1);
	find mayInstanceOfFAMTerminator_class(problem,interpretation,var_virtual1);
	find mayEquivalent(problem, interpretation, var_virtual1, var_T);
}or{
	find interpretation(problem,interpretation);
	find mayInstanceOfFAMTerminator_class(problem,interpretation,var_T);
	find mayInstanceOfInformationLink_class(problem,interpretation,var_I);
	// T is exported
	// I is exported
	find mayInstanceOfInformationLink_class(problem,interpretation,var_I);
	find mayInRelationto_reference_InformationLink(problem,interpretation,var_I,var_virtual0);
	find mayInstanceOfFunctionalInput_class(problem,interpretation,var_virtual0);
	find mayEquivalent(problem, interpretation, var_virtual0, var_In);
	find mayInstanceOfFunctionalInput_class(problem,interpretation,var_In);
	find mayInRelationterminator_reference_FunctionalData(problem,interpretation,var_In,var_virtual1);
	find mayInstanceOfFAMTerminator_class(problem,interpretation,var_virtual1);
	find mayEquivalent(problem, interpretation, var_virtual1, var_T);
}
private pattern currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_terminatorAndInformation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_T, var_I)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfFAMTerminator_class(problem,interpretation,var_T);
	find mustInstanceOfInformationLink_class(problem,interpretation,var_I);
	// T is exported
	// I is exported
	find mustInstanceOfFunctionalOutput_class(problem,interpretation,var_Out);
	find mustInRelationoutgoingLinks_reference_FunctionalOutput(problem,interpretation,var_Out,var_virtual0);
	find mustInstanceOfInformationLink_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_I;
	find mustInstanceOfFunctionalOutput_class(problem,interpretation,var_Out);
	find mustInRelationterminator_reference_FunctionalData(problem,interpretation,var_Out,var_virtual1);
	find mustInstanceOfFAMTerminator_class(problem,interpretation,var_virtual1);
	var_virtual1 == var_T;
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFAMTerminator_class(problem,interpretation,var_T);
	find mustInstanceOfInformationLink_class(problem,interpretation,var_I);
	// T is exported
	// I is exported
	find mustInstanceOfInformationLink_class(problem,interpretation,var_I);
	find mustInRelationto_reference_InformationLink(problem,interpretation,var_I,var_virtual0);
	find mustInstanceOfFunctionalInput_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_In;
	find mustInstanceOfFunctionalInput_class(problem,interpretation,var_In);
	find mustInRelationterminator_reference_FunctionalData(problem,interpretation,var_In,var_virtual1);
	find mustInstanceOfFAMTerminator_class(problem,interpretation,var_virtual1);
	var_virtual1 == var_T;
}
// Must, May and Current queries for pattern ca mcgill ecse dslreasoner standalone test fam type
private pattern mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_type(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_This, var_Target)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunction_class(problem,interpretation,var_This);
	// type constraint is enforced by construction
	// This is exported
	// Target is exported
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_rootElements(problem,interpretation,_var__Model,var_This);
	var_virtual0 == const_Root_FunctionType;DefinedElement.name(const_Root_FunctionType,"Root FunctionType");  //LogicProblem.elements(problem,const_Root_FunctionType);
	var_Target == var_virtual0;
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunction_class(problem,interpretation,var_This);
	// type constraint is enforced by construction
	// This is exported
	// Target is exported
	neg find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_parent(problem,interpretation,_var__Child,var_This);
	neg find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_rootElements(problem,interpretation,_var__Model,var_This);
	var_virtual0 == const_Leaf_FunctionType;DefinedElement.name(const_Leaf_FunctionType,"Leaf FunctionType");  //LogicProblem.elements(problem,const_Leaf_FunctionType);
	var_Target == var_virtual0;
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunction_class(problem,interpretation,var_This);
	// type constraint is enforced by construction
	// This is exported
	// Target is exported
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_parent(problem,interpretation,var_This,_var__Par);
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_parent(problem,interpretation,_var__Child,var_This);
	var_virtual0 == const_Intermediate_FunctionType;DefinedElement.name(const_Intermediate_FunctionType,"Intermediate FunctionType");  //LogicProblem.elements(problem,const_Intermediate_FunctionType);
	var_Target == var_virtual0;
}
private pattern mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_type(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_This, var_Target)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfFunction_class(problem,interpretation,var_This);
	// type constraint is enforced by construction
	// This is exported
	// Target is exported
	find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_rootElements(problem,interpretation,_var__Model,var_This);
	var_virtual0 == const_Root_FunctionType;DefinedElement.name(const_Root_FunctionType,"Root FunctionType");  //LogicProblem.elements(problem,const_Root_FunctionType);
	find mayEquivalent(problem, interpretation, var_Target, var_virtual0);
}or{
	find interpretation(problem,interpretation);
	find mayInstanceOfFunction_class(problem,interpretation,var_This);
	// type constraint is enforced by construction
	// This is exported
	// Target is exported
	neg find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_parent(problem,interpretation,_var__Child,var_This);
	neg find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_rootElements(problem,interpretation,_var__Model,var_This);
	var_virtual0 == const_Leaf_FunctionType;DefinedElement.name(const_Leaf_FunctionType,"Leaf FunctionType");  //LogicProblem.elements(problem,const_Leaf_FunctionType);
	find mayEquivalent(problem, interpretation, var_Target, var_virtual0);
}or{
	find interpretation(problem,interpretation);
	find mayInstanceOfFunction_class(problem,interpretation,var_This);
	// type constraint is enforced by construction
	// This is exported
	// Target is exported
	find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_parent(problem,interpretation,var_This,_var__Par);
	find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_parent(problem,interpretation,_var__Child,var_This);
	var_virtual0 == const_Intermediate_FunctionType;DefinedElement.name(const_Intermediate_FunctionType,"Intermediate FunctionType");  //LogicProblem.elements(problem,const_Intermediate_FunctionType);
	find mayEquivalent(problem, interpretation, var_Target, var_virtual0);
}
private pattern currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_type(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_This, var_Target)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunction_class(problem,interpretation,var_This);
	// type constraint is enforced by construction
	// This is exported
	// Target is exported
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_rootElements(problem,interpretation,_var__Model,var_This);
	var_virtual0 == const_Root_FunctionType;DefinedElement.name(const_Root_FunctionType,"Root FunctionType");  //LogicProblem.elements(problem,const_Root_FunctionType);
	var_Target == var_virtual0;
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunction_class(problem,interpretation,var_This);
	// type constraint is enforced by construction
	// This is exported
	// Target is exported
	neg find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_parent(problem,interpretation,_var__Child,var_This);
	neg find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_rootElements(problem,interpretation,_var__Model,var_This);
	var_virtual0 == const_Leaf_FunctionType;DefinedElement.name(const_Leaf_FunctionType,"Leaf FunctionType");  //LogicProblem.elements(problem,const_Leaf_FunctionType);
	var_Target == var_virtual0;
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunction_class(problem,interpretation,var_This);
	// type constraint is enforced by construction
	// This is exported
	// Target is exported
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_parent(problem,interpretation,var_This,_var__Par);
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_parent(problem,interpretation,_var__Child,var_This);
	var_virtual0 == const_Intermediate_FunctionType;DefinedElement.name(const_Intermediate_FunctionType,"Intermediate FunctionType");  //LogicProblem.elements(problem,const_Intermediate_FunctionType);
	var_Target == var_virtual0;
}
// Must, May and Current queries for pattern ca mcgill ecse dslreasoner standalone test fam rootElements
private pattern mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_rootElements(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_Model, var_Root)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,var_Model);
	find mustInstanceOfFunction_class(problem,interpretation,var_Root);
	// Model is exported
	// Root is exported
	find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,var_Model);
	find mustInRelationrootElements_reference_FunctionalArchitectureModel(problem,interpretation,var_Model,var_virtual0);
	find mustInstanceOfFunctionalElement_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_Root;
}
private pattern mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_rootElements(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_Model, var_Root)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfFunctionalArchitectureModel_class(problem,interpretation,var_Model);
	find mayInstanceOfFunction_class(problem,interpretation,var_Root);
	// Model is exported
	// Root is exported
	find mayInstanceOfFunctionalArchitectureModel_class(problem,interpretation,var_Model);
	find mayInRelationrootElements_reference_FunctionalArchitectureModel(problem,interpretation,var_Model,var_virtual0);
	find mayInstanceOfFunctionalElement_class(problem,interpretation,var_virtual0);
	find mayEquivalent(problem, interpretation, var_virtual0, var_Root);
}
private pattern currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_rootElements(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_Model, var_Root)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,var_Model);
	find mustInstanceOfFunction_class(problem,interpretation,var_Root);
	// Model is exported
	// Root is exported
	find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,var_Model);
	find mustInRelationrootElements_reference_FunctionalArchitectureModel(problem,interpretation,var_Model,var_virtual0);
	find mustInstanceOfFunctionalElement_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_Root;
}
// Must, May and Current queries for pattern ca mcgill ecse dslreasoner standalone test fam parent
private pattern mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_parent(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_Func, var_Par)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunction_class(problem,interpretation,var_Func);
	find mustInstanceOfFunction_class(problem,interpretation,var_Par);
	// Func is exported
	// Par is exported
	find mustInstanceOfFunction_class(problem,interpretation,var_Func);
	find mustInRelationparent_reference_FunctionalElement(problem,interpretation,var_Func,var_virtual0);
	find mustInstanceOfFunction_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_Par;
}
private pattern mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_parent(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_Func, var_Par)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfFunction_class(problem,interpretation,var_Func);
	find mayInstanceOfFunction_class(problem,interpretation,var_Par);
	// Func is exported
	// Par is exported
	find mayInstanceOfFunction_class(problem,interpretation,var_Func);
	find mayInRelationparent_reference_FunctionalElement(problem,interpretation,var_Func,var_virtual0);
	find mayInstanceOfFunction_class(problem,interpretation,var_virtual0);
	find mayEquivalent(problem, interpretation, var_virtual0, var_Par);
}
private pattern currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_parent(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_Func, var_Par)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunction_class(problem,interpretation,var_Func);
	find mustInstanceOfFunction_class(problem,interpretation,var_Par);
	// Func is exported
	// Par is exported
	find mustInstanceOfFunction_class(problem,interpretation,var_Func);
	find mustInRelationparent_reference_FunctionalElement(problem,interpretation,var_Func,var_virtual0);
	find mustInstanceOfFunction_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_Par;
}
// Must, May and Current queries for pattern ca mcgill ecse dslreasoner standalone test fam model
private pattern mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_model(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_This, var_Target)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalElement_class(problem,interpretation,var_This);
	find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,var_Target);
	// This is exported
	// Target is exported
	find mustInstanceOfFunctionalElement_class(problem,interpretation,var_This);
	find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,var_Target);
}
private pattern mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_model(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_This, var_Target)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfFunctionalElement_class(problem,interpretation,var_This);
	find mayInstanceOfFunctionalArchitectureModel_class(problem,interpretation,var_Target);
	// This is exported
	// Target is exported
	find mayInstanceOfFunctionalElement_class(problem,interpretation,var_This);
	find mayInstanceOfFunctionalArchitectureModel_class(problem,interpretation,var_Target);
}
private pattern currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_model(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_This, var_Target)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalElement_class(problem,interpretation,var_This);
	find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,var_Target);
	// This is exported
	// Target is exported
	find mustInstanceOfFunctionalElement_class(problem,interpretation,var_This);
	find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,var_Target);
}

//////////
// 1.4 Containment Indexer
//////////
private pattern mustContains2(source: DefinedElement, target: DefinedElement) {
	find mustContains4(_,_,source,target);
}
	
private pattern mustContains4(problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target: DefinedElement)
	{ find mustInRelationinterface_reference_FunctionalElement(problem,interpretation,source,target); }or
	
	{ find mustInRelationrootElements_reference_FunctionalArchitectureModel(problem,interpretation,source,target); }or
	
	{ find mustInRelationsubElements_reference_Function(problem,interpretation,source,target); }or
	
	{ find mustInRelationdata_reference_FunctionalInterface(problem,interpretation,source,target); }or
	
	{ find mustInRelationoutgoingLinks_reference_FunctionalOutput(problem,interpretation,source,target); }or
	
	{ find mustInRelationterminator_reference_FunctionalData(problem,interpretation,source,target); }

private pattern mustTransitiveContains(source,target) {
	find mustContains2+(source,target);
}

//////////
// 2. Invalidation Indexers
//////////
// 2.1 Invalidated by WF Queries
//////////
pattern invalidatedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_terminatorAndInformation(problem:LogicProblem, interpretation:PartialInterpretation,
	var_T, var_I)
{
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_terminatorAndInformation(problem,interpretation,var_T,var_I);
}

//////////
// 3. Unfinishedness Indexers
//////////
// 3.1 Unfinishedness Measured by Multiplicity
//////////
pattern unfinishedLowerMultiplicity_to_reference_InformationLink(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"to reference InformationLink");
	find mustInstanceOfInformationLink_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationto_reference_InformationLink(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}

//////////
// 3.2 Unfinishedness Measured by WF Queries
//////////
pattern unfinishedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_terminatorAndInformation(problem:LogicProblem, interpretation:PartialInterpretation,
	var_T, var_I)
{
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_terminatorAndInformation(problem,interpretation,var_T,var_I);
}

//////////
// 4. Refinement Indexers
//////////
// 4.1 Object constructors
//////////
private pattern hasElementInContainment(problem:LogicProblem, interpretation:PartialInterpretation)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalElement_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalInput_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunction_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalInterface_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFAMTerminator_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfInformationLink_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalOutput_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalData_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalArchitectureModel_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}
pattern createObject_FunctionalInput_class_by_data_reference_FunctionalInterface_with_interface_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalInput class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"data reference FunctionalInterface");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"interface reference FunctionalData");
	find mustInstanceOfFunctionalInterface_class(problem,interpretation,container);
	find mayInstanceOfFunctionalInput_class(problem,interpretation,newObject);
	find mayInRelationdata_reference_FunctionalInterface(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalInput_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalInput class");
	find mayInstanceOfFunctionalInput_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalInterface_class_by_interface_reference_FunctionalElement_with_element_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalInterface class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"interface reference FunctionalElement");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"element reference FunctionalInterface");
	find mustInstanceOfFunctionalElement_class(problem,interpretation,container);
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,newObject);
	find mayInRelationinterface_reference_FunctionalElement(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalInterface_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalInterface class");
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Function_class_by_rootElements_reference_FunctionalArchitectureModel(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Function class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"rootElements reference FunctionalArchitectureModel");
	find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,container);
	find mayInstanceOfFunction_class(problem,interpretation,newObject);
	find mayInRelationrootElements_reference_FunctionalArchitectureModel(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Function_class_by_subElements_reference_Function_with_parent_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Function class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"subElements reference Function");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"parent reference FunctionalElement");
	find mustInstanceOfFunction_class(problem,interpretation,container);
	find mayInstanceOfFunction_class(problem,interpretation,newObject);
	find mayInRelationsubElements_reference_Function(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Function_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Function class");
	find mayInstanceOfFunction_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FAMTerminator_class_by_terminator_reference_FunctionalData_with_data_reference_FAMTerminator(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FAMTerminator class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"terminator reference FunctionalData");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"data reference FAMTerminator");
	find mustInstanceOfFunctionalData_class(problem,interpretation,container);
	find mayInstanceOfFAMTerminator_class(problem,interpretation,newObject);
	find mayInRelationterminator_reference_FunctionalData(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FAMTerminator_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FAMTerminator class");
	find mayInstanceOfFAMTerminator_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_InformationLink_class_by_outgoingLinks_reference_FunctionalOutput_with_from_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"InformationLink class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"outgoingLinks reference FunctionalOutput");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"from reference InformationLink");
	find mustInstanceOfFunctionalOutput_class(problem,interpretation,container);
	find mayInstanceOfInformationLink_class(problem,interpretation,newObject);
	find mayInRelationoutgoingLinks_reference_FunctionalOutput(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_InformationLink_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"InformationLink class");
	find mayInstanceOfInformationLink_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalArchitectureModel_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalArchitectureModel class UndefinedPart");
	find mayInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalOutput_class_by_data_reference_FunctionalInterface_with_interface_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalOutput class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"data reference FunctionalInterface");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"interface reference FunctionalData");
	find mustInstanceOfFunctionalInterface_class(problem,interpretation,container);
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,newObject);
	find mayInRelationdata_reference_FunctionalInterface(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalOutput_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalOutput class");
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}

//////////
// 4.2 Type refinement
//////////
pattern refineTypeTo_FunctionalInput_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
}
pattern refineTypeTo_FunctionalInterface_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
}
pattern refineTypeTo_Function_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunction_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunction_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
}
pattern refineTypeTo_FAMTerminator_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
}
pattern refineTypeTo_InformationLink_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
}
pattern refineTypeTo_FunctionalArchitectureModel_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem,interpretation,element);
}
pattern refineTypeTo_FunctionalOutput_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
}

//////////
// 4.3 Relation refinement
//////////
pattern refineRelation_model_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"model reference FunctionalElement");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFunctionalElement_class(problem,interpretation,from);
	find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,to);
	find mayInRelationmodel_reference_FunctionalElement(problem,interpretation,from,to);
	neg find mustInRelationmodel_reference_FunctionalElement(problem,interpretation,from,to);
}
pattern refineRelation_IncomingLinks_reference_FunctionalInput_and_to_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation, oppositeInterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"IncomingLinks reference FunctionalInput");
	PartialInterpretation.partialrelationinterpretation(interpretation,oppositeInterpretation);
	PartialRelationInterpretation.interpretationOf.name(oppositeInterpretation,"to reference InformationLink");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFunctionalInput_class(problem,interpretation,from);
	find mustInstanceOfInformationLink_class(problem,interpretation,to);
	find mayInRelationIncomingLinks_reference_FunctionalInput(problem,interpretation,from,to);
	neg find mustInRelationIncomingLinks_reference_FunctionalInput(problem,interpretation,from,to);
}
pattern refineRelation_type_attribute_Function(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"type attribute Function");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFunction_class(problem,interpretation,from);
	find mustInstanceOfFunctionType_enum(problem,interpretation,to);
	find mayInRelationtype_attribute_Function(problem,interpretation,from,to);
	neg find mustInRelationtype_attribute_Function(problem,interpretation,from,to);
}
import epackage "http://www.bme.hu/mit/inf/dslreasoner/viatrasolver/partialinterpretationlanguage"
import epackage "http://www.bme.hu/mit/inf/dslreasoner/logic/model/problem"
import epackage "http://www.bme.hu/mit/inf/dslreasoner/logic/model/language"

//////////
// 0. Util
//////////
private pattern interpretation(problem:LogicProblem, interpretation:PartialInterpretation) {
	PartialInterpretation.problem(interpretation,problem);
}
	
/////////////////////////
// 0.1 Existence
/////////////////////////
private pattern mustExist(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	find interpretation(problem,interpretation);
	LogicProblem.elements(problem,element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
}

private pattern mayExist(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
    find mustExist(problem,interpretation,element);
} or {
    find interpretation(problem,interpretation);
    neg find elementCloseWorld(element);
    PartialInterpretation.openWorldElements(interpretation,element);
}

private pattern elementCloseWorld(element:DefinedElement) {
	PartialInterpretation.openWorldElements(i,element);
    PartialInterpretation.maxNewElements(i,0);
} or {
	Scope.targetTypeInterpretation(scope,interpretation);
	PartialTypeInterpratation.elements(interpretation,element);
	Scope.maxNewElements(scope,0);
}

////////////////////////
// 0.2 Equivalence
////////////////////////
pattern mayEquivalent(problem:LogicProblem, interpretation:PartialInterpretation, a: DefinedElement, b: DefinedElement) {
	find mayExist(problem,interpretation,a);
	find mayExist(problem,interpretation,b);
	a == b;
}

////////////////////////
// 0.3 Required Patterns by TypeIndexer
////////////////////////
private pattern typeInterpretation(problem:LogicProblem, interpretation:PartialInterpretation, type:TypeDeclaration, typeInterpretation:PartialComplexTypeInterpretation) {
	find interpretation(problem,interpretation);
	LogicProblem.types(problem,type);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
}

private pattern directInstanceOf(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement, type:Type) {
	find interpretation(problem,interpretation);
	LogicProblem.types(problem,type);
	TypeDefinition.elements(type,element);
} or {
	find interpretation(problem,interpretation);
	find typeInterpretation(problem,interpretation,type,typeInterpretation);
	PartialComplexTypeInterpretation.elements(typeInterpretation,element);
}

private pattern isPrimitive(element: PrimitiveElement) {
	PrimitiveElement(element);
}

//////////
// 1. Problem-Specific Base Indexers
//////////
// 1.1 Type Indexers
//////////
// 1.1.1 primitive Type Indexers
//////////

//////////
// 1.1.2 domain-specific Type Indexers
//////////
/**
 * An element must be an instance of type "FunctionalElement class".
 */
private pattern mustInstanceOfFunctionalElement_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalElement class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalElement_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalElement class");
}

/**
 * An element may be an instance of type "FunctionalElement class".
 */
private pattern mayInstanceOfFunctionalElement_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunction_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalElement_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunction_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalElement_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalElement_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalArchitectureModel class".
 */
private pattern mustInstanceOfFunctionalArchitectureModel_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalArchitectureModel class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalArchitectureModel_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalArchitectureModel class");
}

/**
 * An element may be an instance of type "FunctionalArchitectureModel class".
 */
private pattern mayInstanceOfFunctionalArchitectureModel_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalArchitectureModel_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalArchitectureModel_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Function class".
 */
private pattern mustInstanceOfFunction_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Function class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunction_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Function class");
}

/**
 * An element may be an instance of type "Function class".
 */
private pattern mayInstanceOfFunction_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunction_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunction_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunction_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FAMTerminator class".
 */
private pattern mustInstanceOfFAMTerminator_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FAMTerminator class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFAMTerminator_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FAMTerminator class");
}

/**
 * An element may be an instance of type "FAMTerminator class".
 */
private pattern mayInstanceOfFAMTerminator_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find scopeDisallowsNewFAMTerminator_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find scopeDisallowsNewFAMTerminator_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFAMTerminator_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "InformationLink class".
 */
private pattern mustInstanceOfInformationLink_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"InformationLink class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewInformationLink_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"InformationLink class");
}

/**
 * An element may be an instance of type "InformationLink class".
 */
private pattern mayInstanceOfInformationLink_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find scopeDisallowsNewInformationLink_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find scopeDisallowsNewInformationLink_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfInformationLink_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalInterface class".
 */
private pattern mustInstanceOfFunctionalInterface_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalInterface class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalInterface_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalInterface class");
}

/**
 * An element may be an instance of type "FunctionalInterface class".
 */
private pattern mayInstanceOfFunctionalInterface_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalInterface_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalInterface_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalInterface_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalInput class".
 */
private pattern mustInstanceOfFunctionalInput_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalInput class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalInput_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalInput class");
}

/**
 * An element may be an instance of type "FunctionalInput class".
 */
private pattern mayInstanceOfFunctionalInput_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalInput_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalInput_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalInput_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalOutput class".
 */
private pattern mustInstanceOfFunctionalOutput_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalOutput class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalOutput_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalOutput class");
}

/**
 * An element may be an instance of type "FunctionalOutput class".
 */
private pattern mayInstanceOfFunctionalOutput_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalOutput_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalOutput_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalOutput_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalData class".
 */
private pattern mustInstanceOfFunctionalData_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalData class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalData_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalData class");
}

/**
 * An element may be an instance of type "FunctionalData class".
 */
private pattern mayInstanceOfFunctionalData_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalData_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalData_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalData_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionType enum".
 */
private pattern mustInstanceOfFunctionType_enum(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionType enum");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionType_enum(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionType enum");
}

/**
 * An element may be an instance of type "FunctionType enum".
 */
private pattern mayInstanceOfFunctionType_enum(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfFunctionType_enum(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalArchitectureModel class DefinedPart".
 */
private pattern mustInstanceOfFunctionalArchitectureModel_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalArchitectureModel class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalArchitectureModel_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalArchitectureModel class DefinedPart");
}

/**
 * An element may be an instance of type "FunctionalArchitectureModel class DefinedPart".
 */
private pattern mayInstanceOfFunctionalArchitectureModel_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfFunctionalArchitectureModel_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalArchitectureModel class UndefinedPart".
 */
private pattern mustInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalArchitectureModel class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalArchitectureModel_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalArchitectureModel class UndefinedPart");
}

/**
 * An element may be an instance of type "FunctionalArchitectureModel class UndefinedPart".
 */
private pattern mayInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalArchitectureModel_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalArchitectureModel_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem,interpretation,element); }

//////////
// 1.2 Relation Declaration Indexers
//////////
/**
 * Matcher for detecting tuples t where []interface reference FunctionalElement(source,target)
 */
private pattern mustInRelationinterface_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"interface reference FunctionalElement");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>interface reference FunctionalElement(source,target)
 */
private pattern mayInRelationinterface_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalElement_class(problem,interpretation,source);
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationinterface_reference_FunctionalElement(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationelement_reference_FunctionalInterface(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationinterface_reference_FunctionalElement(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []model reference FunctionalElement(source,target)
 */
 private pattern mustInRelationmodel_reference_FunctionalElement(
 	problem:LogicProblem, interpretation:PartialInterpretation,
 	source: DefinedElement, target:DefinedElement)
 {
 	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_model(problem,interpretation,source,target);
 }
/**
 * Matcher for detecting tuples t where []model reference FunctionalElement(source,target)
 */
 private pattern mayInRelationmodel_reference_FunctionalElement(
 	problem:LogicProblem, interpretation:PartialInterpretation,
 	source: DefinedElement, target:DefinedElement)
 {
 	find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_model(problem,interpretation,source,target);
 }
/**
 * Matcher for detecting tuples t where []parent reference FunctionalElement(source,target)
 */
private pattern mustInRelationparent_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"parent reference FunctionalElement");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>parent reference FunctionalElement(source,target)
 */
private pattern mayInRelationparent_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalElement_class(problem,interpretation,source);
	find mayInstanceOfFunction_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationparent_reference_FunctionalElement(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationparent_reference_FunctionalElement(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []rootElements reference FunctionalArchitectureModel(source,target)
 */
private pattern mustInRelationrootElements_reference_FunctionalArchitectureModel(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"rootElements reference FunctionalArchitectureModel");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>rootElements reference FunctionalArchitectureModel(source,target)
 */
private pattern mayInRelationrootElements_reference_FunctionalArchitectureModel(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalArchitectureModel_class(problem,interpretation,source);
	find mayInstanceOfFunctionalElement_class(problem,interpretation,target);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationrootElements_reference_FunctionalArchitectureModel(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []subElements reference Function(source,target)
 */
private pattern mustInRelationsubElements_reference_Function(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"subElements reference Function");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>subElements reference Function(source,target)
 */
private pattern mayInRelationsubElements_reference_Function(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunction_class(problem,interpretation,source);
	find mayInstanceOfFunctionalElement_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationparent_reference_FunctionalElement(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationsubElements_reference_Function(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []data reference FAMTerminator(source,target)
 */
private pattern mustInRelationdata_reference_FAMTerminator(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"data reference FAMTerminator");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>data reference FAMTerminator(source,target)
 */
private pattern mayInRelationdata_reference_FAMTerminator(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFAMTerminator_class(problem,interpretation,source);
	find mayInstanceOfFunctionalData_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationdata_reference_FAMTerminator(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationterminator_reference_FunctionalData(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationdata_reference_FAMTerminator(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []from reference InformationLink(source,target)
 */
private pattern mustInRelationfrom_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"from reference InformationLink");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>from reference InformationLink(source,target)
 */
private pattern mayInRelationfrom_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfInformationLink_class(problem,interpretation,source);
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationfrom_reference_InformationLink(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationfrom_reference_InformationLink(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []to reference InformationLink(source,target)
 */
private pattern mustInRelationto_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"to reference InformationLink");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>to reference InformationLink(source,target)
 */
private pattern mayInRelationto_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfInformationLink_class(problem,interpretation,source);
	find mayInstanceOfFunctionalInput_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationto_reference_InformationLink(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationto_reference_InformationLink(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []data reference FunctionalInterface(source,target)
 */
private pattern mustInRelationdata_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"data reference FunctionalInterface");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>data reference FunctionalInterface(source,target)
 */
private pattern mayInRelationdata_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,source);
	find mayInstanceOfFunctionalData_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationinterface_reference_FunctionalData(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationdata_reference_FunctionalInterface(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []element reference FunctionalInterface(source,target)
 */
private pattern mustInRelationelement_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"element reference FunctionalInterface");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>element reference FunctionalInterface(source,target)
 */
private pattern mayInRelationelement_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,source);
	find mayInstanceOfFunctionalElement_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationelement_reference_FunctionalInterface(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationinterface_reference_FunctionalElement(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationelement_reference_FunctionalInterface(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []IncomingLinks reference FunctionalInput(source,target)
 */
private pattern mustInRelationIncomingLinks_reference_FunctionalInput(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"IncomingLinks reference FunctionalInput");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>IncomingLinks reference FunctionalInput(source,target)
 */
private pattern mayInRelationIncomingLinks_reference_FunctionalInput(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalInput_class(problem,interpretation,source);
	find mayInstanceOfInformationLink_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationto_reference_InformationLink(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
} or {
	find mustInRelationIncomingLinks_reference_FunctionalInput(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []outgoingLinks reference FunctionalOutput(source,target)
 */
private pattern mustInRelationoutgoingLinks_reference_FunctionalOutput(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"outgoingLinks reference FunctionalOutput");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>outgoingLinks reference FunctionalOutput(source,target)
 */
private pattern mayInRelationoutgoingLinks_reference_FunctionalOutput(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,source);
	find mayInstanceOfInformationLink_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationfrom_reference_InformationLink(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationoutgoingLinks_reference_FunctionalOutput(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []terminator reference FunctionalData(source,target)
 */
private pattern mustInRelationterminator_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"terminator reference FunctionalData");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>terminator reference FunctionalData(source,target)
 */
private pattern mayInRelationterminator_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalData_class(problem,interpretation,source);
	find mayInstanceOfFAMTerminator_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationterminator_reference_FunctionalData(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationdata_reference_FAMTerminator(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationterminator_reference_FunctionalData(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []interface reference FunctionalData(source,target)
 */
private pattern mustInRelationinterface_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"interface reference FunctionalData");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>interface reference FunctionalData(source,target)
 */
private pattern mayInRelationinterface_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalData_class(problem,interpretation,source);
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationinterface_reference_FunctionalData(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationinterface_reference_FunctionalData(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []type attribute Function(source,target)
 */
 private pattern mustInRelationtype_attribute_Function(
 	problem:LogicProblem, interpretation:PartialInterpretation,
 	source: DefinedElement, target:DefinedElement)
 {
 	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_type(problem,interpretation,source,target);
 }
/**
 * Matcher for detecting tuples t where []type attribute Function(source,target)
 */
 private pattern mayInRelationtype_attribute_Function(
 	problem:LogicProblem, interpretation:PartialInterpretation,
 	source: DefinedElement, target:DefinedElement)
 {
 	find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_type(problem,interpretation,source,target);
 }

//////////
// 1.3 Relation Definition Indexers
//////////
// Must, May and Current queries for pattern ca mcgill ecse dslreasoner standalone test fam terminatorAndInformation
private pattern mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_terminatorAndInformation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_T, var_I)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfFAMTerminator_class(problem,interpretation,var_T);
	find mustInstanceOfInformationLink_class(problem,interpretation,var_I);
	// T is exported
	// I is exported
	find mustInstanceOfFunctionalOutput_class(problem,interpretation,var_Out);
	find mustInRelationoutgoingLinks_reference_FunctionalOutput(problem,interpretation,var_Out,var_virtual0);
	find mustInstanceOfInformationLink_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_I;
	find mustInstanceOfFunctionalOutput_class(problem,interpretation,var_Out);
	find mustInRelationterminator_reference_FunctionalData(problem,interpretation,var_Out,var_virtual1);
	find mustInstanceOfFAMTerminator_class(problem,interpretation,var_virtual1);
	var_virtual1 == var_T;
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFAMTerminator_class(problem,interpretation,var_T);
	find mustInstanceOfInformationLink_class(problem,interpretation,var_I);
	// T is exported
	// I is exported
	find mustInstanceOfInformationLink_class(problem,interpretation,var_I);
	find mustInRelationto_reference_InformationLink(problem,interpretation,var_I,var_virtual0);
	find mustInstanceOfFunctionalInput_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_In;
	find mustInstanceOfFunctionalInput_class(problem,interpretation,var_In);
	find mustInRelationterminator_reference_FunctionalData(problem,interpretation,var_In,var_virtual1);
	find mustInstanceOfFAMTerminator_class(problem,interpretation,var_virtual1);
	var_virtual1 == var_T;
}
private pattern mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_terminatorAndInformation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_T, var_I)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfFAMTerminator_class(problem,interpretation,var_T);
	find mayInstanceOfInformationLink_class(problem,interpretation,var_I);
	// T is exported
	// I is exported
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,var_Out);
	find mayInRelationoutgoingLinks_reference_FunctionalOutput(problem,interpretation,var_Out,var_virtual0);
	find mayInstanceOfInformationLink_class(problem,interpretation,var_virtual0);
	find mayEquivalent(problem, interpretation, var_virtual0, var_I);
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,var_Out);
	find mayInRelationterminator_reference_FunctionalData(problem,interpretation,var_Out,var_virtual1);
	find mayInstanceOfFAMTerminator_class(problem,interpretation,var_virtual1);
	find mayEquivalent(problem, interpretation, var_virtual1, var_T);
}or{
	find interpretation(problem,interpretation);
	find mayInstanceOfFAMTerminator_class(problem,interpretation,var_T);
	find mayInstanceOfInformationLink_class(problem,interpretation,var_I);
	// T is exported
	// I is exported
	find mayInstanceOfInformationLink_class(problem,interpretation,var_I);
	find mayInRelationto_reference_InformationLink(problem,interpretation,var_I,var_virtual0);
	find mayInstanceOfFunctionalInput_class(problem,interpretation,var_virtual0);
	find mayEquivalent(problem, interpretation, var_virtual0, var_In);
	find mayInstanceOfFunctionalInput_class(problem,interpretation,var_In);
	find mayInRelationterminator_reference_FunctionalData(problem,interpretation,var_In,var_virtual1);
	find mayInstanceOfFAMTerminator_class(problem,interpretation,var_virtual1);
	find mayEquivalent(problem, interpretation, var_virtual1, var_T);
}
private pattern currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_terminatorAndInformation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_T, var_I)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfFAMTerminator_class(problem,interpretation,var_T);
	find mustInstanceOfInformationLink_class(problem,interpretation,var_I);
	// T is exported
	// I is exported
	find mustInstanceOfFunctionalOutput_class(problem,interpretation,var_Out);
	find mustInRelationoutgoingLinks_reference_FunctionalOutput(problem,interpretation,var_Out,var_virtual0);
	find mustInstanceOfInformationLink_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_I;
	find mustInstanceOfFunctionalOutput_class(problem,interpretation,var_Out);
	find mustInRelationterminator_reference_FunctionalData(problem,interpretation,var_Out,var_virtual1);
	find mustInstanceOfFAMTerminator_class(problem,interpretation,var_virtual1);
	var_virtual1 == var_T;
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFAMTerminator_class(problem,interpretation,var_T);
	find mustInstanceOfInformationLink_class(problem,interpretation,var_I);
	// T is exported
	// I is exported
	find mustInstanceOfInformationLink_class(problem,interpretation,var_I);
	find mustInRelationto_reference_InformationLink(problem,interpretation,var_I,var_virtual0);
	find mustInstanceOfFunctionalInput_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_In;
	find mustInstanceOfFunctionalInput_class(problem,interpretation,var_In);
	find mustInRelationterminator_reference_FunctionalData(problem,interpretation,var_In,var_virtual1);
	find mustInstanceOfFAMTerminator_class(problem,interpretation,var_virtual1);
	var_virtual1 == var_T;
}
// Must, May and Current queries for pattern ca mcgill ecse dslreasoner standalone test fam type
private pattern mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_type(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_This, var_Target)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunction_class(problem,interpretation,var_This);
	// type constraint is enforced by construction
	// This is exported
	// Target is exported
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_rootElements(problem,interpretation,_var__Model,var_This);
	var_virtual0 == const_Root_FunctionType;DefinedElement.name(const_Root_FunctionType,"Root FunctionType");  //LogicProblem.elements(problem,const_Root_FunctionType);
	var_Target == var_virtual0;
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunction_class(problem,interpretation,var_This);
	// type constraint is enforced by construction
	// This is exported
	// Target is exported
	neg find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_parent(problem,interpretation,_var__Child,var_This);
	neg find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_rootElements(problem,interpretation,_var__Model,var_This);
	var_virtual0 == const_Leaf_FunctionType;DefinedElement.name(const_Leaf_FunctionType,"Leaf FunctionType");  //LogicProblem.elements(problem,const_Leaf_FunctionType);
	var_Target == var_virtual0;
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunction_class(problem,interpretation,var_This);
	// type constraint is enforced by construction
	// This is exported
	// Target is exported
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_parent(problem,interpretation,var_This,_var__Par);
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_parent(problem,interpretation,_var__Child,var_This);
	var_virtual0 == const_Intermediate_FunctionType;DefinedElement.name(const_Intermediate_FunctionType,"Intermediate FunctionType");  //LogicProblem.elements(problem,const_Intermediate_FunctionType);
	var_Target == var_virtual0;
}
private pattern mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_type(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_This, var_Target)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfFunction_class(problem,interpretation,var_This);
	// type constraint is enforced by construction
	// This is exported
	// Target is exported
	find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_rootElements(problem,interpretation,_var__Model,var_This);
	var_virtual0 == const_Root_FunctionType;DefinedElement.name(const_Root_FunctionType,"Root FunctionType");  //LogicProblem.elements(problem,const_Root_FunctionType);
	find mayEquivalent(problem, interpretation, var_Target, var_virtual0);
}or{
	find interpretation(problem,interpretation);
	find mayInstanceOfFunction_class(problem,interpretation,var_This);
	// type constraint is enforced by construction
	// This is exported
	// Target is exported
	neg find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_parent(problem,interpretation,_var__Child,var_This);
	neg find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_rootElements(problem,interpretation,_var__Model,var_This);
	var_virtual0 == const_Leaf_FunctionType;DefinedElement.name(const_Leaf_FunctionType,"Leaf FunctionType");  //LogicProblem.elements(problem,const_Leaf_FunctionType);
	find mayEquivalent(problem, interpretation, var_Target, var_virtual0);
}or{
	find interpretation(problem,interpretation);
	find mayInstanceOfFunction_class(problem,interpretation,var_This);
	// type constraint is enforced by construction
	// This is exported
	// Target is exported
	find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_parent(problem,interpretation,var_This,_var__Par);
	find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_parent(problem,interpretation,_var__Child,var_This);
	var_virtual0 == const_Intermediate_FunctionType;DefinedElement.name(const_Intermediate_FunctionType,"Intermediate FunctionType");  //LogicProblem.elements(problem,const_Intermediate_FunctionType);
	find mayEquivalent(problem, interpretation, var_Target, var_virtual0);
}
private pattern currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_type(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_This, var_Target)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunction_class(problem,interpretation,var_This);
	// type constraint is enforced by construction
	// This is exported
	// Target is exported
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_rootElements(problem,interpretation,_var__Model,var_This);
	var_virtual0 == const_Root_FunctionType;DefinedElement.name(const_Root_FunctionType,"Root FunctionType");  //LogicProblem.elements(problem,const_Root_FunctionType);
	var_Target == var_virtual0;
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunction_class(problem,interpretation,var_This);
	// type constraint is enforced by construction
	// This is exported
	// Target is exported
	neg find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_parent(problem,interpretation,_var__Child,var_This);
	neg find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_rootElements(problem,interpretation,_var__Model,var_This);
	var_virtual0 == const_Leaf_FunctionType;DefinedElement.name(const_Leaf_FunctionType,"Leaf FunctionType");  //LogicProblem.elements(problem,const_Leaf_FunctionType);
	var_Target == var_virtual0;
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunction_class(problem,interpretation,var_This);
	// type constraint is enforced by construction
	// This is exported
	// Target is exported
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_parent(problem,interpretation,var_This,_var__Par);
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_parent(problem,interpretation,_var__Child,var_This);
	var_virtual0 == const_Intermediate_FunctionType;DefinedElement.name(const_Intermediate_FunctionType,"Intermediate FunctionType");  //LogicProblem.elements(problem,const_Intermediate_FunctionType);
	var_Target == var_virtual0;
}
// Must, May and Current queries for pattern ca mcgill ecse dslreasoner standalone test fam rootElements
private pattern mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_rootElements(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_Model, var_Root)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,var_Model);
	find mustInstanceOfFunction_class(problem,interpretation,var_Root);
	// Model is exported
	// Root is exported
	find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,var_Model);
	find mustInRelationrootElements_reference_FunctionalArchitectureModel(problem,interpretation,var_Model,var_virtual0);
	find mustInstanceOfFunctionalElement_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_Root;
}
private pattern mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_rootElements(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_Model, var_Root)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfFunctionalArchitectureModel_class(problem,interpretation,var_Model);
	find mayInstanceOfFunction_class(problem,interpretation,var_Root);
	// Model is exported
	// Root is exported
	find mayInstanceOfFunctionalArchitectureModel_class(problem,interpretation,var_Model);
	find mayInRelationrootElements_reference_FunctionalArchitectureModel(problem,interpretation,var_Model,var_virtual0);
	find mayInstanceOfFunctionalElement_class(problem,interpretation,var_virtual0);
	find mayEquivalent(problem, interpretation, var_virtual0, var_Root);
}
private pattern currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_rootElements(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_Model, var_Root)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,var_Model);
	find mustInstanceOfFunction_class(problem,interpretation,var_Root);
	// Model is exported
	// Root is exported
	find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,var_Model);
	find mustInRelationrootElements_reference_FunctionalArchitectureModel(problem,interpretation,var_Model,var_virtual0);
	find mustInstanceOfFunctionalElement_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_Root;
}
// Must, May and Current queries for pattern ca mcgill ecse dslreasoner standalone test fam parent
private pattern mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_parent(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_Func, var_Par)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunction_class(problem,interpretation,var_Func);
	find mustInstanceOfFunction_class(problem,interpretation,var_Par);
	// Func is exported
	// Par is exported
	find mustInstanceOfFunction_class(problem,interpretation,var_Func);
	find mustInRelationparent_reference_FunctionalElement(problem,interpretation,var_Func,var_virtual0);
	find mustInstanceOfFunction_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_Par;
}
private pattern mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_parent(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_Func, var_Par)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfFunction_class(problem,interpretation,var_Func);
	find mayInstanceOfFunction_class(problem,interpretation,var_Par);
	// Func is exported
	// Par is exported
	find mayInstanceOfFunction_class(problem,interpretation,var_Func);
	find mayInRelationparent_reference_FunctionalElement(problem,interpretation,var_Func,var_virtual0);
	find mayInstanceOfFunction_class(problem,interpretation,var_virtual0);
	find mayEquivalent(problem, interpretation, var_virtual0, var_Par);
}
private pattern currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_parent(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_Func, var_Par)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunction_class(problem,interpretation,var_Func);
	find mustInstanceOfFunction_class(problem,interpretation,var_Par);
	// Func is exported
	// Par is exported
	find mustInstanceOfFunction_class(problem,interpretation,var_Func);
	find mustInRelationparent_reference_FunctionalElement(problem,interpretation,var_Func,var_virtual0);
	find mustInstanceOfFunction_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_Par;
}
// Must, May and Current queries for pattern ca mcgill ecse dslreasoner standalone test fam model
private pattern mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_model(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_This, var_Target)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalElement_class(problem,interpretation,var_This);
	find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,var_Target);
	// This is exported
	// Target is exported
	find mustInstanceOfFunctionalElement_class(problem,interpretation,var_This);
	find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,var_Target);
}
private pattern mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_model(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_This, var_Target)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfFunctionalElement_class(problem,interpretation,var_This);
	find mayInstanceOfFunctionalArchitectureModel_class(problem,interpretation,var_Target);
	// This is exported
	// Target is exported
	find mayInstanceOfFunctionalElement_class(problem,interpretation,var_This);
	find mayInstanceOfFunctionalArchitectureModel_class(problem,interpretation,var_Target);
}
private pattern currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_model(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_This, var_Target)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalElement_class(problem,interpretation,var_This);
	find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,var_Target);
	// This is exported
	// Target is exported
	find mustInstanceOfFunctionalElement_class(problem,interpretation,var_This);
	find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,var_Target);
}

//////////
// 1.4 Containment Indexer
//////////
private pattern mustContains2(source: DefinedElement, target: DefinedElement) {
	find mustContains4(_,_,source,target);
}
	
private pattern mustContains4(problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target: DefinedElement)
	{ find mustInRelationinterface_reference_FunctionalElement(problem,interpretation,source,target); }or
	
	{ find mustInRelationrootElements_reference_FunctionalArchitectureModel(problem,interpretation,source,target); }or
	
	{ find mustInRelationsubElements_reference_Function(problem,interpretation,source,target); }or
	
	{ find mustInRelationdata_reference_FunctionalInterface(problem,interpretation,source,target); }or
	
	{ find mustInRelationoutgoingLinks_reference_FunctionalOutput(problem,interpretation,source,target); }or
	
	{ find mustInRelationterminator_reference_FunctionalData(problem,interpretation,source,target); }

private pattern mustTransitiveContains(source,target) {
	find mustContains2+(source,target);
}

//////////
// 2. Invalidation Indexers
//////////
// 2.1 Invalidated by WF Queries
//////////

//////////
// 3. Unfinishedness Indexers
//////////
// 3.1 Unfinishedness Measured by Multiplicity
//////////
pattern unfinishedLowerMultiplicity_to_reference_InformationLink(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"to reference InformationLink");
	find mustInstanceOfInformationLink_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationto_reference_InformationLink(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}

//////////
// 3.2 Unfinishedness Measured by WF Queries
//////////

//////////
// 4. Refinement Indexers
//////////
// 4.1 Object constructors
//////////
private pattern hasElementInContainment(problem:LogicProblem, interpretation:PartialInterpretation)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalData_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfInformationLink_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalInterface_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFAMTerminator_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalElement_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalOutput_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunction_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalInput_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalArchitectureModel_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}
pattern createObject_FunctionalOutput_class_by_data_reference_FunctionalInterface_with_interface_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalOutput class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"data reference FunctionalInterface");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"interface reference FunctionalData");
	find mustInstanceOfFunctionalInterface_class(problem,interpretation,container);
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,newObject);
	find mayInRelationdata_reference_FunctionalInterface(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalOutput_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalOutput class");
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FAMTerminator_class_by_terminator_reference_FunctionalData_with_data_reference_FAMTerminator(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FAMTerminator class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"terminator reference FunctionalData");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"data reference FAMTerminator");
	find mustInstanceOfFunctionalData_class(problem,interpretation,container);
	find mayInstanceOfFAMTerminator_class(problem,interpretation,newObject);
	find mayInRelationterminator_reference_FunctionalData(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FAMTerminator_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FAMTerminator class");
	find mayInstanceOfFAMTerminator_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Function_class_by_rootElements_reference_FunctionalArchitectureModel(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Function class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"rootElements reference FunctionalArchitectureModel");
	find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,container);
	find mayInstanceOfFunction_class(problem,interpretation,newObject);
	find mayInRelationrootElements_reference_FunctionalArchitectureModel(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Function_class_by_subElements_reference_Function_with_parent_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Function class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"subElements reference Function");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"parent reference FunctionalElement");
	find mustInstanceOfFunction_class(problem,interpretation,container);
	find mayInstanceOfFunction_class(problem,interpretation,newObject);
	find mayInRelationsubElements_reference_Function(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Function_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Function class");
	find mayInstanceOfFunction_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalInput_class_by_data_reference_FunctionalInterface_with_interface_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalInput class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"data reference FunctionalInterface");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"interface reference FunctionalData");
	find mustInstanceOfFunctionalInterface_class(problem,interpretation,container);
	find mayInstanceOfFunctionalInput_class(problem,interpretation,newObject);
	find mayInRelationdata_reference_FunctionalInterface(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalInput_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalInput class");
	find mayInstanceOfFunctionalInput_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalArchitectureModel_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalArchitectureModel class UndefinedPart");
	find mayInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalInterface_class_by_interface_reference_FunctionalElement_with_element_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalInterface class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"interface reference FunctionalElement");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"element reference FunctionalInterface");
	find mustInstanceOfFunctionalElement_class(problem,interpretation,container);
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,newObject);
	find mayInRelationinterface_reference_FunctionalElement(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalInterface_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalInterface class");
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_InformationLink_class_by_outgoingLinks_reference_FunctionalOutput_with_from_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"InformationLink class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"outgoingLinks reference FunctionalOutput");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"from reference InformationLink");
	find mustInstanceOfFunctionalOutput_class(problem,interpretation,container);
	find mayInstanceOfInformationLink_class(problem,interpretation,newObject);
	find mayInRelationoutgoingLinks_reference_FunctionalOutput(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_InformationLink_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"InformationLink class");
	find mayInstanceOfInformationLink_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}

//////////
// 4.2 Type refinement
//////////
pattern refineTypeTo_FunctionalOutput_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
}
pattern refineTypeTo_FAMTerminator_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
}
pattern refineTypeTo_Function_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunction_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunction_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
}
pattern refineTypeTo_FunctionalInput_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
}
pattern refineTypeTo_FunctionalArchitectureModel_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
}
pattern refineTypeTo_FunctionalInterface_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
}
pattern refineTypeTo_InformationLink_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
}

//////////
// 4.3 Relation refinement
//////////
pattern refineRelation_model_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"model reference FunctionalElement");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFunctionalElement_class(problem,interpretation,from);
	find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,to);
	find mayInRelationmodel_reference_FunctionalElement(problem,interpretation,from,to);
	neg find mustInRelationmodel_reference_FunctionalElement(problem,interpretation,from,to);
}
pattern refineRelation_IncomingLinks_reference_FunctionalInput_and_to_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation, oppositeInterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"IncomingLinks reference FunctionalInput");
	PartialInterpretation.partialrelationinterpretation(interpretation,oppositeInterpretation);
	PartialRelationInterpretation.interpretationOf.name(oppositeInterpretation,"to reference InformationLink");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFunctionalInput_class(problem,interpretation,from);
	find mustInstanceOfInformationLink_class(problem,interpretation,to);
	find mayInRelationIncomingLinks_reference_FunctionalInput(problem,interpretation,from,to);
	neg find mustInRelationIncomingLinks_reference_FunctionalInput(problem,interpretation,from,to);
}
pattern refineRelation_type_attribute_Function(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"type attribute Function");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFunction_class(problem,interpretation,from);
	find mustInstanceOfFunctionType_enum(problem,interpretation,to);
	find mayInRelationtype_attribute_Function(problem,interpretation,from,to);
	neg find mustInRelationtype_attribute_Function(problem,interpretation,from,to);
}
import epackage "http://www.bme.hu/mit/inf/dslreasoner/viatrasolver/partialinterpretationlanguage"
import epackage "http://www.bme.hu/mit/inf/dslreasoner/logic/model/problem"
import epackage "http://www.bme.hu/mit/inf/dslreasoner/logic/model/language"

//////////
// 0. Util
//////////
private pattern interpretation(problem:LogicProblem, interpretation:PartialInterpretation) {
	PartialInterpretation.problem(interpretation,problem);
}
	
/////////////////////////
// 0.1 Existence
/////////////////////////
private pattern mustExist(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	find interpretation(problem,interpretation);
	LogicProblem.elements(problem,element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
}

private pattern mayExist(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
    find mustExist(problem,interpretation,element);
} or {
    find interpretation(problem,interpretation);
    neg find elementCloseWorld(element);
    PartialInterpretation.openWorldElements(interpretation,element);
}

private pattern elementCloseWorld(element:DefinedElement) {
	PartialInterpretation.openWorldElements(i,element);
    PartialInterpretation.maxNewElements(i,0);
} or {
	Scope.targetTypeInterpretation(scope,interpretation);
	PartialTypeInterpratation.elements(interpretation,element);
	Scope.maxNewElements(scope,0);
}

////////////////////////
// 0.2 Equivalence
////////////////////////
pattern mayEquivalent(problem:LogicProblem, interpretation:PartialInterpretation, a: DefinedElement, b: DefinedElement) {
	find mayExist(problem,interpretation,a);
	find mayExist(problem,interpretation,b);
	a == b;
}

////////////////////////
// 0.3 Required Patterns by TypeIndexer
////////////////////////
private pattern typeInterpretation(problem:LogicProblem, interpretation:PartialInterpretation, type:TypeDeclaration, typeInterpretation:PartialComplexTypeInterpretation) {
	find interpretation(problem,interpretation);
	LogicProblem.types(problem,type);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
}

private pattern directInstanceOf(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement, type:Type) {
	find interpretation(problem,interpretation);
	LogicProblem.types(problem,type);
	TypeDefinition.elements(type,element);
} or {
	find interpretation(problem,interpretation);
	find typeInterpretation(problem,interpretation,type,typeInterpretation);
	PartialComplexTypeInterpretation.elements(typeInterpretation,element);
}

private pattern isPrimitive(element: PrimitiveElement) {
	PrimitiveElement(element);
}

//////////
// 1. Problem-Specific Base Indexers
//////////
// 1.1 Type Indexers
//////////
// 1.1.1 primitive Type Indexers
//////////

//////////
// 1.1.2 domain-specific Type Indexers
//////////
/**
 * An element must be an instance of type "FunctionalElement class".
 */
private pattern mustInstanceOfFunctionalElement_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalElement class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalElement_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalElement class");
}

/**
 * An element may be an instance of type "FunctionalElement class".
 */
private pattern mayInstanceOfFunctionalElement_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunction_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalElement_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunction_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalElement_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalElement_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalArchitectureModel class".
 */
private pattern mustInstanceOfFunctionalArchitectureModel_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalArchitectureModel class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalArchitectureModel_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalArchitectureModel class");
}

/**
 * An element may be an instance of type "FunctionalArchitectureModel class".
 */
private pattern mayInstanceOfFunctionalArchitectureModel_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalArchitectureModel_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalArchitectureModel_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Function class".
 */
private pattern mustInstanceOfFunction_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Function class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunction_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Function class");
}

/**
 * An element may be an instance of type "Function class".
 */
private pattern mayInstanceOfFunction_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunction_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunction_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunction_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FAMTerminator class".
 */
private pattern mustInstanceOfFAMTerminator_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FAMTerminator class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFAMTerminator_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FAMTerminator class");
}

/**
 * An element may be an instance of type "FAMTerminator class".
 */
private pattern mayInstanceOfFAMTerminator_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find scopeDisallowsNewFAMTerminator_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find scopeDisallowsNewFAMTerminator_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFAMTerminator_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "InformationLink class".
 */
private pattern mustInstanceOfInformationLink_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"InformationLink class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewInformationLink_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"InformationLink class");
}

/**
 * An element may be an instance of type "InformationLink class".
 */
private pattern mayInstanceOfInformationLink_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find scopeDisallowsNewInformationLink_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find scopeDisallowsNewInformationLink_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfInformationLink_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalInterface class".
 */
private pattern mustInstanceOfFunctionalInterface_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalInterface class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalInterface_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalInterface class");
}

/**
 * An element may be an instance of type "FunctionalInterface class".
 */
private pattern mayInstanceOfFunctionalInterface_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalInterface_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalInterface_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalInterface_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalInput class".
 */
private pattern mustInstanceOfFunctionalInput_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalInput class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalInput_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalInput class");
}

/**
 * An element may be an instance of type "FunctionalInput class".
 */
private pattern mayInstanceOfFunctionalInput_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalInput_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalInput_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalInput_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalOutput class".
 */
private pattern mustInstanceOfFunctionalOutput_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalOutput class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalOutput_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalOutput class");
}

/**
 * An element may be an instance of type "FunctionalOutput class".
 */
private pattern mayInstanceOfFunctionalOutput_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalOutput_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalOutput_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalOutput_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalData class".
 */
private pattern mustInstanceOfFunctionalData_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalData class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalData_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalData class");
}

/**
 * An element may be an instance of type "FunctionalData class".
 */
private pattern mayInstanceOfFunctionalData_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalData_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalData_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalData_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionType enum".
 */
private pattern mustInstanceOfFunctionType_enum(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionType enum");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionType_enum(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionType enum");
}

/**
 * An element may be an instance of type "FunctionType enum".
 */
private pattern mayInstanceOfFunctionType_enum(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfFunctionType_enum(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalArchitectureModel class DefinedPart".
 */
private pattern mustInstanceOfFunctionalArchitectureModel_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalArchitectureModel class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalArchitectureModel_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalArchitectureModel class DefinedPart");
}

/**
 * An element may be an instance of type "FunctionalArchitectureModel class DefinedPart".
 */
private pattern mayInstanceOfFunctionalArchitectureModel_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfFunctionalArchitectureModel_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalArchitectureModel class UndefinedPart".
 */
private pattern mustInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalArchitectureModel class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalArchitectureModel_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalArchitectureModel class UndefinedPart");
}

/**
 * An element may be an instance of type "FunctionalArchitectureModel class UndefinedPart".
 */
private pattern mayInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalArchitectureModel_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalArchitectureModel_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem,interpretation,element); }

//////////
// 1.2 Relation Declaration Indexers
//////////
/**
 * Matcher for detecting tuples t where []interface reference FunctionalElement(source,target)
 */
private pattern mustInRelationinterface_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"interface reference FunctionalElement");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>interface reference FunctionalElement(source,target)
 */
private pattern mayInRelationinterface_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalElement_class(problem,interpretation,source);
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationinterface_reference_FunctionalElement(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationelement_reference_FunctionalInterface(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationinterface_reference_FunctionalElement(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []model reference FunctionalElement(source,target)
 */
 private pattern mustInRelationmodel_reference_FunctionalElement(
 	problem:LogicProblem, interpretation:PartialInterpretation,
 	source: DefinedElement, target:DefinedElement)
 {
 	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_model(problem,interpretation,source,target);
 }
/**
 * Matcher for detecting tuples t where []model reference FunctionalElement(source,target)
 */
 private pattern mayInRelationmodel_reference_FunctionalElement(
 	problem:LogicProblem, interpretation:PartialInterpretation,
 	source: DefinedElement, target:DefinedElement)
 {
 	find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_model(problem,interpretation,source,target);
 }
/**
 * Matcher for detecting tuples t where []parent reference FunctionalElement(source,target)
 */
private pattern mustInRelationparent_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"parent reference FunctionalElement");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>parent reference FunctionalElement(source,target)
 */
private pattern mayInRelationparent_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalElement_class(problem,interpretation,source);
	find mayInstanceOfFunction_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationparent_reference_FunctionalElement(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationparent_reference_FunctionalElement(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []rootElements reference FunctionalArchitectureModel(source,target)
 */
private pattern mustInRelationrootElements_reference_FunctionalArchitectureModel(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"rootElements reference FunctionalArchitectureModel");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>rootElements reference FunctionalArchitectureModel(source,target)
 */
private pattern mayInRelationrootElements_reference_FunctionalArchitectureModel(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalArchitectureModel_class(problem,interpretation,source);
	find mayInstanceOfFunctionalElement_class(problem,interpretation,target);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationrootElements_reference_FunctionalArchitectureModel(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []subElements reference Function(source,target)
 */
private pattern mustInRelationsubElements_reference_Function(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"subElements reference Function");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>subElements reference Function(source,target)
 */
private pattern mayInRelationsubElements_reference_Function(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunction_class(problem,interpretation,source);
	find mayInstanceOfFunctionalElement_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationparent_reference_FunctionalElement(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationsubElements_reference_Function(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []data reference FAMTerminator(source,target)
 */
private pattern mustInRelationdata_reference_FAMTerminator(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"data reference FAMTerminator");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>data reference FAMTerminator(source,target)
 */
private pattern mayInRelationdata_reference_FAMTerminator(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFAMTerminator_class(problem,interpretation,source);
	find mayInstanceOfFunctionalData_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationdata_reference_FAMTerminator(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationterminator_reference_FunctionalData(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationdata_reference_FAMTerminator(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []from reference InformationLink(source,target)
 */
private pattern mustInRelationfrom_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"from reference InformationLink");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>from reference InformationLink(source,target)
 */
private pattern mayInRelationfrom_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfInformationLink_class(problem,interpretation,source);
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationfrom_reference_InformationLink(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationfrom_reference_InformationLink(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []to reference InformationLink(source,target)
 */
private pattern mustInRelationto_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"to reference InformationLink");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>to reference InformationLink(source,target)
 */
private pattern mayInRelationto_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfInformationLink_class(problem,interpretation,source);
	find mayInstanceOfFunctionalInput_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationto_reference_InformationLink(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationto_reference_InformationLink(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []data reference FunctionalInterface(source,target)
 */
private pattern mustInRelationdata_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"data reference FunctionalInterface");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>data reference FunctionalInterface(source,target)
 */
private pattern mayInRelationdata_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,source);
	find mayInstanceOfFunctionalData_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationinterface_reference_FunctionalData(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationdata_reference_FunctionalInterface(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []element reference FunctionalInterface(source,target)
 */
private pattern mustInRelationelement_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"element reference FunctionalInterface");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>element reference FunctionalInterface(source,target)
 */
private pattern mayInRelationelement_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,source);
	find mayInstanceOfFunctionalElement_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationelement_reference_FunctionalInterface(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationinterface_reference_FunctionalElement(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationelement_reference_FunctionalInterface(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []IncomingLinks reference FunctionalInput(source,target)
 */
private pattern mustInRelationIncomingLinks_reference_FunctionalInput(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"IncomingLinks reference FunctionalInput");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>IncomingLinks reference FunctionalInput(source,target)
 */
private pattern mayInRelationIncomingLinks_reference_FunctionalInput(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalInput_class(problem,interpretation,source);
	find mayInstanceOfInformationLink_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationto_reference_InformationLink(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
} or {
	find mustInRelationIncomingLinks_reference_FunctionalInput(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []outgoingLinks reference FunctionalOutput(source,target)
 */
private pattern mustInRelationoutgoingLinks_reference_FunctionalOutput(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"outgoingLinks reference FunctionalOutput");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>outgoingLinks reference FunctionalOutput(source,target)
 */
private pattern mayInRelationoutgoingLinks_reference_FunctionalOutput(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,source);
	find mayInstanceOfInformationLink_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationfrom_reference_InformationLink(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationoutgoingLinks_reference_FunctionalOutput(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []terminator reference FunctionalData(source,target)
 */
private pattern mustInRelationterminator_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"terminator reference FunctionalData");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>terminator reference FunctionalData(source,target)
 */
private pattern mayInRelationterminator_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalData_class(problem,interpretation,source);
	find mayInstanceOfFAMTerminator_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationterminator_reference_FunctionalData(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationdata_reference_FAMTerminator(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationterminator_reference_FunctionalData(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []interface reference FunctionalData(source,target)
 */
private pattern mustInRelationinterface_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"interface reference FunctionalData");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>interface reference FunctionalData(source,target)
 */
private pattern mayInRelationinterface_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalData_class(problem,interpretation,source);
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationinterface_reference_FunctionalData(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationinterface_reference_FunctionalData(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []type attribute Function(source,target)
 */
 private pattern mustInRelationtype_attribute_Function(
 	problem:LogicProblem, interpretation:PartialInterpretation,
 	source: DefinedElement, target:DefinedElement)
 {
 	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_type(problem,interpretation,source,target);
 }
/**
 * Matcher for detecting tuples t where []type attribute Function(source,target)
 */
 private pattern mayInRelationtype_attribute_Function(
 	problem:LogicProblem, interpretation:PartialInterpretation,
 	source: DefinedElement, target:DefinedElement)
 {
 	find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_type(problem,interpretation,source,target);
 }

//////////
// 1.3 Relation Definition Indexers
//////////
// Must, May and Current queries for pattern ca mcgill ecse dslreasoner standalone test fam terminatorAndInformation
private pattern mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_terminatorAndInformation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_T, var_I)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfFAMTerminator_class(problem,interpretation,var_T);
	find mustInstanceOfInformationLink_class(problem,interpretation,var_I);
	// T is exported
	// I is exported
	find mustInstanceOfFunctionalOutput_class(problem,interpretation,var_Out);
	find mustInRelationoutgoingLinks_reference_FunctionalOutput(problem,interpretation,var_Out,var_virtual0);
	find mustInstanceOfInformationLink_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_I;
	find mustInstanceOfFunctionalOutput_class(problem,interpretation,var_Out);
	find mustInRelationterminator_reference_FunctionalData(problem,interpretation,var_Out,var_virtual1);
	find mustInstanceOfFAMTerminator_class(problem,interpretation,var_virtual1);
	var_virtual1 == var_T;
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFAMTerminator_class(problem,interpretation,var_T);
	find mustInstanceOfInformationLink_class(problem,interpretation,var_I);
	// T is exported
	// I is exported
	find mustInstanceOfInformationLink_class(problem,interpretation,var_I);
	find mustInRelationto_reference_InformationLink(problem,interpretation,var_I,var_virtual0);
	find mustInstanceOfFunctionalInput_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_In;
	find mustInstanceOfFunctionalInput_class(problem,interpretation,var_In);
	find mustInRelationterminator_reference_FunctionalData(problem,interpretation,var_In,var_virtual1);
	find mustInstanceOfFAMTerminator_class(problem,interpretation,var_virtual1);
	var_virtual1 == var_T;
}
private pattern mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_terminatorAndInformation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_T, var_I)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfFAMTerminator_class(problem,interpretation,var_T);
	find mayInstanceOfInformationLink_class(problem,interpretation,var_I);
	// T is exported
	// I is exported
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,var_Out);
	find mayInRelationoutgoingLinks_reference_FunctionalOutput(problem,interpretation,var_Out,var_virtual0);
	find mayInstanceOfInformationLink_class(problem,interpretation,var_virtual0);
	find mayEquivalent(problem, interpretation, var_virtual0, var_I);
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,var_Out);
	find mayInRelationterminator_reference_FunctionalData(problem,interpretation,var_Out,var_virtual1);
	find mayInstanceOfFAMTerminator_class(problem,interpretation,var_virtual1);
	find mayEquivalent(problem, interpretation, var_virtual1, var_T);
}or{
	find interpretation(problem,interpretation);
	find mayInstanceOfFAMTerminator_class(problem,interpretation,var_T);
	find mayInstanceOfInformationLink_class(problem,interpretation,var_I);
	// T is exported
	// I is exported
	find mayInstanceOfInformationLink_class(problem,interpretation,var_I);
	find mayInRelationto_reference_InformationLink(problem,interpretation,var_I,var_virtual0);
	find mayInstanceOfFunctionalInput_class(problem,interpretation,var_virtual0);
	find mayEquivalent(problem, interpretation, var_virtual0, var_In);
	find mayInstanceOfFunctionalInput_class(problem,interpretation,var_In);
	find mayInRelationterminator_reference_FunctionalData(problem,interpretation,var_In,var_virtual1);
	find mayInstanceOfFAMTerminator_class(problem,interpretation,var_virtual1);
	find mayEquivalent(problem, interpretation, var_virtual1, var_T);
}
private pattern currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_terminatorAndInformation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_T, var_I)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfFAMTerminator_class(problem,interpretation,var_T);
	find mustInstanceOfInformationLink_class(problem,interpretation,var_I);
	// T is exported
	// I is exported
	find mustInstanceOfFunctionalOutput_class(problem,interpretation,var_Out);
	find mustInRelationoutgoingLinks_reference_FunctionalOutput(problem,interpretation,var_Out,var_virtual0);
	find mustInstanceOfInformationLink_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_I;
	find mustInstanceOfFunctionalOutput_class(problem,interpretation,var_Out);
	find mustInRelationterminator_reference_FunctionalData(problem,interpretation,var_Out,var_virtual1);
	find mustInstanceOfFAMTerminator_class(problem,interpretation,var_virtual1);
	var_virtual1 == var_T;
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFAMTerminator_class(problem,interpretation,var_T);
	find mustInstanceOfInformationLink_class(problem,interpretation,var_I);
	// T is exported
	// I is exported
	find mustInstanceOfInformationLink_class(problem,interpretation,var_I);
	find mustInRelationto_reference_InformationLink(problem,interpretation,var_I,var_virtual0);
	find mustInstanceOfFunctionalInput_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_In;
	find mustInstanceOfFunctionalInput_class(problem,interpretation,var_In);
	find mustInRelationterminator_reference_FunctionalData(problem,interpretation,var_In,var_virtual1);
	find mustInstanceOfFAMTerminator_class(problem,interpretation,var_virtual1);
	var_virtual1 == var_T;
}
// Must, May and Current queries for pattern ca mcgill ecse dslreasoner standalone test fam type
private pattern mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_type(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_This, var_Target)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunction_class(problem,interpretation,var_This);
	// type constraint is enforced by construction
	// This is exported
	// Target is exported
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_rootElements(problem,interpretation,_var__Model,var_This);
	var_virtual0 == const_Root_FunctionType;DefinedElement.name(const_Root_FunctionType,"Root FunctionType");  //LogicProblem.elements(problem,const_Root_FunctionType);
	var_Target == var_virtual0;
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunction_class(problem,interpretation,var_This);
	// type constraint is enforced by construction
	// This is exported
	// Target is exported
	neg find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_parent(problem,interpretation,_var__Child,var_This);
	neg find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_rootElements(problem,interpretation,_var__Model,var_This);
	var_virtual0 == const_Leaf_FunctionType;DefinedElement.name(const_Leaf_FunctionType,"Leaf FunctionType");  //LogicProblem.elements(problem,const_Leaf_FunctionType);
	var_Target == var_virtual0;
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunction_class(problem,interpretation,var_This);
	// type constraint is enforced by construction
	// This is exported
	// Target is exported
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_parent(problem,interpretation,var_This,_var__Par);
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_parent(problem,interpretation,_var__Child,var_This);
	var_virtual0 == const_Intermediate_FunctionType;DefinedElement.name(const_Intermediate_FunctionType,"Intermediate FunctionType");  //LogicProblem.elements(problem,const_Intermediate_FunctionType);
	var_Target == var_virtual0;
}
private pattern mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_type(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_This, var_Target)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfFunction_class(problem,interpretation,var_This);
	// type constraint is enforced by construction
	// This is exported
	// Target is exported
	find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_rootElements(problem,interpretation,_var__Model,var_This);
	var_virtual0 == const_Root_FunctionType;DefinedElement.name(const_Root_FunctionType,"Root FunctionType");  //LogicProblem.elements(problem,const_Root_FunctionType);
	find mayEquivalent(problem, interpretation, var_Target, var_virtual0);
}or{
	find interpretation(problem,interpretation);
	find mayInstanceOfFunction_class(problem,interpretation,var_This);
	// type constraint is enforced by construction
	// This is exported
	// Target is exported
	neg find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_parent(problem,interpretation,_var__Child,var_This);
	neg find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_rootElements(problem,interpretation,_var__Model,var_This);
	var_virtual0 == const_Leaf_FunctionType;DefinedElement.name(const_Leaf_FunctionType,"Leaf FunctionType");  //LogicProblem.elements(problem,const_Leaf_FunctionType);
	find mayEquivalent(problem, interpretation, var_Target, var_virtual0);
}or{
	find interpretation(problem,interpretation);
	find mayInstanceOfFunction_class(problem,interpretation,var_This);
	// type constraint is enforced by construction
	// This is exported
	// Target is exported
	find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_parent(problem,interpretation,var_This,_var__Par);
	find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_parent(problem,interpretation,_var__Child,var_This);
	var_virtual0 == const_Intermediate_FunctionType;DefinedElement.name(const_Intermediate_FunctionType,"Intermediate FunctionType");  //LogicProblem.elements(problem,const_Intermediate_FunctionType);
	find mayEquivalent(problem, interpretation, var_Target, var_virtual0);
}
private pattern currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_type(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_This, var_Target)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunction_class(problem,interpretation,var_This);
	// type constraint is enforced by construction
	// This is exported
	// Target is exported
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_rootElements(problem,interpretation,_var__Model,var_This);
	var_virtual0 == const_Root_FunctionType;DefinedElement.name(const_Root_FunctionType,"Root FunctionType");  //LogicProblem.elements(problem,const_Root_FunctionType);
	var_Target == var_virtual0;
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunction_class(problem,interpretation,var_This);
	// type constraint is enforced by construction
	// This is exported
	// Target is exported
	neg find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_parent(problem,interpretation,_var__Child,var_This);
	neg find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_rootElements(problem,interpretation,_var__Model,var_This);
	var_virtual0 == const_Leaf_FunctionType;DefinedElement.name(const_Leaf_FunctionType,"Leaf FunctionType");  //LogicProblem.elements(problem,const_Leaf_FunctionType);
	var_Target == var_virtual0;
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunction_class(problem,interpretation,var_This);
	// type constraint is enforced by construction
	// This is exported
	// Target is exported
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_parent(problem,interpretation,var_This,_var__Par);
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_parent(problem,interpretation,_var__Child,var_This);
	var_virtual0 == const_Intermediate_FunctionType;DefinedElement.name(const_Intermediate_FunctionType,"Intermediate FunctionType");  //LogicProblem.elements(problem,const_Intermediate_FunctionType);
	var_Target == var_virtual0;
}
// Must, May and Current queries for pattern ca mcgill ecse dslreasoner standalone test fam rootElements
private pattern mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_rootElements(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_Model, var_Root)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,var_Model);
	find mustInstanceOfFunction_class(problem,interpretation,var_Root);
	// Model is exported
	// Root is exported
	find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,var_Model);
	find mustInRelationrootElements_reference_FunctionalArchitectureModel(problem,interpretation,var_Model,var_virtual0);
	find mustInstanceOfFunctionalElement_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_Root;
}
private pattern mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_rootElements(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_Model, var_Root)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfFunctionalArchitectureModel_class(problem,interpretation,var_Model);
	find mayInstanceOfFunction_class(problem,interpretation,var_Root);
	// Model is exported
	// Root is exported
	find mayInstanceOfFunctionalArchitectureModel_class(problem,interpretation,var_Model);
	find mayInRelationrootElements_reference_FunctionalArchitectureModel(problem,interpretation,var_Model,var_virtual0);
	find mayInstanceOfFunctionalElement_class(problem,interpretation,var_virtual0);
	find mayEquivalent(problem, interpretation, var_virtual0, var_Root);
}
private pattern currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_rootElements(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_Model, var_Root)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,var_Model);
	find mustInstanceOfFunction_class(problem,interpretation,var_Root);
	// Model is exported
	// Root is exported
	find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,var_Model);
	find mustInRelationrootElements_reference_FunctionalArchitectureModel(problem,interpretation,var_Model,var_virtual0);
	find mustInstanceOfFunctionalElement_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_Root;
}
// Must, May and Current queries for pattern ca mcgill ecse dslreasoner standalone test fam parent
private pattern mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_parent(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_Func, var_Par)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunction_class(problem,interpretation,var_Func);
	find mustInstanceOfFunction_class(problem,interpretation,var_Par);
	// Func is exported
	// Par is exported
	find mustInstanceOfFunction_class(problem,interpretation,var_Func);
	find mustInRelationparent_reference_FunctionalElement(problem,interpretation,var_Func,var_virtual0);
	find mustInstanceOfFunction_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_Par;
}
private pattern mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_parent(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_Func, var_Par)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfFunction_class(problem,interpretation,var_Func);
	find mayInstanceOfFunction_class(problem,interpretation,var_Par);
	// Func is exported
	// Par is exported
	find mayInstanceOfFunction_class(problem,interpretation,var_Func);
	find mayInRelationparent_reference_FunctionalElement(problem,interpretation,var_Func,var_virtual0);
	find mayInstanceOfFunction_class(problem,interpretation,var_virtual0);
	find mayEquivalent(problem, interpretation, var_virtual0, var_Par);
}
private pattern currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_parent(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_Func, var_Par)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunction_class(problem,interpretation,var_Func);
	find mustInstanceOfFunction_class(problem,interpretation,var_Par);
	// Func is exported
	// Par is exported
	find mustInstanceOfFunction_class(problem,interpretation,var_Func);
	find mustInRelationparent_reference_FunctionalElement(problem,interpretation,var_Func,var_virtual0);
	find mustInstanceOfFunction_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_Par;
}
// Must, May and Current queries for pattern ca mcgill ecse dslreasoner standalone test fam model
private pattern mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_model(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_This, var_Target)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalElement_class(problem,interpretation,var_This);
	find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,var_Target);
	// This is exported
	// Target is exported
	find mustInstanceOfFunctionalElement_class(problem,interpretation,var_This);
	find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,var_Target);
}
private pattern mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_model(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_This, var_Target)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfFunctionalElement_class(problem,interpretation,var_This);
	find mayInstanceOfFunctionalArchitectureModel_class(problem,interpretation,var_Target);
	// This is exported
	// Target is exported
	find mayInstanceOfFunctionalElement_class(problem,interpretation,var_This);
	find mayInstanceOfFunctionalArchitectureModel_class(problem,interpretation,var_Target);
}
private pattern currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_model(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_This, var_Target)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalElement_class(problem,interpretation,var_This);
	find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,var_Target);
	// This is exported
	// Target is exported
	find mustInstanceOfFunctionalElement_class(problem,interpretation,var_This);
	find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,var_Target);
}

//////////
// 1.4 Containment Indexer
//////////
private pattern mustContains2(source: DefinedElement, target: DefinedElement) {
	find mustContains4(_,_,source,target);
}
	
private pattern mustContains4(problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target: DefinedElement)
	{ find mustInRelationinterface_reference_FunctionalElement(problem,interpretation,source,target); }or
	
	{ find mustInRelationrootElements_reference_FunctionalArchitectureModel(problem,interpretation,source,target); }or
	
	{ find mustInRelationsubElements_reference_Function(problem,interpretation,source,target); }or
	
	{ find mustInRelationdata_reference_FunctionalInterface(problem,interpretation,source,target); }or
	
	{ find mustInRelationoutgoingLinks_reference_FunctionalOutput(problem,interpretation,source,target); }or
	
	{ find mustInRelationterminator_reference_FunctionalData(problem,interpretation,source,target); }

private pattern mustTransitiveContains(source,target) {
	find mustContains2+(source,target);
}

//////////
// 2. Invalidation Indexers
//////////
// 2.1 Invalidated by WF Queries
//////////

//////////
// 3. Unfinishedness Indexers
//////////
// 3.1 Unfinishedness Measured by Multiplicity
//////////
pattern unfinishedLowerMultiplicity_to_reference_InformationLink(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"to reference InformationLink");
	find mustInstanceOfInformationLink_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationto_reference_InformationLink(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}

//////////
// 3.2 Unfinishedness Measured by WF Queries
//////////

//////////
// 4. Refinement Indexers
//////////
// 4.1 Object constructors
//////////
private pattern hasElementInContainment(problem:LogicProblem, interpretation:PartialInterpretation)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalOutput_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalElement_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfInformationLink_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalInterface_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalData_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunction_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFAMTerminator_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalInput_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalArchitectureModel_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}
pattern createObject_FunctionalInput_class_by_data_reference_FunctionalInterface_with_interface_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalInput class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"data reference FunctionalInterface");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"interface reference FunctionalData");
	find mustInstanceOfFunctionalInterface_class(problem,interpretation,container);
	find mayInstanceOfFunctionalInput_class(problem,interpretation,newObject);
	find mayInRelationdata_reference_FunctionalInterface(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalInput_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalInput class");
	find mayInstanceOfFunctionalInput_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalOutput_class_by_data_reference_FunctionalInterface_with_interface_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalOutput class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"data reference FunctionalInterface");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"interface reference FunctionalData");
	find mustInstanceOfFunctionalInterface_class(problem,interpretation,container);
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,newObject);
	find mayInRelationdata_reference_FunctionalInterface(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalOutput_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalOutput class");
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FAMTerminator_class_by_terminator_reference_FunctionalData_with_data_reference_FAMTerminator(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FAMTerminator class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"terminator reference FunctionalData");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"data reference FAMTerminator");
	find mustInstanceOfFunctionalData_class(problem,interpretation,container);
	find mayInstanceOfFAMTerminator_class(problem,interpretation,newObject);
	find mayInRelationterminator_reference_FunctionalData(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FAMTerminator_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FAMTerminator class");
	find mayInstanceOfFAMTerminator_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_InformationLink_class_by_outgoingLinks_reference_FunctionalOutput_with_from_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"InformationLink class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"outgoingLinks reference FunctionalOutput");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"from reference InformationLink");
	find mustInstanceOfFunctionalOutput_class(problem,interpretation,container);
	find mayInstanceOfInformationLink_class(problem,interpretation,newObject);
	find mayInRelationoutgoingLinks_reference_FunctionalOutput(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_InformationLink_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"InformationLink class");
	find mayInstanceOfInformationLink_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalArchitectureModel_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalArchitectureModel class UndefinedPart");
	find mayInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Function_class_by_rootElements_reference_FunctionalArchitectureModel(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Function class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"rootElements reference FunctionalArchitectureModel");
	find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,container);
	find mayInstanceOfFunction_class(problem,interpretation,newObject);
	find mayInRelationrootElements_reference_FunctionalArchitectureModel(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Function_class_by_subElements_reference_Function_with_parent_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Function class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"subElements reference Function");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"parent reference FunctionalElement");
	find mustInstanceOfFunction_class(problem,interpretation,container);
	find mayInstanceOfFunction_class(problem,interpretation,newObject);
	find mayInRelationsubElements_reference_Function(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Function_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Function class");
	find mayInstanceOfFunction_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalInterface_class_by_interface_reference_FunctionalElement_with_element_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalInterface class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"interface reference FunctionalElement");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"element reference FunctionalInterface");
	find mustInstanceOfFunctionalElement_class(problem,interpretation,container);
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,newObject);
	find mayInRelationinterface_reference_FunctionalElement(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalInterface_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalInterface class");
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}

//////////
// 4.2 Type refinement
//////////
pattern refineTypeTo_FunctionalInput_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
}
pattern refineTypeTo_FunctionalOutput_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
}
pattern refineTypeTo_FAMTerminator_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
}
pattern refineTypeTo_InformationLink_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
}
pattern refineTypeTo_FunctionalArchitectureModel_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
}
pattern refineTypeTo_Function_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunction_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunction_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
}
pattern refineTypeTo_FunctionalInterface_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
}

//////////
// 4.3 Relation refinement
//////////
pattern refineRelation_model_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"model reference FunctionalElement");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFunctionalElement_class(problem,interpretation,from);
	find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,to);
	find mayInRelationmodel_reference_FunctionalElement(problem,interpretation,from,to);
	neg find mustInRelationmodel_reference_FunctionalElement(problem,interpretation,from,to);
}
pattern refineRelation_IncomingLinks_reference_FunctionalInput_and_to_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation, oppositeInterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"IncomingLinks reference FunctionalInput");
	PartialInterpretation.partialrelationinterpretation(interpretation,oppositeInterpretation);
	PartialRelationInterpretation.interpretationOf.name(oppositeInterpretation,"to reference InformationLink");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFunctionalInput_class(problem,interpretation,from);
	find mustInstanceOfInformationLink_class(problem,interpretation,to);
	find mayInRelationIncomingLinks_reference_FunctionalInput(problem,interpretation,from,to);
	neg find mustInRelationIncomingLinks_reference_FunctionalInput(problem,interpretation,from,to);
}
pattern refineRelation_type_attribute_Function(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"type attribute Function");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFunction_class(problem,interpretation,from);
	find mustInstanceOfFunctionType_enum(problem,interpretation,to);
	find mayInRelationtype_attribute_Function(problem,interpretation,from,to);
	neg find mustInRelationtype_attribute_Function(problem,interpretation,from,to);
}
import epackage "http://www.bme.hu/mit/inf/dslreasoner/viatrasolver/partialinterpretationlanguage"
import epackage "http://www.bme.hu/mit/inf/dslreasoner/logic/model/problem"
import epackage "http://www.bme.hu/mit/inf/dslreasoner/logic/model/language"

//////////
// 0. Util
//////////
private pattern interpretation(problem:LogicProblem, interpretation:PartialInterpretation) {
	PartialInterpretation.problem(interpretation,problem);
}
	
/////////////////////////
// 0.1 Existence
/////////////////////////
private pattern mustExist(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	find interpretation(problem,interpretation);
	LogicProblem.elements(problem,element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
}

private pattern mayExist(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
    find mustExist(problem,interpretation,element);
} or {
    find interpretation(problem,interpretation);
    neg find elementCloseWorld(element);
    PartialInterpretation.openWorldElements(interpretation,element);
}

private pattern elementCloseWorld(element:DefinedElement) {
	PartialInterpretation.openWorldElements(i,element);
    PartialInterpretation.maxNewElements(i,0);
} or {
	Scope.targetTypeInterpretation(scope,interpretation);
	PartialTypeInterpratation.elements(interpretation,element);
	Scope.maxNewElements(scope,0);
}

////////////////////////
// 0.2 Equivalence
////////////////////////
pattern mayEquivalent(problem:LogicProblem, interpretation:PartialInterpretation, a: DefinedElement, b: DefinedElement) {
	find mayExist(problem,interpretation,a);
	find mayExist(problem,interpretation,b);
	a == b;
}

////////////////////////
// 0.3 Required Patterns by TypeIndexer
////////////////////////
private pattern typeInterpretation(problem:LogicProblem, interpretation:PartialInterpretation, type:TypeDeclaration, typeInterpretation:PartialComplexTypeInterpretation) {
	find interpretation(problem,interpretation);
	LogicProblem.types(problem,type);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
}

private pattern directInstanceOf(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement, type:Type) {
	find interpretation(problem,interpretation);
	LogicProblem.types(problem,type);
	TypeDefinition.elements(type,element);
} or {
	find interpretation(problem,interpretation);
	find typeInterpretation(problem,interpretation,type,typeInterpretation);
	PartialComplexTypeInterpretation.elements(typeInterpretation,element);
}

private pattern isPrimitive(element: PrimitiveElement) {
	PrimitiveElement(element);
}

//////////
// 1. Problem-Specific Base Indexers
//////////
// 1.1 Type Indexers
//////////
// 1.1.1 primitive Type Indexers
//////////

//////////
// 1.1.2 domain-specific Type Indexers
//////////
/**
 * An element must be an instance of type "FunctionalElement class".
 */
private pattern mustInstanceOfFunctionalElement_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalElement class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalElement_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalElement class");
}

/**
 * An element may be an instance of type "FunctionalElement class".
 */
private pattern mayInstanceOfFunctionalElement_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunction_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalElement_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunction_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalElement_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalElement_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalArchitectureModel class".
 */
private pattern mustInstanceOfFunctionalArchitectureModel_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalArchitectureModel class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalArchitectureModel_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalArchitectureModel class");
}

/**
 * An element may be an instance of type "FunctionalArchitectureModel class".
 */
private pattern mayInstanceOfFunctionalArchitectureModel_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalArchitectureModel_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalArchitectureModel_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Function class".
 */
private pattern mustInstanceOfFunction_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Function class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunction_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Function class");
}

/**
 * An element may be an instance of type "Function class".
 */
private pattern mayInstanceOfFunction_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunction_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunction_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunction_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FAMTerminator class".
 */
private pattern mustInstanceOfFAMTerminator_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FAMTerminator class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFAMTerminator_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FAMTerminator class");
}

/**
 * An element may be an instance of type "FAMTerminator class".
 */
private pattern mayInstanceOfFAMTerminator_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find scopeDisallowsNewFAMTerminator_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find scopeDisallowsNewFAMTerminator_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFAMTerminator_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "InformationLink class".
 */
private pattern mustInstanceOfInformationLink_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"InformationLink class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewInformationLink_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"InformationLink class");
}

/**
 * An element may be an instance of type "InformationLink class".
 */
private pattern mayInstanceOfInformationLink_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find scopeDisallowsNewInformationLink_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find scopeDisallowsNewInformationLink_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfInformationLink_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalInterface class".
 */
private pattern mustInstanceOfFunctionalInterface_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalInterface class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalInterface_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalInterface class");
}

/**
 * An element may be an instance of type "FunctionalInterface class".
 */
private pattern mayInstanceOfFunctionalInterface_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalInterface_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalInterface_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalInterface_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalInput class".
 */
private pattern mustInstanceOfFunctionalInput_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalInput class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalInput_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalInput class");
}

/**
 * An element may be an instance of type "FunctionalInput class".
 */
private pattern mayInstanceOfFunctionalInput_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalInput_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalInput_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalInput_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalOutput class".
 */
private pattern mustInstanceOfFunctionalOutput_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalOutput class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalOutput_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalOutput class");
}

/**
 * An element may be an instance of type "FunctionalOutput class".
 */
private pattern mayInstanceOfFunctionalOutput_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalOutput_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalOutput_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalOutput_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalData class".
 */
private pattern mustInstanceOfFunctionalData_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalData class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalData_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalData class");
}

/**
 * An element may be an instance of type "FunctionalData class".
 */
private pattern mayInstanceOfFunctionalData_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalData_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalData_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalData_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionType enum".
 */
private pattern mustInstanceOfFunctionType_enum(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionType enum");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionType_enum(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionType enum");
}

/**
 * An element may be an instance of type "FunctionType enum".
 */
private pattern mayInstanceOfFunctionType_enum(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfFunctionType_enum(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalArchitectureModel class DefinedPart".
 */
private pattern mustInstanceOfFunctionalArchitectureModel_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalArchitectureModel class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalArchitectureModel_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalArchitectureModel class DefinedPart");
}

/**
 * An element may be an instance of type "FunctionalArchitectureModel class DefinedPart".
 */
private pattern mayInstanceOfFunctionalArchitectureModel_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfFunctionalArchitectureModel_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalArchitectureModel class UndefinedPart".
 */
private pattern mustInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalArchitectureModel class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalArchitectureModel_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalArchitectureModel class UndefinedPart");
}

/**
 * An element may be an instance of type "FunctionalArchitectureModel class UndefinedPart".
 */
private pattern mayInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalArchitectureModel_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalArchitectureModel_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem,interpretation,element); }

//////////
// 1.2 Relation Declaration Indexers
//////////
/**
 * Matcher for detecting tuples t where []interface reference FunctionalElement(source,target)
 */
private pattern mustInRelationinterface_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"interface reference FunctionalElement");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>interface reference FunctionalElement(source,target)
 */
private pattern mayInRelationinterface_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalElement_class(problem,interpretation,source);
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationinterface_reference_FunctionalElement(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationelement_reference_FunctionalInterface(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationinterface_reference_FunctionalElement(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []model reference FunctionalElement(source,target)
 */
private pattern mustInRelationmodel_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"model reference FunctionalElement");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>model reference FunctionalElement(source,target)
 */
private pattern mayInRelationmodel_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalElement_class(problem,interpretation,source);
	find mayInstanceOfFunctionalArchitectureModel_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationmodel_reference_FunctionalElement(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationmodel_reference_FunctionalElement(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []parent reference FunctionalElement(source,target)
 */
private pattern mustInRelationparent_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"parent reference FunctionalElement");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>parent reference FunctionalElement(source,target)
 */
private pattern mayInRelationparent_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalElement_class(problem,interpretation,source);
	find mayInstanceOfFunction_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationparent_reference_FunctionalElement(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationparent_reference_FunctionalElement(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []rootElements reference FunctionalArchitectureModel(source,target)
 */
private pattern mustInRelationrootElements_reference_FunctionalArchitectureModel(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"rootElements reference FunctionalArchitectureModel");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>rootElements reference FunctionalArchitectureModel(source,target)
 */
private pattern mayInRelationrootElements_reference_FunctionalArchitectureModel(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalArchitectureModel_class(problem,interpretation,source);
	find mayInstanceOfFunctionalElement_class(problem,interpretation,target);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationrootElements_reference_FunctionalArchitectureModel(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []subElements reference Function(source,target)
 */
private pattern mustInRelationsubElements_reference_Function(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"subElements reference Function");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>subElements reference Function(source,target)
 */
private pattern mayInRelationsubElements_reference_Function(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunction_class(problem,interpretation,source);
	find mayInstanceOfFunctionalElement_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationparent_reference_FunctionalElement(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationsubElements_reference_Function(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []data reference FAMTerminator(source,target)
 */
private pattern mustInRelationdata_reference_FAMTerminator(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"data reference FAMTerminator");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>data reference FAMTerminator(source,target)
 */
private pattern mayInRelationdata_reference_FAMTerminator(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFAMTerminator_class(problem,interpretation,source);
	find mayInstanceOfFunctionalData_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationdata_reference_FAMTerminator(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationterminator_reference_FunctionalData(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationdata_reference_FAMTerminator(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []from reference InformationLink(source,target)
 */
private pattern mustInRelationfrom_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"from reference InformationLink");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>from reference InformationLink(source,target)
 */
private pattern mayInRelationfrom_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfInformationLink_class(problem,interpretation,source);
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationfrom_reference_InformationLink(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationfrom_reference_InformationLink(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []to reference InformationLink(source,target)
 */
private pattern mustInRelationto_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"to reference InformationLink");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>to reference InformationLink(source,target)
 */
private pattern mayInRelationto_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfInformationLink_class(problem,interpretation,source);
	find mayInstanceOfFunctionalInput_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationto_reference_InformationLink(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationto_reference_InformationLink(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []data reference FunctionalInterface(source,target)
 */
private pattern mustInRelationdata_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"data reference FunctionalInterface");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>data reference FunctionalInterface(source,target)
 */
private pattern mayInRelationdata_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,source);
	find mayInstanceOfFunctionalData_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationinterface_reference_FunctionalData(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationdata_reference_FunctionalInterface(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []element reference FunctionalInterface(source,target)
 */
private pattern mustInRelationelement_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"element reference FunctionalInterface");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>element reference FunctionalInterface(source,target)
 */
private pattern mayInRelationelement_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,source);
	find mayInstanceOfFunctionalElement_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationelement_reference_FunctionalInterface(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationinterface_reference_FunctionalElement(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationelement_reference_FunctionalInterface(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []IncomingLinks reference FunctionalInput(source,target)
 */
private pattern mustInRelationIncomingLinks_reference_FunctionalInput(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"IncomingLinks reference FunctionalInput");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>IncomingLinks reference FunctionalInput(source,target)
 */
private pattern mayInRelationIncomingLinks_reference_FunctionalInput(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalInput_class(problem,interpretation,source);
	find mayInstanceOfInformationLink_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationto_reference_InformationLink(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
} or {
	find mustInRelationIncomingLinks_reference_FunctionalInput(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []outgoingLinks reference FunctionalOutput(source,target)
 */
private pattern mustInRelationoutgoingLinks_reference_FunctionalOutput(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"outgoingLinks reference FunctionalOutput");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>outgoingLinks reference FunctionalOutput(source,target)
 */
private pattern mayInRelationoutgoingLinks_reference_FunctionalOutput(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,source);
	find mayInstanceOfInformationLink_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationfrom_reference_InformationLink(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationoutgoingLinks_reference_FunctionalOutput(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []terminator reference FunctionalData(source,target)
 */
private pattern mustInRelationterminator_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"terminator reference FunctionalData");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>terminator reference FunctionalData(source,target)
 */
private pattern mayInRelationterminator_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalData_class(problem,interpretation,source);
	find mayInstanceOfFAMTerminator_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationterminator_reference_FunctionalData(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationdata_reference_FAMTerminator(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationterminator_reference_FunctionalData(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []interface reference FunctionalData(source,target)
 */
private pattern mustInRelationinterface_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"interface reference FunctionalData");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>interface reference FunctionalData(source,target)
 */
private pattern mayInRelationinterface_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalData_class(problem,interpretation,source);
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationinterface_reference_FunctionalData(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationinterface_reference_FunctionalData(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []type attribute Function(source,target)
 */
private pattern mustInRelationtype_attribute_Function(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"type attribute Function");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>type attribute Function(source,target)
 */
private pattern mayInRelationtype_attribute_Function(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunction_class(problem,interpretation,source);
	find mayInstanceOfFunctionType_enum(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationtype_attribute_Function(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationtype_attribute_Function(problem,interpretation,source,target);
}

//////////
// 1.3 Relation Definition Indexers
//////////

//////////
// 1.4 Containment Indexer
//////////
private pattern mustContains2(source: DefinedElement, target: DefinedElement) {
	find mustContains4(_,_,source,target);
}
	
private pattern mustContains4(problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target: DefinedElement)
	{ find mustInRelationinterface_reference_FunctionalElement(problem,interpretation,source,target); }or
	
	{ find mustInRelationrootElements_reference_FunctionalArchitectureModel(problem,interpretation,source,target); }or
	
	{ find mustInRelationsubElements_reference_Function(problem,interpretation,source,target); }or
	
	{ find mustInRelationdata_reference_FunctionalInterface(problem,interpretation,source,target); }or
	
	{ find mustInRelationoutgoingLinks_reference_FunctionalOutput(problem,interpretation,source,target); }or
	
	{ find mustInRelationterminator_reference_FunctionalData(problem,interpretation,source,target); }

private pattern mustTransitiveContains(source,target) {
	find mustContains2+(source,target);
}

//////////
// 2. Invalidation Indexers
//////////
// 2.1 Invalidated by WF Queries
//////////

//////////
// 3. Unfinishedness Indexers
//////////
// 3.1 Unfinishedness Measured by Multiplicity
//////////
pattern unfinishedLowerMultiplicity_model_reference_FunctionalElement(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"model reference FunctionalElement");
	find mustInstanceOfFunctionalElement_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationmodel_reference_FunctionalElement(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_to_reference_InformationLink(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"to reference InformationLink");
	find mustInstanceOfInformationLink_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationto_reference_InformationLink(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_type_attribute_Function(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"type attribute Function");
	find mustInstanceOfFunction_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationtype_attribute_Function(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}

//////////
// 3.2 Unfinishedness Measured by WF Queries
//////////

//////////
// 4. Refinement Indexers
//////////
// 4.1 Object constructors
//////////
private pattern hasElementInContainment(problem:LogicProblem, interpretation:PartialInterpretation)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalData_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfInformationLink_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalInterface_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFAMTerminator_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalElement_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalInput_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalOutput_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunction_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalArchitectureModel_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}
pattern createObject_InformationLink_class_by_outgoingLinks_reference_FunctionalOutput_with_from_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"InformationLink class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"outgoingLinks reference FunctionalOutput");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"from reference InformationLink");
	find mustInstanceOfFunctionalOutput_class(problem,interpretation,container);
	find mayInstanceOfInformationLink_class(problem,interpretation,newObject);
	find mayInRelationoutgoingLinks_reference_FunctionalOutput(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_InformationLink_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"InformationLink class");
	find mayInstanceOfInformationLink_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalOutput_class_by_data_reference_FunctionalInterface_with_interface_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalOutput class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"data reference FunctionalInterface");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"interface reference FunctionalData");
	find mustInstanceOfFunctionalInterface_class(problem,interpretation,container);
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,newObject);
	find mayInRelationdata_reference_FunctionalInterface(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalOutput_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalOutput class");
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalInput_class_by_data_reference_FunctionalInterface_with_interface_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalInput class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"data reference FunctionalInterface");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"interface reference FunctionalData");
	find mustInstanceOfFunctionalInterface_class(problem,interpretation,container);
	find mayInstanceOfFunctionalInput_class(problem,interpretation,newObject);
	find mayInRelationdata_reference_FunctionalInterface(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalInput_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalInput class");
	find mayInstanceOfFunctionalInput_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalArchitectureModel_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalArchitectureModel class UndefinedPart");
	find mayInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalInterface_class_by_interface_reference_FunctionalElement_with_element_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalInterface class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"interface reference FunctionalElement");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"element reference FunctionalInterface");
	find mustInstanceOfFunctionalElement_class(problem,interpretation,container);
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,newObject);
	find mayInRelationinterface_reference_FunctionalElement(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalInterface_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalInterface class");
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Function_class_by_rootElements_reference_FunctionalArchitectureModel(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Function class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"rootElements reference FunctionalArchitectureModel");
	find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,container);
	find mayInstanceOfFunction_class(problem,interpretation,newObject);
	find mayInRelationrootElements_reference_FunctionalArchitectureModel(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Function_class_by_subElements_reference_Function_with_parent_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Function class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"subElements reference Function");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"parent reference FunctionalElement");
	find mustInstanceOfFunction_class(problem,interpretation,container);
	find mayInstanceOfFunction_class(problem,interpretation,newObject);
	find mayInRelationsubElements_reference_Function(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Function_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Function class");
	find mayInstanceOfFunction_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FAMTerminator_class_by_terminator_reference_FunctionalData_with_data_reference_FAMTerminator(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FAMTerminator class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"terminator reference FunctionalData");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"data reference FAMTerminator");
	find mustInstanceOfFunctionalData_class(problem,interpretation,container);
	find mayInstanceOfFAMTerminator_class(problem,interpretation,newObject);
	find mayInRelationterminator_reference_FunctionalData(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FAMTerminator_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FAMTerminator class");
	find mayInstanceOfFAMTerminator_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}

//////////
// 4.2 Type refinement
//////////
pattern refineTypeTo_InformationLink_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
}
pattern refineTypeTo_FunctionalOutput_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
}
pattern refineTypeTo_FunctionalInput_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
}
pattern refineTypeTo_FunctionalArchitectureModel_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
}
pattern refineTypeTo_FunctionalInterface_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
}
pattern refineTypeTo_Function_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunction_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunction_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
}
pattern refineTypeTo_FAMTerminator_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
}

//////////
// 4.3 Relation refinement
//////////
pattern refineRelation_model_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"model reference FunctionalElement");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFunctionalElement_class(problem,interpretation,from);
	find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,to);
	find mayInRelationmodel_reference_FunctionalElement(problem,interpretation,from,to);
	neg find mustInRelationmodel_reference_FunctionalElement(problem,interpretation,from,to);
}
pattern refineRelation_IncomingLinks_reference_FunctionalInput_and_to_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation, oppositeInterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"IncomingLinks reference FunctionalInput");
	PartialInterpretation.partialrelationinterpretation(interpretation,oppositeInterpretation);
	PartialRelationInterpretation.interpretationOf.name(oppositeInterpretation,"to reference InformationLink");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFunctionalInput_class(problem,interpretation,from);
	find mustInstanceOfInformationLink_class(problem,interpretation,to);
	find mayInRelationIncomingLinks_reference_FunctionalInput(problem,interpretation,from,to);
	neg find mustInRelationIncomingLinks_reference_FunctionalInput(problem,interpretation,from,to);
}
pattern refineRelation_type_attribute_Function(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"type attribute Function");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFunction_class(problem,interpretation,from);
	find mustInstanceOfFunctionType_enum(problem,interpretation,to);
	find mayInRelationtype_attribute_Function(problem,interpretation,from,to);
	neg find mustInRelationtype_attribute_Function(problem,interpretation,from,to);
}
import epackage "http://www.bme.hu/mit/inf/dslreasoner/viatrasolver/partialinterpretationlanguage"
import epackage "http://www.bme.hu/mit/inf/dslreasoner/logic/model/problem"
import epackage "http://www.bme.hu/mit/inf/dslreasoner/logic/model/language"

//////////
// 0. Util
//////////
private pattern interpretation(problem:LogicProblem, interpretation:PartialInterpretation) {
	PartialInterpretation.problem(interpretation,problem);
}
	
/////////////////////////
// 0.1 Existence
/////////////////////////
private pattern mustExist(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	find interpretation(problem,interpretation);
	LogicProblem.elements(problem,element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
}

private pattern mayExist(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
    find mustExist(problem,interpretation,element);
} or {
    find interpretation(problem,interpretation);
    neg find elementCloseWorld(element);
    PartialInterpretation.openWorldElements(interpretation,element);
}

private pattern elementCloseWorld(element:DefinedElement) {
	PartialInterpretation.openWorldElements(i,element);
    PartialInterpretation.maxNewElements(i,0);
} or {
	Scope.targetTypeInterpretation(scope,interpretation);
	PartialTypeInterpratation.elements(interpretation,element);
	Scope.maxNewElements(scope,0);
}

////////////////////////
// 0.2 Equivalence
////////////////////////
pattern mayEquivalent(problem:LogicProblem, interpretation:PartialInterpretation, a: DefinedElement, b: DefinedElement) {
	find mayExist(problem,interpretation,a);
	find mayExist(problem,interpretation,b);
	a == b;
}

////////////////////////
// 0.3 Required Patterns by TypeIndexer
////////////////////////
private pattern typeInterpretation(problem:LogicProblem, interpretation:PartialInterpretation, type:TypeDeclaration, typeInterpretation:PartialComplexTypeInterpretation) {
	find interpretation(problem,interpretation);
	LogicProblem.types(problem,type);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
}

private pattern directInstanceOf(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement, type:Type) {
	find interpretation(problem,interpretation);
	LogicProblem.types(problem,type);
	TypeDefinition.elements(type,element);
} or {
	find interpretation(problem,interpretation);
	find typeInterpretation(problem,interpretation,type,typeInterpretation);
	PartialComplexTypeInterpretation.elements(typeInterpretation,element);
}

private pattern isPrimitive(element: PrimitiveElement) {
	PrimitiveElement(element);
}

//////////
// 1. Problem-Specific Base Indexers
//////////
// 1.1 Type Indexers
//////////
// 1.1.1 primitive Type Indexers
//////////

//////////
// 1.1.2 domain-specific Type Indexers
//////////
/**
 * An element must be an instance of type "FunctionalElement class".
 */
private pattern mustInstanceOfFunctionalElement_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalElement class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalElement_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalElement class");
}

/**
 * An element may be an instance of type "FunctionalElement class".
 */
private pattern mayInstanceOfFunctionalElement_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunction_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalElement_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunction_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalElement_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalElement_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalArchitectureModel class".
 */
private pattern mustInstanceOfFunctionalArchitectureModel_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalArchitectureModel class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalArchitectureModel_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalArchitectureModel class");
}

/**
 * An element may be an instance of type "FunctionalArchitectureModel class".
 */
private pattern mayInstanceOfFunctionalArchitectureModel_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalArchitectureModel_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalArchitectureModel_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Function class".
 */
private pattern mustInstanceOfFunction_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Function class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunction_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Function class");
}

/**
 * An element may be an instance of type "Function class".
 */
private pattern mayInstanceOfFunction_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunction_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunction_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunction_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FAMTerminator class".
 */
private pattern mustInstanceOfFAMTerminator_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FAMTerminator class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFAMTerminator_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FAMTerminator class");
}

/**
 * An element may be an instance of type "FAMTerminator class".
 */
private pattern mayInstanceOfFAMTerminator_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find scopeDisallowsNewFAMTerminator_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find scopeDisallowsNewFAMTerminator_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFAMTerminator_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "InformationLink class".
 */
private pattern mustInstanceOfInformationLink_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"InformationLink class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewInformationLink_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"InformationLink class");
}

/**
 * An element may be an instance of type "InformationLink class".
 */
private pattern mayInstanceOfInformationLink_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find scopeDisallowsNewInformationLink_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find scopeDisallowsNewInformationLink_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfInformationLink_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalInterface class".
 */
private pattern mustInstanceOfFunctionalInterface_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalInterface class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalInterface_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalInterface class");
}

/**
 * An element may be an instance of type "FunctionalInterface class".
 */
private pattern mayInstanceOfFunctionalInterface_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalInterface_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalInterface_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalInterface_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalInput class".
 */
private pattern mustInstanceOfFunctionalInput_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalInput class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalInput_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalInput class");
}

/**
 * An element may be an instance of type "FunctionalInput class".
 */
private pattern mayInstanceOfFunctionalInput_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalInput_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalInput_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalInput_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalOutput class".
 */
private pattern mustInstanceOfFunctionalOutput_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalOutput class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalOutput_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalOutput class");
}

/**
 * An element may be an instance of type "FunctionalOutput class".
 */
private pattern mayInstanceOfFunctionalOutput_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalOutput_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalOutput_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalOutput_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalData class".
 */
private pattern mustInstanceOfFunctionalData_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalData class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalData_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalData class");
}

/**
 * An element may be an instance of type "FunctionalData class".
 */
private pattern mayInstanceOfFunctionalData_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalData_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalData_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalData_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionType enum".
 */
private pattern mustInstanceOfFunctionType_enum(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionType enum");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionType_enum(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionType enum");
}

/**
 * An element may be an instance of type "FunctionType enum".
 */
private pattern mayInstanceOfFunctionType_enum(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfFunctionType_enum(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalArchitectureModel class DefinedPart".
 */
private pattern mustInstanceOfFunctionalArchitectureModel_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalArchitectureModel class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalArchitectureModel_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalArchitectureModel class DefinedPart");
}

/**
 * An element may be an instance of type "FunctionalArchitectureModel class DefinedPart".
 */
private pattern mayInstanceOfFunctionalArchitectureModel_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfFunctionalArchitectureModel_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalArchitectureModel class UndefinedPart".
 */
private pattern mustInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalArchitectureModel class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalArchitectureModel_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalArchitectureModel class UndefinedPart");
}

/**
 * An element may be an instance of type "FunctionalArchitectureModel class UndefinedPart".
 */
private pattern mayInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalArchitectureModel_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalArchitectureModel_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem,interpretation,element); }

//////////
// 1.2 Relation Declaration Indexers
//////////
/**
 * Matcher for detecting tuples t where []interface reference FunctionalElement(source,target)
 */
private pattern mustInRelationinterface_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"interface reference FunctionalElement");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>interface reference FunctionalElement(source,target)
 */
private pattern mayInRelationinterface_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalElement_class(problem,interpretation,source);
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationinterface_reference_FunctionalElement(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationelement_reference_FunctionalInterface(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationinterface_reference_FunctionalElement(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []model reference FunctionalElement(source,target)
 */
private pattern mustInRelationmodel_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"model reference FunctionalElement");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>model reference FunctionalElement(source,target)
 */
private pattern mayInRelationmodel_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalElement_class(problem,interpretation,source);
	find mayInstanceOfFunctionalArchitectureModel_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationmodel_reference_FunctionalElement(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationmodel_reference_FunctionalElement(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []parent reference FunctionalElement(source,target)
 */
private pattern mustInRelationparent_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"parent reference FunctionalElement");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>parent reference FunctionalElement(source,target)
 */
private pattern mayInRelationparent_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalElement_class(problem,interpretation,source);
	find mayInstanceOfFunction_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationparent_reference_FunctionalElement(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationparent_reference_FunctionalElement(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []rootElements reference FunctionalArchitectureModel(source,target)
 */
private pattern mustInRelationrootElements_reference_FunctionalArchitectureModel(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"rootElements reference FunctionalArchitectureModel");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>rootElements reference FunctionalArchitectureModel(source,target)
 */
private pattern mayInRelationrootElements_reference_FunctionalArchitectureModel(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalArchitectureModel_class(problem,interpretation,source);
	find mayInstanceOfFunctionalElement_class(problem,interpretation,target);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationrootElements_reference_FunctionalArchitectureModel(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []subElements reference Function(source,target)
 */
private pattern mustInRelationsubElements_reference_Function(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"subElements reference Function");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>subElements reference Function(source,target)
 */
private pattern mayInRelationsubElements_reference_Function(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunction_class(problem,interpretation,source);
	find mayInstanceOfFunctionalElement_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationparent_reference_FunctionalElement(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationsubElements_reference_Function(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []data reference FAMTerminator(source,target)
 */
private pattern mustInRelationdata_reference_FAMTerminator(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"data reference FAMTerminator");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>data reference FAMTerminator(source,target)
 */
private pattern mayInRelationdata_reference_FAMTerminator(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFAMTerminator_class(problem,interpretation,source);
	find mayInstanceOfFunctionalData_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationdata_reference_FAMTerminator(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationterminator_reference_FunctionalData(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationdata_reference_FAMTerminator(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []from reference InformationLink(source,target)
 */
private pattern mustInRelationfrom_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"from reference InformationLink");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>from reference InformationLink(source,target)
 */
private pattern mayInRelationfrom_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfInformationLink_class(problem,interpretation,source);
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationfrom_reference_InformationLink(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationfrom_reference_InformationLink(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []to reference InformationLink(source,target)
 */
private pattern mustInRelationto_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"to reference InformationLink");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>to reference InformationLink(source,target)
 */
private pattern mayInRelationto_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfInformationLink_class(problem,interpretation,source);
	find mayInstanceOfFunctionalInput_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationto_reference_InformationLink(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationto_reference_InformationLink(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []data reference FunctionalInterface(source,target)
 */
private pattern mustInRelationdata_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"data reference FunctionalInterface");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>data reference FunctionalInterface(source,target)
 */
private pattern mayInRelationdata_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,source);
	find mayInstanceOfFunctionalData_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationinterface_reference_FunctionalData(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationdata_reference_FunctionalInterface(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []element reference FunctionalInterface(source,target)
 */
private pattern mustInRelationelement_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"element reference FunctionalInterface");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>element reference FunctionalInterface(source,target)
 */
private pattern mayInRelationelement_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,source);
	find mayInstanceOfFunctionalElement_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationelement_reference_FunctionalInterface(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationinterface_reference_FunctionalElement(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationelement_reference_FunctionalInterface(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []IncomingLinks reference FunctionalInput(source,target)
 */
private pattern mustInRelationIncomingLinks_reference_FunctionalInput(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"IncomingLinks reference FunctionalInput");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>IncomingLinks reference FunctionalInput(source,target)
 */
private pattern mayInRelationIncomingLinks_reference_FunctionalInput(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalInput_class(problem,interpretation,source);
	find mayInstanceOfInformationLink_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationto_reference_InformationLink(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
} or {
	find mustInRelationIncomingLinks_reference_FunctionalInput(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []outgoingLinks reference FunctionalOutput(source,target)
 */
private pattern mustInRelationoutgoingLinks_reference_FunctionalOutput(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"outgoingLinks reference FunctionalOutput");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>outgoingLinks reference FunctionalOutput(source,target)
 */
private pattern mayInRelationoutgoingLinks_reference_FunctionalOutput(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,source);
	find mayInstanceOfInformationLink_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationfrom_reference_InformationLink(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationoutgoingLinks_reference_FunctionalOutput(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []terminator reference FunctionalData(source,target)
 */
private pattern mustInRelationterminator_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"terminator reference FunctionalData");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>terminator reference FunctionalData(source,target)
 */
private pattern mayInRelationterminator_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalData_class(problem,interpretation,source);
	find mayInstanceOfFAMTerminator_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationterminator_reference_FunctionalData(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationdata_reference_FAMTerminator(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationterminator_reference_FunctionalData(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []interface reference FunctionalData(source,target)
 */
private pattern mustInRelationinterface_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"interface reference FunctionalData");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>interface reference FunctionalData(source,target)
 */
private pattern mayInRelationinterface_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalData_class(problem,interpretation,source);
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationinterface_reference_FunctionalData(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationinterface_reference_FunctionalData(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []type attribute Function(source,target)
 */
private pattern mustInRelationtype_attribute_Function(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"type attribute Function");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>type attribute Function(source,target)
 */
private pattern mayInRelationtype_attribute_Function(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunction_class(problem,interpretation,source);
	find mayInstanceOfFunctionType_enum(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationtype_attribute_Function(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationtype_attribute_Function(problem,interpretation,source,target);
}

//////////
// 1.3 Relation Definition Indexers
//////////

//////////
// 1.4 Containment Indexer
//////////
private pattern mustContains2(source: DefinedElement, target: DefinedElement) {
	find mustContains4(_,_,source,target);
}
	
private pattern mustContains4(problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target: DefinedElement)
	{ find mustInRelationinterface_reference_FunctionalElement(problem,interpretation,source,target); }or
	
	{ find mustInRelationrootElements_reference_FunctionalArchitectureModel(problem,interpretation,source,target); }or
	
	{ find mustInRelationsubElements_reference_Function(problem,interpretation,source,target); }or
	
	{ find mustInRelationdata_reference_FunctionalInterface(problem,interpretation,source,target); }or
	
	{ find mustInRelationoutgoingLinks_reference_FunctionalOutput(problem,interpretation,source,target); }or
	
	{ find mustInRelationterminator_reference_FunctionalData(problem,interpretation,source,target); }

private pattern mustTransitiveContains(source,target) {
	find mustContains2+(source,target);
}

//////////
// 2. Invalidation Indexers
//////////
// 2.1 Invalidated by WF Queries
//////////

//////////
// 3. Unfinishedness Indexers
//////////
// 3.1 Unfinishedness Measured by Multiplicity
//////////
pattern unfinishedLowerMultiplicity_model_reference_FunctionalElement(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"model reference FunctionalElement");
	find mustInstanceOfFunctionalElement_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationmodel_reference_FunctionalElement(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_to_reference_InformationLink(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"to reference InformationLink");
	find mustInstanceOfInformationLink_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationto_reference_InformationLink(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_type_attribute_Function(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"type attribute Function");
	find mustInstanceOfFunction_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationtype_attribute_Function(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}

//////////
// 3.2 Unfinishedness Measured by WF Queries
//////////

//////////
// 4. Refinement Indexers
//////////
// 4.1 Object constructors
//////////
private pattern hasElementInContainment(problem:LogicProblem, interpretation:PartialInterpretation)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfFAMTerminator_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunction_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalData_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalInterface_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfInformationLink_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalElement_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalInput_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalOutput_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalArchitectureModel_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}
pattern createObject_FunctionalInterface_class_by_interface_reference_FunctionalElement_with_element_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalInterface class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"interface reference FunctionalElement");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"element reference FunctionalInterface");
	find mustInstanceOfFunctionalElement_class(problem,interpretation,container);
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,newObject);
	find mayInRelationinterface_reference_FunctionalElement(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalInterface_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalInterface class");
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalInput_class_by_data_reference_FunctionalInterface_with_interface_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalInput class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"data reference FunctionalInterface");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"interface reference FunctionalData");
	find mustInstanceOfFunctionalInterface_class(problem,interpretation,container);
	find mayInstanceOfFunctionalInput_class(problem,interpretation,newObject);
	find mayInRelationdata_reference_FunctionalInterface(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalInput_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalInput class");
	find mayInstanceOfFunctionalInput_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalArchitectureModel_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalArchitectureModel class UndefinedPart");
	find mayInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_InformationLink_class_by_outgoingLinks_reference_FunctionalOutput_with_from_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"InformationLink class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"outgoingLinks reference FunctionalOutput");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"from reference InformationLink");
	find mustInstanceOfFunctionalOutput_class(problem,interpretation,container);
	find mayInstanceOfInformationLink_class(problem,interpretation,newObject);
	find mayInRelationoutgoingLinks_reference_FunctionalOutput(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_InformationLink_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"InformationLink class");
	find mayInstanceOfInformationLink_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalOutput_class_by_data_reference_FunctionalInterface_with_interface_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalOutput class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"data reference FunctionalInterface");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"interface reference FunctionalData");
	find mustInstanceOfFunctionalInterface_class(problem,interpretation,container);
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,newObject);
	find mayInRelationdata_reference_FunctionalInterface(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalOutput_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalOutput class");
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Function_class_by_rootElements_reference_FunctionalArchitectureModel(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Function class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"rootElements reference FunctionalArchitectureModel");
	find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,container);
	find mayInstanceOfFunction_class(problem,interpretation,newObject);
	find mayInRelationrootElements_reference_FunctionalArchitectureModel(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Function_class_by_subElements_reference_Function_with_parent_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Function class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"subElements reference Function");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"parent reference FunctionalElement");
	find mustInstanceOfFunction_class(problem,interpretation,container);
	find mayInstanceOfFunction_class(problem,interpretation,newObject);
	find mayInRelationsubElements_reference_Function(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Function_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Function class");
	find mayInstanceOfFunction_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FAMTerminator_class_by_terminator_reference_FunctionalData_with_data_reference_FAMTerminator(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FAMTerminator class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"terminator reference FunctionalData");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"data reference FAMTerminator");
	find mustInstanceOfFunctionalData_class(problem,interpretation,container);
	find mayInstanceOfFAMTerminator_class(problem,interpretation,newObject);
	find mayInRelationterminator_reference_FunctionalData(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FAMTerminator_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FAMTerminator class");
	find mayInstanceOfFAMTerminator_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}

//////////
// 4.2 Type refinement
//////////
pattern refineTypeTo_FunctionalInterface_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
}
pattern refineTypeTo_FunctionalInput_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
}
pattern refineTypeTo_FunctionalArchitectureModel_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
}
pattern refineTypeTo_InformationLink_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
}
pattern refineTypeTo_FunctionalOutput_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
}
pattern refineTypeTo_Function_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunction_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunction_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
}
pattern refineTypeTo_FAMTerminator_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
}

//////////
// 4.3 Relation refinement
//////////
pattern refineRelation_model_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"model reference FunctionalElement");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFunctionalElement_class(problem,interpretation,from);
	find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,to);
	find mayInRelationmodel_reference_FunctionalElement(problem,interpretation,from,to);
	neg find mustInRelationmodel_reference_FunctionalElement(problem,interpretation,from,to);
}
pattern refineRelation_IncomingLinks_reference_FunctionalInput_and_to_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation, oppositeInterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"IncomingLinks reference FunctionalInput");
	PartialInterpretation.partialrelationinterpretation(interpretation,oppositeInterpretation);
	PartialRelationInterpretation.interpretationOf.name(oppositeInterpretation,"to reference InformationLink");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFunctionalInput_class(problem,interpretation,from);
	find mustInstanceOfInformationLink_class(problem,interpretation,to);
	find mayInRelationIncomingLinks_reference_FunctionalInput(problem,interpretation,from,to);
	neg find mustInRelationIncomingLinks_reference_FunctionalInput(problem,interpretation,from,to);
}
pattern refineRelation_type_attribute_Function(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"type attribute Function");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFunction_class(problem,interpretation,from);
	find mustInstanceOfFunctionType_enum(problem,interpretation,to);
	find mayInRelationtype_attribute_Function(problem,interpretation,from,to);
	neg find mustInRelationtype_attribute_Function(problem,interpretation,from,to);
}
import epackage "http://www.bme.hu/mit/inf/dslreasoner/viatrasolver/partialinterpretationlanguage"
import epackage "http://www.bme.hu/mit/inf/dslreasoner/logic/model/problem"
import epackage "http://www.bme.hu/mit/inf/dslreasoner/logic/model/language"

//////////
// 0. Util
//////////
private pattern interpretation(problem:LogicProblem, interpretation:PartialInterpretation) {
	PartialInterpretation.problem(interpretation,problem);
}
	
/////////////////////////
// 0.1 Existence
/////////////////////////
private pattern mustExist(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	find interpretation(problem,interpretation);
	LogicProblem.elements(problem,element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
}

private pattern mayExist(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
    find mustExist(problem,interpretation,element);
} or {
    find interpretation(problem,interpretation);
    neg find elementCloseWorld(element);
    PartialInterpretation.openWorldElements(interpretation,element);
}

private pattern elementCloseWorld(element:DefinedElement) {
	PartialInterpretation.openWorldElements(i,element);
    PartialInterpretation.maxNewElements(i,0);
} or {
	Scope.targetTypeInterpretation(scope,interpretation);
	PartialTypeInterpratation.elements(interpretation,element);
	Scope.maxNewElements(scope,0);
}

////////////////////////
// 0.2 Equivalence
////////////////////////
pattern mayEquivalent(problem:LogicProblem, interpretation:PartialInterpretation, a: DefinedElement, b: DefinedElement) {
	find mayExist(problem,interpretation,a);
	find mayExist(problem,interpretation,b);
	a == b;
}

////////////////////////
// 0.3 Required Patterns by TypeIndexer
////////////////////////
private pattern typeInterpretation(problem:LogicProblem, interpretation:PartialInterpretation, type:TypeDeclaration, typeInterpretation:PartialComplexTypeInterpretation) {
	find interpretation(problem,interpretation);
	LogicProblem.types(problem,type);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
}

private pattern directInstanceOf(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement, type:Type) {
	find interpretation(problem,interpretation);
	LogicProblem.types(problem,type);
	TypeDefinition.elements(type,element);
} or {
	find interpretation(problem,interpretation);
	find typeInterpretation(problem,interpretation,type,typeInterpretation);
	PartialComplexTypeInterpretation.elements(typeInterpretation,element);
}

private pattern isPrimitive(element: PrimitiveElement) {
	PrimitiveElement(element);
}

//////////
// 1. Problem-Specific Base Indexers
//////////
// 1.1 Type Indexers
//////////
// 1.1.1 primitive Type Indexers
//////////

//////////
// 1.1.2 domain-specific Type Indexers
//////////
/**
 * An element must be an instance of type "FunctionalElement class".
 */
private pattern mustInstanceOfFunctionalElement_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalElement class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalElement_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalElement class");
}

/**
 * An element may be an instance of type "FunctionalElement class".
 */
private pattern mayInstanceOfFunctionalElement_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunction_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalElement_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunction_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalElement_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalElement_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalArchitectureModel class".
 */
private pattern mustInstanceOfFunctionalArchitectureModel_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalArchitectureModel class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalArchitectureModel_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalArchitectureModel class");
}

/**
 * An element may be an instance of type "FunctionalArchitectureModel class".
 */
private pattern mayInstanceOfFunctionalArchitectureModel_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalArchitectureModel_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalArchitectureModel_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Function class".
 */
private pattern mustInstanceOfFunction_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Function class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunction_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Function class");
}

/**
 * An element may be an instance of type "Function class".
 */
private pattern mayInstanceOfFunction_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunction_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunction_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunction_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FAMTerminator class".
 */
private pattern mustInstanceOfFAMTerminator_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FAMTerminator class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFAMTerminator_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FAMTerminator class");
}

/**
 * An element may be an instance of type "FAMTerminator class".
 */
private pattern mayInstanceOfFAMTerminator_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find scopeDisallowsNewFAMTerminator_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find scopeDisallowsNewFAMTerminator_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFAMTerminator_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "InformationLink class".
 */
private pattern mustInstanceOfInformationLink_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"InformationLink class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewInformationLink_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"InformationLink class");
}

/**
 * An element may be an instance of type "InformationLink class".
 */
private pattern mayInstanceOfInformationLink_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find scopeDisallowsNewInformationLink_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find scopeDisallowsNewInformationLink_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfInformationLink_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalInterface class".
 */
private pattern mustInstanceOfFunctionalInterface_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalInterface class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalInterface_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalInterface class");
}

/**
 * An element may be an instance of type "FunctionalInterface class".
 */
private pattern mayInstanceOfFunctionalInterface_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalInterface_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalInterface_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalInterface_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalInput class".
 */
private pattern mustInstanceOfFunctionalInput_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalInput class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalInput_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalInput class");
}

/**
 * An element may be an instance of type "FunctionalInput class".
 */
private pattern mayInstanceOfFunctionalInput_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalInput_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalInput_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalInput_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalOutput class".
 */
private pattern mustInstanceOfFunctionalOutput_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalOutput class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalOutput_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalOutput class");
}

/**
 * An element may be an instance of type "FunctionalOutput class".
 */
private pattern mayInstanceOfFunctionalOutput_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalOutput_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalOutput_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalOutput_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalData class".
 */
private pattern mustInstanceOfFunctionalData_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalData class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalData_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalData class");
}

/**
 * An element may be an instance of type "FunctionalData class".
 */
private pattern mayInstanceOfFunctionalData_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalData_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalData_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalData_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionType enum".
 */
private pattern mustInstanceOfFunctionType_enum(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionType enum");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionType_enum(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionType enum");
}

/**
 * An element may be an instance of type "FunctionType enum".
 */
private pattern mayInstanceOfFunctionType_enum(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfFunctionType_enum(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalArchitectureModel class DefinedPart".
 */
private pattern mustInstanceOfFunctionalArchitectureModel_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalArchitectureModel class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalArchitectureModel_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalArchitectureModel class DefinedPart");
}

/**
 * An element may be an instance of type "FunctionalArchitectureModel class DefinedPart".
 */
private pattern mayInstanceOfFunctionalArchitectureModel_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfFunctionalArchitectureModel_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalArchitectureModel class UndefinedPart".
 */
private pattern mustInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalArchitectureModel class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalArchitectureModel_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalArchitectureModel class UndefinedPart");
}

/**
 * An element may be an instance of type "FunctionalArchitectureModel class UndefinedPart".
 */
private pattern mayInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalArchitectureModel_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalArchitectureModel_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem,interpretation,element); }

//////////
// 1.2 Relation Declaration Indexers
//////////
/**
 * Matcher for detecting tuples t where []interface reference FunctionalElement(source,target)
 */
private pattern mustInRelationinterface_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"interface reference FunctionalElement");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>interface reference FunctionalElement(source,target)
 */
private pattern mayInRelationinterface_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalElement_class(problem,interpretation,source);
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationinterface_reference_FunctionalElement(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationelement_reference_FunctionalInterface(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationinterface_reference_FunctionalElement(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []model reference FunctionalElement(source,target)
 */
private pattern mustInRelationmodel_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"model reference FunctionalElement");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>model reference FunctionalElement(source,target)
 */
private pattern mayInRelationmodel_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalElement_class(problem,interpretation,source);
	find mayInstanceOfFunctionalArchitectureModel_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationmodel_reference_FunctionalElement(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationmodel_reference_FunctionalElement(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []parent reference FunctionalElement(source,target)
 */
private pattern mustInRelationparent_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"parent reference FunctionalElement");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>parent reference FunctionalElement(source,target)
 */
private pattern mayInRelationparent_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalElement_class(problem,interpretation,source);
	find mayInstanceOfFunction_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationparent_reference_FunctionalElement(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationparent_reference_FunctionalElement(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []rootElements reference FunctionalArchitectureModel(source,target)
 */
private pattern mustInRelationrootElements_reference_FunctionalArchitectureModel(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"rootElements reference FunctionalArchitectureModel");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>rootElements reference FunctionalArchitectureModel(source,target)
 */
private pattern mayInRelationrootElements_reference_FunctionalArchitectureModel(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalArchitectureModel_class(problem,interpretation,source);
	find mayInstanceOfFunctionalElement_class(problem,interpretation,target);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationrootElements_reference_FunctionalArchitectureModel(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []subElements reference Function(source,target)
 */
private pattern mustInRelationsubElements_reference_Function(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"subElements reference Function");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>subElements reference Function(source,target)
 */
private pattern mayInRelationsubElements_reference_Function(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunction_class(problem,interpretation,source);
	find mayInstanceOfFunctionalElement_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationparent_reference_FunctionalElement(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationsubElements_reference_Function(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []data reference FAMTerminator(source,target)
 */
private pattern mustInRelationdata_reference_FAMTerminator(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"data reference FAMTerminator");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>data reference FAMTerminator(source,target)
 */
private pattern mayInRelationdata_reference_FAMTerminator(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFAMTerminator_class(problem,interpretation,source);
	find mayInstanceOfFunctionalData_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationdata_reference_FAMTerminator(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationterminator_reference_FunctionalData(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationdata_reference_FAMTerminator(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []from reference InformationLink(source,target)
 */
private pattern mustInRelationfrom_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"from reference InformationLink");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>from reference InformationLink(source,target)
 */
private pattern mayInRelationfrom_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfInformationLink_class(problem,interpretation,source);
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationfrom_reference_InformationLink(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationfrom_reference_InformationLink(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []to reference InformationLink(source,target)
 */
private pattern mustInRelationto_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"to reference InformationLink");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>to reference InformationLink(source,target)
 */
private pattern mayInRelationto_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfInformationLink_class(problem,interpretation,source);
	find mayInstanceOfFunctionalInput_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationto_reference_InformationLink(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationto_reference_InformationLink(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []data reference FunctionalInterface(source,target)
 */
private pattern mustInRelationdata_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"data reference FunctionalInterface");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>data reference FunctionalInterface(source,target)
 */
private pattern mayInRelationdata_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,source);
	find mayInstanceOfFunctionalData_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationinterface_reference_FunctionalData(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationdata_reference_FunctionalInterface(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []element reference FunctionalInterface(source,target)
 */
private pattern mustInRelationelement_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"element reference FunctionalInterface");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>element reference FunctionalInterface(source,target)
 */
private pattern mayInRelationelement_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,source);
	find mayInstanceOfFunctionalElement_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationelement_reference_FunctionalInterface(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationinterface_reference_FunctionalElement(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationelement_reference_FunctionalInterface(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []IncomingLinks reference FunctionalInput(source,target)
 */
private pattern mustInRelationIncomingLinks_reference_FunctionalInput(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"IncomingLinks reference FunctionalInput");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>IncomingLinks reference FunctionalInput(source,target)
 */
private pattern mayInRelationIncomingLinks_reference_FunctionalInput(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalInput_class(problem,interpretation,source);
	find mayInstanceOfInformationLink_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationto_reference_InformationLink(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
} or {
	find mustInRelationIncomingLinks_reference_FunctionalInput(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []outgoingLinks reference FunctionalOutput(source,target)
 */
private pattern mustInRelationoutgoingLinks_reference_FunctionalOutput(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"outgoingLinks reference FunctionalOutput");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>outgoingLinks reference FunctionalOutput(source,target)
 */
private pattern mayInRelationoutgoingLinks_reference_FunctionalOutput(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,source);
	find mayInstanceOfInformationLink_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationfrom_reference_InformationLink(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationoutgoingLinks_reference_FunctionalOutput(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []terminator reference FunctionalData(source,target)
 */
private pattern mustInRelationterminator_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"terminator reference FunctionalData");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>terminator reference FunctionalData(source,target)
 */
private pattern mayInRelationterminator_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalData_class(problem,interpretation,source);
	find mayInstanceOfFAMTerminator_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationterminator_reference_FunctionalData(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationdata_reference_FAMTerminator(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationterminator_reference_FunctionalData(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []interface reference FunctionalData(source,target)
 */
private pattern mustInRelationinterface_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"interface reference FunctionalData");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>interface reference FunctionalData(source,target)
 */
private pattern mayInRelationinterface_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalData_class(problem,interpretation,source);
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationinterface_reference_FunctionalData(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationinterface_reference_FunctionalData(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []type attribute Function(source,target)
 */
private pattern mustInRelationtype_attribute_Function(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"type attribute Function");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>type attribute Function(source,target)
 */
private pattern mayInRelationtype_attribute_Function(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunction_class(problem,interpretation,source);
	find mayInstanceOfFunctionType_enum(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationtype_attribute_Function(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationtype_attribute_Function(problem,interpretation,source,target);
}

//////////
// 1.3 Relation Definition Indexers
//////////

//////////
// 1.4 Containment Indexer
//////////
private pattern mustContains2(source: DefinedElement, target: DefinedElement) {
	find mustContains4(_,_,source,target);
}
	
private pattern mustContains4(problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target: DefinedElement)
	{ find mustInRelationinterface_reference_FunctionalElement(problem,interpretation,source,target); }or
	
	{ find mustInRelationrootElements_reference_FunctionalArchitectureModel(problem,interpretation,source,target); }or
	
	{ find mustInRelationsubElements_reference_Function(problem,interpretation,source,target); }or
	
	{ find mustInRelationdata_reference_FunctionalInterface(problem,interpretation,source,target); }or
	
	{ find mustInRelationoutgoingLinks_reference_FunctionalOutput(problem,interpretation,source,target); }or
	
	{ find mustInRelationterminator_reference_FunctionalData(problem,interpretation,source,target); }

private pattern mustTransitiveContains(source,target) {
	find mustContains2+(source,target);
}

//////////
// 2. Invalidation Indexers
//////////
// 2.1 Invalidated by WF Queries
//////////

//////////
// 3. Unfinishedness Indexers
//////////
// 3.1 Unfinishedness Measured by Multiplicity
//////////
pattern unfinishedLowerMultiplicity_model_reference_FunctionalElement(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"model reference FunctionalElement");
	find mustInstanceOfFunctionalElement_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationmodel_reference_FunctionalElement(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_to_reference_InformationLink(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"to reference InformationLink");
	find mustInstanceOfInformationLink_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationto_reference_InformationLink(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_type_attribute_Function(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"type attribute Function");
	find mustInstanceOfFunction_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationtype_attribute_Function(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}

//////////
// 3.2 Unfinishedness Measured by WF Queries
//////////

//////////
// 4. Refinement Indexers
//////////
// 4.1 Object constructors
//////////
private pattern hasElementInContainment(problem:LogicProblem, interpretation:PartialInterpretation)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalOutput_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalElement_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalInterface_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalData_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalInput_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfInformationLink_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFAMTerminator_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunction_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalArchitectureModel_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}
pattern createObject_Function_class_by_rootElements_reference_FunctionalArchitectureModel(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Function class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"rootElements reference FunctionalArchitectureModel");
	find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,container);
	find mayInstanceOfFunction_class(problem,interpretation,newObject);
	find mayInRelationrootElements_reference_FunctionalArchitectureModel(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Function_class_by_subElements_reference_Function_with_parent_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Function class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"subElements reference Function");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"parent reference FunctionalElement");
	find mustInstanceOfFunction_class(problem,interpretation,container);
	find mayInstanceOfFunction_class(problem,interpretation,newObject);
	find mayInRelationsubElements_reference_Function(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Function_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Function class");
	find mayInstanceOfFunction_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_InformationLink_class_by_outgoingLinks_reference_FunctionalOutput_with_from_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"InformationLink class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"outgoingLinks reference FunctionalOutput");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"from reference InformationLink");
	find mustInstanceOfFunctionalOutput_class(problem,interpretation,container);
	find mayInstanceOfInformationLink_class(problem,interpretation,newObject);
	find mayInRelationoutgoingLinks_reference_FunctionalOutput(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_InformationLink_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"InformationLink class");
	find mayInstanceOfInformationLink_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FAMTerminator_class_by_terminator_reference_FunctionalData_with_data_reference_FAMTerminator(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FAMTerminator class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"terminator reference FunctionalData");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"data reference FAMTerminator");
	find mustInstanceOfFunctionalData_class(problem,interpretation,container);
	find mayInstanceOfFAMTerminator_class(problem,interpretation,newObject);
	find mayInRelationterminator_reference_FunctionalData(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FAMTerminator_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FAMTerminator class");
	find mayInstanceOfFAMTerminator_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalInput_class_by_data_reference_FunctionalInterface_with_interface_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalInput class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"data reference FunctionalInterface");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"interface reference FunctionalData");
	find mustInstanceOfFunctionalInterface_class(problem,interpretation,container);
	find mayInstanceOfFunctionalInput_class(problem,interpretation,newObject);
	find mayInRelationdata_reference_FunctionalInterface(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalInput_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalInput class");
	find mayInstanceOfFunctionalInput_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalArchitectureModel_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalArchitectureModel class UndefinedPart");
	find mayInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalOutput_class_by_data_reference_FunctionalInterface_with_interface_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalOutput class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"data reference FunctionalInterface");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"interface reference FunctionalData");
	find mustInstanceOfFunctionalInterface_class(problem,interpretation,container);
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,newObject);
	find mayInRelationdata_reference_FunctionalInterface(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalOutput_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalOutput class");
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalInterface_class_by_interface_reference_FunctionalElement_with_element_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalInterface class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"interface reference FunctionalElement");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"element reference FunctionalInterface");
	find mustInstanceOfFunctionalElement_class(problem,interpretation,container);
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,newObject);
	find mayInRelationinterface_reference_FunctionalElement(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalInterface_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalInterface class");
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}

//////////
// 4.2 Type refinement
//////////
pattern refineTypeTo_Function_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunction_class(problem,interpretation,element);
	neg find mustInstanceOfFunction_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
}
pattern refineTypeTo_InformationLink_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
}
pattern refineTypeTo_FAMTerminator_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
}
pattern refineTypeTo_FunctionalInput_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
}
pattern refineTypeTo_FunctionalArchitectureModel_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
}
pattern refineTypeTo_FunctionalOutput_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
}
pattern refineTypeTo_FunctionalInterface_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
}

//////////
// 4.3 Relation refinement
//////////
pattern refineRelation_model_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"model reference FunctionalElement");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFunctionalElement_class(problem,interpretation,from);
	find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,to);
	find mayInRelationmodel_reference_FunctionalElement(problem,interpretation,from,to);
	neg find mustInRelationmodel_reference_FunctionalElement(problem,interpretation,from,to);
}
pattern refineRelation_IncomingLinks_reference_FunctionalInput_and_to_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation, oppositeInterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"IncomingLinks reference FunctionalInput");
	PartialInterpretation.partialrelationinterpretation(interpretation,oppositeInterpretation);
	PartialRelationInterpretation.interpretationOf.name(oppositeInterpretation,"to reference InformationLink");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFunctionalInput_class(problem,interpretation,from);
	find mustInstanceOfInformationLink_class(problem,interpretation,to);
	find mayInRelationIncomingLinks_reference_FunctionalInput(problem,interpretation,from,to);
	neg find mustInRelationIncomingLinks_reference_FunctionalInput(problem,interpretation,from,to);
}
pattern refineRelation_type_attribute_Function(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"type attribute Function");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFunction_class(problem,interpretation,from);
	find mustInstanceOfFunctionType_enum(problem,interpretation,to);
	find mayInRelationtype_attribute_Function(problem,interpretation,from,to);
	neg find mustInRelationtype_attribute_Function(problem,interpretation,from,to);
}
import epackage "http://www.bme.hu/mit/inf/dslreasoner/viatrasolver/partialinterpretationlanguage"
import epackage "http://www.bme.hu/mit/inf/dslreasoner/logic/model/problem"
import epackage "http://www.bme.hu/mit/inf/dslreasoner/logic/model/language"

//////////
// 0. Util
//////////
private pattern interpretation(problem:LogicProblem, interpretation:PartialInterpretation) {
	PartialInterpretation.problem(interpretation,problem);
}
	
/////////////////////////
// 0.1 Existence
/////////////////////////
private pattern mustExist(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	find interpretation(problem,interpretation);
	LogicProblem.elements(problem,element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
}

private pattern mayExist(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
    find mustExist(problem,interpretation,element);
} or {
    find interpretation(problem,interpretation);
    neg find elementCloseWorld(element);
    PartialInterpretation.openWorldElements(interpretation,element);
}

private pattern elementCloseWorld(element:DefinedElement) {
	PartialInterpretation.openWorldElements(i,element);
    PartialInterpretation.maxNewElements(i,0);
} or {
	Scope.targetTypeInterpretation(scope,interpretation);
	PartialTypeInterpratation.elements(interpretation,element);
	Scope.maxNewElements(scope,0);
}

////////////////////////
// 0.2 Equivalence
////////////////////////
pattern mayEquivalent(problem:LogicProblem, interpretation:PartialInterpretation, a: DefinedElement, b: DefinedElement) {
	find mayExist(problem,interpretation,a);
	find mayExist(problem,interpretation,b);
	a == b;
}

////////////////////////
// 0.3 Required Patterns by TypeIndexer
////////////////////////
private pattern typeInterpretation(problem:LogicProblem, interpretation:PartialInterpretation, type:TypeDeclaration, typeInterpretation:PartialComplexTypeInterpretation) {
	find interpretation(problem,interpretation);
	LogicProblem.types(problem,type);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
}

private pattern directInstanceOf(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement, type:Type) {
	find interpretation(problem,interpretation);
	LogicProblem.types(problem,type);
	TypeDefinition.elements(type,element);
} or {
	find interpretation(problem,interpretation);
	find typeInterpretation(problem,interpretation,type,typeInterpretation);
	PartialComplexTypeInterpretation.elements(typeInterpretation,element);
}

private pattern isPrimitive(element: PrimitiveElement) {
	PrimitiveElement(element);
}

//////////
// 1. Problem-Specific Base Indexers
//////////
// 1.1 Type Indexers
//////////
// 1.1.1 primitive Type Indexers
//////////

//////////
// 1.1.2 domain-specific Type Indexers
//////////
/**
 * An element must be an instance of type "FunctionalElement class".
 */
private pattern mustInstanceOfFunctionalElement_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalElement class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalElement_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalElement class");
}

/**
 * An element may be an instance of type "FunctionalElement class".
 */
private pattern mayInstanceOfFunctionalElement_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunction_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalElement_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunction_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalElement_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalElement_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalArchitectureModel class".
 */
private pattern mustInstanceOfFunctionalArchitectureModel_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalArchitectureModel class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalArchitectureModel_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalArchitectureModel class");
}

/**
 * An element may be an instance of type "FunctionalArchitectureModel class".
 */
private pattern mayInstanceOfFunctionalArchitectureModel_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalArchitectureModel_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalArchitectureModel_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Function class".
 */
private pattern mustInstanceOfFunction_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Function class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunction_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Function class");
}

/**
 * An element may be an instance of type "Function class".
 */
private pattern mayInstanceOfFunction_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunction_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunction_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunction_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FAMTerminator class".
 */
private pattern mustInstanceOfFAMTerminator_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FAMTerminator class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFAMTerminator_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FAMTerminator class");
}

/**
 * An element may be an instance of type "FAMTerminator class".
 */
private pattern mayInstanceOfFAMTerminator_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find scopeDisallowsNewFAMTerminator_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find scopeDisallowsNewFAMTerminator_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFAMTerminator_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "InformationLink class".
 */
private pattern mustInstanceOfInformationLink_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"InformationLink class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewInformationLink_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"InformationLink class");
}

/**
 * An element may be an instance of type "InformationLink class".
 */
private pattern mayInstanceOfInformationLink_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find scopeDisallowsNewInformationLink_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find scopeDisallowsNewInformationLink_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfInformationLink_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalInterface class".
 */
private pattern mustInstanceOfFunctionalInterface_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalInterface class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalInterface_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalInterface class");
}

/**
 * An element may be an instance of type "FunctionalInterface class".
 */
private pattern mayInstanceOfFunctionalInterface_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalInterface_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalInterface_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalInterface_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalInput class".
 */
private pattern mustInstanceOfFunctionalInput_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalInput class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalInput_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalInput class");
}

/**
 * An element may be an instance of type "FunctionalInput class".
 */
private pattern mayInstanceOfFunctionalInput_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalInput_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalInput_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalInput_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalOutput class".
 */
private pattern mustInstanceOfFunctionalOutput_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalOutput class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalOutput_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalOutput class");
}

/**
 * An element may be an instance of type "FunctionalOutput class".
 */
private pattern mayInstanceOfFunctionalOutput_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalOutput_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalOutput_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalOutput_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalData class".
 */
private pattern mustInstanceOfFunctionalData_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalData class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalData_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalData class");
}

/**
 * An element may be an instance of type "FunctionalData class".
 */
private pattern mayInstanceOfFunctionalData_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalData_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalData_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalData_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionType enum".
 */
private pattern mustInstanceOfFunctionType_enum(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionType enum");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionType_enum(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionType enum");
}

/**
 * An element may be an instance of type "FunctionType enum".
 */
private pattern mayInstanceOfFunctionType_enum(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfFunctionType_enum(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalArchitectureModel class DefinedPart".
 */
private pattern mustInstanceOfFunctionalArchitectureModel_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalArchitectureModel class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalArchitectureModel_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalArchitectureModel class DefinedPart");
}

/**
 * An element may be an instance of type "FunctionalArchitectureModel class DefinedPart".
 */
private pattern mayInstanceOfFunctionalArchitectureModel_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfFunctionalArchitectureModel_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalArchitectureModel class UndefinedPart".
 */
private pattern mustInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalArchitectureModel class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalArchitectureModel_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalArchitectureModel class UndefinedPart");
}

/**
 * An element may be an instance of type "FunctionalArchitectureModel class UndefinedPart".
 */
private pattern mayInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalArchitectureModel_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalArchitectureModel_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem,interpretation,element); }

//////////
// 1.2 Relation Declaration Indexers
//////////
/**
 * Matcher for detecting tuples t where []interface reference FunctionalElement(source,target)
 */
private pattern mustInRelationinterface_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"interface reference FunctionalElement");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>interface reference FunctionalElement(source,target)
 */
private pattern mayInRelationinterface_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalElement_class(problem,interpretation,source);
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationinterface_reference_FunctionalElement(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationelement_reference_FunctionalInterface(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationinterface_reference_FunctionalElement(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []model reference FunctionalElement(source,target)
 */
private pattern mustInRelationmodel_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"model reference FunctionalElement");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>model reference FunctionalElement(source,target)
 */
private pattern mayInRelationmodel_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalElement_class(problem,interpretation,source);
	find mayInstanceOfFunctionalArchitectureModel_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationmodel_reference_FunctionalElement(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationmodel_reference_FunctionalElement(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []parent reference FunctionalElement(source,target)
 */
private pattern mustInRelationparent_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"parent reference FunctionalElement");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>parent reference FunctionalElement(source,target)
 */
private pattern mayInRelationparent_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalElement_class(problem,interpretation,source);
	find mayInstanceOfFunction_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationparent_reference_FunctionalElement(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationparent_reference_FunctionalElement(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []rootElements reference FunctionalArchitectureModel(source,target)
 */
private pattern mustInRelationrootElements_reference_FunctionalArchitectureModel(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"rootElements reference FunctionalArchitectureModel");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>rootElements reference FunctionalArchitectureModel(source,target)
 */
private pattern mayInRelationrootElements_reference_FunctionalArchitectureModel(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalArchitectureModel_class(problem,interpretation,source);
	find mayInstanceOfFunctionalElement_class(problem,interpretation,target);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationrootElements_reference_FunctionalArchitectureModel(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []subElements reference Function(source,target)
 */
private pattern mustInRelationsubElements_reference_Function(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"subElements reference Function");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>subElements reference Function(source,target)
 */
private pattern mayInRelationsubElements_reference_Function(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunction_class(problem,interpretation,source);
	find mayInstanceOfFunctionalElement_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationparent_reference_FunctionalElement(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationsubElements_reference_Function(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []data reference FAMTerminator(source,target)
 */
private pattern mustInRelationdata_reference_FAMTerminator(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"data reference FAMTerminator");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>data reference FAMTerminator(source,target)
 */
private pattern mayInRelationdata_reference_FAMTerminator(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFAMTerminator_class(problem,interpretation,source);
	find mayInstanceOfFunctionalData_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationdata_reference_FAMTerminator(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationterminator_reference_FunctionalData(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationdata_reference_FAMTerminator(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []from reference InformationLink(source,target)
 */
private pattern mustInRelationfrom_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"from reference InformationLink");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>from reference InformationLink(source,target)
 */
private pattern mayInRelationfrom_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfInformationLink_class(problem,interpretation,source);
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationfrom_reference_InformationLink(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationfrom_reference_InformationLink(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []to reference InformationLink(source,target)
 */
private pattern mustInRelationto_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"to reference InformationLink");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>to reference InformationLink(source,target)
 */
private pattern mayInRelationto_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfInformationLink_class(problem,interpretation,source);
	find mayInstanceOfFunctionalInput_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationto_reference_InformationLink(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationto_reference_InformationLink(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []data reference FunctionalInterface(source,target)
 */
private pattern mustInRelationdata_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"data reference FunctionalInterface");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>data reference FunctionalInterface(source,target)
 */
private pattern mayInRelationdata_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,source);
	find mayInstanceOfFunctionalData_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationinterface_reference_FunctionalData(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationdata_reference_FunctionalInterface(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []element reference FunctionalInterface(source,target)
 */
private pattern mustInRelationelement_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"element reference FunctionalInterface");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>element reference FunctionalInterface(source,target)
 */
private pattern mayInRelationelement_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,source);
	find mayInstanceOfFunctionalElement_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationelement_reference_FunctionalInterface(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationinterface_reference_FunctionalElement(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationelement_reference_FunctionalInterface(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []IncomingLinks reference FunctionalInput(source,target)
 */
private pattern mustInRelationIncomingLinks_reference_FunctionalInput(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"IncomingLinks reference FunctionalInput");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>IncomingLinks reference FunctionalInput(source,target)
 */
private pattern mayInRelationIncomingLinks_reference_FunctionalInput(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalInput_class(problem,interpretation,source);
	find mayInstanceOfInformationLink_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationto_reference_InformationLink(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
} or {
	find mustInRelationIncomingLinks_reference_FunctionalInput(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []outgoingLinks reference FunctionalOutput(source,target)
 */
private pattern mustInRelationoutgoingLinks_reference_FunctionalOutput(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"outgoingLinks reference FunctionalOutput");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>outgoingLinks reference FunctionalOutput(source,target)
 */
private pattern mayInRelationoutgoingLinks_reference_FunctionalOutput(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,source);
	find mayInstanceOfInformationLink_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationfrom_reference_InformationLink(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationoutgoingLinks_reference_FunctionalOutput(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []terminator reference FunctionalData(source,target)
 */
private pattern mustInRelationterminator_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"terminator reference FunctionalData");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>terminator reference FunctionalData(source,target)
 */
private pattern mayInRelationterminator_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalData_class(problem,interpretation,source);
	find mayInstanceOfFAMTerminator_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationterminator_reference_FunctionalData(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationdata_reference_FAMTerminator(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationterminator_reference_FunctionalData(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []interface reference FunctionalData(source,target)
 */
private pattern mustInRelationinterface_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"interface reference FunctionalData");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>interface reference FunctionalData(source,target)
 */
private pattern mayInRelationinterface_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalData_class(problem,interpretation,source);
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationinterface_reference_FunctionalData(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationinterface_reference_FunctionalData(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []type attribute Function(source,target)
 */
private pattern mustInRelationtype_attribute_Function(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"type attribute Function");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>type attribute Function(source,target)
 */
private pattern mayInRelationtype_attribute_Function(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunction_class(problem,interpretation,source);
	find mayInstanceOfFunctionType_enum(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationtype_attribute_Function(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationtype_attribute_Function(problem,interpretation,source,target);
}

//////////
// 1.3 Relation Definition Indexers
//////////

//////////
// 1.4 Containment Indexer
//////////
private pattern mustContains2(source: DefinedElement, target: DefinedElement) {
	find mustContains4(_,_,source,target);
}
	
private pattern mustContains4(problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target: DefinedElement)
	{ find mustInRelationinterface_reference_FunctionalElement(problem,interpretation,source,target); }or
	
	{ find mustInRelationrootElements_reference_FunctionalArchitectureModel(problem,interpretation,source,target); }or
	
	{ find mustInRelationsubElements_reference_Function(problem,interpretation,source,target); }or
	
	{ find mustInRelationdata_reference_FunctionalInterface(problem,interpretation,source,target); }or
	
	{ find mustInRelationoutgoingLinks_reference_FunctionalOutput(problem,interpretation,source,target); }or
	
	{ find mustInRelationterminator_reference_FunctionalData(problem,interpretation,source,target); }

private pattern mustTransitiveContains(source,target) {
	find mustContains2+(source,target);
}

//////////
// 2. Invalidation Indexers
//////////
// 2.1 Invalidated by WF Queries
//////////

//////////
// 3. Unfinishedness Indexers
//////////
// 3.1 Unfinishedness Measured by Multiplicity
//////////
pattern unfinishedLowerMultiplicity_model_reference_FunctionalElement(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"model reference FunctionalElement");
	find mustInstanceOfFunctionalElement_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationmodel_reference_FunctionalElement(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_to_reference_InformationLink(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"to reference InformationLink");
	find mustInstanceOfInformationLink_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationto_reference_InformationLink(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_type_attribute_Function(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"type attribute Function");
	find mustInstanceOfFunction_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationtype_attribute_Function(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}

//////////
// 3.2 Unfinishedness Measured by WF Queries
//////////

//////////
// 4. Refinement Indexers
//////////
// 4.1 Object constructors
//////////
private pattern hasElementInContainment(problem:LogicProblem, interpretation:PartialInterpretation)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfFAMTerminator_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalOutput_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunction_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalInterface_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalElement_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfInformationLink_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalInput_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalData_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalArchitectureModel_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}
pattern createObject_FunctionalInput_class_by_data_reference_FunctionalInterface_with_interface_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalInput class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"data reference FunctionalInterface");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"interface reference FunctionalData");
	find mustInstanceOfFunctionalInterface_class(problem,interpretation,container);
	find mayInstanceOfFunctionalInput_class(problem,interpretation,newObject);
	find mayInRelationdata_reference_FunctionalInterface(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalInput_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalInput class");
	find mayInstanceOfFunctionalInput_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalOutput_class_by_data_reference_FunctionalInterface_with_interface_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalOutput class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"data reference FunctionalInterface");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"interface reference FunctionalData");
	find mustInstanceOfFunctionalInterface_class(problem,interpretation,container);
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,newObject);
	find mayInRelationdata_reference_FunctionalInterface(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalOutput_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalOutput class");
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FAMTerminator_class_by_terminator_reference_FunctionalData_with_data_reference_FAMTerminator(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FAMTerminator class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"terminator reference FunctionalData");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"data reference FAMTerminator");
	find mustInstanceOfFunctionalData_class(problem,interpretation,container);
	find mayInstanceOfFAMTerminator_class(problem,interpretation,newObject);
	find mayInRelationterminator_reference_FunctionalData(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FAMTerminator_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FAMTerminator class");
	find mayInstanceOfFAMTerminator_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_InformationLink_class_by_outgoingLinks_reference_FunctionalOutput_with_from_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"InformationLink class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"outgoingLinks reference FunctionalOutput");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"from reference InformationLink");
	find mustInstanceOfFunctionalOutput_class(problem,interpretation,container);
	find mayInstanceOfInformationLink_class(problem,interpretation,newObject);
	find mayInRelationoutgoingLinks_reference_FunctionalOutput(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_InformationLink_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"InformationLink class");
	find mayInstanceOfInformationLink_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Function_class_by_rootElements_reference_FunctionalArchitectureModel(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Function class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"rootElements reference FunctionalArchitectureModel");
	find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,container);
	find mayInstanceOfFunction_class(problem,interpretation,newObject);
	find mayInRelationrootElements_reference_FunctionalArchitectureModel(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Function_class_by_subElements_reference_Function_with_parent_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Function class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"subElements reference Function");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"parent reference FunctionalElement");
	find mustInstanceOfFunction_class(problem,interpretation,container);
	find mayInstanceOfFunction_class(problem,interpretation,newObject);
	find mayInRelationsubElements_reference_Function(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Function_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Function class");
	find mayInstanceOfFunction_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalInterface_class_by_interface_reference_FunctionalElement_with_element_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalInterface class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"interface reference FunctionalElement");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"element reference FunctionalInterface");
	find mustInstanceOfFunctionalElement_class(problem,interpretation,container);
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,newObject);
	find mayInRelationinterface_reference_FunctionalElement(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalInterface_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalInterface class");
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalArchitectureModel_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalArchitectureModel class UndefinedPart");
	find mayInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}

//////////
// 4.2 Type refinement
//////////
pattern refineTypeTo_FunctionalInput_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
}
pattern refineTypeTo_FunctionalOutput_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
}
pattern refineTypeTo_FAMTerminator_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
}
pattern refineTypeTo_InformationLink_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
}
pattern refineTypeTo_Function_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunction_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunction_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
}
pattern refineTypeTo_FunctionalInterface_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
}
pattern refineTypeTo_FunctionalArchitectureModel_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
}

//////////
// 4.3 Relation refinement
//////////
pattern refineRelation_model_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"model reference FunctionalElement");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFunctionalElement_class(problem,interpretation,from);
	find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,to);
	find mayInRelationmodel_reference_FunctionalElement(problem,interpretation,from,to);
	neg find mustInRelationmodel_reference_FunctionalElement(problem,interpretation,from,to);
}
pattern refineRelation_IncomingLinks_reference_FunctionalInput_and_to_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation, oppositeInterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"IncomingLinks reference FunctionalInput");
	PartialInterpretation.partialrelationinterpretation(interpretation,oppositeInterpretation);
	PartialRelationInterpretation.interpretationOf.name(oppositeInterpretation,"to reference InformationLink");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFunctionalInput_class(problem,interpretation,from);
	find mustInstanceOfInformationLink_class(problem,interpretation,to);
	find mayInRelationIncomingLinks_reference_FunctionalInput(problem,interpretation,from,to);
	neg find mustInRelationIncomingLinks_reference_FunctionalInput(problem,interpretation,from,to);
}
pattern refineRelation_type_attribute_Function(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"type attribute Function");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFunction_class(problem,interpretation,from);
	find mustInstanceOfFunctionType_enum(problem,interpretation,to);
	find mayInRelationtype_attribute_Function(problem,interpretation,from,to);
	neg find mustInRelationtype_attribute_Function(problem,interpretation,from,to);
}
import epackage "http://www.bme.hu/mit/inf/dslreasoner/viatrasolver/partialinterpretationlanguage"
import epackage "http://www.bme.hu/mit/inf/dslreasoner/logic/model/problem"
import epackage "http://www.bme.hu/mit/inf/dslreasoner/logic/model/language"

//////////
// 0. Util
//////////
private pattern interpretation(problem:LogicProblem, interpretation:PartialInterpretation) {
	PartialInterpretation.problem(interpretation,problem);
}
	
/////////////////////////
// 0.1 Existence
/////////////////////////
private pattern mustExist(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	find interpretation(problem,interpretation);
	LogicProblem.elements(problem,element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
}

private pattern mayExist(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
    find mustExist(problem,interpretation,element);
} or {
    find interpretation(problem,interpretation);
    neg find elementCloseWorld(element);
    PartialInterpretation.openWorldElements(interpretation,element);
}

private pattern elementCloseWorld(element:DefinedElement) {
	PartialInterpretation.openWorldElements(i,element);
    PartialInterpretation.maxNewElements(i,0);
} or {
	Scope.targetTypeInterpretation(scope,interpretation);
	PartialTypeInterpratation.elements(interpretation,element);
	Scope.maxNewElements(scope,0);
}

////////////////////////
// 0.2 Equivalence
////////////////////////
pattern mayEquivalent(problem:LogicProblem, interpretation:PartialInterpretation, a: DefinedElement, b: DefinedElement) {
	find mayExist(problem,interpretation,a);
	find mayExist(problem,interpretation,b);
	a == b;
}

////////////////////////
// 0.3 Required Patterns by TypeIndexer
////////////////////////
private pattern typeInterpretation(problem:LogicProblem, interpretation:PartialInterpretation, type:TypeDeclaration, typeInterpretation:PartialComplexTypeInterpretation) {
	find interpretation(problem,interpretation);
	LogicProblem.types(problem,type);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
}

private pattern directInstanceOf(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement, type:Type) {
	find interpretation(problem,interpretation);
	LogicProblem.types(problem,type);
	TypeDefinition.elements(type,element);
} or {
	find interpretation(problem,interpretation);
	find typeInterpretation(problem,interpretation,type,typeInterpretation);
	PartialComplexTypeInterpretation.elements(typeInterpretation,element);
}

private pattern isPrimitive(element: PrimitiveElement) {
	PrimitiveElement(element);
}

//////////
// 1. Problem-Specific Base Indexers
//////////
// 1.1 Type Indexers
//////////
// 1.1.1 primitive Type Indexers
//////////

//////////
// 1.1.2 domain-specific Type Indexers
//////////
/**
 * An element must be an instance of type "FunctionalElement class".
 */
private pattern mustInstanceOfFunctionalElement_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalElement class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalElement_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalElement class");
}

/**
 * An element may be an instance of type "FunctionalElement class".
 */
private pattern mayInstanceOfFunctionalElement_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunction_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalElement_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunction_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalElement_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalElement_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalArchitectureModel class".
 */
private pattern mustInstanceOfFunctionalArchitectureModel_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalArchitectureModel class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalArchitectureModel_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalArchitectureModel class");
}

/**
 * An element may be an instance of type "FunctionalArchitectureModel class".
 */
private pattern mayInstanceOfFunctionalArchitectureModel_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalArchitectureModel_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalArchitectureModel_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Function class".
 */
private pattern mustInstanceOfFunction_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Function class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunction_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Function class");
}

/**
 * An element may be an instance of type "Function class".
 */
private pattern mayInstanceOfFunction_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunction_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunction_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunction_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FAMTerminator class".
 */
private pattern mustInstanceOfFAMTerminator_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FAMTerminator class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFAMTerminator_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FAMTerminator class");
}

/**
 * An element may be an instance of type "FAMTerminator class".
 */
private pattern mayInstanceOfFAMTerminator_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find scopeDisallowsNewFAMTerminator_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find scopeDisallowsNewFAMTerminator_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFAMTerminator_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "InformationLink class".
 */
private pattern mustInstanceOfInformationLink_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"InformationLink class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewInformationLink_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"InformationLink class");
}

/**
 * An element may be an instance of type "InformationLink class".
 */
private pattern mayInstanceOfInformationLink_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find scopeDisallowsNewInformationLink_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find scopeDisallowsNewInformationLink_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfInformationLink_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalInterface class".
 */
private pattern mustInstanceOfFunctionalInterface_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalInterface class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalInterface_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalInterface class");
}

/**
 * An element may be an instance of type "FunctionalInterface class".
 */
private pattern mayInstanceOfFunctionalInterface_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalInterface_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalInterface_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalInterface_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalInput class".
 */
private pattern mustInstanceOfFunctionalInput_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalInput class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalInput_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalInput class");
}

/**
 * An element may be an instance of type "FunctionalInput class".
 */
private pattern mayInstanceOfFunctionalInput_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalInput_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalInput_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalInput_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalOutput class".
 */
private pattern mustInstanceOfFunctionalOutput_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalOutput class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalOutput_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalOutput class");
}

/**
 * An element may be an instance of type "FunctionalOutput class".
 */
private pattern mayInstanceOfFunctionalOutput_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalOutput_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalOutput_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalOutput_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalData class".
 */
private pattern mustInstanceOfFunctionalData_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalData class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalData_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalData class");
}

/**
 * An element may be an instance of type "FunctionalData class".
 */
private pattern mayInstanceOfFunctionalData_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalData_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalData_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalData_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionType enum".
 */
private pattern mustInstanceOfFunctionType_enum(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionType enum");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionType_enum(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionType enum");
}

/**
 * An element may be an instance of type "FunctionType enum".
 */
private pattern mayInstanceOfFunctionType_enum(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfFunctionType_enum(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalArchitectureModel class DefinedPart".
 */
private pattern mustInstanceOfFunctionalArchitectureModel_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalArchitectureModel class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalArchitectureModel_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalArchitectureModel class DefinedPart");
}

/**
 * An element may be an instance of type "FunctionalArchitectureModel class DefinedPart".
 */
private pattern mayInstanceOfFunctionalArchitectureModel_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfFunctionalArchitectureModel_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalArchitectureModel class UndefinedPart".
 */
private pattern mustInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalArchitectureModel class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalArchitectureModel_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalArchitectureModel class UndefinedPart");
}

/**
 * An element may be an instance of type "FunctionalArchitectureModel class UndefinedPart".
 */
private pattern mayInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalArchitectureModel_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalArchitectureModel_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem,interpretation,element); }

//////////
// 1.2 Relation Declaration Indexers
//////////
/**
 * Matcher for detecting tuples t where []interface reference FunctionalElement(source,target)
 */
private pattern mustInRelationinterface_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"interface reference FunctionalElement");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>interface reference FunctionalElement(source,target)
 */
private pattern mayInRelationinterface_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalElement_class(problem,interpretation,source);
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationinterface_reference_FunctionalElement(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationelement_reference_FunctionalInterface(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationinterface_reference_FunctionalElement(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []model reference FunctionalElement(source,target)
 */
 private pattern mustInRelationmodel_reference_FunctionalElement(
 	problem:LogicProblem, interpretation:PartialInterpretation,
 	source: DefinedElement, target:DefinedElement)
 {
 	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_model(problem,interpretation,source,target);
 }
/**
 * Matcher for detecting tuples t where []model reference FunctionalElement(source,target)
 */
 private pattern mayInRelationmodel_reference_FunctionalElement(
 	problem:LogicProblem, interpretation:PartialInterpretation,
 	source: DefinedElement, target:DefinedElement)
 {
 	find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_model(problem,interpretation,source,target);
 }
/**
 * Matcher for detecting tuples t where []parent reference FunctionalElement(source,target)
 */
private pattern mustInRelationparent_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"parent reference FunctionalElement");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>parent reference FunctionalElement(source,target)
 */
private pattern mayInRelationparent_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalElement_class(problem,interpretation,source);
	find mayInstanceOfFunction_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationparent_reference_FunctionalElement(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationparent_reference_FunctionalElement(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []rootElements reference FunctionalArchitectureModel(source,target)
 */
private pattern mustInRelationrootElements_reference_FunctionalArchitectureModel(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"rootElements reference FunctionalArchitectureModel");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>rootElements reference FunctionalArchitectureModel(source,target)
 */
private pattern mayInRelationrootElements_reference_FunctionalArchitectureModel(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalArchitectureModel_class(problem,interpretation,source);
	find mayInstanceOfFunctionalElement_class(problem,interpretation,target);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationrootElements_reference_FunctionalArchitectureModel(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []subElements reference Function(source,target)
 */
private pattern mustInRelationsubElements_reference_Function(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"subElements reference Function");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>subElements reference Function(source,target)
 */
private pattern mayInRelationsubElements_reference_Function(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunction_class(problem,interpretation,source);
	find mayInstanceOfFunctionalElement_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationparent_reference_FunctionalElement(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationsubElements_reference_Function(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []data reference FAMTerminator(source,target)
 */
private pattern mustInRelationdata_reference_FAMTerminator(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"data reference FAMTerminator");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>data reference FAMTerminator(source,target)
 */
private pattern mayInRelationdata_reference_FAMTerminator(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFAMTerminator_class(problem,interpretation,source);
	find mayInstanceOfFunctionalData_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationdata_reference_FAMTerminator(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationterminator_reference_FunctionalData(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationdata_reference_FAMTerminator(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []from reference InformationLink(source,target)
 */
private pattern mustInRelationfrom_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"from reference InformationLink");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>from reference InformationLink(source,target)
 */
private pattern mayInRelationfrom_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfInformationLink_class(problem,interpretation,source);
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationfrom_reference_InformationLink(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationfrom_reference_InformationLink(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []to reference InformationLink(source,target)
 */
private pattern mustInRelationto_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"to reference InformationLink");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>to reference InformationLink(source,target)
 */
private pattern mayInRelationto_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfInformationLink_class(problem,interpretation,source);
	find mayInstanceOfFunctionalInput_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationto_reference_InformationLink(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationto_reference_InformationLink(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []data reference FunctionalInterface(source,target)
 */
private pattern mustInRelationdata_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"data reference FunctionalInterface");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>data reference FunctionalInterface(source,target)
 */
private pattern mayInRelationdata_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,source);
	find mayInstanceOfFunctionalData_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationinterface_reference_FunctionalData(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationdata_reference_FunctionalInterface(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []element reference FunctionalInterface(source,target)
 */
private pattern mustInRelationelement_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"element reference FunctionalInterface");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>element reference FunctionalInterface(source,target)
 */
private pattern mayInRelationelement_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,source);
	find mayInstanceOfFunctionalElement_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationelement_reference_FunctionalInterface(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationinterface_reference_FunctionalElement(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationelement_reference_FunctionalInterface(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []IncomingLinks reference FunctionalInput(source,target)
 */
private pattern mustInRelationIncomingLinks_reference_FunctionalInput(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"IncomingLinks reference FunctionalInput");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>IncomingLinks reference FunctionalInput(source,target)
 */
private pattern mayInRelationIncomingLinks_reference_FunctionalInput(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalInput_class(problem,interpretation,source);
	find mayInstanceOfInformationLink_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationto_reference_InformationLink(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
} or {
	find mustInRelationIncomingLinks_reference_FunctionalInput(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []outgoingLinks reference FunctionalOutput(source,target)
 */
private pattern mustInRelationoutgoingLinks_reference_FunctionalOutput(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"outgoingLinks reference FunctionalOutput");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>outgoingLinks reference FunctionalOutput(source,target)
 */
private pattern mayInRelationoutgoingLinks_reference_FunctionalOutput(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,source);
	find mayInstanceOfInformationLink_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationfrom_reference_InformationLink(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationoutgoingLinks_reference_FunctionalOutput(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []terminator reference FunctionalData(source,target)
 */
private pattern mustInRelationterminator_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"terminator reference FunctionalData");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>terminator reference FunctionalData(source,target)
 */
private pattern mayInRelationterminator_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalData_class(problem,interpretation,source);
	find mayInstanceOfFAMTerminator_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationterminator_reference_FunctionalData(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationdata_reference_FAMTerminator(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationterminator_reference_FunctionalData(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []interface reference FunctionalData(source,target)
 */
private pattern mustInRelationinterface_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"interface reference FunctionalData");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>interface reference FunctionalData(source,target)
 */
private pattern mayInRelationinterface_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalData_class(problem,interpretation,source);
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationinterface_reference_FunctionalData(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationinterface_reference_FunctionalData(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []type attribute Function(source,target)
 */
 private pattern mustInRelationtype_attribute_Function(
 	problem:LogicProblem, interpretation:PartialInterpretation,
 	source: DefinedElement, target:DefinedElement)
 {
 	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_type(problem,interpretation,source,target);
 }
/**
 * Matcher for detecting tuples t where []type attribute Function(source,target)
 */
 private pattern mayInRelationtype_attribute_Function(
 	problem:LogicProblem, interpretation:PartialInterpretation,
 	source: DefinedElement, target:DefinedElement)
 {
 	find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_type(problem,interpretation,source,target);
 }

//////////
// 1.3 Relation Definition Indexers
//////////
// Must, May and Current queries for pattern ca mcgill ecse dslreasoner standalone test fam terminatorAndInformation
private pattern mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_terminatorAndInformation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_T, var_I)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfFAMTerminator_class(problem,interpretation,var_T);
	find mustInstanceOfInformationLink_class(problem,interpretation,var_I);
	// T is exported
	// I is exported
	find mustInstanceOfFunctionalOutput_class(problem,interpretation,var_Out);
	find mustInRelationoutgoingLinks_reference_FunctionalOutput(problem,interpretation,var_Out,var_virtual0);
	find mustInstanceOfInformationLink_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_I;
	find mustInstanceOfFunctionalOutput_class(problem,interpretation,var_Out);
	find mustInRelationterminator_reference_FunctionalData(problem,interpretation,var_Out,var_virtual1);
	find mustInstanceOfFAMTerminator_class(problem,interpretation,var_virtual1);
	var_virtual1 == var_T;
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFAMTerminator_class(problem,interpretation,var_T);
	find mustInstanceOfInformationLink_class(problem,interpretation,var_I);
	// T is exported
	// I is exported
	find mustInstanceOfInformationLink_class(problem,interpretation,var_I);
	find mustInRelationto_reference_InformationLink(problem,interpretation,var_I,var_virtual0);
	find mustInstanceOfFunctionalInput_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_In;
	find mustInstanceOfFunctionalInput_class(problem,interpretation,var_In);
	find mustInRelationterminator_reference_FunctionalData(problem,interpretation,var_In,var_virtual1);
	find mustInstanceOfFAMTerminator_class(problem,interpretation,var_virtual1);
	var_virtual1 == var_T;
}
private pattern mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_terminatorAndInformation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_T, var_I)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfFAMTerminator_class(problem,interpretation,var_T);
	find mayInstanceOfInformationLink_class(problem,interpretation,var_I);
	// T is exported
	// I is exported
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,var_Out);
	find mayInRelationoutgoingLinks_reference_FunctionalOutput(problem,interpretation,var_Out,var_virtual0);
	find mayInstanceOfInformationLink_class(problem,interpretation,var_virtual0);
	find mayEquivalent(problem, interpretation, var_virtual0, var_I);
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,var_Out);
	find mayInRelationterminator_reference_FunctionalData(problem,interpretation,var_Out,var_virtual1);
	find mayInstanceOfFAMTerminator_class(problem,interpretation,var_virtual1);
	find mayEquivalent(problem, interpretation, var_virtual1, var_T);
}or{
	find interpretation(problem,interpretation);
	find mayInstanceOfFAMTerminator_class(problem,interpretation,var_T);
	find mayInstanceOfInformationLink_class(problem,interpretation,var_I);
	// T is exported
	// I is exported
	find mayInstanceOfInformationLink_class(problem,interpretation,var_I);
	find mayInRelationto_reference_InformationLink(problem,interpretation,var_I,var_virtual0);
	find mayInstanceOfFunctionalInput_class(problem,interpretation,var_virtual0);
	find mayEquivalent(problem, interpretation, var_virtual0, var_In);
	find mayInstanceOfFunctionalInput_class(problem,interpretation,var_In);
	find mayInRelationterminator_reference_FunctionalData(problem,interpretation,var_In,var_virtual1);
	find mayInstanceOfFAMTerminator_class(problem,interpretation,var_virtual1);
	find mayEquivalent(problem, interpretation, var_virtual1, var_T);
}
private pattern currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_terminatorAndInformation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_T, var_I)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfFAMTerminator_class(problem,interpretation,var_T);
	find mustInstanceOfInformationLink_class(problem,interpretation,var_I);
	// T is exported
	// I is exported
	find mustInstanceOfFunctionalOutput_class(problem,interpretation,var_Out);
	find mustInRelationoutgoingLinks_reference_FunctionalOutput(problem,interpretation,var_Out,var_virtual0);
	find mustInstanceOfInformationLink_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_I;
	find mustInstanceOfFunctionalOutput_class(problem,interpretation,var_Out);
	find mustInRelationterminator_reference_FunctionalData(problem,interpretation,var_Out,var_virtual1);
	find mustInstanceOfFAMTerminator_class(problem,interpretation,var_virtual1);
	var_virtual1 == var_T;
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFAMTerminator_class(problem,interpretation,var_T);
	find mustInstanceOfInformationLink_class(problem,interpretation,var_I);
	// T is exported
	// I is exported
	find mustInstanceOfInformationLink_class(problem,interpretation,var_I);
	find mustInRelationto_reference_InformationLink(problem,interpretation,var_I,var_virtual0);
	find mustInstanceOfFunctionalInput_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_In;
	find mustInstanceOfFunctionalInput_class(problem,interpretation,var_In);
	find mustInRelationterminator_reference_FunctionalData(problem,interpretation,var_In,var_virtual1);
	find mustInstanceOfFAMTerminator_class(problem,interpretation,var_virtual1);
	var_virtual1 == var_T;
}
// Must, May and Current queries for pattern ca mcgill ecse dslreasoner standalone test fam type
private pattern mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_type(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_This, var_Target)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunction_class(problem,interpretation,var_This);
	// type constraint is enforced by construction
	// This is exported
	// Target is exported
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_rootElements(problem,interpretation,_var__Model,var_This);
	var_virtual0 == const_Root_FunctionType;DefinedElement.name(const_Root_FunctionType,"Root FunctionType");  //LogicProblem.elements(problem,const_Root_FunctionType);
	var_Target == var_virtual0;
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunction_class(problem,interpretation,var_This);
	// type constraint is enforced by construction
	// This is exported
	// Target is exported
	neg find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_parent(problem,interpretation,_var__Child,var_This);
	neg find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_rootElements(problem,interpretation,_var__Model,var_This);
	var_virtual0 == const_Leaf_FunctionType;DefinedElement.name(const_Leaf_FunctionType,"Leaf FunctionType");  //LogicProblem.elements(problem,const_Leaf_FunctionType);
	var_Target == var_virtual0;
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunction_class(problem,interpretation,var_This);
	// type constraint is enforced by construction
	// This is exported
	// Target is exported
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_parent(problem,interpretation,var_This,_var__Par);
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_parent(problem,interpretation,_var__Child,var_This);
	var_virtual0 == const_Intermediate_FunctionType;DefinedElement.name(const_Intermediate_FunctionType,"Intermediate FunctionType");  //LogicProblem.elements(problem,const_Intermediate_FunctionType);
	var_Target == var_virtual0;
}
private pattern mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_type(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_This, var_Target)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfFunction_class(problem,interpretation,var_This);
	// type constraint is enforced by construction
	// This is exported
	// Target is exported
	find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_rootElements(problem,interpretation,_var__Model,var_This);
	var_virtual0 == const_Root_FunctionType;DefinedElement.name(const_Root_FunctionType,"Root FunctionType");  //LogicProblem.elements(problem,const_Root_FunctionType);
	find mayEquivalent(problem, interpretation, var_Target, var_virtual0);
}or{
	find interpretation(problem,interpretation);
	find mayInstanceOfFunction_class(problem,interpretation,var_This);
	// type constraint is enforced by construction
	// This is exported
	// Target is exported
	neg find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_parent(problem,interpretation,_var__Child,var_This);
	neg find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_rootElements(problem,interpretation,_var__Model,var_This);
	var_virtual0 == const_Leaf_FunctionType;DefinedElement.name(const_Leaf_FunctionType,"Leaf FunctionType");  //LogicProblem.elements(problem,const_Leaf_FunctionType);
	find mayEquivalent(problem, interpretation, var_Target, var_virtual0);
}or{
	find interpretation(problem,interpretation);
	find mayInstanceOfFunction_class(problem,interpretation,var_This);
	// type constraint is enforced by construction
	// This is exported
	// Target is exported
	find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_parent(problem,interpretation,var_This,_var__Par);
	find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_parent(problem,interpretation,_var__Child,var_This);
	var_virtual0 == const_Intermediate_FunctionType;DefinedElement.name(const_Intermediate_FunctionType,"Intermediate FunctionType");  //LogicProblem.elements(problem,const_Intermediate_FunctionType);
	find mayEquivalent(problem, interpretation, var_Target, var_virtual0);
}
private pattern currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_type(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_This, var_Target)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunction_class(problem,interpretation,var_This);
	// type constraint is enforced by construction
	// This is exported
	// Target is exported
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_rootElements(problem,interpretation,_var__Model,var_This);
	var_virtual0 == const_Root_FunctionType;DefinedElement.name(const_Root_FunctionType,"Root FunctionType");  //LogicProblem.elements(problem,const_Root_FunctionType);
	var_Target == var_virtual0;
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunction_class(problem,interpretation,var_This);
	// type constraint is enforced by construction
	// This is exported
	// Target is exported
	neg find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_parent(problem,interpretation,_var__Child,var_This);
	neg find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_rootElements(problem,interpretation,_var__Model,var_This);
	var_virtual0 == const_Leaf_FunctionType;DefinedElement.name(const_Leaf_FunctionType,"Leaf FunctionType");  //LogicProblem.elements(problem,const_Leaf_FunctionType);
	var_Target == var_virtual0;
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunction_class(problem,interpretation,var_This);
	// type constraint is enforced by construction
	// This is exported
	// Target is exported
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_parent(problem,interpretation,var_This,_var__Par);
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_parent(problem,interpretation,_var__Child,var_This);
	var_virtual0 == const_Intermediate_FunctionType;DefinedElement.name(const_Intermediate_FunctionType,"Intermediate FunctionType");  //LogicProblem.elements(problem,const_Intermediate_FunctionType);
	var_Target == var_virtual0;
}
// Must, May and Current queries for pattern ca mcgill ecse dslreasoner standalone test fam rootElements
private pattern mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_rootElements(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_Model, var_Root)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,var_Model);
	find mustInstanceOfFunction_class(problem,interpretation,var_Root);
	// Model is exported
	// Root is exported
	find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,var_Model);
	find mustInRelationrootElements_reference_FunctionalArchitectureModel(problem,interpretation,var_Model,var_virtual0);
	find mustInstanceOfFunctionalElement_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_Root;
}
private pattern mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_rootElements(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_Model, var_Root)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfFunctionalArchitectureModel_class(problem,interpretation,var_Model);
	find mayInstanceOfFunction_class(problem,interpretation,var_Root);
	// Model is exported
	// Root is exported
	find mayInstanceOfFunctionalArchitectureModel_class(problem,interpretation,var_Model);
	find mayInRelationrootElements_reference_FunctionalArchitectureModel(problem,interpretation,var_Model,var_virtual0);
	find mayInstanceOfFunctionalElement_class(problem,interpretation,var_virtual0);
	find mayEquivalent(problem, interpretation, var_virtual0, var_Root);
}
private pattern currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_rootElements(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_Model, var_Root)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,var_Model);
	find mustInstanceOfFunction_class(problem,interpretation,var_Root);
	// Model is exported
	// Root is exported
	find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,var_Model);
	find mustInRelationrootElements_reference_FunctionalArchitectureModel(problem,interpretation,var_Model,var_virtual0);
	find mustInstanceOfFunctionalElement_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_Root;
}
// Must, May and Current queries for pattern ca mcgill ecse dslreasoner standalone test fam parent
private pattern mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_parent(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_Func, var_Par)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunction_class(problem,interpretation,var_Func);
	find mustInstanceOfFunction_class(problem,interpretation,var_Par);
	// Func is exported
	// Par is exported
	find mustInstanceOfFunction_class(problem,interpretation,var_Func);
	find mustInRelationparent_reference_FunctionalElement(problem,interpretation,var_Func,var_virtual0);
	find mustInstanceOfFunction_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_Par;
}
private pattern mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_parent(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_Func, var_Par)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfFunction_class(problem,interpretation,var_Func);
	find mayInstanceOfFunction_class(problem,interpretation,var_Par);
	// Func is exported
	// Par is exported
	find mayInstanceOfFunction_class(problem,interpretation,var_Func);
	find mayInRelationparent_reference_FunctionalElement(problem,interpretation,var_Func,var_virtual0);
	find mayInstanceOfFunction_class(problem,interpretation,var_virtual0);
	find mayEquivalent(problem, interpretation, var_virtual0, var_Par);
}
private pattern currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_parent(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_Func, var_Par)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunction_class(problem,interpretation,var_Func);
	find mustInstanceOfFunction_class(problem,interpretation,var_Par);
	// Func is exported
	// Par is exported
	find mustInstanceOfFunction_class(problem,interpretation,var_Func);
	find mustInRelationparent_reference_FunctionalElement(problem,interpretation,var_Func,var_virtual0);
	find mustInstanceOfFunction_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_Par;
}
// Must, May and Current queries for pattern ca mcgill ecse dslreasoner standalone test fam model
private pattern mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_model(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_This, var_Target)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalElement_class(problem,interpretation,var_This);
	find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,var_Target);
	// This is exported
	// Target is exported
	find mustInstanceOfFunctionalElement_class(problem,interpretation,var_This);
	find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,var_Target);
}
private pattern mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_model(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_This, var_Target)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfFunctionalElement_class(problem,interpretation,var_This);
	find mayInstanceOfFunctionalArchitectureModel_class(problem,interpretation,var_Target);
	// This is exported
	// Target is exported
	find mayInstanceOfFunctionalElement_class(problem,interpretation,var_This);
	find mayInstanceOfFunctionalArchitectureModel_class(problem,interpretation,var_Target);
}
private pattern currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_model(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_This, var_Target)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalElement_class(problem,interpretation,var_This);
	find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,var_Target);
	// This is exported
	// Target is exported
	find mustInstanceOfFunctionalElement_class(problem,interpretation,var_This);
	find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,var_Target);
}

//////////
// 1.4 Containment Indexer
//////////
private pattern mustContains2(source: DefinedElement, target: DefinedElement) {
	find mustContains4(_,_,source,target);
}
	
private pattern mustContains4(problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target: DefinedElement)
	{ find mustInRelationinterface_reference_FunctionalElement(problem,interpretation,source,target); }or
	
	{ find mustInRelationrootElements_reference_FunctionalArchitectureModel(problem,interpretation,source,target); }or
	
	{ find mustInRelationsubElements_reference_Function(problem,interpretation,source,target); }or
	
	{ find mustInRelationdata_reference_FunctionalInterface(problem,interpretation,source,target); }or
	
	{ find mustInRelationoutgoingLinks_reference_FunctionalOutput(problem,interpretation,source,target); }or
	
	{ find mustInRelationterminator_reference_FunctionalData(problem,interpretation,source,target); }

private pattern mustTransitiveContains(source,target) {
	find mustContains2+(source,target);
}

//////////
// 2. Invalidation Indexers
//////////
// 2.1 Invalidated by WF Queries
//////////

//////////
// 3. Unfinishedness Indexers
//////////
// 3.1 Unfinishedness Measured by Multiplicity
//////////
pattern unfinishedLowerMultiplicity_to_reference_InformationLink(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"to reference InformationLink");
	find mustInstanceOfInformationLink_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationto_reference_InformationLink(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}

//////////
// 3.2 Unfinishedness Measured by WF Queries
//////////

//////////
// 4. Refinement Indexers
//////////
// 4.1 Object constructors
//////////
private pattern hasElementInContainment(problem:LogicProblem, interpretation:PartialInterpretation)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalInterface_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalElement_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFAMTerminator_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalInput_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalOutput_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfInformationLink_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunction_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalData_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalArchitectureModel_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}
pattern createObject_FAMTerminator_class_by_terminator_reference_FunctionalData_with_data_reference_FAMTerminator(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FAMTerminator class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"terminator reference FunctionalData");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"data reference FAMTerminator");
	find mustInstanceOfFunctionalData_class(problem,interpretation,container);
	find mayInstanceOfFAMTerminator_class(problem,interpretation,newObject);
	find mayInRelationterminator_reference_FunctionalData(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FAMTerminator_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FAMTerminator class");
	find mayInstanceOfFAMTerminator_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalInput_class_by_data_reference_FunctionalInterface_with_interface_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalInput class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"data reference FunctionalInterface");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"interface reference FunctionalData");
	find mustInstanceOfFunctionalInterface_class(problem,interpretation,container);
	find mayInstanceOfFunctionalInput_class(problem,interpretation,newObject);
	find mayInRelationdata_reference_FunctionalInterface(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalInput_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalInput class");
	find mayInstanceOfFunctionalInput_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalOutput_class_by_data_reference_FunctionalInterface_with_interface_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalOutput class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"data reference FunctionalInterface");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"interface reference FunctionalData");
	find mustInstanceOfFunctionalInterface_class(problem,interpretation,container);
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,newObject);
	find mayInRelationdata_reference_FunctionalInterface(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalOutput_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalOutput class");
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalInterface_class_by_interface_reference_FunctionalElement_with_element_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalInterface class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"interface reference FunctionalElement");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"element reference FunctionalInterface");
	find mustInstanceOfFunctionalElement_class(problem,interpretation,container);
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,newObject);
	find mayInRelationinterface_reference_FunctionalElement(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalInterface_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalInterface class");
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Function_class_by_rootElements_reference_FunctionalArchitectureModel(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Function class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"rootElements reference FunctionalArchitectureModel");
	find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,container);
	find mayInstanceOfFunction_class(problem,interpretation,newObject);
	find mayInRelationrootElements_reference_FunctionalArchitectureModel(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Function_class_by_subElements_reference_Function_with_parent_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Function class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"subElements reference Function");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"parent reference FunctionalElement");
	find mustInstanceOfFunction_class(problem,interpretation,container);
	find mayInstanceOfFunction_class(problem,interpretation,newObject);
	find mayInRelationsubElements_reference_Function(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Function_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Function class");
	find mayInstanceOfFunction_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalArchitectureModel_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalArchitectureModel class UndefinedPart");
	find mayInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_InformationLink_class_by_outgoingLinks_reference_FunctionalOutput_with_from_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"InformationLink class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"outgoingLinks reference FunctionalOutput");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"from reference InformationLink");
	find mustInstanceOfFunctionalOutput_class(problem,interpretation,container);
	find mayInstanceOfInformationLink_class(problem,interpretation,newObject);
	find mayInRelationoutgoingLinks_reference_FunctionalOutput(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_InformationLink_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"InformationLink class");
	find mayInstanceOfInformationLink_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}

//////////
// 4.2 Type refinement
//////////
pattern refineTypeTo_FAMTerminator_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
}
pattern refineTypeTo_FunctionalInput_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
}
pattern refineTypeTo_FunctionalOutput_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
}
pattern refineTypeTo_FunctionalInterface_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
}
pattern refineTypeTo_Function_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunction_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunction_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
}
pattern refineTypeTo_FunctionalArchitectureModel_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
}
pattern refineTypeTo_InformationLink_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
}

//////////
// 4.3 Relation refinement
//////////
pattern refineRelation_model_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"model reference FunctionalElement");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFunctionalElement_class(problem,interpretation,from);
	find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,to);
	find mayInRelationmodel_reference_FunctionalElement(problem,interpretation,from,to);
	neg find mustInRelationmodel_reference_FunctionalElement(problem,interpretation,from,to);
}
pattern refineRelation_IncomingLinks_reference_FunctionalInput_and_to_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation, oppositeInterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"IncomingLinks reference FunctionalInput");
	PartialInterpretation.partialrelationinterpretation(interpretation,oppositeInterpretation);
	PartialRelationInterpretation.interpretationOf.name(oppositeInterpretation,"to reference InformationLink");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFunctionalInput_class(problem,interpretation,from);
	find mustInstanceOfInformationLink_class(problem,interpretation,to);
	find mayInRelationIncomingLinks_reference_FunctionalInput(problem,interpretation,from,to);
	neg find mustInRelationIncomingLinks_reference_FunctionalInput(problem,interpretation,from,to);
}
pattern refineRelation_type_attribute_Function(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"type attribute Function");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFunction_class(problem,interpretation,from);
	find mustInstanceOfFunctionType_enum(problem,interpretation,to);
	find mayInRelationtype_attribute_Function(problem,interpretation,from,to);
	neg find mustInRelationtype_attribute_Function(problem,interpretation,from,to);
}
import epackage "http://www.bme.hu/mit/inf/dslreasoner/viatrasolver/partialinterpretationlanguage"
import epackage "http://www.bme.hu/mit/inf/dslreasoner/logic/model/problem"
import epackage "http://www.bme.hu/mit/inf/dslreasoner/logic/model/language"

//////////
// 0. Util
//////////
private pattern interpretation(problem:LogicProblem, interpretation:PartialInterpretation) {
	PartialInterpretation.problem(interpretation,problem);
}
	
/////////////////////////
// 0.1 Existence
/////////////////////////
private pattern mustExist(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	find interpretation(problem,interpretation);
	LogicProblem.elements(problem,element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
}

private pattern mayExist(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
    find mustExist(problem,interpretation,element);
} or {
    find interpretation(problem,interpretation);
    neg find elementCloseWorld(element);
    PartialInterpretation.openWorldElements(interpretation,element);
}

private pattern elementCloseWorld(element:DefinedElement) {
	PartialInterpretation.openWorldElements(i,element);
    PartialInterpretation.maxNewElements(i,0);
} or {
	Scope.targetTypeInterpretation(scope,interpretation);
	PartialTypeInterpratation.elements(interpretation,element);
	Scope.maxNewElements(scope,0);
}

////////////////////////
// 0.2 Equivalence
////////////////////////
pattern mayEquivalent(problem:LogicProblem, interpretation:PartialInterpretation, a: DefinedElement, b: DefinedElement) {
	find mayExist(problem,interpretation,a);
	find mayExist(problem,interpretation,b);
	a == b;
}

////////////////////////
// 0.3 Required Patterns by TypeIndexer
////////////////////////
private pattern typeInterpretation(problem:LogicProblem, interpretation:PartialInterpretation, type:TypeDeclaration, typeInterpretation:PartialComplexTypeInterpretation) {
	find interpretation(problem,interpretation);
	LogicProblem.types(problem,type);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
}

private pattern directInstanceOf(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement, type:Type) {
	find interpretation(problem,interpretation);
	LogicProblem.types(problem,type);
	TypeDefinition.elements(type,element);
} or {
	find interpretation(problem,interpretation);
	find typeInterpretation(problem,interpretation,type,typeInterpretation);
	PartialComplexTypeInterpretation.elements(typeInterpretation,element);
}

private pattern isPrimitive(element: PrimitiveElement) {
	PrimitiveElement(element);
}

//////////
// 1. Problem-Specific Base Indexers
//////////
// 1.1 Type Indexers
//////////
// 1.1.1 primitive Type Indexers
//////////

//////////
// 1.1.2 domain-specific Type Indexers
//////////
/**
 * An element must be an instance of type "FunctionalElement class".
 */
private pattern mustInstanceOfFunctionalElement_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalElement class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalElement_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalElement class");
}

/**
 * An element may be an instance of type "FunctionalElement class".
 */
private pattern mayInstanceOfFunctionalElement_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunction_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalElement_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunction_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalElement_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalElement_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalArchitectureModel class".
 */
private pattern mustInstanceOfFunctionalArchitectureModel_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalArchitectureModel class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalArchitectureModel_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalArchitectureModel class");
}

/**
 * An element may be an instance of type "FunctionalArchitectureModel class".
 */
private pattern mayInstanceOfFunctionalArchitectureModel_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalArchitectureModel_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalArchitectureModel_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Function class".
 */
private pattern mustInstanceOfFunction_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Function class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunction_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Function class");
}

/**
 * An element may be an instance of type "Function class".
 */
private pattern mayInstanceOfFunction_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunction_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunction_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunction_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FAMTerminator class".
 */
private pattern mustInstanceOfFAMTerminator_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FAMTerminator class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFAMTerminator_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FAMTerminator class");
}

/**
 * An element may be an instance of type "FAMTerminator class".
 */
private pattern mayInstanceOfFAMTerminator_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find scopeDisallowsNewFAMTerminator_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find scopeDisallowsNewFAMTerminator_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFAMTerminator_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "InformationLink class".
 */
private pattern mustInstanceOfInformationLink_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"InformationLink class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewInformationLink_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"InformationLink class");
}

/**
 * An element may be an instance of type "InformationLink class".
 */
private pattern mayInstanceOfInformationLink_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find scopeDisallowsNewInformationLink_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find scopeDisallowsNewInformationLink_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfInformationLink_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalInterface class".
 */
private pattern mustInstanceOfFunctionalInterface_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalInterface class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalInterface_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalInterface class");
}

/**
 * An element may be an instance of type "FunctionalInterface class".
 */
private pattern mayInstanceOfFunctionalInterface_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalInterface_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalInterface_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalInterface_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalInput class".
 */
private pattern mustInstanceOfFunctionalInput_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalInput class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalInput_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalInput class");
}

/**
 * An element may be an instance of type "FunctionalInput class".
 */
private pattern mayInstanceOfFunctionalInput_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalInput_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalInput_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalInput_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalOutput class".
 */
private pattern mustInstanceOfFunctionalOutput_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalOutput class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalOutput_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalOutput class");
}

/**
 * An element may be an instance of type "FunctionalOutput class".
 */
private pattern mayInstanceOfFunctionalOutput_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalOutput_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalOutput_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalOutput_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalData class".
 */
private pattern mustInstanceOfFunctionalData_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalData class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalData_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalData class");
}

/**
 * An element may be an instance of type "FunctionalData class".
 */
private pattern mayInstanceOfFunctionalData_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalData_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalData_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalData_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionType enum".
 */
private pattern mustInstanceOfFunctionType_enum(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionType enum");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionType_enum(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionType enum");
}

/**
 * An element may be an instance of type "FunctionType enum".
 */
private pattern mayInstanceOfFunctionType_enum(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfFunctionType_enum(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalArchitectureModel class DefinedPart".
 */
private pattern mustInstanceOfFunctionalArchitectureModel_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalArchitectureModel class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalArchitectureModel_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalArchitectureModel class DefinedPart");
}

/**
 * An element may be an instance of type "FunctionalArchitectureModel class DefinedPart".
 */
private pattern mayInstanceOfFunctionalArchitectureModel_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfFunctionalArchitectureModel_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalArchitectureModel class UndefinedPart".
 */
private pattern mustInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalArchitectureModel class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalArchitectureModel_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalArchitectureModel class UndefinedPart");
}

/**
 * An element may be an instance of type "FunctionalArchitectureModel class UndefinedPart".
 */
private pattern mayInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalArchitectureModel_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalArchitectureModel_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem,interpretation,element); }

//////////
// 1.2 Relation Declaration Indexers
//////////
/**
 * Matcher for detecting tuples t where []interface reference FunctionalElement(source,target)
 */
private pattern mustInRelationinterface_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"interface reference FunctionalElement");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>interface reference FunctionalElement(source,target)
 */
private pattern mayInRelationinterface_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalElement_class(problem,interpretation,source);
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationinterface_reference_FunctionalElement(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationelement_reference_FunctionalInterface(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationinterface_reference_FunctionalElement(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []model reference FunctionalElement(source,target)
 */
private pattern mustInRelationmodel_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"model reference FunctionalElement");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>model reference FunctionalElement(source,target)
 */
private pattern mayInRelationmodel_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalElement_class(problem,interpretation,source);
	find mayInstanceOfFunctionalArchitectureModel_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationmodel_reference_FunctionalElement(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationmodel_reference_FunctionalElement(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []parent reference FunctionalElement(source,target)
 */
private pattern mustInRelationparent_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"parent reference FunctionalElement");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>parent reference FunctionalElement(source,target)
 */
private pattern mayInRelationparent_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalElement_class(problem,interpretation,source);
	find mayInstanceOfFunction_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationparent_reference_FunctionalElement(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationparent_reference_FunctionalElement(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []rootElements reference FunctionalArchitectureModel(source,target)
 */
private pattern mustInRelationrootElements_reference_FunctionalArchitectureModel(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"rootElements reference FunctionalArchitectureModel");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>rootElements reference FunctionalArchitectureModel(source,target)
 */
private pattern mayInRelationrootElements_reference_FunctionalArchitectureModel(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalArchitectureModel_class(problem,interpretation,source);
	find mayInstanceOfFunctionalElement_class(problem,interpretation,target);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationrootElements_reference_FunctionalArchitectureModel(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []subElements reference Function(source,target)
 */
private pattern mustInRelationsubElements_reference_Function(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"subElements reference Function");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>subElements reference Function(source,target)
 */
private pattern mayInRelationsubElements_reference_Function(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunction_class(problem,interpretation,source);
	find mayInstanceOfFunctionalElement_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationparent_reference_FunctionalElement(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationsubElements_reference_Function(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []data reference FAMTerminator(source,target)
 */
private pattern mustInRelationdata_reference_FAMTerminator(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"data reference FAMTerminator");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>data reference FAMTerminator(source,target)
 */
private pattern mayInRelationdata_reference_FAMTerminator(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFAMTerminator_class(problem,interpretation,source);
	find mayInstanceOfFunctionalData_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationdata_reference_FAMTerminator(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationterminator_reference_FunctionalData(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationdata_reference_FAMTerminator(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []from reference InformationLink(source,target)
 */
private pattern mustInRelationfrom_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"from reference InformationLink");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>from reference InformationLink(source,target)
 */
private pattern mayInRelationfrom_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfInformationLink_class(problem,interpretation,source);
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationfrom_reference_InformationLink(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationfrom_reference_InformationLink(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []to reference InformationLink(source,target)
 */
private pattern mustInRelationto_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"to reference InformationLink");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>to reference InformationLink(source,target)
 */
private pattern mayInRelationto_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfInformationLink_class(problem,interpretation,source);
	find mayInstanceOfFunctionalInput_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationto_reference_InformationLink(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationto_reference_InformationLink(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []data reference FunctionalInterface(source,target)
 */
private pattern mustInRelationdata_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"data reference FunctionalInterface");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>data reference FunctionalInterface(source,target)
 */
private pattern mayInRelationdata_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,source);
	find mayInstanceOfFunctionalData_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationinterface_reference_FunctionalData(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationdata_reference_FunctionalInterface(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []element reference FunctionalInterface(source,target)
 */
private pattern mustInRelationelement_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"element reference FunctionalInterface");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>element reference FunctionalInterface(source,target)
 */
private pattern mayInRelationelement_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,source);
	find mayInstanceOfFunctionalElement_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationelement_reference_FunctionalInterface(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationinterface_reference_FunctionalElement(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationelement_reference_FunctionalInterface(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []IncomingLinks reference FunctionalInput(source,target)
 */
private pattern mustInRelationIncomingLinks_reference_FunctionalInput(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"IncomingLinks reference FunctionalInput");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>IncomingLinks reference FunctionalInput(source,target)
 */
private pattern mayInRelationIncomingLinks_reference_FunctionalInput(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalInput_class(problem,interpretation,source);
	find mayInstanceOfInformationLink_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationto_reference_InformationLink(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
} or {
	find mustInRelationIncomingLinks_reference_FunctionalInput(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []outgoingLinks reference FunctionalOutput(source,target)
 */
private pattern mustInRelationoutgoingLinks_reference_FunctionalOutput(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"outgoingLinks reference FunctionalOutput");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>outgoingLinks reference FunctionalOutput(source,target)
 */
private pattern mayInRelationoutgoingLinks_reference_FunctionalOutput(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,source);
	find mayInstanceOfInformationLink_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationfrom_reference_InformationLink(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationoutgoingLinks_reference_FunctionalOutput(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []terminator reference FunctionalData(source,target)
 */
private pattern mustInRelationterminator_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"terminator reference FunctionalData");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>terminator reference FunctionalData(source,target)
 */
private pattern mayInRelationterminator_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalData_class(problem,interpretation,source);
	find mayInstanceOfFAMTerminator_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationterminator_reference_FunctionalData(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationdata_reference_FAMTerminator(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationterminator_reference_FunctionalData(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []interface reference FunctionalData(source,target)
 */
private pattern mustInRelationinterface_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"interface reference FunctionalData");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>interface reference FunctionalData(source,target)
 */
private pattern mayInRelationinterface_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalData_class(problem,interpretation,source);
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationinterface_reference_FunctionalData(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationinterface_reference_FunctionalData(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []type attribute Function(source,target)
 */
private pattern mustInRelationtype_attribute_Function(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"type attribute Function");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>type attribute Function(source,target)
 */
private pattern mayInRelationtype_attribute_Function(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunction_class(problem,interpretation,source);
	find mayInstanceOfFunctionType_enum(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationtype_attribute_Function(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationtype_attribute_Function(problem,interpretation,source,target);
}

//////////
// 1.3 Relation Definition Indexers
//////////

//////////
// 1.4 Containment Indexer
//////////
private pattern mustContains2(source: DefinedElement, target: DefinedElement) {
	find mustContains4(_,_,source,target);
}
	
private pattern mustContains4(problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target: DefinedElement)
	{ find mustInRelationinterface_reference_FunctionalElement(problem,interpretation,source,target); }or
	
	{ find mustInRelationrootElements_reference_FunctionalArchitectureModel(problem,interpretation,source,target); }or
	
	{ find mustInRelationsubElements_reference_Function(problem,interpretation,source,target); }or
	
	{ find mustInRelationdata_reference_FunctionalInterface(problem,interpretation,source,target); }or
	
	{ find mustInRelationoutgoingLinks_reference_FunctionalOutput(problem,interpretation,source,target); }or
	
	{ find mustInRelationterminator_reference_FunctionalData(problem,interpretation,source,target); }

private pattern mustTransitiveContains(source,target) {
	find mustContains2+(source,target);
}

//////////
// 2. Invalidation Indexers
//////////
// 2.1 Invalidated by WF Queries
//////////

//////////
// 3. Unfinishedness Indexers
//////////
// 3.1 Unfinishedness Measured by Multiplicity
//////////
pattern unfinishedLowerMultiplicity_model_reference_FunctionalElement(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"model reference FunctionalElement");
	find mustInstanceOfFunctionalElement_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationmodel_reference_FunctionalElement(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_to_reference_InformationLink(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"to reference InformationLink");
	find mustInstanceOfInformationLink_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationto_reference_InformationLink(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_type_attribute_Function(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"type attribute Function");
	find mustInstanceOfFunction_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationtype_attribute_Function(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}

//////////
// 3.2 Unfinishedness Measured by WF Queries
//////////

//////////
// 4. Refinement Indexers
//////////
// 4.1 Object constructors
//////////
private pattern hasElementInContainment(problem:LogicProblem, interpretation:PartialInterpretation)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunction_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalElement_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalOutput_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalData_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFAMTerminator_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalInterface_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalInput_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfInformationLink_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalArchitectureModel_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}
pattern createObject_Function_class_by_rootElements_reference_FunctionalArchitectureModel(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Function class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"rootElements reference FunctionalArchitectureModel");
	find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,container);
	find mayInstanceOfFunction_class(problem,interpretation,newObject);
	find mayInRelationrootElements_reference_FunctionalArchitectureModel(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Function_class_by_subElements_reference_Function_with_parent_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Function class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"subElements reference Function");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"parent reference FunctionalElement");
	find mustInstanceOfFunction_class(problem,interpretation,container);
	find mayInstanceOfFunction_class(problem,interpretation,newObject);
	find mayInRelationsubElements_reference_Function(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Function_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Function class");
	find mayInstanceOfFunction_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalArchitectureModel_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalArchitectureModel class UndefinedPart");
	find mayInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalOutput_class_by_data_reference_FunctionalInterface_with_interface_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalOutput class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"data reference FunctionalInterface");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"interface reference FunctionalData");
	find mustInstanceOfFunctionalInterface_class(problem,interpretation,container);
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,newObject);
	find mayInRelationdata_reference_FunctionalInterface(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalOutput_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalOutput class");
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FAMTerminator_class_by_terminator_reference_FunctionalData_with_data_reference_FAMTerminator(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FAMTerminator class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"terminator reference FunctionalData");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"data reference FAMTerminator");
	find mustInstanceOfFunctionalData_class(problem,interpretation,container);
	find mayInstanceOfFAMTerminator_class(problem,interpretation,newObject);
	find mayInRelationterminator_reference_FunctionalData(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FAMTerminator_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FAMTerminator class");
	find mayInstanceOfFAMTerminator_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalInput_class_by_data_reference_FunctionalInterface_with_interface_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalInput class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"data reference FunctionalInterface");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"interface reference FunctionalData");
	find mustInstanceOfFunctionalInterface_class(problem,interpretation,container);
	find mayInstanceOfFunctionalInput_class(problem,interpretation,newObject);
	find mayInRelationdata_reference_FunctionalInterface(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalInput_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalInput class");
	find mayInstanceOfFunctionalInput_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_InformationLink_class_by_outgoingLinks_reference_FunctionalOutput_with_from_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"InformationLink class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"outgoingLinks reference FunctionalOutput");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"from reference InformationLink");
	find mustInstanceOfFunctionalOutput_class(problem,interpretation,container);
	find mayInstanceOfInformationLink_class(problem,interpretation,newObject);
	find mayInRelationoutgoingLinks_reference_FunctionalOutput(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_InformationLink_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"InformationLink class");
	find mayInstanceOfInformationLink_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalInterface_class_by_interface_reference_FunctionalElement_with_element_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalInterface class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"interface reference FunctionalElement");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"element reference FunctionalInterface");
	find mustInstanceOfFunctionalElement_class(problem,interpretation,container);
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,newObject);
	find mayInRelationinterface_reference_FunctionalElement(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalInterface_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalInterface class");
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}

//////////
// 4.2 Type refinement
//////////
pattern refineTypeTo_Function_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunction_class(problem,interpretation,element);
	neg find mustInstanceOfFunction_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
}
pattern refineTypeTo_FunctionalArchitectureModel_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
}
pattern refineTypeTo_FunctionalOutput_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
}
pattern refineTypeTo_FAMTerminator_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
}
pattern refineTypeTo_FunctionalInput_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
}
pattern refineTypeTo_InformationLink_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
}
pattern refineTypeTo_FunctionalInterface_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
}

//////////
// 4.3 Relation refinement
//////////
pattern refineRelation_model_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"model reference FunctionalElement");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFunctionalElement_class(problem,interpretation,from);
	find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,to);
	find mayInRelationmodel_reference_FunctionalElement(problem,interpretation,from,to);
	neg find mustInRelationmodel_reference_FunctionalElement(problem,interpretation,from,to);
}
pattern refineRelation_IncomingLinks_reference_FunctionalInput_and_to_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation, oppositeInterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"IncomingLinks reference FunctionalInput");
	PartialInterpretation.partialrelationinterpretation(interpretation,oppositeInterpretation);
	PartialRelationInterpretation.interpretationOf.name(oppositeInterpretation,"to reference InformationLink");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFunctionalInput_class(problem,interpretation,from);
	find mustInstanceOfInformationLink_class(problem,interpretation,to);
	find mayInRelationIncomingLinks_reference_FunctionalInput(problem,interpretation,from,to);
	neg find mustInRelationIncomingLinks_reference_FunctionalInput(problem,interpretation,from,to);
}
pattern refineRelation_type_attribute_Function(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"type attribute Function");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFunction_class(problem,interpretation,from);
	find mustInstanceOfFunctionType_enum(problem,interpretation,to);
	find mayInRelationtype_attribute_Function(problem,interpretation,from,to);
	neg find mustInRelationtype_attribute_Function(problem,interpretation,from,to);
}
import epackage "http://www.bme.hu/mit/inf/dslreasoner/viatrasolver/partialinterpretationlanguage"
import epackage "http://www.bme.hu/mit/inf/dslreasoner/logic/model/problem"
import epackage "http://www.bme.hu/mit/inf/dslreasoner/logic/model/language"

//////////
// 0. Util
//////////
private pattern interpretation(problem:LogicProblem, interpretation:PartialInterpretation) {
	PartialInterpretation.problem(interpretation,problem);
}
	
/////////////////////////
// 0.1 Existence
/////////////////////////
private pattern mustExist(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	find interpretation(problem,interpretation);
	LogicProblem.elements(problem,element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
}

private pattern mayExist(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
    find mustExist(problem,interpretation,element);
} or {
    find interpretation(problem,interpretation);
    neg find elementCloseWorld(element);
    PartialInterpretation.openWorldElements(interpretation,element);
}

private pattern elementCloseWorld(element:DefinedElement) {
	PartialInterpretation.openWorldElements(i,element);
    PartialInterpretation.maxNewElements(i,0);
} or {
	Scope.targetTypeInterpretation(scope,interpretation);
	PartialTypeInterpratation.elements(interpretation,element);
	Scope.maxNewElements(scope,0);
}

////////////////////////
// 0.2 Equivalence
////////////////////////
pattern mayEquivalent(problem:LogicProblem, interpretation:PartialInterpretation, a: DefinedElement, b: DefinedElement) {
	find mayExist(problem,interpretation,a);
	find mayExist(problem,interpretation,b);
	a == b;
}

////////////////////////
// 0.3 Required Patterns by TypeIndexer
////////////////////////
private pattern typeInterpretation(problem:LogicProblem, interpretation:PartialInterpretation, type:TypeDeclaration, typeInterpretation:PartialComplexTypeInterpretation) {
	find interpretation(problem,interpretation);
	LogicProblem.types(problem,type);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
}

private pattern directInstanceOf(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement, type:Type) {
	find interpretation(problem,interpretation);
	LogicProblem.types(problem,type);
	TypeDefinition.elements(type,element);
} or {
	find interpretation(problem,interpretation);
	find typeInterpretation(problem,interpretation,type,typeInterpretation);
	PartialComplexTypeInterpretation.elements(typeInterpretation,element);
}

private pattern isPrimitive(element: PrimitiveElement) {
	PrimitiveElement(element);
}

//////////
// 1. Problem-Specific Base Indexers
//////////
// 1.1 Type Indexers
//////////
// 1.1.1 primitive Type Indexers
//////////

//////////
// 1.1.2 domain-specific Type Indexers
//////////
/**
 * An element must be an instance of type "FunctionalElement class".
 */
private pattern mustInstanceOfFunctionalElement_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalElement class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalElement_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalElement class");
}

/**
 * An element may be an instance of type "FunctionalElement class".
 */
private pattern mayInstanceOfFunctionalElement_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunction_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalElement_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunction_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalElement_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalElement_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalArchitectureModel class".
 */
private pattern mustInstanceOfFunctionalArchitectureModel_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalArchitectureModel class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalArchitectureModel_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalArchitectureModel class");
}

/**
 * An element may be an instance of type "FunctionalArchitectureModel class".
 */
private pattern mayInstanceOfFunctionalArchitectureModel_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalArchitectureModel_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalArchitectureModel_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Function class".
 */
private pattern mustInstanceOfFunction_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Function class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunction_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Function class");
}

/**
 * An element may be an instance of type "Function class".
 */
private pattern mayInstanceOfFunction_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunction_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunction_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunction_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FAMTerminator class".
 */
private pattern mustInstanceOfFAMTerminator_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FAMTerminator class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFAMTerminator_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FAMTerminator class");
}

/**
 * An element may be an instance of type "FAMTerminator class".
 */
private pattern mayInstanceOfFAMTerminator_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find scopeDisallowsNewFAMTerminator_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find scopeDisallowsNewFAMTerminator_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFAMTerminator_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "InformationLink class".
 */
private pattern mustInstanceOfInformationLink_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"InformationLink class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewInformationLink_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"InformationLink class");
}

/**
 * An element may be an instance of type "InformationLink class".
 */
private pattern mayInstanceOfInformationLink_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find scopeDisallowsNewInformationLink_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find scopeDisallowsNewInformationLink_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfInformationLink_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalInterface class".
 */
private pattern mustInstanceOfFunctionalInterface_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalInterface class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalInterface_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalInterface class");
}

/**
 * An element may be an instance of type "FunctionalInterface class".
 */
private pattern mayInstanceOfFunctionalInterface_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalInterface_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalInterface_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalInterface_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalInput class".
 */
private pattern mustInstanceOfFunctionalInput_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalInput class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalInput_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalInput class");
}

/**
 * An element may be an instance of type "FunctionalInput class".
 */
private pattern mayInstanceOfFunctionalInput_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalInput_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalInput_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalInput_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalOutput class".
 */
private pattern mustInstanceOfFunctionalOutput_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalOutput class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalOutput_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalOutput class");
}

/**
 * An element may be an instance of type "FunctionalOutput class".
 */
private pattern mayInstanceOfFunctionalOutput_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalOutput_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalOutput_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalOutput_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalData class".
 */
private pattern mustInstanceOfFunctionalData_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalData class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalData_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalData class");
}

/**
 * An element may be an instance of type "FunctionalData class".
 */
private pattern mayInstanceOfFunctionalData_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalData_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalData_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalData_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionType enum".
 */
private pattern mustInstanceOfFunctionType_enum(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionType enum");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionType_enum(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionType enum");
}

/**
 * An element may be an instance of type "FunctionType enum".
 */
private pattern mayInstanceOfFunctionType_enum(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfFunctionType_enum(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalArchitectureModel class DefinedPart".
 */
private pattern mustInstanceOfFunctionalArchitectureModel_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalArchitectureModel class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalArchitectureModel_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalArchitectureModel class DefinedPart");
}

/**
 * An element may be an instance of type "FunctionalArchitectureModel class DefinedPart".
 */
private pattern mayInstanceOfFunctionalArchitectureModel_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfFunctionalArchitectureModel_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalArchitectureModel class UndefinedPart".
 */
private pattern mustInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalArchitectureModel class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalArchitectureModel_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalArchitectureModel class UndefinedPart");
}

/**
 * An element may be an instance of type "FunctionalArchitectureModel class UndefinedPart".
 */
private pattern mayInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalArchitectureModel_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalArchitectureModel_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem,interpretation,element); }

//////////
// 1.2 Relation Declaration Indexers
//////////
/**
 * Matcher for detecting tuples t where []interface reference FunctionalElement(source,target)
 */
private pattern mustInRelationinterface_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"interface reference FunctionalElement");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>interface reference FunctionalElement(source,target)
 */
private pattern mayInRelationinterface_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalElement_class(problem,interpretation,source);
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationinterface_reference_FunctionalElement(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationelement_reference_FunctionalInterface(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationinterface_reference_FunctionalElement(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []model reference FunctionalElement(source,target)
 */
private pattern mustInRelationmodel_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"model reference FunctionalElement");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>model reference FunctionalElement(source,target)
 */
private pattern mayInRelationmodel_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalElement_class(problem,interpretation,source);
	find mayInstanceOfFunctionalArchitectureModel_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationmodel_reference_FunctionalElement(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationmodel_reference_FunctionalElement(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []parent reference FunctionalElement(source,target)
 */
private pattern mustInRelationparent_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"parent reference FunctionalElement");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>parent reference FunctionalElement(source,target)
 */
private pattern mayInRelationparent_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalElement_class(problem,interpretation,source);
	find mayInstanceOfFunction_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationparent_reference_FunctionalElement(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationparent_reference_FunctionalElement(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []rootElements reference FunctionalArchitectureModel(source,target)
 */
private pattern mustInRelationrootElements_reference_FunctionalArchitectureModel(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"rootElements reference FunctionalArchitectureModel");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>rootElements reference FunctionalArchitectureModel(source,target)
 */
private pattern mayInRelationrootElements_reference_FunctionalArchitectureModel(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalArchitectureModel_class(problem,interpretation,source);
	find mayInstanceOfFunctionalElement_class(problem,interpretation,target);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationrootElements_reference_FunctionalArchitectureModel(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []subElements reference Function(source,target)
 */
private pattern mustInRelationsubElements_reference_Function(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"subElements reference Function");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>subElements reference Function(source,target)
 */
private pattern mayInRelationsubElements_reference_Function(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunction_class(problem,interpretation,source);
	find mayInstanceOfFunctionalElement_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationparent_reference_FunctionalElement(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationsubElements_reference_Function(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []data reference FAMTerminator(source,target)
 */
private pattern mustInRelationdata_reference_FAMTerminator(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"data reference FAMTerminator");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>data reference FAMTerminator(source,target)
 */
private pattern mayInRelationdata_reference_FAMTerminator(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFAMTerminator_class(problem,interpretation,source);
	find mayInstanceOfFunctionalData_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationdata_reference_FAMTerminator(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationterminator_reference_FunctionalData(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationdata_reference_FAMTerminator(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []from reference InformationLink(source,target)
 */
private pattern mustInRelationfrom_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"from reference InformationLink");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>from reference InformationLink(source,target)
 */
private pattern mayInRelationfrom_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfInformationLink_class(problem,interpretation,source);
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationfrom_reference_InformationLink(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationfrom_reference_InformationLink(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []to reference InformationLink(source,target)
 */
private pattern mustInRelationto_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"to reference InformationLink");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>to reference InformationLink(source,target)
 */
private pattern mayInRelationto_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfInformationLink_class(problem,interpretation,source);
	find mayInstanceOfFunctionalInput_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationto_reference_InformationLink(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationto_reference_InformationLink(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []data reference FunctionalInterface(source,target)
 */
private pattern mustInRelationdata_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"data reference FunctionalInterface");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>data reference FunctionalInterface(source,target)
 */
private pattern mayInRelationdata_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,source);
	find mayInstanceOfFunctionalData_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationinterface_reference_FunctionalData(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationdata_reference_FunctionalInterface(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []element reference FunctionalInterface(source,target)
 */
private pattern mustInRelationelement_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"element reference FunctionalInterface");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>element reference FunctionalInterface(source,target)
 */
private pattern mayInRelationelement_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,source);
	find mayInstanceOfFunctionalElement_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationelement_reference_FunctionalInterface(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationinterface_reference_FunctionalElement(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationelement_reference_FunctionalInterface(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []IncomingLinks reference FunctionalInput(source,target)
 */
private pattern mustInRelationIncomingLinks_reference_FunctionalInput(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"IncomingLinks reference FunctionalInput");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>IncomingLinks reference FunctionalInput(source,target)
 */
private pattern mayInRelationIncomingLinks_reference_FunctionalInput(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalInput_class(problem,interpretation,source);
	find mayInstanceOfInformationLink_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationto_reference_InformationLink(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
} or {
	find mustInRelationIncomingLinks_reference_FunctionalInput(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []outgoingLinks reference FunctionalOutput(source,target)
 */
private pattern mustInRelationoutgoingLinks_reference_FunctionalOutput(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"outgoingLinks reference FunctionalOutput");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>outgoingLinks reference FunctionalOutput(source,target)
 */
private pattern mayInRelationoutgoingLinks_reference_FunctionalOutput(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,source);
	find mayInstanceOfInformationLink_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationfrom_reference_InformationLink(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationoutgoingLinks_reference_FunctionalOutput(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []terminator reference FunctionalData(source,target)
 */
private pattern mustInRelationterminator_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"terminator reference FunctionalData");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>terminator reference FunctionalData(source,target)
 */
private pattern mayInRelationterminator_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalData_class(problem,interpretation,source);
	find mayInstanceOfFAMTerminator_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationterminator_reference_FunctionalData(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationdata_reference_FAMTerminator(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationterminator_reference_FunctionalData(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []interface reference FunctionalData(source,target)
 */
private pattern mustInRelationinterface_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"interface reference FunctionalData");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>interface reference FunctionalData(source,target)
 */
private pattern mayInRelationinterface_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalData_class(problem,interpretation,source);
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationinterface_reference_FunctionalData(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationinterface_reference_FunctionalData(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []type attribute Function(source,target)
 */
private pattern mustInRelationtype_attribute_Function(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"type attribute Function");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>type attribute Function(source,target)
 */
private pattern mayInRelationtype_attribute_Function(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunction_class(problem,interpretation,source);
	find mayInstanceOfFunctionType_enum(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationtype_attribute_Function(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationtype_attribute_Function(problem,interpretation,source,target);
}

//////////
// 1.3 Relation Definition Indexers
//////////

//////////
// 1.4 Containment Indexer
//////////
private pattern mustContains2(source: DefinedElement, target: DefinedElement) {
	find mustContains4(_,_,source,target);
}
	
private pattern mustContains4(problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target: DefinedElement)
	{ find mustInRelationinterface_reference_FunctionalElement(problem,interpretation,source,target); }or
	
	{ find mustInRelationrootElements_reference_FunctionalArchitectureModel(problem,interpretation,source,target); }or
	
	{ find mustInRelationsubElements_reference_Function(problem,interpretation,source,target); }or
	
	{ find mustInRelationdata_reference_FunctionalInterface(problem,interpretation,source,target); }or
	
	{ find mustInRelationoutgoingLinks_reference_FunctionalOutput(problem,interpretation,source,target); }or
	
	{ find mustInRelationterminator_reference_FunctionalData(problem,interpretation,source,target); }

private pattern mustTransitiveContains(source,target) {
	find mustContains2+(source,target);
}

//////////
// 2. Invalidation Indexers
//////////
// 2.1 Invalidated by WF Queries
//////////

//////////
// 3. Unfinishedness Indexers
//////////
// 3.1 Unfinishedness Measured by Multiplicity
//////////
pattern unfinishedLowerMultiplicity_model_reference_FunctionalElement(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"model reference FunctionalElement");
	find mustInstanceOfFunctionalElement_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationmodel_reference_FunctionalElement(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_to_reference_InformationLink(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"to reference InformationLink");
	find mustInstanceOfInformationLink_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationto_reference_InformationLink(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_type_attribute_Function(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"type attribute Function");
	find mustInstanceOfFunction_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationtype_attribute_Function(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}

//////////
// 3.2 Unfinishedness Measured by WF Queries
//////////

//////////
// 4. Refinement Indexers
//////////
// 4.1 Object constructors
//////////
private pattern hasElementInContainment(problem:LogicProblem, interpretation:PartialInterpretation)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalInput_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFAMTerminator_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalData_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalInterface_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfInformationLink_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalOutput_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalElement_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunction_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalArchitectureModel_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}
pattern createObject_FunctionalArchitectureModel_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalArchitectureModel class UndefinedPart");
	find mayInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Function_class_by_rootElements_reference_FunctionalArchitectureModel(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Function class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"rootElements reference FunctionalArchitectureModel");
	find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,container);
	find mayInstanceOfFunction_class(problem,interpretation,newObject);
	find mayInRelationrootElements_reference_FunctionalArchitectureModel(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Function_class_by_subElements_reference_Function_with_parent_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Function class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"subElements reference Function");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"parent reference FunctionalElement");
	find mustInstanceOfFunction_class(problem,interpretation,container);
	find mayInstanceOfFunction_class(problem,interpretation,newObject);
	find mayInRelationsubElements_reference_Function(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Function_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Function class");
	find mayInstanceOfFunction_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalOutput_class_by_data_reference_FunctionalInterface_with_interface_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalOutput class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"data reference FunctionalInterface");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"interface reference FunctionalData");
	find mustInstanceOfFunctionalInterface_class(problem,interpretation,container);
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,newObject);
	find mayInRelationdata_reference_FunctionalInterface(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalOutput_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalOutput class");
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FAMTerminator_class_by_terminator_reference_FunctionalData_with_data_reference_FAMTerminator(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FAMTerminator class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"terminator reference FunctionalData");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"data reference FAMTerminator");
	find mustInstanceOfFunctionalData_class(problem,interpretation,container);
	find mayInstanceOfFAMTerminator_class(problem,interpretation,newObject);
	find mayInRelationterminator_reference_FunctionalData(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FAMTerminator_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FAMTerminator class");
	find mayInstanceOfFAMTerminator_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalInput_class_by_data_reference_FunctionalInterface_with_interface_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalInput class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"data reference FunctionalInterface");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"interface reference FunctionalData");
	find mustInstanceOfFunctionalInterface_class(problem,interpretation,container);
	find mayInstanceOfFunctionalInput_class(problem,interpretation,newObject);
	find mayInRelationdata_reference_FunctionalInterface(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalInput_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalInput class");
	find mayInstanceOfFunctionalInput_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_InformationLink_class_by_outgoingLinks_reference_FunctionalOutput_with_from_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"InformationLink class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"outgoingLinks reference FunctionalOutput");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"from reference InformationLink");
	find mustInstanceOfFunctionalOutput_class(problem,interpretation,container);
	find mayInstanceOfInformationLink_class(problem,interpretation,newObject);
	find mayInRelationoutgoingLinks_reference_FunctionalOutput(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_InformationLink_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"InformationLink class");
	find mayInstanceOfInformationLink_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalInterface_class_by_interface_reference_FunctionalElement_with_element_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalInterface class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"interface reference FunctionalElement");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"element reference FunctionalInterface");
	find mustInstanceOfFunctionalElement_class(problem,interpretation,container);
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,newObject);
	find mayInRelationinterface_reference_FunctionalElement(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalInterface_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalInterface class");
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}

//////////
// 4.2 Type refinement
//////////
pattern refineTypeTo_FunctionalArchitectureModel_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
}
pattern refineTypeTo_Function_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunction_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunction_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
}
pattern refineTypeTo_FunctionalOutput_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
}
pattern refineTypeTo_FAMTerminator_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
}
pattern refineTypeTo_FunctionalInput_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
}
pattern refineTypeTo_InformationLink_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
}
pattern refineTypeTo_FunctionalInterface_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
}

//////////
// 4.3 Relation refinement
//////////
pattern refineRelation_model_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"model reference FunctionalElement");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFunctionalElement_class(problem,interpretation,from);
	find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,to);
	find mayInRelationmodel_reference_FunctionalElement(problem,interpretation,from,to);
	neg find mustInRelationmodel_reference_FunctionalElement(problem,interpretation,from,to);
}
pattern refineRelation_IncomingLinks_reference_FunctionalInput_and_to_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation, oppositeInterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"IncomingLinks reference FunctionalInput");
	PartialInterpretation.partialrelationinterpretation(interpretation,oppositeInterpretation);
	PartialRelationInterpretation.interpretationOf.name(oppositeInterpretation,"to reference InformationLink");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFunctionalInput_class(problem,interpretation,from);
	find mustInstanceOfInformationLink_class(problem,interpretation,to);
	find mayInRelationIncomingLinks_reference_FunctionalInput(problem,interpretation,from,to);
	neg find mustInRelationIncomingLinks_reference_FunctionalInput(problem,interpretation,from,to);
}
pattern refineRelation_type_attribute_Function(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"type attribute Function");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFunction_class(problem,interpretation,from);
	find mustInstanceOfFunctionType_enum(problem,interpretation,to);
	find mayInRelationtype_attribute_Function(problem,interpretation,from,to);
	neg find mustInRelationtype_attribute_Function(problem,interpretation,from,to);
}
import epackage "http://www.bme.hu/mit/inf/dslreasoner/viatrasolver/partialinterpretationlanguage"
import epackage "http://www.bme.hu/mit/inf/dslreasoner/logic/model/problem"
import epackage "http://www.bme.hu/mit/inf/dslreasoner/logic/model/language"

//////////
// 0. Util
//////////
private pattern interpretation(problem:LogicProblem, interpretation:PartialInterpretation) {
	PartialInterpretation.problem(interpretation,problem);
}
	
/////////////////////////
// 0.1 Existence
/////////////////////////
private pattern mustExist(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	find interpretation(problem,interpretation);
	LogicProblem.elements(problem,element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
}

private pattern mayExist(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
    find mustExist(problem,interpretation,element);
} or {
    find interpretation(problem,interpretation);
    neg find elementCloseWorld(element);
    PartialInterpretation.openWorldElements(interpretation,element);
}

private pattern elementCloseWorld(element:DefinedElement) {
	PartialInterpretation.openWorldElements(i,element);
    PartialInterpretation.maxNewElements(i,0);
} or {
	Scope.targetTypeInterpretation(scope,interpretation);
	PartialTypeInterpratation.elements(interpretation,element);
	Scope.maxNewElements(scope,0);
}

////////////////////////
// 0.2 Equivalence
////////////////////////
pattern mayEquivalent(problem:LogicProblem, interpretation:PartialInterpretation, a: DefinedElement, b: DefinedElement) {
	find mayExist(problem,interpretation,a);
	find mayExist(problem,interpretation,b);
	a == b;
}

////////////////////////
// 0.3 Required Patterns by TypeIndexer
////////////////////////
private pattern typeInterpretation(problem:LogicProblem, interpretation:PartialInterpretation, type:TypeDeclaration, typeInterpretation:PartialComplexTypeInterpretation) {
	find interpretation(problem,interpretation);
	LogicProblem.types(problem,type);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
}

private pattern directInstanceOf(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement, type:Type) {
	find interpretation(problem,interpretation);
	LogicProblem.types(problem,type);
	TypeDefinition.elements(type,element);
} or {
	find interpretation(problem,interpretation);
	find typeInterpretation(problem,interpretation,type,typeInterpretation);
	PartialComplexTypeInterpretation.elements(typeInterpretation,element);
}

private pattern isPrimitive(element: PrimitiveElement) {
	PrimitiveElement(element);
}

//////////
// 1. Problem-Specific Base Indexers
//////////
// 1.1 Type Indexers
//////////
// 1.1.1 primitive Type Indexers
//////////

//////////
// 1.1.2 domain-specific Type Indexers
//////////
/**
 * An element must be an instance of type "FunctionalElement class".
 */
private pattern mustInstanceOfFunctionalElement_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalElement class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalElement_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalElement class");
}

/**
 * An element may be an instance of type "FunctionalElement class".
 */
private pattern mayInstanceOfFunctionalElement_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunction_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalElement_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunction_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalElement_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalElement_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalArchitectureModel class".
 */
private pattern mustInstanceOfFunctionalArchitectureModel_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalArchitectureModel class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalArchitectureModel_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalArchitectureModel class");
}

/**
 * An element may be an instance of type "FunctionalArchitectureModel class".
 */
private pattern mayInstanceOfFunctionalArchitectureModel_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalArchitectureModel_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalArchitectureModel_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Function class".
 */
private pattern mustInstanceOfFunction_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Function class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunction_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Function class");
}

/**
 * An element may be an instance of type "Function class".
 */
private pattern mayInstanceOfFunction_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunction_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunction_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunction_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FAMTerminator class".
 */
private pattern mustInstanceOfFAMTerminator_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FAMTerminator class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFAMTerminator_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FAMTerminator class");
}

/**
 * An element may be an instance of type "FAMTerminator class".
 */
private pattern mayInstanceOfFAMTerminator_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find scopeDisallowsNewFAMTerminator_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find scopeDisallowsNewFAMTerminator_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFAMTerminator_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "InformationLink class".
 */
private pattern mustInstanceOfInformationLink_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"InformationLink class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewInformationLink_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"InformationLink class");
}

/**
 * An element may be an instance of type "InformationLink class".
 */
private pattern mayInstanceOfInformationLink_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find scopeDisallowsNewInformationLink_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find scopeDisallowsNewInformationLink_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfInformationLink_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalInterface class".
 */
private pattern mustInstanceOfFunctionalInterface_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalInterface class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalInterface_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalInterface class");
}

/**
 * An element may be an instance of type "FunctionalInterface class".
 */
private pattern mayInstanceOfFunctionalInterface_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalInterface_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalInterface_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalInterface_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalInput class".
 */
private pattern mustInstanceOfFunctionalInput_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalInput class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalInput_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalInput class");
}

/**
 * An element may be an instance of type "FunctionalInput class".
 */
private pattern mayInstanceOfFunctionalInput_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalInput_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalInput_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalInput_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalOutput class".
 */
private pattern mustInstanceOfFunctionalOutput_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalOutput class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalOutput_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalOutput class");
}

/**
 * An element may be an instance of type "FunctionalOutput class".
 */
private pattern mayInstanceOfFunctionalOutput_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalOutput_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalOutput_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalOutput_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalData class".
 */
private pattern mustInstanceOfFunctionalData_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalData class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalData_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalData class");
}

/**
 * An element may be an instance of type "FunctionalData class".
 */
private pattern mayInstanceOfFunctionalData_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalData_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalData_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalData_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionType enum".
 */
private pattern mustInstanceOfFunctionType_enum(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionType enum");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionType_enum(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionType enum");
}

/**
 * An element may be an instance of type "FunctionType enum".
 */
private pattern mayInstanceOfFunctionType_enum(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfFunctionType_enum(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalArchitectureModel class DefinedPart".
 */
private pattern mustInstanceOfFunctionalArchitectureModel_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalArchitectureModel class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalArchitectureModel_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalArchitectureModel class DefinedPart");
}

/**
 * An element may be an instance of type "FunctionalArchitectureModel class DefinedPart".
 */
private pattern mayInstanceOfFunctionalArchitectureModel_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfFunctionalArchitectureModel_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalArchitectureModel class UndefinedPart".
 */
private pattern mustInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalArchitectureModel class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalArchitectureModel_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalArchitectureModel class UndefinedPart");
}

/**
 * An element may be an instance of type "FunctionalArchitectureModel class UndefinedPart".
 */
private pattern mayInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalArchitectureModel_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalArchitectureModel_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem,interpretation,element); }

//////////
// 1.2 Relation Declaration Indexers
//////////
/**
 * Matcher for detecting tuples t where []interface reference FunctionalElement(source,target)
 */
private pattern mustInRelationinterface_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"interface reference FunctionalElement");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>interface reference FunctionalElement(source,target)
 */
private pattern mayInRelationinterface_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalElement_class(problem,interpretation,source);
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationinterface_reference_FunctionalElement(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationelement_reference_FunctionalInterface(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationinterface_reference_FunctionalElement(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []model reference FunctionalElement(source,target)
 */
private pattern mustInRelationmodel_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"model reference FunctionalElement");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>model reference FunctionalElement(source,target)
 */
private pattern mayInRelationmodel_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalElement_class(problem,interpretation,source);
	find mayInstanceOfFunctionalArchitectureModel_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationmodel_reference_FunctionalElement(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationmodel_reference_FunctionalElement(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []parent reference FunctionalElement(source,target)
 */
private pattern mustInRelationparent_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"parent reference FunctionalElement");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>parent reference FunctionalElement(source,target)
 */
private pattern mayInRelationparent_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalElement_class(problem,interpretation,source);
	find mayInstanceOfFunction_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationparent_reference_FunctionalElement(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationparent_reference_FunctionalElement(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []rootElements reference FunctionalArchitectureModel(source,target)
 */
private pattern mustInRelationrootElements_reference_FunctionalArchitectureModel(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"rootElements reference FunctionalArchitectureModel");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>rootElements reference FunctionalArchitectureModel(source,target)
 */
private pattern mayInRelationrootElements_reference_FunctionalArchitectureModel(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalArchitectureModel_class(problem,interpretation,source);
	find mayInstanceOfFunctionalElement_class(problem,interpretation,target);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationrootElements_reference_FunctionalArchitectureModel(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []subElements reference Function(source,target)
 */
private pattern mustInRelationsubElements_reference_Function(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"subElements reference Function");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>subElements reference Function(source,target)
 */
private pattern mayInRelationsubElements_reference_Function(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunction_class(problem,interpretation,source);
	find mayInstanceOfFunctionalElement_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationparent_reference_FunctionalElement(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationsubElements_reference_Function(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []data reference FAMTerminator(source,target)
 */
private pattern mustInRelationdata_reference_FAMTerminator(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"data reference FAMTerminator");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>data reference FAMTerminator(source,target)
 */
private pattern mayInRelationdata_reference_FAMTerminator(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFAMTerminator_class(problem,interpretation,source);
	find mayInstanceOfFunctionalData_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationdata_reference_FAMTerminator(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationterminator_reference_FunctionalData(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationdata_reference_FAMTerminator(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []from reference InformationLink(source,target)
 */
private pattern mustInRelationfrom_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"from reference InformationLink");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>from reference InformationLink(source,target)
 */
private pattern mayInRelationfrom_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfInformationLink_class(problem,interpretation,source);
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationfrom_reference_InformationLink(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationfrom_reference_InformationLink(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []to reference InformationLink(source,target)
 */
private pattern mustInRelationto_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"to reference InformationLink");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>to reference InformationLink(source,target)
 */
private pattern mayInRelationto_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfInformationLink_class(problem,interpretation,source);
	find mayInstanceOfFunctionalInput_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationto_reference_InformationLink(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationto_reference_InformationLink(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []data reference FunctionalInterface(source,target)
 */
private pattern mustInRelationdata_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"data reference FunctionalInterface");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>data reference FunctionalInterface(source,target)
 */
private pattern mayInRelationdata_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,source);
	find mayInstanceOfFunctionalData_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationinterface_reference_FunctionalData(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationdata_reference_FunctionalInterface(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []element reference FunctionalInterface(source,target)
 */
private pattern mustInRelationelement_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"element reference FunctionalInterface");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>element reference FunctionalInterface(source,target)
 */
private pattern mayInRelationelement_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,source);
	find mayInstanceOfFunctionalElement_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationelement_reference_FunctionalInterface(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationinterface_reference_FunctionalElement(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationelement_reference_FunctionalInterface(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []IncomingLinks reference FunctionalInput(source,target)
 */
private pattern mustInRelationIncomingLinks_reference_FunctionalInput(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"IncomingLinks reference FunctionalInput");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>IncomingLinks reference FunctionalInput(source,target)
 */
private pattern mayInRelationIncomingLinks_reference_FunctionalInput(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalInput_class(problem,interpretation,source);
	find mayInstanceOfInformationLink_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationto_reference_InformationLink(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
} or {
	find mustInRelationIncomingLinks_reference_FunctionalInput(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []outgoingLinks reference FunctionalOutput(source,target)
 */
private pattern mustInRelationoutgoingLinks_reference_FunctionalOutput(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"outgoingLinks reference FunctionalOutput");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>outgoingLinks reference FunctionalOutput(source,target)
 */
private pattern mayInRelationoutgoingLinks_reference_FunctionalOutput(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,source);
	find mayInstanceOfInformationLink_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationfrom_reference_InformationLink(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationoutgoingLinks_reference_FunctionalOutput(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []terminator reference FunctionalData(source,target)
 */
private pattern mustInRelationterminator_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"terminator reference FunctionalData");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>terminator reference FunctionalData(source,target)
 */
private pattern mayInRelationterminator_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalData_class(problem,interpretation,source);
	find mayInstanceOfFAMTerminator_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationterminator_reference_FunctionalData(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationdata_reference_FAMTerminator(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationterminator_reference_FunctionalData(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []interface reference FunctionalData(source,target)
 */
private pattern mustInRelationinterface_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"interface reference FunctionalData");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>interface reference FunctionalData(source,target)
 */
private pattern mayInRelationinterface_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalData_class(problem,interpretation,source);
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationinterface_reference_FunctionalData(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationinterface_reference_FunctionalData(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []type attribute Function(source,target)
 */
private pattern mustInRelationtype_attribute_Function(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"type attribute Function");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>type attribute Function(source,target)
 */
private pattern mayInRelationtype_attribute_Function(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunction_class(problem,interpretation,source);
	find mayInstanceOfFunctionType_enum(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationtype_attribute_Function(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationtype_attribute_Function(problem,interpretation,source,target);
}

//////////
// 1.3 Relation Definition Indexers
//////////

//////////
// 1.4 Containment Indexer
//////////
private pattern mustContains2(source: DefinedElement, target: DefinedElement) {
	find mustContains4(_,_,source,target);
}
	
private pattern mustContains4(problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target: DefinedElement)
	{ find mustInRelationinterface_reference_FunctionalElement(problem,interpretation,source,target); }or
	
	{ find mustInRelationrootElements_reference_FunctionalArchitectureModel(problem,interpretation,source,target); }or
	
	{ find mustInRelationsubElements_reference_Function(problem,interpretation,source,target); }or
	
	{ find mustInRelationdata_reference_FunctionalInterface(problem,interpretation,source,target); }or
	
	{ find mustInRelationoutgoingLinks_reference_FunctionalOutput(problem,interpretation,source,target); }or
	
	{ find mustInRelationterminator_reference_FunctionalData(problem,interpretation,source,target); }

private pattern mustTransitiveContains(source,target) {
	find mustContains2+(source,target);
}

//////////
// 2. Invalidation Indexers
//////////
// 2.1 Invalidated by WF Queries
//////////

//////////
// 3. Unfinishedness Indexers
//////////
// 3.1 Unfinishedness Measured by Multiplicity
//////////
pattern unfinishedLowerMultiplicity_model_reference_FunctionalElement(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"model reference FunctionalElement");
	find mustInstanceOfFunctionalElement_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationmodel_reference_FunctionalElement(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_to_reference_InformationLink(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"to reference InformationLink");
	find mustInstanceOfInformationLink_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationto_reference_InformationLink(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_type_attribute_Function(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"type attribute Function");
	find mustInstanceOfFunction_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationtype_attribute_Function(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}

//////////
// 3.2 Unfinishedness Measured by WF Queries
//////////

//////////
// 4. Refinement Indexers
//////////
// 4.1 Object constructors
//////////
private pattern hasElementInContainment(problem:LogicProblem, interpretation:PartialInterpretation)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalInput_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFAMTerminator_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalElement_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunction_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalData_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfInformationLink_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalInterface_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalOutput_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalArchitectureModel_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}
pattern createObject_FunctionalInterface_class_by_interface_reference_FunctionalElement_with_element_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalInterface class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"interface reference FunctionalElement");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"element reference FunctionalInterface");
	find mustInstanceOfFunctionalElement_class(problem,interpretation,container);
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,newObject);
	find mayInRelationinterface_reference_FunctionalElement(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalInterface_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalInterface class");
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Function_class_by_rootElements_reference_FunctionalArchitectureModel(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Function class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"rootElements reference FunctionalArchitectureModel");
	find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,container);
	find mayInstanceOfFunction_class(problem,interpretation,newObject);
	find mayInRelationrootElements_reference_FunctionalArchitectureModel(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Function_class_by_subElements_reference_Function_with_parent_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Function class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"subElements reference Function");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"parent reference FunctionalElement");
	find mustInstanceOfFunction_class(problem,interpretation,container);
	find mayInstanceOfFunction_class(problem,interpretation,newObject);
	find mayInRelationsubElements_reference_Function(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Function_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Function class");
	find mayInstanceOfFunction_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalOutput_class_by_data_reference_FunctionalInterface_with_interface_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalOutput class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"data reference FunctionalInterface");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"interface reference FunctionalData");
	find mustInstanceOfFunctionalInterface_class(problem,interpretation,container);
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,newObject);
	find mayInRelationdata_reference_FunctionalInterface(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalOutput_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalOutput class");
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalInput_class_by_data_reference_FunctionalInterface_with_interface_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalInput class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"data reference FunctionalInterface");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"interface reference FunctionalData");
	find mustInstanceOfFunctionalInterface_class(problem,interpretation,container);
	find mayInstanceOfFunctionalInput_class(problem,interpretation,newObject);
	find mayInRelationdata_reference_FunctionalInterface(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalInput_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalInput class");
	find mayInstanceOfFunctionalInput_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalArchitectureModel_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalArchitectureModel class UndefinedPart");
	find mayInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_InformationLink_class_by_outgoingLinks_reference_FunctionalOutput_with_from_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"InformationLink class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"outgoingLinks reference FunctionalOutput");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"from reference InformationLink");
	find mustInstanceOfFunctionalOutput_class(problem,interpretation,container);
	find mayInstanceOfInformationLink_class(problem,interpretation,newObject);
	find mayInRelationoutgoingLinks_reference_FunctionalOutput(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_InformationLink_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"InformationLink class");
	find mayInstanceOfInformationLink_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FAMTerminator_class_by_terminator_reference_FunctionalData_with_data_reference_FAMTerminator(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FAMTerminator class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"terminator reference FunctionalData");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"data reference FAMTerminator");
	find mustInstanceOfFunctionalData_class(problem,interpretation,container);
	find mayInstanceOfFAMTerminator_class(problem,interpretation,newObject);
	find mayInRelationterminator_reference_FunctionalData(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FAMTerminator_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FAMTerminator class");
	find mayInstanceOfFAMTerminator_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}

//////////
// 4.2 Type refinement
//////////
pattern refineTypeTo_FunctionalInterface_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
}
pattern refineTypeTo_Function_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunction_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunction_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
}
pattern refineTypeTo_FunctionalOutput_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
}
pattern refineTypeTo_FunctionalInput_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
}
pattern refineTypeTo_FunctionalArchitectureModel_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
}
pattern refineTypeTo_InformationLink_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
}
pattern refineTypeTo_FAMTerminator_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
}

//////////
// 4.3 Relation refinement
//////////
pattern refineRelation_model_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"model reference FunctionalElement");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFunctionalElement_class(problem,interpretation,from);
	find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,to);
	find mayInRelationmodel_reference_FunctionalElement(problem,interpretation,from,to);
	neg find mustInRelationmodel_reference_FunctionalElement(problem,interpretation,from,to);
}
pattern refineRelation_IncomingLinks_reference_FunctionalInput_and_to_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation, oppositeInterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"IncomingLinks reference FunctionalInput");
	PartialInterpretation.partialrelationinterpretation(interpretation,oppositeInterpretation);
	PartialRelationInterpretation.interpretationOf.name(oppositeInterpretation,"to reference InformationLink");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFunctionalInput_class(problem,interpretation,from);
	find mustInstanceOfInformationLink_class(problem,interpretation,to);
	find mayInRelationIncomingLinks_reference_FunctionalInput(problem,interpretation,from,to);
	neg find mustInRelationIncomingLinks_reference_FunctionalInput(problem,interpretation,from,to);
}
pattern refineRelation_type_attribute_Function(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"type attribute Function");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFunction_class(problem,interpretation,from);
	find mustInstanceOfFunctionType_enum(problem,interpretation,to);
	find mayInRelationtype_attribute_Function(problem,interpretation,from,to);
	neg find mustInRelationtype_attribute_Function(problem,interpretation,from,to);
}
import epackage "http://www.bme.hu/mit/inf/dslreasoner/viatrasolver/partialinterpretationlanguage"
import epackage "http://www.bme.hu/mit/inf/dslreasoner/logic/model/problem"
import epackage "http://www.bme.hu/mit/inf/dslreasoner/logic/model/language"

//////////
// 0. Util
//////////
private pattern interpretation(problem:LogicProblem, interpretation:PartialInterpretation) {
	PartialInterpretation.problem(interpretation,problem);
}
	
/////////////////////////
// 0.1 Existence
/////////////////////////
private pattern mustExist(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	find interpretation(problem,interpretation);
	LogicProblem.elements(problem,element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
}

private pattern mayExist(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
    find mustExist(problem,interpretation,element);
} or {
    find interpretation(problem,interpretation);
    neg find elementCloseWorld(element);
    PartialInterpretation.openWorldElements(interpretation,element);
}

private pattern elementCloseWorld(element:DefinedElement) {
	PartialInterpretation.openWorldElements(i,element);
    PartialInterpretation.maxNewElements(i,0);
} or {
	Scope.targetTypeInterpretation(scope,interpretation);
	PartialTypeInterpratation.elements(interpretation,element);
	Scope.maxNewElements(scope,0);
}

////////////////////////
// 0.2 Equivalence
////////////////////////
pattern mayEquivalent(problem:LogicProblem, interpretation:PartialInterpretation, a: DefinedElement, b: DefinedElement) {
	find mayExist(problem,interpretation,a);
	find mayExist(problem,interpretation,b);
	a == b;
}

////////////////////////
// 0.3 Required Patterns by TypeIndexer
////////////////////////
private pattern typeInterpretation(problem:LogicProblem, interpretation:PartialInterpretation, type:TypeDeclaration, typeInterpretation:PartialComplexTypeInterpretation) {
	find interpretation(problem,interpretation);
	LogicProblem.types(problem,type);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
}

private pattern directInstanceOf(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement, type:Type) {
	find interpretation(problem,interpretation);
	LogicProblem.types(problem,type);
	TypeDefinition.elements(type,element);
} or {
	find interpretation(problem,interpretation);
	find typeInterpretation(problem,interpretation,type,typeInterpretation);
	PartialComplexTypeInterpretation.elements(typeInterpretation,element);
}

private pattern isPrimitive(element: PrimitiveElement) {
	PrimitiveElement(element);
}

//////////
// 1. Problem-Specific Base Indexers
//////////
// 1.1 Type Indexers
//////////
// 1.1.1 primitive Type Indexers
//////////

//////////
// 1.1.2 domain-specific Type Indexers
//////////
/**
 * An element must be an instance of type "FunctionalElement class".
 */
private pattern mustInstanceOfFunctionalElement_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalElement class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalElement_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalElement class");
}

/**
 * An element may be an instance of type "FunctionalElement class".
 */
private pattern mayInstanceOfFunctionalElement_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunction_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalElement_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunction_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalElement_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalElement_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalArchitectureModel class".
 */
private pattern mustInstanceOfFunctionalArchitectureModel_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalArchitectureModel class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalArchitectureModel_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalArchitectureModel class");
}

/**
 * An element may be an instance of type "FunctionalArchitectureModel class".
 */
private pattern mayInstanceOfFunctionalArchitectureModel_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalArchitectureModel_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalArchitectureModel_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Function class".
 */
private pattern mustInstanceOfFunction_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Function class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunction_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Function class");
}

/**
 * An element may be an instance of type "Function class".
 */
private pattern mayInstanceOfFunction_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunction_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunction_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunction_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FAMTerminator class".
 */
private pattern mustInstanceOfFAMTerminator_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FAMTerminator class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFAMTerminator_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FAMTerminator class");
}

/**
 * An element may be an instance of type "FAMTerminator class".
 */
private pattern mayInstanceOfFAMTerminator_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find scopeDisallowsNewFAMTerminator_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find scopeDisallowsNewFAMTerminator_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFAMTerminator_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "InformationLink class".
 */
private pattern mustInstanceOfInformationLink_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"InformationLink class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewInformationLink_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"InformationLink class");
}

/**
 * An element may be an instance of type "InformationLink class".
 */
private pattern mayInstanceOfInformationLink_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find scopeDisallowsNewInformationLink_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find scopeDisallowsNewInformationLink_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfInformationLink_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalInterface class".
 */
private pattern mustInstanceOfFunctionalInterface_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalInterface class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalInterface_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalInterface class");
}

/**
 * An element may be an instance of type "FunctionalInterface class".
 */
private pattern mayInstanceOfFunctionalInterface_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalInterface_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalInterface_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalInterface_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalInput class".
 */
private pattern mustInstanceOfFunctionalInput_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalInput class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalInput_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalInput class");
}

/**
 * An element may be an instance of type "FunctionalInput class".
 */
private pattern mayInstanceOfFunctionalInput_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalInput_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalInput_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalInput_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalOutput class".
 */
private pattern mustInstanceOfFunctionalOutput_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalOutput class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalOutput_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalOutput class");
}

/**
 * An element may be an instance of type "FunctionalOutput class".
 */
private pattern mayInstanceOfFunctionalOutput_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalOutput_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalOutput_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalOutput_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalData class".
 */
private pattern mustInstanceOfFunctionalData_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalData class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalData_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalData class");
}

/**
 * An element may be an instance of type "FunctionalData class".
 */
private pattern mayInstanceOfFunctionalData_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalData_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalData_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalData_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionType enum".
 */
private pattern mustInstanceOfFunctionType_enum(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionType enum");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionType_enum(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionType enum");
}

/**
 * An element may be an instance of type "FunctionType enum".
 */
private pattern mayInstanceOfFunctionType_enum(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfFunctionType_enum(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalArchitectureModel class DefinedPart".
 */
private pattern mustInstanceOfFunctionalArchitectureModel_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalArchitectureModel class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalArchitectureModel_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalArchitectureModel class DefinedPart");
}

/**
 * An element may be an instance of type "FunctionalArchitectureModel class DefinedPart".
 */
private pattern mayInstanceOfFunctionalArchitectureModel_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfFunctionalArchitectureModel_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalArchitectureModel class UndefinedPart".
 */
private pattern mustInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalArchitectureModel class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalArchitectureModel_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalArchitectureModel class UndefinedPart");
}

/**
 * An element may be an instance of type "FunctionalArchitectureModel class UndefinedPart".
 */
private pattern mayInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalArchitectureModel_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalArchitectureModel_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem,interpretation,element); }

//////////
// 1.2 Relation Declaration Indexers
//////////
/**
 * Matcher for detecting tuples t where []interface reference FunctionalElement(source,target)
 */
private pattern mustInRelationinterface_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"interface reference FunctionalElement");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>interface reference FunctionalElement(source,target)
 */
private pattern mayInRelationinterface_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalElement_class(problem,interpretation,source);
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationinterface_reference_FunctionalElement(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationelement_reference_FunctionalInterface(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationinterface_reference_FunctionalElement(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []model reference FunctionalElement(source,target)
 */
 private pattern mustInRelationmodel_reference_FunctionalElement(
 	problem:LogicProblem, interpretation:PartialInterpretation,
 	source: DefinedElement, target:DefinedElement)
 {
 	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_model(problem,interpretation,source,target);
 }
/**
 * Matcher for detecting tuples t where []model reference FunctionalElement(source,target)
 */
 private pattern mayInRelationmodel_reference_FunctionalElement(
 	problem:LogicProblem, interpretation:PartialInterpretation,
 	source: DefinedElement, target:DefinedElement)
 {
 	find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_model(problem,interpretation,source,target);
 }
/**
 * Matcher for detecting tuples t where []parent reference FunctionalElement(source,target)
 */
private pattern mustInRelationparent_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"parent reference FunctionalElement");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>parent reference FunctionalElement(source,target)
 */
private pattern mayInRelationparent_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalElement_class(problem,interpretation,source);
	find mayInstanceOfFunction_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationparent_reference_FunctionalElement(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationparent_reference_FunctionalElement(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []rootElements reference FunctionalArchitectureModel(source,target)
 */
private pattern mustInRelationrootElements_reference_FunctionalArchitectureModel(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"rootElements reference FunctionalArchitectureModel");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>rootElements reference FunctionalArchitectureModel(source,target)
 */
private pattern mayInRelationrootElements_reference_FunctionalArchitectureModel(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalArchitectureModel_class(problem,interpretation,source);
	find mayInstanceOfFunctionalElement_class(problem,interpretation,target);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationrootElements_reference_FunctionalArchitectureModel(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []subElements reference Function(source,target)
 */
private pattern mustInRelationsubElements_reference_Function(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"subElements reference Function");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>subElements reference Function(source,target)
 */
private pattern mayInRelationsubElements_reference_Function(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunction_class(problem,interpretation,source);
	find mayInstanceOfFunctionalElement_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationparent_reference_FunctionalElement(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationsubElements_reference_Function(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []data reference FAMTerminator(source,target)
 */
private pattern mustInRelationdata_reference_FAMTerminator(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"data reference FAMTerminator");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>data reference FAMTerminator(source,target)
 */
private pattern mayInRelationdata_reference_FAMTerminator(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFAMTerminator_class(problem,interpretation,source);
	find mayInstanceOfFunctionalData_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationdata_reference_FAMTerminator(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationterminator_reference_FunctionalData(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationdata_reference_FAMTerminator(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []from reference InformationLink(source,target)
 */
private pattern mustInRelationfrom_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"from reference InformationLink");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>from reference InformationLink(source,target)
 */
private pattern mayInRelationfrom_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfInformationLink_class(problem,interpretation,source);
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationfrom_reference_InformationLink(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationfrom_reference_InformationLink(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []to reference InformationLink(source,target)
 */
private pattern mustInRelationto_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"to reference InformationLink");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>to reference InformationLink(source,target)
 */
private pattern mayInRelationto_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfInformationLink_class(problem,interpretation,source);
	find mayInstanceOfFunctionalInput_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationto_reference_InformationLink(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationto_reference_InformationLink(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []data reference FunctionalInterface(source,target)
 */
private pattern mustInRelationdata_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"data reference FunctionalInterface");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>data reference FunctionalInterface(source,target)
 */
private pattern mayInRelationdata_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,source);
	find mayInstanceOfFunctionalData_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationinterface_reference_FunctionalData(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationdata_reference_FunctionalInterface(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []element reference FunctionalInterface(source,target)
 */
private pattern mustInRelationelement_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"element reference FunctionalInterface");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>element reference FunctionalInterface(source,target)
 */
private pattern mayInRelationelement_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,source);
	find mayInstanceOfFunctionalElement_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationelement_reference_FunctionalInterface(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationinterface_reference_FunctionalElement(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationelement_reference_FunctionalInterface(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []IncomingLinks reference FunctionalInput(source,target)
 */
private pattern mustInRelationIncomingLinks_reference_FunctionalInput(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"IncomingLinks reference FunctionalInput");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>IncomingLinks reference FunctionalInput(source,target)
 */
private pattern mayInRelationIncomingLinks_reference_FunctionalInput(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalInput_class(problem,interpretation,source);
	find mayInstanceOfInformationLink_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationto_reference_InformationLink(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
} or {
	find mustInRelationIncomingLinks_reference_FunctionalInput(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []outgoingLinks reference FunctionalOutput(source,target)
 */
private pattern mustInRelationoutgoingLinks_reference_FunctionalOutput(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"outgoingLinks reference FunctionalOutput");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>outgoingLinks reference FunctionalOutput(source,target)
 */
private pattern mayInRelationoutgoingLinks_reference_FunctionalOutput(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,source);
	find mayInstanceOfInformationLink_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationfrom_reference_InformationLink(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationoutgoingLinks_reference_FunctionalOutput(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []terminator reference FunctionalData(source,target)
 */
private pattern mustInRelationterminator_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"terminator reference FunctionalData");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>terminator reference FunctionalData(source,target)
 */
private pattern mayInRelationterminator_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalData_class(problem,interpretation,source);
	find mayInstanceOfFAMTerminator_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationterminator_reference_FunctionalData(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationdata_reference_FAMTerminator(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationterminator_reference_FunctionalData(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []interface reference FunctionalData(source,target)
 */
private pattern mustInRelationinterface_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"interface reference FunctionalData");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>interface reference FunctionalData(source,target)
 */
private pattern mayInRelationinterface_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalData_class(problem,interpretation,source);
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationinterface_reference_FunctionalData(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationinterface_reference_FunctionalData(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []type attribute Function(source,target)
 */
 private pattern mustInRelationtype_attribute_Function(
 	problem:LogicProblem, interpretation:PartialInterpretation,
 	source: DefinedElement, target:DefinedElement)
 {
 	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_type(problem,interpretation,source,target);
 }
/**
 * Matcher for detecting tuples t where []type attribute Function(source,target)
 */
 private pattern mayInRelationtype_attribute_Function(
 	problem:LogicProblem, interpretation:PartialInterpretation,
 	source: DefinedElement, target:DefinedElement)
 {
 	find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_type(problem,interpretation,source,target);
 }

//////////
// 1.3 Relation Definition Indexers
//////////
// Must, May and Current queries for pattern ca mcgill ecse dslreasoner standalone test fam terminatorAndInformation
private pattern mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_terminatorAndInformation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_T, var_I)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfFAMTerminator_class(problem,interpretation,var_T);
	find mustInstanceOfInformationLink_class(problem,interpretation,var_I);
	// T is exported
	// I is exported
	find mustInstanceOfFunctionalOutput_class(problem,interpretation,var_Out);
	find mustInRelationoutgoingLinks_reference_FunctionalOutput(problem,interpretation,var_Out,var_virtual0);
	find mustInstanceOfInformationLink_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_I;
	find mustInstanceOfFunctionalOutput_class(problem,interpretation,var_Out);
	find mustInRelationterminator_reference_FunctionalData(problem,interpretation,var_Out,var_virtual1);
	find mustInstanceOfFAMTerminator_class(problem,interpretation,var_virtual1);
	var_virtual1 == var_T;
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFAMTerminator_class(problem,interpretation,var_T);
	find mustInstanceOfInformationLink_class(problem,interpretation,var_I);
	// T is exported
	// I is exported
	find mustInstanceOfInformationLink_class(problem,interpretation,var_I);
	find mustInRelationto_reference_InformationLink(problem,interpretation,var_I,var_virtual0);
	find mustInstanceOfFunctionalInput_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_In;
	find mustInstanceOfFunctionalInput_class(problem,interpretation,var_In);
	find mustInRelationterminator_reference_FunctionalData(problem,interpretation,var_In,var_virtual1);
	find mustInstanceOfFAMTerminator_class(problem,interpretation,var_virtual1);
	var_virtual1 == var_T;
}
private pattern mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_terminatorAndInformation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_T, var_I)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfFAMTerminator_class(problem,interpretation,var_T);
	find mayInstanceOfInformationLink_class(problem,interpretation,var_I);
	// T is exported
	// I is exported
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,var_Out);
	find mayInRelationoutgoingLinks_reference_FunctionalOutput(problem,interpretation,var_Out,var_virtual0);
	find mayInstanceOfInformationLink_class(problem,interpretation,var_virtual0);
	find mayEquivalent(problem, interpretation, var_virtual0, var_I);
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,var_Out);
	find mayInRelationterminator_reference_FunctionalData(problem,interpretation,var_Out,var_virtual1);
	find mayInstanceOfFAMTerminator_class(problem,interpretation,var_virtual1);
	find mayEquivalent(problem, interpretation, var_virtual1, var_T);
}or{
	find interpretation(problem,interpretation);
	find mayInstanceOfFAMTerminator_class(problem,interpretation,var_T);
	find mayInstanceOfInformationLink_class(problem,interpretation,var_I);
	// T is exported
	// I is exported
	find mayInstanceOfInformationLink_class(problem,interpretation,var_I);
	find mayInRelationto_reference_InformationLink(problem,interpretation,var_I,var_virtual0);
	find mayInstanceOfFunctionalInput_class(problem,interpretation,var_virtual0);
	find mayEquivalent(problem, interpretation, var_virtual0, var_In);
	find mayInstanceOfFunctionalInput_class(problem,interpretation,var_In);
	find mayInRelationterminator_reference_FunctionalData(problem,interpretation,var_In,var_virtual1);
	find mayInstanceOfFAMTerminator_class(problem,interpretation,var_virtual1);
	find mayEquivalent(problem, interpretation, var_virtual1, var_T);
}
private pattern currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_terminatorAndInformation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_T, var_I)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfFAMTerminator_class(problem,interpretation,var_T);
	find mustInstanceOfInformationLink_class(problem,interpretation,var_I);
	// T is exported
	// I is exported
	find mustInstanceOfFunctionalOutput_class(problem,interpretation,var_Out);
	find mustInRelationoutgoingLinks_reference_FunctionalOutput(problem,interpretation,var_Out,var_virtual0);
	find mustInstanceOfInformationLink_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_I;
	find mustInstanceOfFunctionalOutput_class(problem,interpretation,var_Out);
	find mustInRelationterminator_reference_FunctionalData(problem,interpretation,var_Out,var_virtual1);
	find mustInstanceOfFAMTerminator_class(problem,interpretation,var_virtual1);
	var_virtual1 == var_T;
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFAMTerminator_class(problem,interpretation,var_T);
	find mustInstanceOfInformationLink_class(problem,interpretation,var_I);
	// T is exported
	// I is exported
	find mustInstanceOfInformationLink_class(problem,interpretation,var_I);
	find mustInRelationto_reference_InformationLink(problem,interpretation,var_I,var_virtual0);
	find mustInstanceOfFunctionalInput_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_In;
	find mustInstanceOfFunctionalInput_class(problem,interpretation,var_In);
	find mustInRelationterminator_reference_FunctionalData(problem,interpretation,var_In,var_virtual1);
	find mustInstanceOfFAMTerminator_class(problem,interpretation,var_virtual1);
	var_virtual1 == var_T;
}
// Must, May and Current queries for pattern ca mcgill ecse dslreasoner standalone test fam type
private pattern mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_type(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_This, var_Target)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunction_class(problem,interpretation,var_This);
	// type constraint is enforced by construction
	// This is exported
	// Target is exported
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_rootElements(problem,interpretation,_var__Model,var_This);
	var_virtual0 == const_Root_FunctionType;DefinedElement.name(const_Root_FunctionType,"Root FunctionType");  //LogicProblem.elements(problem,const_Root_FunctionType);
	var_Target == var_virtual0;
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunction_class(problem,interpretation,var_This);
	// type constraint is enforced by construction
	// This is exported
	// Target is exported
	neg find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_parent(problem,interpretation,_var__Child,var_This);
	neg find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_rootElements(problem,interpretation,_var__Model,var_This);
	var_virtual0 == const_Leaf_FunctionType;DefinedElement.name(const_Leaf_FunctionType,"Leaf FunctionType");  //LogicProblem.elements(problem,const_Leaf_FunctionType);
	var_Target == var_virtual0;
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunction_class(problem,interpretation,var_This);
	// type constraint is enforced by construction
	// This is exported
	// Target is exported
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_parent(problem,interpretation,var_This,_var__Par);
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_parent(problem,interpretation,_var__Child,var_This);
	var_virtual0 == const_Intermediate_FunctionType;DefinedElement.name(const_Intermediate_FunctionType,"Intermediate FunctionType");  //LogicProblem.elements(problem,const_Intermediate_FunctionType);
	var_Target == var_virtual0;
}
private pattern mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_type(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_This, var_Target)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfFunction_class(problem,interpretation,var_This);
	// type constraint is enforced by construction
	// This is exported
	// Target is exported
	find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_rootElements(problem,interpretation,_var__Model,var_This);
	var_virtual0 == const_Root_FunctionType;DefinedElement.name(const_Root_FunctionType,"Root FunctionType");  //LogicProblem.elements(problem,const_Root_FunctionType);
	find mayEquivalent(problem, interpretation, var_Target, var_virtual0);
}or{
	find interpretation(problem,interpretation);
	find mayInstanceOfFunction_class(problem,interpretation,var_This);
	// type constraint is enforced by construction
	// This is exported
	// Target is exported
	neg find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_parent(problem,interpretation,_var__Child,var_This);
	neg find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_rootElements(problem,interpretation,_var__Model,var_This);
	var_virtual0 == const_Leaf_FunctionType;DefinedElement.name(const_Leaf_FunctionType,"Leaf FunctionType");  //LogicProblem.elements(problem,const_Leaf_FunctionType);
	find mayEquivalent(problem, interpretation, var_Target, var_virtual0);
}or{
	find interpretation(problem,interpretation);
	find mayInstanceOfFunction_class(problem,interpretation,var_This);
	// type constraint is enforced by construction
	// This is exported
	// Target is exported
	find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_parent(problem,interpretation,var_This,_var__Par);
	find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_parent(problem,interpretation,_var__Child,var_This);
	var_virtual0 == const_Intermediate_FunctionType;DefinedElement.name(const_Intermediate_FunctionType,"Intermediate FunctionType");  //LogicProblem.elements(problem,const_Intermediate_FunctionType);
	find mayEquivalent(problem, interpretation, var_Target, var_virtual0);
}
private pattern currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_type(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_This, var_Target)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunction_class(problem,interpretation,var_This);
	// type constraint is enforced by construction
	// This is exported
	// Target is exported
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_rootElements(problem,interpretation,_var__Model,var_This);
	var_virtual0 == const_Root_FunctionType;DefinedElement.name(const_Root_FunctionType,"Root FunctionType");  //LogicProblem.elements(problem,const_Root_FunctionType);
	var_Target == var_virtual0;
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunction_class(problem,interpretation,var_This);
	// type constraint is enforced by construction
	// This is exported
	// Target is exported
	neg find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_parent(problem,interpretation,_var__Child,var_This);
	neg find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_rootElements(problem,interpretation,_var__Model,var_This);
	var_virtual0 == const_Leaf_FunctionType;DefinedElement.name(const_Leaf_FunctionType,"Leaf FunctionType");  //LogicProblem.elements(problem,const_Leaf_FunctionType);
	var_Target == var_virtual0;
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunction_class(problem,interpretation,var_This);
	// type constraint is enforced by construction
	// This is exported
	// Target is exported
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_parent(problem,interpretation,var_This,_var__Par);
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_parent(problem,interpretation,_var__Child,var_This);
	var_virtual0 == const_Intermediate_FunctionType;DefinedElement.name(const_Intermediate_FunctionType,"Intermediate FunctionType");  //LogicProblem.elements(problem,const_Intermediate_FunctionType);
	var_Target == var_virtual0;
}
// Must, May and Current queries for pattern ca mcgill ecse dslreasoner standalone test fam rootElements
private pattern mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_rootElements(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_Model, var_Root)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,var_Model);
	find mustInstanceOfFunction_class(problem,interpretation,var_Root);
	// Model is exported
	// Root is exported
	find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,var_Model);
	find mustInRelationrootElements_reference_FunctionalArchitectureModel(problem,interpretation,var_Model,var_virtual0);
	find mustInstanceOfFunctionalElement_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_Root;
}
private pattern mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_rootElements(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_Model, var_Root)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfFunctionalArchitectureModel_class(problem,interpretation,var_Model);
	find mayInstanceOfFunction_class(problem,interpretation,var_Root);
	// Model is exported
	// Root is exported
	find mayInstanceOfFunctionalArchitectureModel_class(problem,interpretation,var_Model);
	find mayInRelationrootElements_reference_FunctionalArchitectureModel(problem,interpretation,var_Model,var_virtual0);
	find mayInstanceOfFunctionalElement_class(problem,interpretation,var_virtual0);
	find mayEquivalent(problem, interpretation, var_virtual0, var_Root);
}
private pattern currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_rootElements(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_Model, var_Root)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,var_Model);
	find mustInstanceOfFunction_class(problem,interpretation,var_Root);
	// Model is exported
	// Root is exported
	find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,var_Model);
	find mustInRelationrootElements_reference_FunctionalArchitectureModel(problem,interpretation,var_Model,var_virtual0);
	find mustInstanceOfFunctionalElement_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_Root;
}
// Must, May and Current queries for pattern ca mcgill ecse dslreasoner standalone test fam parent
private pattern mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_parent(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_Func, var_Par)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunction_class(problem,interpretation,var_Func);
	find mustInstanceOfFunction_class(problem,interpretation,var_Par);
	// Func is exported
	// Par is exported
	find mustInstanceOfFunction_class(problem,interpretation,var_Func);
	find mustInRelationparent_reference_FunctionalElement(problem,interpretation,var_Func,var_virtual0);
	find mustInstanceOfFunction_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_Par;
}
private pattern mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_parent(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_Func, var_Par)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfFunction_class(problem,interpretation,var_Func);
	find mayInstanceOfFunction_class(problem,interpretation,var_Par);
	// Func is exported
	// Par is exported
	find mayInstanceOfFunction_class(problem,interpretation,var_Func);
	find mayInRelationparent_reference_FunctionalElement(problem,interpretation,var_Func,var_virtual0);
	find mayInstanceOfFunction_class(problem,interpretation,var_virtual0);
	find mayEquivalent(problem, interpretation, var_virtual0, var_Par);
}
private pattern currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_parent(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_Func, var_Par)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunction_class(problem,interpretation,var_Func);
	find mustInstanceOfFunction_class(problem,interpretation,var_Par);
	// Func is exported
	// Par is exported
	find mustInstanceOfFunction_class(problem,interpretation,var_Func);
	find mustInRelationparent_reference_FunctionalElement(problem,interpretation,var_Func,var_virtual0);
	find mustInstanceOfFunction_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_Par;
}
// Must, May and Current queries for pattern ca mcgill ecse dslreasoner standalone test fam model
private pattern mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_model(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_This, var_Target)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalElement_class(problem,interpretation,var_This);
	find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,var_Target);
	// This is exported
	// Target is exported
	find mustInstanceOfFunctionalElement_class(problem,interpretation,var_This);
	find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,var_Target);
}
private pattern mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_model(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_This, var_Target)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfFunctionalElement_class(problem,interpretation,var_This);
	find mayInstanceOfFunctionalArchitectureModel_class(problem,interpretation,var_Target);
	// This is exported
	// Target is exported
	find mayInstanceOfFunctionalElement_class(problem,interpretation,var_This);
	find mayInstanceOfFunctionalArchitectureModel_class(problem,interpretation,var_Target);
}
private pattern currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_model(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_This, var_Target)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalElement_class(problem,interpretation,var_This);
	find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,var_Target);
	// This is exported
	// Target is exported
	find mustInstanceOfFunctionalElement_class(problem,interpretation,var_This);
	find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,var_Target);
}

//////////
// 1.4 Containment Indexer
//////////
private pattern mustContains2(source: DefinedElement, target: DefinedElement) {
	find mustContains4(_,_,source,target);
}
	
private pattern mustContains4(problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target: DefinedElement)
	{ find mustInRelationinterface_reference_FunctionalElement(problem,interpretation,source,target); }or
	
	{ find mustInRelationrootElements_reference_FunctionalArchitectureModel(problem,interpretation,source,target); }or
	
	{ find mustInRelationsubElements_reference_Function(problem,interpretation,source,target); }or
	
	{ find mustInRelationdata_reference_FunctionalInterface(problem,interpretation,source,target); }or
	
	{ find mustInRelationoutgoingLinks_reference_FunctionalOutput(problem,interpretation,source,target); }or
	
	{ find mustInRelationterminator_reference_FunctionalData(problem,interpretation,source,target); }

private pattern mustTransitiveContains(source,target) {
	find mustContains2+(source,target);
}

//////////
// 2. Invalidation Indexers
//////////
// 2.1 Invalidated by WF Queries
//////////
pattern invalidatedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_terminatorAndInformation(problem:LogicProblem, interpretation:PartialInterpretation,
	var_T, var_I)
{
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_terminatorAndInformation(problem,interpretation,var_T,var_I);
}

//////////
// 3. Unfinishedness Indexers
//////////
// 3.1 Unfinishedness Measured by Multiplicity
//////////
pattern unfinishedLowerMultiplicity_to_reference_InformationLink(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"to reference InformationLink");
	find mustInstanceOfInformationLink_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationto_reference_InformationLink(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}

//////////
// 3.2 Unfinishedness Measured by WF Queries
//////////
pattern unfinishedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_terminatorAndInformation(problem:LogicProblem, interpretation:PartialInterpretation,
	var_T, var_I)
{
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_fam_terminatorAndInformation(problem,interpretation,var_T,var_I);
}

//////////
// 4. Refinement Indexers
//////////
// 4.1 Object constructors
//////////
private pattern hasElementInContainment(problem:LogicProblem, interpretation:PartialInterpretation)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunction_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFAMTerminator_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalOutput_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalData_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalInput_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfInformationLink_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalInterface_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalElement_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalArchitectureModel_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}
pattern createObject_FunctionalInterface_class_by_interface_reference_FunctionalElement_with_element_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalInterface class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"interface reference FunctionalElement");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"element reference FunctionalInterface");
	find mustInstanceOfFunctionalElement_class(problem,interpretation,container);
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,newObject);
	find mayInRelationinterface_reference_FunctionalElement(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalInterface_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalInterface class");
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Function_class_by_rootElements_reference_FunctionalArchitectureModel(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Function class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"rootElements reference FunctionalArchitectureModel");
	find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,container);
	find mayInstanceOfFunction_class(problem,interpretation,newObject);
	find mayInRelationrootElements_reference_FunctionalArchitectureModel(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Function_class_by_subElements_reference_Function_with_parent_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Function class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"subElements reference Function");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"parent reference FunctionalElement");
	find mustInstanceOfFunction_class(problem,interpretation,container);
	find mayInstanceOfFunction_class(problem,interpretation,newObject);
	find mayInRelationsubElements_reference_Function(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Function_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Function class");
	find mayInstanceOfFunction_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FAMTerminator_class_by_terminator_reference_FunctionalData_with_data_reference_FAMTerminator(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FAMTerminator class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"terminator reference FunctionalData");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"data reference FAMTerminator");
	find mustInstanceOfFunctionalData_class(problem,interpretation,container);
	find mayInstanceOfFAMTerminator_class(problem,interpretation,newObject);
	find mayInRelationterminator_reference_FunctionalData(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FAMTerminator_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FAMTerminator class");
	find mayInstanceOfFAMTerminator_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalArchitectureModel_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalArchitectureModel class UndefinedPart");
	find mayInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_InformationLink_class_by_outgoingLinks_reference_FunctionalOutput_with_from_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"InformationLink class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"outgoingLinks reference FunctionalOutput");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"from reference InformationLink");
	find mustInstanceOfFunctionalOutput_class(problem,interpretation,container);
	find mayInstanceOfInformationLink_class(problem,interpretation,newObject);
	find mayInRelationoutgoingLinks_reference_FunctionalOutput(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_InformationLink_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"InformationLink class");
	find mayInstanceOfInformationLink_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalOutput_class_by_data_reference_FunctionalInterface_with_interface_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalOutput class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"data reference FunctionalInterface");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"interface reference FunctionalData");
	find mustInstanceOfFunctionalInterface_class(problem,interpretation,container);
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,newObject);
	find mayInRelationdata_reference_FunctionalInterface(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalOutput_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalOutput class");
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalInput_class_by_data_reference_FunctionalInterface_with_interface_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalInput class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"data reference FunctionalInterface");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"interface reference FunctionalData");
	find mustInstanceOfFunctionalInterface_class(problem,interpretation,container);
	find mayInstanceOfFunctionalInput_class(problem,interpretation,newObject);
	find mayInRelationdata_reference_FunctionalInterface(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalInput_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalInput class");
	find mayInstanceOfFunctionalInput_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}

//////////
// 4.2 Type refinement
//////////
pattern refineTypeTo_FunctionalInterface_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
}
pattern refineTypeTo_Function_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunction_class(problem,interpretation,element);
	neg find mustInstanceOfFunction_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
}
pattern refineTypeTo_FAMTerminator_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
}
pattern refineTypeTo_FunctionalArchitectureModel_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
}
pattern refineTypeTo_InformationLink_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
}
pattern refineTypeTo_FunctionalOutput_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
}
pattern refineTypeTo_FunctionalInput_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
}

//////////
// 4.3 Relation refinement
//////////
pattern refineRelation_model_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"model reference FunctionalElement");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFunctionalElement_class(problem,interpretation,from);
	find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,to);
	find mayInRelationmodel_reference_FunctionalElement(problem,interpretation,from,to);
	neg find mustInRelationmodel_reference_FunctionalElement(problem,interpretation,from,to);
}
pattern refineRelation_IncomingLinks_reference_FunctionalInput_and_to_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation, oppositeInterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"IncomingLinks reference FunctionalInput");
	PartialInterpretation.partialrelationinterpretation(interpretation,oppositeInterpretation);
	PartialRelationInterpretation.interpretationOf.name(oppositeInterpretation,"to reference InformationLink");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFunctionalInput_class(problem,interpretation,from);
	find mustInstanceOfInformationLink_class(problem,interpretation,to);
	find mayInRelationIncomingLinks_reference_FunctionalInput(problem,interpretation,from,to);
	neg find mustInRelationIncomingLinks_reference_FunctionalInput(problem,interpretation,from,to);
}
pattern refineRelation_type_attribute_Function(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"type attribute Function");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFunction_class(problem,interpretation,from);
	find mustInstanceOfFunctionType_enum(problem,interpretation,to);
	find mayInRelationtype_attribute_Function(problem,interpretation,from,to);
	neg find mustInRelationtype_attribute_Function(problem,interpretation,from,to);
}
import epackage "http://www.bme.hu/mit/inf/dslreasoner/viatrasolver/partialinterpretationlanguage"
import epackage "http://www.bme.hu/mit/inf/dslreasoner/logic/model/problem"
import epackage "http://www.bme.hu/mit/inf/dslreasoner/logic/model/language"

//////////
// 0. Util
//////////
private pattern interpretation(problem:LogicProblem, interpretation:PartialInterpretation) {
	PartialInterpretation.problem(interpretation,problem);
}
	
/////////////////////////
// 0.1 Existence
/////////////////////////
private pattern mustExist(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	find interpretation(problem,interpretation);
	LogicProblem.elements(problem,element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
}

private pattern mayExist(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
    find mustExist(problem,interpretation,element);
} or {
    find interpretation(problem,interpretation);
    neg find elementCloseWorld(element);
    PartialInterpretation.openWorldElements(interpretation,element);
}

private pattern elementCloseWorld(element:DefinedElement) {
	PartialInterpretation.openWorldElements(i,element);
    PartialInterpretation.maxNewElements(i,0);
} or {
	Scope.targetTypeInterpretation(scope,interpretation);
	PartialTypeInterpratation.elements(interpretation,element);
	Scope.maxNewElements(scope,0);
}

////////////////////////
// 0.2 Equivalence
////////////////////////
pattern mayEquivalent(problem:LogicProblem, interpretation:PartialInterpretation, a: DefinedElement, b: DefinedElement) {
	find mayExist(problem,interpretation,a);
	find mayExist(problem,interpretation,b);
	a == b;
}

////////////////////////
// 0.3 Required Patterns by TypeIndexer
////////////////////////
private pattern typeInterpretation(problem:LogicProblem, interpretation:PartialInterpretation, type:TypeDeclaration, typeInterpretation:PartialComplexTypeInterpretation) {
	find interpretation(problem,interpretation);
	LogicProblem.types(problem,type);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
}

private pattern directInstanceOf(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement, type:Type) {
	find interpretation(problem,interpretation);
	LogicProblem.types(problem,type);
	TypeDefinition.elements(type,element);
} or {
	find interpretation(problem,interpretation);
	find typeInterpretation(problem,interpretation,type,typeInterpretation);
	PartialComplexTypeInterpretation.elements(typeInterpretation,element);
}

private pattern isPrimitive(element: PrimitiveElement) {
	PrimitiveElement(element);
}

//////////
// 1. Problem-Specific Base Indexers
//////////
// 1.1 Type Indexers
//////////
// 1.1.1 primitive Type Indexers
//////////

//////////
// 1.1.2 domain-specific Type Indexers
//////////
/**
 * An element must be an instance of type "FunctionalElement class".
 */
private pattern mustInstanceOfFunctionalElement_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalElement class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalElement_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalElement class");
}

/**
 * An element may be an instance of type "FunctionalElement class".
 */
private pattern mayInstanceOfFunctionalElement_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunction_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalElement_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunction_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalElement_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalElement_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalArchitectureModel class".
 */
private pattern mustInstanceOfFunctionalArchitectureModel_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalArchitectureModel class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalArchitectureModel_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalArchitectureModel class");
}

/**
 * An element may be an instance of type "FunctionalArchitectureModel class".
 */
private pattern mayInstanceOfFunctionalArchitectureModel_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalArchitectureModel_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalArchitectureModel_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Function class".
 */
private pattern mustInstanceOfFunction_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Function class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunction_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Function class");
}

/**
 * An element may be an instance of type "Function class".
 */
private pattern mayInstanceOfFunction_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunction_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunction_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunction_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FAMTerminator class".
 */
private pattern mustInstanceOfFAMTerminator_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FAMTerminator class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFAMTerminator_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FAMTerminator class");
}

/**
 * An element may be an instance of type "FAMTerminator class".
 */
private pattern mayInstanceOfFAMTerminator_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find scopeDisallowsNewFAMTerminator_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find scopeDisallowsNewFAMTerminator_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFAMTerminator_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "InformationLink class".
 */
private pattern mustInstanceOfInformationLink_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"InformationLink class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewInformationLink_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"InformationLink class");
}

/**
 * An element may be an instance of type "InformationLink class".
 */
private pattern mayInstanceOfInformationLink_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find scopeDisallowsNewInformationLink_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find scopeDisallowsNewInformationLink_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfInformationLink_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalInterface class".
 */
private pattern mustInstanceOfFunctionalInterface_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalInterface class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalInterface_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalInterface class");
}

/**
 * An element may be an instance of type "FunctionalInterface class".
 */
private pattern mayInstanceOfFunctionalInterface_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalInterface_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalInterface_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalInterface_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalInput class".
 */
private pattern mustInstanceOfFunctionalInput_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalInput class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalInput_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalInput class");
}

/**
 * An element may be an instance of type "FunctionalInput class".
 */
private pattern mayInstanceOfFunctionalInput_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalInput_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalInput_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalInput_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalOutput class".
 */
private pattern mustInstanceOfFunctionalOutput_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalOutput class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalOutput_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalOutput class");
}

/**
 * An element may be an instance of type "FunctionalOutput class".
 */
private pattern mayInstanceOfFunctionalOutput_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalOutput_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalOutput_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalOutput_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalData class".
 */
private pattern mustInstanceOfFunctionalData_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalData class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalData_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalData class");
}

/**
 * An element may be an instance of type "FunctionalData class".
 */
private pattern mayInstanceOfFunctionalData_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalData_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalData_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalData_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionType enum".
 */
private pattern mustInstanceOfFunctionType_enum(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionType enum");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionType_enum(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionType enum");
}

/**
 * An element may be an instance of type "FunctionType enum".
 */
private pattern mayInstanceOfFunctionType_enum(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfFunctionType_enum(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalArchitectureModel class DefinedPart".
 */
private pattern mustInstanceOfFunctionalArchitectureModel_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalArchitectureModel class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalArchitectureModel_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalArchitectureModel class DefinedPart");
}

/**
 * An element may be an instance of type "FunctionalArchitectureModel class DefinedPart".
 */
private pattern mayInstanceOfFunctionalArchitectureModel_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfFunctionalArchitectureModel_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalArchitectureModel class UndefinedPart".
 */
private pattern mustInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalArchitectureModel class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalArchitectureModel_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalArchitectureModel class UndefinedPart");
}

/**
 * An element may be an instance of type "FunctionalArchitectureModel class UndefinedPart".
 */
private pattern mayInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalArchitectureModel_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalArchitectureModel_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem,interpretation,element); }

//////////
// 1.2 Relation Declaration Indexers
//////////
/**
 * Matcher for detecting tuples t where []interface reference FunctionalElement(source,target)
 */
private pattern mustInRelationinterface_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"interface reference FunctionalElement");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>interface reference FunctionalElement(source,target)
 */
private pattern mayInRelationinterface_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalElement_class(problem,interpretation,source);
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationinterface_reference_FunctionalElement(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationelement_reference_FunctionalInterface(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationinterface_reference_FunctionalElement(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []model reference FunctionalElement(source,target)
 */
 private pattern mustInRelationmodel_reference_FunctionalElement(
 	problem:LogicProblem, interpretation:PartialInterpretation,
 	source: DefinedElement, target:DefinedElement)
 {
 	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_xyz_model(problem,interpretation,source,target);
 }
/**
 * Matcher for detecting tuples t where []model reference FunctionalElement(source,target)
 */
 private pattern mayInRelationmodel_reference_FunctionalElement(
 	problem:LogicProblem, interpretation:PartialInterpretation,
 	source: DefinedElement, target:DefinedElement)
 {
 	find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_xyz_model(problem,interpretation,source,target);
 }
/**
 * Matcher for detecting tuples t where []parent reference FunctionalElement(source,target)
 */
private pattern mustInRelationparent_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"parent reference FunctionalElement");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>parent reference FunctionalElement(source,target)
 */
private pattern mayInRelationparent_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalElement_class(problem,interpretation,source);
	find mayInstanceOfFunction_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationparent_reference_FunctionalElement(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationparent_reference_FunctionalElement(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []rootElements reference FunctionalArchitectureModel(source,target)
 */
private pattern mustInRelationrootElements_reference_FunctionalArchitectureModel(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"rootElements reference FunctionalArchitectureModel");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>rootElements reference FunctionalArchitectureModel(source,target)
 */
private pattern mayInRelationrootElements_reference_FunctionalArchitectureModel(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalArchitectureModel_class(problem,interpretation,source);
	find mayInstanceOfFunctionalElement_class(problem,interpretation,target);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationrootElements_reference_FunctionalArchitectureModel(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []subElements reference Function(source,target)
 */
private pattern mustInRelationsubElements_reference_Function(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"subElements reference Function");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>subElements reference Function(source,target)
 */
private pattern mayInRelationsubElements_reference_Function(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunction_class(problem,interpretation,source);
	find mayInstanceOfFunctionalElement_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationparent_reference_FunctionalElement(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationsubElements_reference_Function(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []data reference FAMTerminator(source,target)
 */
private pattern mustInRelationdata_reference_FAMTerminator(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"data reference FAMTerminator");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>data reference FAMTerminator(source,target)
 */
private pattern mayInRelationdata_reference_FAMTerminator(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFAMTerminator_class(problem,interpretation,source);
	find mayInstanceOfFunctionalData_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationdata_reference_FAMTerminator(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationterminator_reference_FunctionalData(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationdata_reference_FAMTerminator(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []from reference InformationLink(source,target)
 */
private pattern mustInRelationfrom_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"from reference InformationLink");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>from reference InformationLink(source,target)
 */
private pattern mayInRelationfrom_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfInformationLink_class(problem,interpretation,source);
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationfrom_reference_InformationLink(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationfrom_reference_InformationLink(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []to reference InformationLink(source,target)
 */
private pattern mustInRelationto_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"to reference InformationLink");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>to reference InformationLink(source,target)
 */
private pattern mayInRelationto_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfInformationLink_class(problem,interpretation,source);
	find mayInstanceOfFunctionalInput_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationto_reference_InformationLink(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationto_reference_InformationLink(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []data reference FunctionalInterface(source,target)
 */
private pattern mustInRelationdata_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"data reference FunctionalInterface");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>data reference FunctionalInterface(source,target)
 */
private pattern mayInRelationdata_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,source);
	find mayInstanceOfFunctionalData_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationinterface_reference_FunctionalData(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationdata_reference_FunctionalInterface(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []element reference FunctionalInterface(source,target)
 */
private pattern mustInRelationelement_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"element reference FunctionalInterface");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>element reference FunctionalInterface(source,target)
 */
private pattern mayInRelationelement_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,source);
	find mayInstanceOfFunctionalElement_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationelement_reference_FunctionalInterface(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationinterface_reference_FunctionalElement(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationelement_reference_FunctionalInterface(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []IncomingLinks reference FunctionalInput(source,target)
 */
private pattern mustInRelationIncomingLinks_reference_FunctionalInput(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"IncomingLinks reference FunctionalInput");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>IncomingLinks reference FunctionalInput(source,target)
 */
private pattern mayInRelationIncomingLinks_reference_FunctionalInput(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalInput_class(problem,interpretation,source);
	find mayInstanceOfInformationLink_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationto_reference_InformationLink(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
} or {
	find mustInRelationIncomingLinks_reference_FunctionalInput(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []outgoingLinks reference FunctionalOutput(source,target)
 */
private pattern mustInRelationoutgoingLinks_reference_FunctionalOutput(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"outgoingLinks reference FunctionalOutput");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>outgoingLinks reference FunctionalOutput(source,target)
 */
private pattern mayInRelationoutgoingLinks_reference_FunctionalOutput(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,source);
	find mayInstanceOfInformationLink_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationfrom_reference_InformationLink(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationoutgoingLinks_reference_FunctionalOutput(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []terminator reference FunctionalData(source,target)
 */
private pattern mustInRelationterminator_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"terminator reference FunctionalData");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>terminator reference FunctionalData(source,target)
 */
private pattern mayInRelationterminator_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalData_class(problem,interpretation,source);
	find mayInstanceOfFAMTerminator_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationterminator_reference_FunctionalData(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationdata_reference_FAMTerminator(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationterminator_reference_FunctionalData(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []interface reference FunctionalData(source,target)
 */
private pattern mustInRelationinterface_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"interface reference FunctionalData");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>interface reference FunctionalData(source,target)
 */
private pattern mayInRelationinterface_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalData_class(problem,interpretation,source);
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationinterface_reference_FunctionalData(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationinterface_reference_FunctionalData(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []type attribute Function(source,target)
 */
 private pattern mustInRelationtype_attribute_Function(
 	problem:LogicProblem, interpretation:PartialInterpretation,
 	source: DefinedElement, target:DefinedElement)
 {
 	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_xyz_type(problem,interpretation,source,target);
 }
/**
 * Matcher for detecting tuples t where []type attribute Function(source,target)
 */
 private pattern mayInRelationtype_attribute_Function(
 	problem:LogicProblem, interpretation:PartialInterpretation,
 	source: DefinedElement, target:DefinedElement)
 {
 	find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_xyz_type(problem,interpretation,source,target);
 }

//////////
// 1.3 Relation Definition Indexers
//////////
// Must, May and Current queries for pattern ca mcgill ecse dslreasoner standalone test xyz terminatorAndInformation
private pattern mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_xyz_terminatorAndInformation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_T, var_I)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfFAMTerminator_class(problem,interpretation,var_T);
	find mustInstanceOfInformationLink_class(problem,interpretation,var_I);
	// T is exported
	// I is exported
	find mustInstanceOfFunctionalOutput_class(problem,interpretation,var_Out);
	find mustInRelationoutgoingLinks_reference_FunctionalOutput(problem,interpretation,var_Out,var_virtual0);
	find mustInstanceOfInformationLink_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_I;
	find mustInstanceOfFunctionalOutput_class(problem,interpretation,var_Out);
	find mustInRelationterminator_reference_FunctionalData(problem,interpretation,var_Out,var_virtual1);
	find mustInstanceOfFAMTerminator_class(problem,interpretation,var_virtual1);
	var_virtual1 == var_T;
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFAMTerminator_class(problem,interpretation,var_T);
	find mustInstanceOfInformationLink_class(problem,interpretation,var_I);
	// T is exported
	// I is exported
	find mustInstanceOfInformationLink_class(problem,interpretation,var_I);
	find mustInRelationto_reference_InformationLink(problem,interpretation,var_I,var_virtual0);
	find mustInstanceOfFunctionalInput_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_In;
	find mustInstanceOfFunctionalInput_class(problem,interpretation,var_In);
	find mustInRelationterminator_reference_FunctionalData(problem,interpretation,var_In,var_virtual1);
	find mustInstanceOfFAMTerminator_class(problem,interpretation,var_virtual1);
	var_virtual1 == var_T;
}
private pattern mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_xyz_terminatorAndInformation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_T, var_I)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfFAMTerminator_class(problem,interpretation,var_T);
	find mayInstanceOfInformationLink_class(problem,interpretation,var_I);
	// T is exported
	// I is exported
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,var_Out);
	find mayInRelationoutgoingLinks_reference_FunctionalOutput(problem,interpretation,var_Out,var_virtual0);
	find mayInstanceOfInformationLink_class(problem,interpretation,var_virtual0);
	find mayEquivalent(problem, interpretation, var_virtual0, var_I);
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,var_Out);
	find mayInRelationterminator_reference_FunctionalData(problem,interpretation,var_Out,var_virtual1);
	find mayInstanceOfFAMTerminator_class(problem,interpretation,var_virtual1);
	find mayEquivalent(problem, interpretation, var_virtual1, var_T);
}or{
	find interpretation(problem,interpretation);
	find mayInstanceOfFAMTerminator_class(problem,interpretation,var_T);
	find mayInstanceOfInformationLink_class(problem,interpretation,var_I);
	// T is exported
	// I is exported
	find mayInstanceOfInformationLink_class(problem,interpretation,var_I);
	find mayInRelationto_reference_InformationLink(problem,interpretation,var_I,var_virtual0);
	find mayInstanceOfFunctionalInput_class(problem,interpretation,var_virtual0);
	find mayEquivalent(problem, interpretation, var_virtual0, var_In);
	find mayInstanceOfFunctionalInput_class(problem,interpretation,var_In);
	find mayInRelationterminator_reference_FunctionalData(problem,interpretation,var_In,var_virtual1);
	find mayInstanceOfFAMTerminator_class(problem,interpretation,var_virtual1);
	find mayEquivalent(problem, interpretation, var_virtual1, var_T);
}
private pattern currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_xyz_terminatorAndInformation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_T, var_I)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfFAMTerminator_class(problem,interpretation,var_T);
	find mustInstanceOfInformationLink_class(problem,interpretation,var_I);
	// T is exported
	// I is exported
	find mustInstanceOfFunctionalOutput_class(problem,interpretation,var_Out);
	find mustInRelationoutgoingLinks_reference_FunctionalOutput(problem,interpretation,var_Out,var_virtual0);
	find mustInstanceOfInformationLink_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_I;
	find mustInstanceOfFunctionalOutput_class(problem,interpretation,var_Out);
	find mustInRelationterminator_reference_FunctionalData(problem,interpretation,var_Out,var_virtual1);
	find mustInstanceOfFAMTerminator_class(problem,interpretation,var_virtual1);
	var_virtual1 == var_T;
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFAMTerminator_class(problem,interpretation,var_T);
	find mustInstanceOfInformationLink_class(problem,interpretation,var_I);
	// T is exported
	// I is exported
	find mustInstanceOfInformationLink_class(problem,interpretation,var_I);
	find mustInRelationto_reference_InformationLink(problem,interpretation,var_I,var_virtual0);
	find mustInstanceOfFunctionalInput_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_In;
	find mustInstanceOfFunctionalInput_class(problem,interpretation,var_In);
	find mustInRelationterminator_reference_FunctionalData(problem,interpretation,var_In,var_virtual1);
	find mustInstanceOfFAMTerminator_class(problem,interpretation,var_virtual1);
	var_virtual1 == var_T;
}
// Must, May and Current queries for pattern ca mcgill ecse dslreasoner standalone test xyz type
private pattern mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_xyz_type(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_This, var_Target)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunction_class(problem,interpretation,var_This);
	// type constraint is enforced by construction
	// This is exported
	// Target is exported
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_xyz_rootElements(problem,interpretation,_var__Model,var_This);
	var_virtual0 == const_Root_FunctionType;DefinedElement.name(const_Root_FunctionType,"Root FunctionType");  //LogicProblem.elements(problem,const_Root_FunctionType);
	var_Target == var_virtual0;
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunction_class(problem,interpretation,var_This);
	// type constraint is enforced by construction
	// This is exported
	// Target is exported
	neg find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_xyz_parent(problem,interpretation,_var__Child,var_This);
	neg find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_xyz_rootElements(problem,interpretation,_var__Model,var_This);
	var_virtual0 == const_Leaf_FunctionType;DefinedElement.name(const_Leaf_FunctionType,"Leaf FunctionType");  //LogicProblem.elements(problem,const_Leaf_FunctionType);
	var_Target == var_virtual0;
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunction_class(problem,interpretation,var_This);
	// type constraint is enforced by construction
	// This is exported
	// Target is exported
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_xyz_parent(problem,interpretation,var_This,_var__Par);
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_xyz_parent(problem,interpretation,_var__Child,var_This);
	var_virtual0 == const_Intermediate_FunctionType;DefinedElement.name(const_Intermediate_FunctionType,"Intermediate FunctionType");  //LogicProblem.elements(problem,const_Intermediate_FunctionType);
	var_Target == var_virtual0;
}
private pattern mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_xyz_type(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_This, var_Target)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfFunction_class(problem,interpretation,var_This);
	// type constraint is enforced by construction
	// This is exported
	// Target is exported
	find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_xyz_rootElements(problem,interpretation,_var__Model,var_This);
	var_virtual0 == const_Root_FunctionType;DefinedElement.name(const_Root_FunctionType,"Root FunctionType");  //LogicProblem.elements(problem,const_Root_FunctionType);
	find mayEquivalent(problem, interpretation, var_Target, var_virtual0);
}or{
	find interpretation(problem,interpretation);
	find mayInstanceOfFunction_class(problem,interpretation,var_This);
	// type constraint is enforced by construction
	// This is exported
	// Target is exported
	neg find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_xyz_parent(problem,interpretation,_var__Child,var_This);
	neg find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_xyz_rootElements(problem,interpretation,_var__Model,var_This);
	var_virtual0 == const_Leaf_FunctionType;DefinedElement.name(const_Leaf_FunctionType,"Leaf FunctionType");  //LogicProblem.elements(problem,const_Leaf_FunctionType);
	find mayEquivalent(problem, interpretation, var_Target, var_virtual0);
}or{
	find interpretation(problem,interpretation);
	find mayInstanceOfFunction_class(problem,interpretation,var_This);
	// type constraint is enforced by construction
	// This is exported
	// Target is exported
	find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_xyz_parent(problem,interpretation,var_This,_var__Par);
	find mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_xyz_parent(problem,interpretation,_var__Child,var_This);
	var_virtual0 == const_Intermediate_FunctionType;DefinedElement.name(const_Intermediate_FunctionType,"Intermediate FunctionType");  //LogicProblem.elements(problem,const_Intermediate_FunctionType);
	find mayEquivalent(problem, interpretation, var_Target, var_virtual0);
}
private pattern currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_xyz_type(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_This, var_Target)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunction_class(problem,interpretation,var_This);
	// type constraint is enforced by construction
	// This is exported
	// Target is exported
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_xyz_rootElements(problem,interpretation,_var__Model,var_This);
	var_virtual0 == const_Root_FunctionType;DefinedElement.name(const_Root_FunctionType,"Root FunctionType");  //LogicProblem.elements(problem,const_Root_FunctionType);
	var_Target == var_virtual0;
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunction_class(problem,interpretation,var_This);
	// type constraint is enforced by construction
	// This is exported
	// Target is exported
	neg find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_xyz_parent(problem,interpretation,_var__Child,var_This);
	neg find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_xyz_rootElements(problem,interpretation,_var__Model,var_This);
	var_virtual0 == const_Leaf_FunctionType;DefinedElement.name(const_Leaf_FunctionType,"Leaf FunctionType");  //LogicProblem.elements(problem,const_Leaf_FunctionType);
	var_Target == var_virtual0;
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunction_class(problem,interpretation,var_This);
	// type constraint is enforced by construction
	// This is exported
	// Target is exported
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_xyz_parent(problem,interpretation,var_This,_var__Par);
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_xyz_parent(problem,interpretation,_var__Child,var_This);
	var_virtual0 == const_Intermediate_FunctionType;DefinedElement.name(const_Intermediate_FunctionType,"Intermediate FunctionType");  //LogicProblem.elements(problem,const_Intermediate_FunctionType);
	var_Target == var_virtual0;
}
// Must, May and Current queries for pattern ca mcgill ecse dslreasoner standalone test xyz rootElements
private pattern mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_xyz_rootElements(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_Model, var_Root)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,var_Model);
	find mustInstanceOfFunction_class(problem,interpretation,var_Root);
	// Model is exported
	// Root is exported
	find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,var_Model);
	find mustInRelationrootElements_reference_FunctionalArchitectureModel(problem,interpretation,var_Model,var_virtual0);
	find mustInstanceOfFunctionalElement_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_Root;
}
private pattern mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_xyz_rootElements(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_Model, var_Root)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfFunctionalArchitectureModel_class(problem,interpretation,var_Model);
	find mayInstanceOfFunction_class(problem,interpretation,var_Root);
	// Model is exported
	// Root is exported
	find mayInstanceOfFunctionalArchitectureModel_class(problem,interpretation,var_Model);
	find mayInRelationrootElements_reference_FunctionalArchitectureModel(problem,interpretation,var_Model,var_virtual0);
	find mayInstanceOfFunctionalElement_class(problem,interpretation,var_virtual0);
	find mayEquivalent(problem, interpretation, var_virtual0, var_Root);
}
private pattern currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_xyz_rootElements(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_Model, var_Root)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,var_Model);
	find mustInstanceOfFunction_class(problem,interpretation,var_Root);
	// Model is exported
	// Root is exported
	find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,var_Model);
	find mustInRelationrootElements_reference_FunctionalArchitectureModel(problem,interpretation,var_Model,var_virtual0);
	find mustInstanceOfFunctionalElement_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_Root;
}
// Must, May and Current queries for pattern ca mcgill ecse dslreasoner standalone test xyz parent
private pattern mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_xyz_parent(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_Func, var_Par)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunction_class(problem,interpretation,var_Func);
	find mustInstanceOfFunction_class(problem,interpretation,var_Par);
	// Func is exported
	// Par is exported
	find mustInstanceOfFunction_class(problem,interpretation,var_Func);
	find mustInRelationparent_reference_FunctionalElement(problem,interpretation,var_Func,var_virtual0);
	find mustInstanceOfFunction_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_Par;
}
private pattern mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_xyz_parent(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_Func, var_Par)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfFunction_class(problem,interpretation,var_Func);
	find mayInstanceOfFunction_class(problem,interpretation,var_Par);
	// Func is exported
	// Par is exported
	find mayInstanceOfFunction_class(problem,interpretation,var_Func);
	find mayInRelationparent_reference_FunctionalElement(problem,interpretation,var_Func,var_virtual0);
	find mayInstanceOfFunction_class(problem,interpretation,var_virtual0);
	find mayEquivalent(problem, interpretation, var_virtual0, var_Par);
}
private pattern currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_xyz_parent(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_Func, var_Par)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunction_class(problem,interpretation,var_Func);
	find mustInstanceOfFunction_class(problem,interpretation,var_Par);
	// Func is exported
	// Par is exported
	find mustInstanceOfFunction_class(problem,interpretation,var_Func);
	find mustInRelationparent_reference_FunctionalElement(problem,interpretation,var_Func,var_virtual0);
	find mustInstanceOfFunction_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_Par;
}
// Must, May and Current queries for pattern ca mcgill ecse dslreasoner standalone test xyz model
private pattern mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_xyz_model(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_This, var_Target)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalElement_class(problem,interpretation,var_This);
	find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,var_Target);
	// This is exported
	// Target is exported
	find mustInstanceOfFunctionalElement_class(problem,interpretation,var_This);
	find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,var_Target);
}
private pattern mayInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_xyz_model(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_This, var_Target)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfFunctionalElement_class(problem,interpretation,var_This);
	find mayInstanceOfFunctionalArchitectureModel_class(problem,interpretation,var_Target);
	// This is exported
	// Target is exported
	find mayInstanceOfFunctionalElement_class(problem,interpretation,var_This);
	find mayInstanceOfFunctionalArchitectureModel_class(problem,interpretation,var_Target);
}
private pattern currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_xyz_model(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_This, var_Target)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalElement_class(problem,interpretation,var_This);
	find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,var_Target);
	// This is exported
	// Target is exported
	find mustInstanceOfFunctionalElement_class(problem,interpretation,var_This);
	find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,var_Target);
}

//////////
// 1.4 Containment Indexer
//////////
private pattern mustContains2(source: DefinedElement, target: DefinedElement) {
	find mustContains4(_,_,source,target);
}
	
private pattern mustContains4(problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target: DefinedElement)
	{ find mustInRelationinterface_reference_FunctionalElement(problem,interpretation,source,target); }or
	
	{ find mustInRelationrootElements_reference_FunctionalArchitectureModel(problem,interpretation,source,target); }or
	
	{ find mustInRelationsubElements_reference_Function(problem,interpretation,source,target); }or
	
	{ find mustInRelationdata_reference_FunctionalInterface(problem,interpretation,source,target); }or
	
	{ find mustInRelationoutgoingLinks_reference_FunctionalOutput(problem,interpretation,source,target); }or
	
	{ find mustInRelationterminator_reference_FunctionalData(problem,interpretation,source,target); }

private pattern mustTransitiveContains(source,target) {
	find mustContains2+(source,target);
}

//////////
// 2. Invalidation Indexers
//////////
// 2.1 Invalidated by WF Queries
//////////
pattern invalidatedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_xyz_terminatorAndInformation(problem:LogicProblem, interpretation:PartialInterpretation,
	var_T, var_I)
{
	find mustInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_xyz_terminatorAndInformation(problem,interpretation,var_T,var_I);
}

//////////
// 3. Unfinishedness Indexers
//////////
// 3.1 Unfinishedness Measured by Multiplicity
//////////
pattern unfinishedLowerMultiplicity_to_reference_InformationLink(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"to reference InformationLink");
	find mustInstanceOfInformationLink_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationto_reference_InformationLink(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}

//////////
// 3.2 Unfinishedness Measured by WF Queries
//////////
pattern unfinishedBy_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_xyz_terminatorAndInformation(problem:LogicProblem, interpretation:PartialInterpretation,
	var_T, var_I)
{
	find currentInRelation_pattern_ca_mcgill_ecse_dslreasoner_standalone_test_xyz_terminatorAndInformation(problem,interpretation,var_T,var_I);
}

//////////
// 4. Refinement Indexers
//////////
// 4.1 Object constructors
//////////
private pattern hasElementInContainment(problem:LogicProblem, interpretation:PartialInterpretation)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalInterface_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalData_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfInformationLink_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunction_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFAMTerminator_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalElement_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalOutput_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalInput_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalArchitectureModel_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}
pattern createObject_FunctionalArchitectureModel_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalArchitectureModel class UndefinedPart");
	find mayInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Function_class_by_rootElements_reference_FunctionalArchitectureModel(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Function class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"rootElements reference FunctionalArchitectureModel");
	find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,container);
	find mayInstanceOfFunction_class(problem,interpretation,newObject);
	find mayInRelationrootElements_reference_FunctionalArchitectureModel(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Function_class_by_subElements_reference_Function_with_parent_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Function class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"subElements reference Function");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"parent reference FunctionalElement");
	find mustInstanceOfFunction_class(problem,interpretation,container);
	find mayInstanceOfFunction_class(problem,interpretation,newObject);
	find mayInRelationsubElements_reference_Function(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Function_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Function class");
	find mayInstanceOfFunction_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_InformationLink_class_by_outgoingLinks_reference_FunctionalOutput_with_from_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"InformationLink class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"outgoingLinks reference FunctionalOutput");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"from reference InformationLink");
	find mustInstanceOfFunctionalOutput_class(problem,interpretation,container);
	find mayInstanceOfInformationLink_class(problem,interpretation,newObject);
	find mayInRelationoutgoingLinks_reference_FunctionalOutput(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_InformationLink_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"InformationLink class");
	find mayInstanceOfInformationLink_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalOutput_class_by_data_reference_FunctionalInterface_with_interface_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalOutput class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"data reference FunctionalInterface");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"interface reference FunctionalData");
	find mustInstanceOfFunctionalInterface_class(problem,interpretation,container);
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,newObject);
	find mayInRelationdata_reference_FunctionalInterface(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalOutput_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalOutput class");
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FAMTerminator_class_by_terminator_reference_FunctionalData_with_data_reference_FAMTerminator(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FAMTerminator class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"terminator reference FunctionalData");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"data reference FAMTerminator");
	find mustInstanceOfFunctionalData_class(problem,interpretation,container);
	find mayInstanceOfFAMTerminator_class(problem,interpretation,newObject);
	find mayInRelationterminator_reference_FunctionalData(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FAMTerminator_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FAMTerminator class");
	find mayInstanceOfFAMTerminator_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalInterface_class_by_interface_reference_FunctionalElement_with_element_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalInterface class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"interface reference FunctionalElement");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"element reference FunctionalInterface");
	find mustInstanceOfFunctionalElement_class(problem,interpretation,container);
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,newObject);
	find mayInRelationinterface_reference_FunctionalElement(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalInterface_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalInterface class");
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalInput_class_by_data_reference_FunctionalInterface_with_interface_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalInput class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"data reference FunctionalInterface");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"interface reference FunctionalData");
	find mustInstanceOfFunctionalInterface_class(problem,interpretation,container);
	find mayInstanceOfFunctionalInput_class(problem,interpretation,newObject);
	find mayInRelationdata_reference_FunctionalInterface(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalInput_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalInput class");
	find mayInstanceOfFunctionalInput_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}

//////////
// 4.2 Type refinement
//////////
pattern refineTypeTo_FunctionalArchitectureModel_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
}
pattern refineTypeTo_Function_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunction_class(problem,interpretation,element);
	neg find mustInstanceOfFunction_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
}
pattern refineTypeTo_InformationLink_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
}
pattern refineTypeTo_FunctionalOutput_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
}
pattern refineTypeTo_FAMTerminator_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
}
pattern refineTypeTo_FunctionalInterface_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
}
pattern refineTypeTo_FunctionalInput_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
}

//////////
// 4.3 Relation refinement
//////////
pattern refineRelation_model_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"model reference FunctionalElement");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFunctionalElement_class(problem,interpretation,from);
	find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,to);
	find mayInRelationmodel_reference_FunctionalElement(problem,interpretation,from,to);
	neg find mustInRelationmodel_reference_FunctionalElement(problem,interpretation,from,to);
}
pattern refineRelation_IncomingLinks_reference_FunctionalInput_and_to_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation, oppositeInterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"IncomingLinks reference FunctionalInput");
	PartialInterpretation.partialrelationinterpretation(interpretation,oppositeInterpretation);
	PartialRelationInterpretation.interpretationOf.name(oppositeInterpretation,"to reference InformationLink");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFunctionalInput_class(problem,interpretation,from);
	find mustInstanceOfInformationLink_class(problem,interpretation,to);
	find mayInRelationIncomingLinks_reference_FunctionalInput(problem,interpretation,from,to);
	neg find mustInRelationIncomingLinks_reference_FunctionalInput(problem,interpretation,from,to);
}
pattern refineRelation_type_attribute_Function(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"type attribute Function");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFunction_class(problem,interpretation,from);
	find mustInstanceOfFunctionType_enum(problem,interpretation,to);
	find mayInRelationtype_attribute_Function(problem,interpretation,from,to);
	neg find mustInRelationtype_attribute_Function(problem,interpretation,from,to);
}
import epackage "http://www.bme.hu/mit/inf/dslreasoner/viatrasolver/partialinterpretationlanguage"
import epackage "http://www.bme.hu/mit/inf/dslreasoner/logic/model/problem"
import epackage "http://www.bme.hu/mit/inf/dslreasoner/logic/model/language"

//////////
// 0. Util
//////////
private pattern interpretation(problem:LogicProblem, interpretation:PartialInterpretation) {
	PartialInterpretation.problem(interpretation,problem);
}
	
/////////////////////////
// 0.1 Existence
/////////////////////////
private pattern mustExist(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	find interpretation(problem,interpretation);
	LogicProblem.elements(problem,element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
}

private pattern mayExist(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
    find mustExist(problem,interpretation,element);
} or {
    find interpretation(problem,interpretation);
    neg find elementCloseWorld(element);
    PartialInterpretation.openWorldElements(interpretation,element);
}

private pattern elementCloseWorld(element:DefinedElement) {
	PartialInterpretation.openWorldElements(i,element);
    PartialInterpretation.maxNewElements(i,0);
} or {
	Scope.targetTypeInterpretation(scope,interpretation);
	PartialTypeInterpratation.elements(interpretation,element);
	Scope.maxNewElements(scope,0);
}

////////////////////////
// 0.2 Equivalence
////////////////////////
pattern mayEquivalent(problem:LogicProblem, interpretation:PartialInterpretation, a: DefinedElement, b: DefinedElement) {
	find mayExist(problem,interpretation,a);
	find mayExist(problem,interpretation,b);
	a == b;
}

////////////////////////
// 0.3 Required Patterns by TypeIndexer
////////////////////////
private pattern typeInterpretation(problem:LogicProblem, interpretation:PartialInterpretation, type:TypeDeclaration, typeInterpretation:PartialComplexTypeInterpretation) {
	find interpretation(problem,interpretation);
	LogicProblem.types(problem,type);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
}

private pattern directInstanceOf(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement, type:Type) {
	find interpretation(problem,interpretation);
	LogicProblem.types(problem,type);
	TypeDefinition.elements(type,element);
} or {
	find interpretation(problem,interpretation);
	find typeInterpretation(problem,interpretation,type,typeInterpretation);
	PartialComplexTypeInterpretation.elements(typeInterpretation,element);
}

private pattern isPrimitive(element: PrimitiveElement) {
	PrimitiveElement(element);
}

//////////
// 1. Problem-Specific Base Indexers
//////////
// 1.1 Type Indexers
//////////
// 1.1.1 primitive Type Indexers
//////////

//////////
// 1.1.2 domain-specific Type Indexers
//////////
/**
 * An element must be an instance of type "FunctionalElement class".
 */
private pattern mustInstanceOfFunctionalElement_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalElement class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalElement_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalElement class");
}

/**
 * An element may be an instance of type "FunctionalElement class".
 */
private pattern mayInstanceOfFunctionalElement_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunction_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalElement_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunction_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalElement_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalElement_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalArchitectureModel class".
 */
private pattern mustInstanceOfFunctionalArchitectureModel_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalArchitectureModel class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalArchitectureModel_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalArchitectureModel class");
}

/**
 * An element may be an instance of type "FunctionalArchitectureModel class".
 */
private pattern mayInstanceOfFunctionalArchitectureModel_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalArchitectureModel_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalArchitectureModel_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Function class".
 */
private pattern mustInstanceOfFunction_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Function class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunction_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Function class");
}

/**
 * An element may be an instance of type "Function class".
 */
private pattern mayInstanceOfFunction_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunction_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunction_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunction_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FAMTerminator class".
 */
private pattern mustInstanceOfFAMTerminator_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FAMTerminator class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFAMTerminator_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FAMTerminator class");
}

/**
 * An element may be an instance of type "FAMTerminator class".
 */
private pattern mayInstanceOfFAMTerminator_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find scopeDisallowsNewFAMTerminator_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find scopeDisallowsNewFAMTerminator_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFAMTerminator_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "InformationLink class".
 */
private pattern mustInstanceOfInformationLink_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"InformationLink class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewInformationLink_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"InformationLink class");
}

/**
 * An element may be an instance of type "InformationLink class".
 */
private pattern mayInstanceOfInformationLink_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find scopeDisallowsNewInformationLink_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find scopeDisallowsNewInformationLink_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfInformationLink_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalInterface class".
 */
private pattern mustInstanceOfFunctionalInterface_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalInterface class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalInterface_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalInterface class");
}

/**
 * An element may be an instance of type "FunctionalInterface class".
 */
private pattern mayInstanceOfFunctionalInterface_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalInterface_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalInterface_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalInterface_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalInput class".
 */
private pattern mustInstanceOfFunctionalInput_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalInput class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalInput_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalInput class");
}

/**
 * An element may be an instance of type "FunctionalInput class".
 */
private pattern mayInstanceOfFunctionalInput_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalInput_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalInput_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalInput_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalOutput class".
 */
private pattern mustInstanceOfFunctionalOutput_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalOutput class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalOutput_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalOutput class");
}

/**
 * An element may be an instance of type "FunctionalOutput class".
 */
private pattern mayInstanceOfFunctionalOutput_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalOutput_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalOutput_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalOutput_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalData class".
 */
private pattern mustInstanceOfFunctionalData_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalData class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalData_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalData class");
}

/**
 * An element may be an instance of type "FunctionalData class".
 */
private pattern mayInstanceOfFunctionalData_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalData_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalData_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalData_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionType enum".
 */
private pattern mustInstanceOfFunctionType_enum(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionType enum");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionType_enum(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionType enum");
}

/**
 * An element may be an instance of type "FunctionType enum".
 */
private pattern mayInstanceOfFunctionType_enum(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfFunctionType_enum(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalArchitectureModel class DefinedPart".
 */
private pattern mustInstanceOfFunctionalArchitectureModel_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalArchitectureModel class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalArchitectureModel_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalArchitectureModel class DefinedPart");
}

/**
 * An element may be an instance of type "FunctionalArchitectureModel class DefinedPart".
 */
private pattern mayInstanceOfFunctionalArchitectureModel_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfFunctionalArchitectureModel_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalArchitectureModel class UndefinedPart".
 */
private pattern mustInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalArchitectureModel class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalArchitectureModel_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalArchitectureModel class UndefinedPart");
}

/**
 * An element may be an instance of type "FunctionalArchitectureModel class UndefinedPart".
 */
private pattern mayInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalArchitectureModel_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalArchitectureModel_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem,interpretation,element); }

//////////
// 1.2 Relation Declaration Indexers
//////////
/**
 * Matcher for detecting tuples t where []interface reference FunctionalElement(source,target)
 */
private pattern mustInRelationinterface_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"interface reference FunctionalElement");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>interface reference FunctionalElement(source,target)
 */
private pattern mayInRelationinterface_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalElement_class(problem,interpretation,source);
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationinterface_reference_FunctionalElement(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationelement_reference_FunctionalInterface(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationinterface_reference_FunctionalElement(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []model reference FunctionalElement(source,target)
 */
private pattern mustInRelationmodel_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"model reference FunctionalElement");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>model reference FunctionalElement(source,target)
 */
private pattern mayInRelationmodel_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalElement_class(problem,interpretation,source);
	find mayInstanceOfFunctionalArchitectureModel_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationmodel_reference_FunctionalElement(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationmodel_reference_FunctionalElement(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []parent reference FunctionalElement(source,target)
 */
private pattern mustInRelationparent_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"parent reference FunctionalElement");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>parent reference FunctionalElement(source,target)
 */
private pattern mayInRelationparent_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalElement_class(problem,interpretation,source);
	find mayInstanceOfFunction_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationparent_reference_FunctionalElement(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationparent_reference_FunctionalElement(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []rootElements reference FunctionalArchitectureModel(source,target)
 */
private pattern mustInRelationrootElements_reference_FunctionalArchitectureModel(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"rootElements reference FunctionalArchitectureModel");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>rootElements reference FunctionalArchitectureModel(source,target)
 */
private pattern mayInRelationrootElements_reference_FunctionalArchitectureModel(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalArchitectureModel_class(problem,interpretation,source);
	find mayInstanceOfFunctionalElement_class(problem,interpretation,target);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationrootElements_reference_FunctionalArchitectureModel(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []subElements reference Function(source,target)
 */
private pattern mustInRelationsubElements_reference_Function(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"subElements reference Function");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>subElements reference Function(source,target)
 */
private pattern mayInRelationsubElements_reference_Function(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunction_class(problem,interpretation,source);
	find mayInstanceOfFunctionalElement_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationparent_reference_FunctionalElement(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationsubElements_reference_Function(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []data reference FAMTerminator(source,target)
 */
private pattern mustInRelationdata_reference_FAMTerminator(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"data reference FAMTerminator");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>data reference FAMTerminator(source,target)
 */
private pattern mayInRelationdata_reference_FAMTerminator(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFAMTerminator_class(problem,interpretation,source);
	find mayInstanceOfFunctionalData_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationdata_reference_FAMTerminator(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationterminator_reference_FunctionalData(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationdata_reference_FAMTerminator(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []from reference InformationLink(source,target)
 */
private pattern mustInRelationfrom_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"from reference InformationLink");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>from reference InformationLink(source,target)
 */
private pattern mayInRelationfrom_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfInformationLink_class(problem,interpretation,source);
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationfrom_reference_InformationLink(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationfrom_reference_InformationLink(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []to reference InformationLink(source,target)
 */
private pattern mustInRelationto_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"to reference InformationLink");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>to reference InformationLink(source,target)
 */
private pattern mayInRelationto_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfInformationLink_class(problem,interpretation,source);
	find mayInstanceOfFunctionalInput_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationto_reference_InformationLink(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationto_reference_InformationLink(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []data reference FunctionalInterface(source,target)
 */
private pattern mustInRelationdata_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"data reference FunctionalInterface");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>data reference FunctionalInterface(source,target)
 */
private pattern mayInRelationdata_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,source);
	find mayInstanceOfFunctionalData_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationinterface_reference_FunctionalData(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationdata_reference_FunctionalInterface(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []element reference FunctionalInterface(source,target)
 */
private pattern mustInRelationelement_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"element reference FunctionalInterface");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>element reference FunctionalInterface(source,target)
 */
private pattern mayInRelationelement_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,source);
	find mayInstanceOfFunctionalElement_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationelement_reference_FunctionalInterface(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationinterface_reference_FunctionalElement(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationelement_reference_FunctionalInterface(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []IncomingLinks reference FunctionalInput(source,target)
 */
private pattern mustInRelationIncomingLinks_reference_FunctionalInput(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"IncomingLinks reference FunctionalInput");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>IncomingLinks reference FunctionalInput(source,target)
 */
private pattern mayInRelationIncomingLinks_reference_FunctionalInput(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalInput_class(problem,interpretation,source);
	find mayInstanceOfInformationLink_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationto_reference_InformationLink(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
} or {
	find mustInRelationIncomingLinks_reference_FunctionalInput(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []outgoingLinks reference FunctionalOutput(source,target)
 */
private pattern mustInRelationoutgoingLinks_reference_FunctionalOutput(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"outgoingLinks reference FunctionalOutput");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>outgoingLinks reference FunctionalOutput(source,target)
 */
private pattern mayInRelationoutgoingLinks_reference_FunctionalOutput(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,source);
	find mayInstanceOfInformationLink_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationfrom_reference_InformationLink(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationoutgoingLinks_reference_FunctionalOutput(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []terminator reference FunctionalData(source,target)
 */
private pattern mustInRelationterminator_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"terminator reference FunctionalData");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>terminator reference FunctionalData(source,target)
 */
private pattern mayInRelationterminator_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalData_class(problem,interpretation,source);
	find mayInstanceOfFAMTerminator_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationterminator_reference_FunctionalData(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationdata_reference_FAMTerminator(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationterminator_reference_FunctionalData(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []interface reference FunctionalData(source,target)
 */
private pattern mustInRelationinterface_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"interface reference FunctionalData");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>interface reference FunctionalData(source,target)
 */
private pattern mayInRelationinterface_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalData_class(problem,interpretation,source);
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationinterface_reference_FunctionalData(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationinterface_reference_FunctionalData(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []type attribute Function(source,target)
 */
private pattern mustInRelationtype_attribute_Function(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"type attribute Function");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>type attribute Function(source,target)
 */
private pattern mayInRelationtype_attribute_Function(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunction_class(problem,interpretation,source);
	find mayInstanceOfFunctionType_enum(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationtype_attribute_Function(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationtype_attribute_Function(problem,interpretation,source,target);
}

//////////
// 1.3 Relation Definition Indexers
//////////

//////////
// 1.4 Containment Indexer
//////////
private pattern mustContains2(source: DefinedElement, target: DefinedElement) {
	find mustContains4(_,_,source,target);
}
	
private pattern mustContains4(problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target: DefinedElement)
	{ find mustInRelationinterface_reference_FunctionalElement(problem,interpretation,source,target); }or
	
	{ find mustInRelationrootElements_reference_FunctionalArchitectureModel(problem,interpretation,source,target); }or
	
	{ find mustInRelationsubElements_reference_Function(problem,interpretation,source,target); }or
	
	{ find mustInRelationdata_reference_FunctionalInterface(problem,interpretation,source,target); }or
	
	{ find mustInRelationoutgoingLinks_reference_FunctionalOutput(problem,interpretation,source,target); }or
	
	{ find mustInRelationterminator_reference_FunctionalData(problem,interpretation,source,target); }

private pattern mustTransitiveContains(source,target) {
	find mustContains2+(source,target);
}

//////////
// 2. Invalidation Indexers
//////////
// 2.1 Invalidated by WF Queries
//////////

//////////
// 3. Unfinishedness Indexers
//////////
// 3.1 Unfinishedness Measured by Multiplicity
//////////
pattern unfinishedLowerMultiplicity_model_reference_FunctionalElement(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"model reference FunctionalElement");
	find mustInstanceOfFunctionalElement_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationmodel_reference_FunctionalElement(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_to_reference_InformationLink(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"to reference InformationLink");
	find mustInstanceOfInformationLink_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationto_reference_InformationLink(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_type_attribute_Function(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"type attribute Function");
	find mustInstanceOfFunction_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationtype_attribute_Function(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}

//////////
// 3.2 Unfinishedness Measured by WF Queries
//////////

//////////
// 4. Refinement Indexers
//////////
// 4.1 Object constructors
//////////
private pattern hasElementInContainment(problem:LogicProblem, interpretation:PartialInterpretation)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalData_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunction_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfInformationLink_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalElement_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalInput_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFAMTerminator_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalInterface_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalOutput_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalArchitectureModel_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}
pattern createObject_Function_class_by_rootElements_reference_FunctionalArchitectureModel(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Function class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"rootElements reference FunctionalArchitectureModel");
	find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,container);
	find mayInstanceOfFunction_class(problem,interpretation,newObject);
	find mayInRelationrootElements_reference_FunctionalArchitectureModel(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Function_class_by_subElements_reference_Function_with_parent_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Function class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"subElements reference Function");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"parent reference FunctionalElement");
	find mustInstanceOfFunction_class(problem,interpretation,container);
	find mayInstanceOfFunction_class(problem,interpretation,newObject);
	find mayInRelationsubElements_reference_Function(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Function_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Function class");
	find mayInstanceOfFunction_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FAMTerminator_class_by_terminator_reference_FunctionalData_with_data_reference_FAMTerminator(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FAMTerminator class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"terminator reference FunctionalData");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"data reference FAMTerminator");
	find mustInstanceOfFunctionalData_class(problem,interpretation,container);
	find mayInstanceOfFAMTerminator_class(problem,interpretation,newObject);
	find mayInRelationterminator_reference_FunctionalData(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FAMTerminator_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FAMTerminator class");
	find mayInstanceOfFAMTerminator_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalOutput_class_by_data_reference_FunctionalInterface_with_interface_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalOutput class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"data reference FunctionalInterface");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"interface reference FunctionalData");
	find mustInstanceOfFunctionalInterface_class(problem,interpretation,container);
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,newObject);
	find mayInRelationdata_reference_FunctionalInterface(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalOutput_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalOutput class");
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalInterface_class_by_interface_reference_FunctionalElement_with_element_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalInterface class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"interface reference FunctionalElement");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"element reference FunctionalInterface");
	find mustInstanceOfFunctionalElement_class(problem,interpretation,container);
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,newObject);
	find mayInRelationinterface_reference_FunctionalElement(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalInterface_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalInterface class");
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalArchitectureModel_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalArchitectureModel class UndefinedPart");
	find mayInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalInput_class_by_data_reference_FunctionalInterface_with_interface_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalInput class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"data reference FunctionalInterface");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"interface reference FunctionalData");
	find mustInstanceOfFunctionalInterface_class(problem,interpretation,container);
	find mayInstanceOfFunctionalInput_class(problem,interpretation,newObject);
	find mayInRelationdata_reference_FunctionalInterface(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalInput_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalInput class");
	find mayInstanceOfFunctionalInput_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_InformationLink_class_by_outgoingLinks_reference_FunctionalOutput_with_from_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"InformationLink class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"outgoingLinks reference FunctionalOutput");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"from reference InformationLink");
	find mustInstanceOfFunctionalOutput_class(problem,interpretation,container);
	find mayInstanceOfInformationLink_class(problem,interpretation,newObject);
	find mayInRelationoutgoingLinks_reference_FunctionalOutput(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_InformationLink_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"InformationLink class");
	find mayInstanceOfInformationLink_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}

//////////
// 4.2 Type refinement
//////////
pattern refineTypeTo_Function_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunction_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunction_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
}
pattern refineTypeTo_FAMTerminator_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
}
pattern refineTypeTo_FunctionalOutput_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
}
pattern refineTypeTo_FunctionalInterface_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
}
pattern refineTypeTo_FunctionalArchitectureModel_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
}
pattern refineTypeTo_FunctionalInput_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
}
pattern refineTypeTo_InformationLink_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
}

//////////
// 4.3 Relation refinement
//////////
pattern refineRelation_model_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"model reference FunctionalElement");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFunctionalElement_class(problem,interpretation,from);
	find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,to);
	find mayInRelationmodel_reference_FunctionalElement(problem,interpretation,from,to);
	neg find mustInRelationmodel_reference_FunctionalElement(problem,interpretation,from,to);
}
pattern refineRelation_IncomingLinks_reference_FunctionalInput_and_to_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation, oppositeInterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"IncomingLinks reference FunctionalInput");
	PartialInterpretation.partialrelationinterpretation(interpretation,oppositeInterpretation);
	PartialRelationInterpretation.interpretationOf.name(oppositeInterpretation,"to reference InformationLink");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFunctionalInput_class(problem,interpretation,from);
	find mustInstanceOfInformationLink_class(problem,interpretation,to);
	find mayInRelationIncomingLinks_reference_FunctionalInput(problem,interpretation,from,to);
	neg find mustInRelationIncomingLinks_reference_FunctionalInput(problem,interpretation,from,to);
}
pattern refineRelation_type_attribute_Function(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"type attribute Function");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFunction_class(problem,interpretation,from);
	find mustInstanceOfFunctionType_enum(problem,interpretation,to);
	find mayInRelationtype_attribute_Function(problem,interpretation,from,to);
	neg find mustInRelationtype_attribute_Function(problem,interpretation,from,to);
}
import epackage "http://www.bme.hu/mit/inf/dslreasoner/viatrasolver/partialinterpretationlanguage"
import epackage "http://www.bme.hu/mit/inf/dslreasoner/logic/model/problem"
import epackage "http://www.bme.hu/mit/inf/dslreasoner/logic/model/language"

//////////
// 0. Util
//////////
private pattern interpretation(problem:LogicProblem, interpretation:PartialInterpretation) {
	PartialInterpretation.problem(interpretation,problem);
}
	
/////////////////////////
// 0.1 Existence
/////////////////////////
private pattern mustExist(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	find interpretation(problem,interpretation);
	LogicProblem.elements(problem,element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
}

private pattern mayExist(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
    find mustExist(problem,interpretation,element);
} or {
    find interpretation(problem,interpretation);
    neg find elementCloseWorld(element);
    PartialInterpretation.openWorldElements(interpretation,element);
}

private pattern elementCloseWorld(element:DefinedElement) {
	PartialInterpretation.openWorldElements(i,element);
    PartialInterpretation.maxNewElements(i,0);
} or {
	Scope.targetTypeInterpretation(scope,interpretation);
	PartialTypeInterpratation.elements(interpretation,element);
	Scope.maxNewElements(scope,0);
}

////////////////////////
// 0.2 Equivalence
////////////////////////
pattern mayEquivalent(problem:LogicProblem, interpretation:PartialInterpretation, a: DefinedElement, b: DefinedElement) {
	find mayExist(problem,interpretation,a);
	find mayExist(problem,interpretation,b);
	a == b;
}

////////////////////////
// 0.3 Required Patterns by TypeIndexer
////////////////////////
private pattern typeInterpretation(problem:LogicProblem, interpretation:PartialInterpretation, type:TypeDeclaration, typeInterpretation:PartialComplexTypeInterpretation) {
	find interpretation(problem,interpretation);
	LogicProblem.types(problem,type);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
}

private pattern directInstanceOf(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement, type:Type) {
	find interpretation(problem,interpretation);
	LogicProblem.types(problem,type);
	TypeDefinition.elements(type,element);
} or {
	find interpretation(problem,interpretation);
	find typeInterpretation(problem,interpretation,type,typeInterpretation);
	PartialComplexTypeInterpretation.elements(typeInterpretation,element);
}

private pattern isPrimitive(element: PrimitiveElement) {
	PrimitiveElement(element);
}

//////////
// 1. Problem-Specific Base Indexers
//////////
// 1.1 Type Indexers
//////////
// 1.1.1 primitive Type Indexers
//////////

//////////
// 1.1.2 domain-specific Type Indexers
//////////
/**
 * An element must be an instance of type "EAttribute class".
 */
private pattern mustInstanceOfEAttribute_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"EAttribute class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewEAttribute_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"EAttribute class");
}

/**
 * An element may be an instance of type "EAttribute class".
 */
private pattern mayInstanceOfEAttribute_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEEnumLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEOperation_class(problem,interpretation,element);
	neg find mustInstanceOfEPackage_class(problem,interpretation,element);
	neg find mustInstanceOfETypeParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEReference_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfEParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEClassifier_class(problem,interpretation,element);
	neg find scopeDisallowsNewEAttribute_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEEnumLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEOperation_class(problem,interpretation,element);
	neg find mustInstanceOfEPackage_class(problem,interpretation,element);
	neg find mustInstanceOfETypeParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEReference_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfEParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEClassifier_class(problem,interpretation,element);
	neg find scopeDisallowsNewEAttribute_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfEAttribute_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "EAnnotation class".
 */
private pattern mustInstanceOfEAnnotation_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"EAnnotation class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewEAnnotation_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"EAnnotation class");
}

/**
 * An element may be an instance of type "EAnnotation class".
 */
private pattern mayInstanceOfEAnnotation_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfENamedElement_class(problem,interpretation,element);
	neg find scopeDisallowsNewEAnnotation_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfENamedElement_class(problem,interpretation,element);
	neg find scopeDisallowsNewEAnnotation_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfEAnnotation_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "EClass class".
 */
private pattern mustInstanceOfEClass_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"EClass class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewEClass_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"EClass class");
}

/**
 * An element may be an instance of type "EClass class".
 */
private pattern mayInstanceOfEClass_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEEnumLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEDataType_class(problem,interpretation,element);
	neg find mustInstanceOfEPackage_class(problem,interpretation,element);
	neg find mustInstanceOfETypeParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfETypedElement_class(problem,interpretation,element);
	neg find scopeDisallowsNewEClass_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEEnumLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEDataType_class(problem,interpretation,element);
	neg find mustInstanceOfEPackage_class(problem,interpretation,element);
	neg find mustInstanceOfETypeParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfETypedElement_class(problem,interpretation,element);
	neg find scopeDisallowsNewEClass_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfEClass_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "EClassifier class".
 */
private pattern mustInstanceOfEClassifier_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"EClassifier class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewEClassifier_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"EClassifier class");
}

/**
 * An element may be an instance of type "EClassifier class".
 */
private pattern mayInstanceOfEClassifier_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEEnumLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEDataType_class(problem,interpretation,element);
	neg find mustInstanceOfEClass_class(problem,interpretation,element);
	neg find mustInstanceOfEPackage_class(problem,interpretation,element);
	neg find mustInstanceOfETypeParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfETypedElement_class(problem,interpretation,element);
	neg find scopeDisallowsNewEClassifier_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEEnumLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEDataType_class(problem,interpretation,element);
	neg find mustInstanceOfEClass_class(problem,interpretation,element);
	neg find mustInstanceOfEPackage_class(problem,interpretation,element);
	neg find mustInstanceOfETypeParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfETypedElement_class(problem,interpretation,element);
	neg find scopeDisallowsNewEClassifier_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfEClassifier_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "EDataType class".
 */
private pattern mustInstanceOfEDataType_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"EDataType class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewEDataType_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"EDataType class");
}

/**
 * An element may be an instance of type "EDataType class".
 */
private pattern mayInstanceOfEDataType_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEEnum_class(problem,interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEEnumLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEPackage_class(problem,interpretation,element);
	neg find mustInstanceOfEClass_class(problem,interpretation,element);
	neg find mustInstanceOfETypeParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfETypedElement_class(problem,interpretation,element);
	neg find scopeDisallowsNewEDataType_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEEnum_class(problem,interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEEnumLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEPackage_class(problem,interpretation,element);
	neg find mustInstanceOfEClass_class(problem,interpretation,element);
	neg find mustInstanceOfETypeParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfETypedElement_class(problem,interpretation,element);
	neg find scopeDisallowsNewEDataType_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfEDataType_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "EEnum class".
 */
private pattern mustInstanceOfEEnum_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"EEnum class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewEEnum_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"EEnum class");
}

/**
 * An element may be an instance of type "EEnum class".
 */
private pattern mayInstanceOfEEnum_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEEnumLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEClass_class(problem,interpretation,element);
	neg find mustInstanceOfEPackage_class(problem,interpretation,element);
	neg find mustInstanceOfETypeParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfETypedElement_class(problem,interpretation,element);
	neg find scopeDisallowsNewEEnum_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEEnumLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEClass_class(problem,interpretation,element);
	neg find mustInstanceOfEPackage_class(problem,interpretation,element);
	neg find mustInstanceOfETypeParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfETypedElement_class(problem,interpretation,element);
	neg find scopeDisallowsNewEEnum_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfEEnum_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "EEnumLiteral class".
 */
private pattern mustInstanceOfEEnumLiteral_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"EEnumLiteral class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewEEnumLiteral_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"EEnumLiteral class");
}

/**
 * An element may be an instance of type "EEnumLiteral class".
 */
private pattern mayInstanceOfEEnumLiteral_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEPackage_class(problem,interpretation,element);
	neg find mustInstanceOfETypeParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfETypedElement_class(problem,interpretation,element);
	neg find mustInstanceOfEClassifier_class(problem,interpretation,element);
	neg find scopeDisallowsNewEEnumLiteral_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEPackage_class(problem,interpretation,element);
	neg find mustInstanceOfETypeParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfETypedElement_class(problem,interpretation,element);
	neg find mustInstanceOfEClassifier_class(problem,interpretation,element);
	neg find scopeDisallowsNewEEnumLiteral_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfEEnumLiteral_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "EModelElement class".
 */
private pattern mustInstanceOfEModelElement_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"EModelElement class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewEModelElement_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"EModelElement class");
}

/**
 * An element may be an instance of type "EModelElement class".
 */
private pattern mayInstanceOfEModelElement_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEModelElement_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfENamedElement_class(problem,interpretation,element);
	neg find scopeDisallowsNewEModelElement_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEModelElement_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfENamedElement_class(problem,interpretation,element);
	neg find scopeDisallowsNewEModelElement_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfEModelElement_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "ENamedElement class".
 */
private pattern mustInstanceOfENamedElement_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"ENamedElement class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewENamedElement_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"ENamedElement class");
}

/**
 * An element may be an instance of type "ENamedElement class".
 */
private pattern mayInstanceOfENamedElement_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEPackage_class(problem,interpretation,element);
	neg find mustInstanceOfEModelElement_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find scopeDisallowsNewENamedElement_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEPackage_class(problem,interpretation,element);
	neg find mustInstanceOfEModelElement_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find scopeDisallowsNewENamedElement_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfENamedElement_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "EObject class".
 */
private pattern mustInstanceOfEObject_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"EObject class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewEObject_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"EObject class");
}

/**
 * An element may be an instance of type "EObject class".
 */
private pattern mayInstanceOfEObject_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfEModelElement_class(problem,interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find scopeDisallowsNewEObject_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfEModelElement_class(problem,interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find scopeDisallowsNewEObject_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfEObject_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "EOperation class".
 */
private pattern mustInstanceOfEOperation_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"EOperation class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewEOperation_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"EOperation class");
}

/**
 * An element may be an instance of type "EOperation class".
 */
private pattern mayInstanceOfEOperation_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEEnumLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEStructuralFeature_class(problem,interpretation,element);
	neg find mustInstanceOfEPackage_class(problem,interpretation,element);
	neg find mustInstanceOfETypeParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfEParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEClassifier_class(problem,interpretation,element);
	neg find scopeDisallowsNewEOperation_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEEnumLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEStructuralFeature_class(problem,interpretation,element);
	neg find mustInstanceOfEPackage_class(problem,interpretation,element);
	neg find mustInstanceOfETypeParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfEParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEClassifier_class(problem,interpretation,element);
	neg find scopeDisallowsNewEOperation_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfEOperation_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "EPackage class".
 */
private pattern mustInstanceOfEPackage_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"EPackage class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewEPackage_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"EPackage class");
}

/**
 * An element may be an instance of type "EPackage class".
 */
private pattern mayInstanceOfEPackage_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEModelElement_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find scopeDisallowsNewEPackage_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEModelElement_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find scopeDisallowsNewEPackage_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfEPackage_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "EParameter class".
 */
private pattern mustInstanceOfEParameter_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"EParameter class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewEParameter_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"EParameter class");
}

/**
 * An element may be an instance of type "EParameter class".
 */
private pattern mayInstanceOfEParameter_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEEnumLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEOperation_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEStructuralFeature_class(problem,interpretation,element);
	neg find mustInstanceOfEPackage_class(problem,interpretation,element);
	neg find mustInstanceOfETypeParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfEClassifier_class(problem,interpretation,element);
	neg find scopeDisallowsNewEParameter_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEEnumLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEOperation_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEStructuralFeature_class(problem,interpretation,element);
	neg find mustInstanceOfEPackage_class(problem,interpretation,element);
	neg find mustInstanceOfETypeParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfEClassifier_class(problem,interpretation,element);
	neg find scopeDisallowsNewEParameter_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfEParameter_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "EReference class".
 */
private pattern mustInstanceOfEReference_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"EReference class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewEReference_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"EReference class");
}

/**
 * An element may be an instance of type "EReference class".
 */
private pattern mayInstanceOfEReference_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfEAttribute_class(problem,interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEEnumLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEOperation_class(problem,interpretation,element);
	neg find mustInstanceOfEPackage_class(problem,interpretation,element);
	neg find mustInstanceOfETypeParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfEParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEClassifier_class(problem,interpretation,element);
	neg find scopeDisallowsNewEReference_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfEAttribute_class(problem,interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEEnumLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEOperation_class(problem,interpretation,element);
	neg find mustInstanceOfEPackage_class(problem,interpretation,element);
	neg find mustInstanceOfETypeParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfEParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEClassifier_class(problem,interpretation,element);
	neg find scopeDisallowsNewEReference_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfEReference_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "EStructuralFeature class".
 */
private pattern mustInstanceOfEStructuralFeature_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"EStructuralFeature class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewEStructuralFeature_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"EStructuralFeature class");
}

/**
 * An element may be an instance of type "EStructuralFeature class".
 */
private pattern mayInstanceOfEStructuralFeature_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfEAttribute_class(problem,interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEEnumLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEOperation_class(problem,interpretation,element);
	neg find mustInstanceOfEPackage_class(problem,interpretation,element);
	neg find mustInstanceOfETypeParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEReference_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfEParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEClassifier_class(problem,interpretation,element);
	neg find scopeDisallowsNewEStructuralFeature_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfEAttribute_class(problem,interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEEnumLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEOperation_class(problem,interpretation,element);
	neg find mustInstanceOfEPackage_class(problem,interpretation,element);
	neg find mustInstanceOfETypeParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEReference_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfEParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEClassifier_class(problem,interpretation,element);
	neg find scopeDisallowsNewEStructuralFeature_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfEStructuralFeature_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "ETypedElement class".
 */
private pattern mustInstanceOfETypedElement_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"ETypedElement class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewETypedElement_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"ETypedElement class");
}

/**
 * An element may be an instance of type "ETypedElement class".
 */
private pattern mayInstanceOfETypedElement_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEEnumLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEOperation_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEStructuralFeature_class(problem,interpretation,element);
	neg find mustInstanceOfEPackage_class(problem,interpretation,element);
	neg find mustInstanceOfETypeParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfEParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEClassifier_class(problem,interpretation,element);
	neg find scopeDisallowsNewETypedElement_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEEnumLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEOperation_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEStructuralFeature_class(problem,interpretation,element);
	neg find mustInstanceOfEPackage_class(problem,interpretation,element);
	neg find mustInstanceOfETypeParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfEParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEClassifier_class(problem,interpretation,element);
	neg find scopeDisallowsNewETypedElement_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfETypedElement_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "EStringToStringMapEntry class".
 */
private pattern mustInstanceOfEStringToStringMapEntry_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"EStringToStringMapEntry class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewEStringToStringMapEntry_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"EStringToStringMapEntry class");
}

/**
 * An element may be an instance of type "EStringToStringMapEntry class".
 */
private pattern mayInstanceOfEStringToStringMapEntry_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfEModelElement_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find scopeDisallowsNewEStringToStringMapEntry_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfEModelElement_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find scopeDisallowsNewEStringToStringMapEntry_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "EGenericType class".
 */
private pattern mustInstanceOfEGenericType_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"EGenericType class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewEGenericType_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"EGenericType class");
}

/**
 * An element may be an instance of type "EGenericType class".
 */
private pattern mayInstanceOfEGenericType_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfEModelElement_class(problem,interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find scopeDisallowsNewEGenericType_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfEModelElement_class(problem,interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find scopeDisallowsNewEGenericType_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfEGenericType_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "ETypeParameter class".
 */
private pattern mustInstanceOfETypeParameter_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"ETypeParameter class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewETypeParameter_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"ETypeParameter class");
}

/**
 * An element may be an instance of type "ETypeParameter class".
 */
private pattern mayInstanceOfETypeParameter_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEEnumLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEPackage_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfETypedElement_class(problem,interpretation,element);
	neg find mustInstanceOfEClassifier_class(problem,interpretation,element);
	neg find scopeDisallowsNewETypeParameter_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEEnumLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEPackage_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfETypedElement_class(problem,interpretation,element);
	neg find mustInstanceOfEClassifier_class(problem,interpretation,element);
	neg find scopeDisallowsNewETypeParameter_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfETypeParameter_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "EModelElement class DefinedPart".
 */
private pattern mustInstanceOfEModelElement_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"EModelElement class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewEModelElement_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"EModelElement class DefinedPart");
}

/**
 * An element may be an instance of type "EModelElement class DefinedPart".
 */
private pattern mayInstanceOfEModelElement_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfEModelElement_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "EModelElement class UndefinedPart".
 */
private pattern mustInstanceOfEModelElement_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"EModelElement class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewEModelElement_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"EModelElement class UndefinedPart");
}

/**
 * An element may be an instance of type "EModelElement class UndefinedPart".
 */
private pattern mayInstanceOfEModelElement_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfENamedElement_class(problem,interpretation,element);
	neg find scopeDisallowsNewEModelElement_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfENamedElement_class(problem,interpretation,element);
	neg find scopeDisallowsNewEModelElement_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfEModelElement_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "ENamedElement class DefinedPart".
 */
private pattern mustInstanceOfENamedElement_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"ENamedElement class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewENamedElement_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"ENamedElement class DefinedPart");
}

/**
 * An element may be an instance of type "ENamedElement class DefinedPart".
 */
private pattern mayInstanceOfENamedElement_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfENamedElement_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "ENamedElement class UndefinedPart".
 */
private pattern mustInstanceOfENamedElement_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"ENamedElement class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewENamedElement_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"ENamedElement class UndefinedPart");
}

/**
 * An element may be an instance of type "ENamedElement class UndefinedPart".
 */
private pattern mayInstanceOfENamedElement_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEEnumLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEPackage_class(problem,interpretation,element);
	neg find mustInstanceOfETypeParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfETypedElement_class(problem,interpretation,element);
	neg find mustInstanceOfEClassifier_class(problem,interpretation,element);
	neg find scopeDisallowsNewENamedElement_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEEnumLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEPackage_class(problem,interpretation,element);
	neg find mustInstanceOfETypeParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfETypedElement_class(problem,interpretation,element);
	neg find mustInstanceOfEClassifier_class(problem,interpretation,element);
	neg find scopeDisallowsNewENamedElement_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfENamedElement_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "EPackage class DefinedPart".
 */
private pattern mustInstanceOfEPackage_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"EPackage class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewEPackage_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"EPackage class DefinedPart");
}

/**
 * An element may be an instance of type "EPackage class DefinedPart".
 */
private pattern mayInstanceOfEPackage_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfEPackage_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "EPackage class UndefinedPart".
 */
private pattern mustInstanceOfEPackage_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"EPackage class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewEPackage_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"EPackage class UndefinedPart");
}

/**
 * An element may be an instance of type "EPackage class UndefinedPart".
 */
private pattern mayInstanceOfEPackage_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEEnumLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfETypeParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfETypedElement_class(problem,interpretation,element);
	neg find mustInstanceOfEClassifier_class(problem,interpretation,element);
	neg find scopeDisallowsNewEPackage_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEEnumLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfETypeParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfETypedElement_class(problem,interpretation,element);
	neg find mustInstanceOfEClassifier_class(problem,interpretation,element);
	neg find scopeDisallowsNewEPackage_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfEPackage_class_UndefinedPart(problem,interpretation,element); }

//////////
// 1.2 Relation Declaration Indexers
//////////
/**
 * Matcher for detecting tuples t where []eAttributeType reference EAttribute(source,target)
 */
private pattern mustInRelationeAttributeType_reference_EAttribute(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eAttributeType reference EAttribute");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eAttributeType reference EAttribute(source,target)
 */
private pattern mayInRelationeAttributeType_reference_EAttribute(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEAttribute_class(problem,interpretation,source);
	find mayInstanceOfEDataType_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationeAttributeType_reference_EAttribute(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationeAttributeType_reference_EAttribute(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []details reference EAnnotation(source,target)
 */
private pattern mustInRelationdetails_reference_EAnnotation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"details reference EAnnotation");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>details reference EAnnotation(source,target)
 */
private pattern mayInRelationdetails_reference_EAnnotation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEAnnotation_class(problem,interpretation,source);
	find mayInstanceOfEStringToStringMapEntry_class(problem,interpretation,target);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationdetails_reference_EAnnotation(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eModelElement reference EAnnotation(source,target)
 */
private pattern mustInRelationeModelElement_reference_EAnnotation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eModelElement reference EAnnotation");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eModelElement reference EAnnotation(source,target)
 */
private pattern mayInRelationeModelElement_reference_EAnnotation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEAnnotation_class(problem,interpretation,source);
	find mayInstanceOfEModelElement_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationeModelElement_reference_EAnnotation(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationeModelElement_reference_EAnnotation(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []contents reference EAnnotation(source,target)
 */
private pattern mustInRelationcontents_reference_EAnnotation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"contents reference EAnnotation");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>contents reference EAnnotation(source,target)
 */
private pattern mayInRelationcontents_reference_EAnnotation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEAnnotation_class(problem,interpretation,source);
	find mayInstanceOfEObject_class(problem,interpretation,target);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationcontents_reference_EAnnotation(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []references reference EAnnotation(source,target)
 */
private pattern mustInRelationreferences_reference_EAnnotation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"references reference EAnnotation");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>references reference EAnnotation(source,target)
 */
private pattern mayInRelationreferences_reference_EAnnotation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEAnnotation_class(problem,interpretation,source);
	find mayInstanceOfEObject_class(problem,interpretation,target);
} or {
	find mustInRelationreferences_reference_EAnnotation(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eSuperTypes reference EClass(source,target)
 */
private pattern mustInRelationeSuperTypes_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eSuperTypes reference EClass");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eSuperTypes reference EClass(source,target)
 */
private pattern mayInRelationeSuperTypes_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEClass_class(problem,interpretation,source);
	find mayInstanceOfEClass_class(problem,interpretation,target);
} or {
	find mustInRelationeSuperTypes_reference_EClass(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eOperations reference EClass(source,target)
 */
private pattern mustInRelationeOperations_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eOperations reference EClass");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eOperations reference EClass(source,target)
 */
private pattern mayInRelationeOperations_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEClass_class(problem,interpretation,source);
	find mayInstanceOfEOperation_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationeContainingClass_reference_EOperation(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationeOperations_reference_EClass(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eAllAttributes reference EClass(source,target)
 */
private pattern mustInRelationeAllAttributes_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eAllAttributes reference EClass");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eAllAttributes reference EClass(source,target)
 */
private pattern mayInRelationeAllAttributes_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEClass_class(problem,interpretation,source);
	find mayInstanceOfEAttribute_class(problem,interpretation,target);
} or {
	find mustInRelationeAllAttributes_reference_EClass(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eAllReferences reference EClass(source,target)
 */
private pattern mustInRelationeAllReferences_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eAllReferences reference EClass");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eAllReferences reference EClass(source,target)
 */
private pattern mayInRelationeAllReferences_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEClass_class(problem,interpretation,source);
	find mayInstanceOfEReference_class(problem,interpretation,target);
} or {
	find mustInRelationeAllReferences_reference_EClass(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eReferences reference EClass(source,target)
 */
private pattern mustInRelationeReferences_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eReferences reference EClass");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eReferences reference EClass(source,target)
 */
private pattern mayInRelationeReferences_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEClass_class(problem,interpretation,source);
	find mayInstanceOfEReference_class(problem,interpretation,target);
} or {
	find mustInRelationeReferences_reference_EClass(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eAttributes reference EClass(source,target)
 */
private pattern mustInRelationeAttributes_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eAttributes reference EClass");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eAttributes reference EClass(source,target)
 */
private pattern mayInRelationeAttributes_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEClass_class(problem,interpretation,source);
	find mayInstanceOfEAttribute_class(problem,interpretation,target);
} or {
	find mustInRelationeAttributes_reference_EClass(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eAllContainments reference EClass(source,target)
 */
private pattern mustInRelationeAllContainments_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eAllContainments reference EClass");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eAllContainments reference EClass(source,target)
 */
private pattern mayInRelationeAllContainments_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEClass_class(problem,interpretation,source);
	find mayInstanceOfEReference_class(problem,interpretation,target);
} or {
	find mustInRelationeAllContainments_reference_EClass(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eAllOperations reference EClass(source,target)
 */
private pattern mustInRelationeAllOperations_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eAllOperations reference EClass");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eAllOperations reference EClass(source,target)
 */
private pattern mayInRelationeAllOperations_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEClass_class(problem,interpretation,source);
	find mayInstanceOfEOperation_class(problem,interpretation,target);
} or {
	find mustInRelationeAllOperations_reference_EClass(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eAllStructuralFeatures reference EClass(source,target)
 */
private pattern mustInRelationeAllStructuralFeatures_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eAllStructuralFeatures reference EClass");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eAllStructuralFeatures reference EClass(source,target)
 */
private pattern mayInRelationeAllStructuralFeatures_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEClass_class(problem,interpretation,source);
	find mayInstanceOfEStructuralFeature_class(problem,interpretation,target);
} or {
	find mustInRelationeAllStructuralFeatures_reference_EClass(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eAllSuperTypes reference EClass(source,target)
 */
private pattern mustInRelationeAllSuperTypes_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eAllSuperTypes reference EClass");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eAllSuperTypes reference EClass(source,target)
 */
private pattern mayInRelationeAllSuperTypes_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEClass_class(problem,interpretation,source);
	find mayInstanceOfEClass_class(problem,interpretation,target);
} or {
	find mustInRelationeAllSuperTypes_reference_EClass(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eIDAttribute reference EClass(source,target)
 */
private pattern mustInRelationeIDAttribute_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eIDAttribute reference EClass");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eIDAttribute reference EClass(source,target)
 */
private pattern mayInRelationeIDAttribute_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEClass_class(problem,interpretation,source);
	find mayInstanceOfEAttribute_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationeIDAttribute_reference_EClass(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationeIDAttribute_reference_EClass(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eStructuralFeatures reference EClass(source,target)
 */
private pattern mustInRelationeStructuralFeatures_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eStructuralFeatures reference EClass");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eStructuralFeatures reference EClass(source,target)
 */
private pattern mayInRelationeStructuralFeatures_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEClass_class(problem,interpretation,source);
	find mayInstanceOfEStructuralFeature_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationeContainingClass_reference_EStructuralFeature(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationeStructuralFeatures_reference_EClass(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eGenericSuperTypes reference EClass(source,target)
 */
private pattern mustInRelationeGenericSuperTypes_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eGenericSuperTypes reference EClass");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eGenericSuperTypes reference EClass(source,target)
 */
private pattern mayInRelationeGenericSuperTypes_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEClass_class(problem,interpretation,source);
	find mayInstanceOfEGenericType_class(problem,interpretation,target);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationeGenericSuperTypes_reference_EClass(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eAllGenericSuperTypes reference EClass(source,target)
 */
private pattern mustInRelationeAllGenericSuperTypes_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eAllGenericSuperTypes reference EClass");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eAllGenericSuperTypes reference EClass(source,target)
 */
private pattern mayInRelationeAllGenericSuperTypes_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEClass_class(problem,interpretation,source);
	find mayInstanceOfEGenericType_class(problem,interpretation,target);
} or {
	find mustInRelationeAllGenericSuperTypes_reference_EClass(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []ePackage reference EClassifier(source,target)
 */
private pattern mustInRelationePackage_reference_EClassifier(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"ePackage reference EClassifier");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>ePackage reference EClassifier(source,target)
 */
private pattern mayInRelationePackage_reference_EClassifier(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEClassifier_class(problem,interpretation,source);
	find mayInstanceOfEPackage_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationePackage_reference_EClassifier(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationePackage_reference_EClassifier(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eTypeParameters reference EClassifier(source,target)
 */
private pattern mustInRelationeTypeParameters_reference_EClassifier(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eTypeParameters reference EClassifier");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eTypeParameters reference EClassifier(source,target)
 */
private pattern mayInRelationeTypeParameters_reference_EClassifier(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEClassifier_class(problem,interpretation,source);
	find mayInstanceOfETypeParameter_class(problem,interpretation,target);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationeTypeParameters_reference_EClassifier(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eLiterals reference EEnum(source,target)
 */
private pattern mustInRelationeLiterals_reference_EEnum(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eLiterals reference EEnum");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eLiterals reference EEnum(source,target)
 */
private pattern mayInRelationeLiterals_reference_EEnum(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEEnum_class(problem,interpretation,source);
	find mayInstanceOfEEnumLiteral_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationeEnum_reference_EEnumLiteral(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationeLiterals_reference_EEnum(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eEnum reference EEnumLiteral(source,target)
 */
private pattern mustInRelationeEnum_reference_EEnumLiteral(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eEnum reference EEnumLiteral");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eEnum reference EEnumLiteral(source,target)
 */
private pattern mayInRelationeEnum_reference_EEnumLiteral(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEEnumLiteral_class(problem,interpretation,source);
	find mayInstanceOfEEnum_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationeEnum_reference_EEnumLiteral(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationeEnum_reference_EEnumLiteral(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eAnnotations reference EModelElement(source,target)
 */
private pattern mustInRelationeAnnotations_reference_EModelElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eAnnotations reference EModelElement");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eAnnotations reference EModelElement(source,target)
 */
private pattern mayInRelationeAnnotations_reference_EModelElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEModelElement_class(problem,interpretation,source);
	find mayInstanceOfEAnnotation_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationeModelElement_reference_EAnnotation(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationeAnnotations_reference_EModelElement(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eContainingClass reference EOperation(source,target)
 */
private pattern mustInRelationeContainingClass_reference_EOperation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eContainingClass reference EOperation");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eContainingClass reference EOperation(source,target)
 */
private pattern mayInRelationeContainingClass_reference_EOperation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEOperation_class(problem,interpretation,source);
	find mayInstanceOfEClass_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationeContainingClass_reference_EOperation(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationeContainingClass_reference_EOperation(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eTypeParameters reference EOperation(source,target)
 */
private pattern mustInRelationeTypeParameters_reference_EOperation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eTypeParameters reference EOperation");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eTypeParameters reference EOperation(source,target)
 */
private pattern mayInRelationeTypeParameters_reference_EOperation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEOperation_class(problem,interpretation,source);
	find mayInstanceOfETypeParameter_class(problem,interpretation,target);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationeTypeParameters_reference_EOperation(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eParameters reference EOperation(source,target)
 */
private pattern mustInRelationeParameters_reference_EOperation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eParameters reference EOperation");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eParameters reference EOperation(source,target)
 */
private pattern mayInRelationeParameters_reference_EOperation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEOperation_class(problem,interpretation,source);
	find mayInstanceOfEParameter_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationeOperation_reference_EParameter(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationeParameters_reference_EOperation(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eExceptions reference EOperation(source,target)
 */
private pattern mustInRelationeExceptions_reference_EOperation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eExceptions reference EOperation");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eExceptions reference EOperation(source,target)
 */
private pattern mayInRelationeExceptions_reference_EOperation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEOperation_class(problem,interpretation,source);
	find mayInstanceOfEClassifier_class(problem,interpretation,target);
} or {
	find mustInRelationeExceptions_reference_EOperation(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eGenericExceptions reference EOperation(source,target)
 */
private pattern mustInRelationeGenericExceptions_reference_EOperation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eGenericExceptions reference EOperation");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eGenericExceptions reference EOperation(source,target)
 */
private pattern mayInRelationeGenericExceptions_reference_EOperation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEOperation_class(problem,interpretation,source);
	find mayInstanceOfEGenericType_class(problem,interpretation,target);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationeGenericExceptions_reference_EOperation(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eClassifiers reference EPackage(source,target)
 */
private pattern mustInRelationeClassifiers_reference_EPackage(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eClassifiers reference EPackage");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eClassifiers reference EPackage(source,target)
 */
private pattern mayInRelationeClassifiers_reference_EPackage(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEPackage_class(problem,interpretation,source);
	find mayInstanceOfEClassifier_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationePackage_reference_EClassifier(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationeClassifiers_reference_EPackage(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eSubpackages reference EPackage(source,target)
 */
private pattern mustInRelationeSubpackages_reference_EPackage(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eSubpackages reference EPackage");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eSubpackages reference EPackage(source,target)
 */
private pattern mayInRelationeSubpackages_reference_EPackage(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEPackage_class(problem,interpretation,source);
	find mayInstanceOfEPackage_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationeSuperPackage_reference_EPackage(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationeSubpackages_reference_EPackage(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eSuperPackage reference EPackage(source,target)
 */
private pattern mustInRelationeSuperPackage_reference_EPackage(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eSuperPackage reference EPackage");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eSuperPackage reference EPackage(source,target)
 */
private pattern mayInRelationeSuperPackage_reference_EPackage(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEPackage_class(problem,interpretation,source);
	find mayInstanceOfEPackage_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationeSuperPackage_reference_EPackage(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationeSuperPackage_reference_EPackage(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eOperation reference EParameter(source,target)
 */
private pattern mustInRelationeOperation_reference_EParameter(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eOperation reference EParameter");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eOperation reference EParameter(source,target)
 */
private pattern mayInRelationeOperation_reference_EParameter(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEParameter_class(problem,interpretation,source);
	find mayInstanceOfEOperation_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationeOperation_reference_EParameter(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationeOperation_reference_EParameter(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eOpposite reference EReference(source,target)
 */
private pattern mustInRelationeOpposite_reference_EReference(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eOpposite reference EReference");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eOpposite reference EReference(source,target)
 */
private pattern mayInRelationeOpposite_reference_EReference(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEReference_class(problem,interpretation,source);
	find mayInstanceOfEReference_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationeOpposite_reference_EReference(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationeOpposite_reference_EReference(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eReferenceType reference EReference(source,target)
 */
private pattern mustInRelationeReferenceType_reference_EReference(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eReferenceType reference EReference");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eReferenceType reference EReference(source,target)
 */
private pattern mayInRelationeReferenceType_reference_EReference(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEReference_class(problem,interpretation,source);
	find mayInstanceOfEClass_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationeReferenceType_reference_EReference(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationeReferenceType_reference_EReference(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eKeys reference EReference(source,target)
 */
private pattern mustInRelationeKeys_reference_EReference(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eKeys reference EReference");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eKeys reference EReference(source,target)
 */
private pattern mayInRelationeKeys_reference_EReference(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEReference_class(problem,interpretation,source);
	find mayInstanceOfEAttribute_class(problem,interpretation,target);
} or {
	find mustInRelationeKeys_reference_EReference(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eContainingClass reference EStructuralFeature(source,target)
 */
private pattern mustInRelationeContainingClass_reference_EStructuralFeature(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eContainingClass reference EStructuralFeature");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eContainingClass reference EStructuralFeature(source,target)
 */
private pattern mayInRelationeContainingClass_reference_EStructuralFeature(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEStructuralFeature_class(problem,interpretation,source);
	find mayInstanceOfEClass_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationeContainingClass_reference_EStructuralFeature(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationeContainingClass_reference_EStructuralFeature(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eType reference ETypedElement(source,target)
 */
private pattern mustInRelationeType_reference_ETypedElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eType reference ETypedElement");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eType reference ETypedElement(source,target)
 */
private pattern mayInRelationeType_reference_ETypedElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfETypedElement_class(problem,interpretation,source);
	find mayInstanceOfEClassifier_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationeType_reference_ETypedElement(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationeType_reference_ETypedElement(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eGenericType reference ETypedElement(source,target)
 */
private pattern mustInRelationeGenericType_reference_ETypedElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eGenericType reference ETypedElement");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eGenericType reference ETypedElement(source,target)
 */
private pattern mayInRelationeGenericType_reference_ETypedElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfETypedElement_class(problem,interpretation,source);
	find mayInstanceOfEGenericType_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationeGenericType_reference_ETypedElement(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationeGenericType_reference_ETypedElement(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eUpperBound reference EGenericType(source,target)
 */
private pattern mustInRelationeUpperBound_reference_EGenericType(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eUpperBound reference EGenericType");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eUpperBound reference EGenericType(source,target)
 */
private pattern mayInRelationeUpperBound_reference_EGenericType(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEGenericType_class(problem,interpretation,source);
	find mayInstanceOfEGenericType_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationeUpperBound_reference_EGenericType(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationeUpperBound_reference_EGenericType(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eTypeArguments reference EGenericType(source,target)
 */
private pattern mustInRelationeTypeArguments_reference_EGenericType(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eTypeArguments reference EGenericType");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eTypeArguments reference EGenericType(source,target)
 */
private pattern mayInRelationeTypeArguments_reference_EGenericType(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEGenericType_class(problem,interpretation,source);
	find mayInstanceOfEGenericType_class(problem,interpretation,target);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationeTypeArguments_reference_EGenericType(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eRawType reference EGenericType(source,target)
 */
private pattern mustInRelationeRawType_reference_EGenericType(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eRawType reference EGenericType");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eRawType reference EGenericType(source,target)
 */
private pattern mayInRelationeRawType_reference_EGenericType(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEGenericType_class(problem,interpretation,source);
	find mayInstanceOfEClassifier_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationeRawType_reference_EGenericType(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationeRawType_reference_EGenericType(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eLowerBound reference EGenericType(source,target)
 */
private pattern mustInRelationeLowerBound_reference_EGenericType(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eLowerBound reference EGenericType");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eLowerBound reference EGenericType(source,target)
 */
private pattern mayInRelationeLowerBound_reference_EGenericType(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEGenericType_class(problem,interpretation,source);
	find mayInstanceOfEGenericType_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationeLowerBound_reference_EGenericType(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationeLowerBound_reference_EGenericType(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eTypeParameter reference EGenericType(source,target)
 */
private pattern mustInRelationeTypeParameter_reference_EGenericType(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eTypeParameter reference EGenericType");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eTypeParameter reference EGenericType(source,target)
 */
private pattern mayInRelationeTypeParameter_reference_EGenericType(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEGenericType_class(problem,interpretation,source);
	find mayInstanceOfETypeParameter_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationeTypeParameter_reference_EGenericType(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationeTypeParameter_reference_EGenericType(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eClassifier reference EGenericType(source,target)
 */
private pattern mustInRelationeClassifier_reference_EGenericType(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eClassifier reference EGenericType");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eClassifier reference EGenericType(source,target)
 */
private pattern mayInRelationeClassifier_reference_EGenericType(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEGenericType_class(problem,interpretation,source);
	find mayInstanceOfEClassifier_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationeClassifier_reference_EGenericType(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationeClassifier_reference_EGenericType(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eBounds reference ETypeParameter(source,target)
 */
private pattern mustInRelationeBounds_reference_ETypeParameter(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eBounds reference ETypeParameter");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eBounds reference ETypeParameter(source,target)
 */
private pattern mayInRelationeBounds_reference_ETypeParameter(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfETypeParameter_class(problem,interpretation,source);
	find mayInstanceOfEGenericType_class(problem,interpretation,target);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationeBounds_reference_ETypeParameter(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []iD attribute EAttribute(source,target)
 */
private pattern mustInRelationiD_attribute_EAttribute(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"iD attribute EAttribute");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>iD attribute EAttribute(source,target)
 */
private pattern mayInRelationiD_attribute_EAttribute(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEAttribute_class(problem,interpretation,source);
	BooleanElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationiD_attribute_EAttribute(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationiD_attribute_EAttribute(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []source attribute EAnnotation(source,target)
 */
private pattern mustInRelationsource_attribute_EAnnotation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"source attribute EAnnotation");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>source attribute EAnnotation(source,target)
 */
private pattern mayInRelationsource_attribute_EAnnotation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEAnnotation_class(problem,interpretation,source);
	StringElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationsource_attribute_EAnnotation(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationsource_attribute_EAnnotation(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []abstract attribute EClass(source,target)
 */
private pattern mustInRelationabstract_attribute_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"abstract attribute EClass");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>abstract attribute EClass(source,target)
 */
private pattern mayInRelationabstract_attribute_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEClass_class(problem,interpretation,source);
	BooleanElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationabstract_attribute_EClass(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationabstract_attribute_EClass(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []interface attribute EClass(source,target)
 */
private pattern mustInRelationinterface_attribute_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"interface attribute EClass");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>interface attribute EClass(source,target)
 */
private pattern mayInRelationinterface_attribute_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEClass_class(problem,interpretation,source);
	BooleanElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationinterface_attribute_EClass(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationinterface_attribute_EClass(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []instanceClassName attribute EClassifier(source,target)
 */
private pattern mustInRelationinstanceClassName_attribute_EClassifier(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"instanceClassName attribute EClassifier");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>instanceClassName attribute EClassifier(source,target)
 */
private pattern mayInRelationinstanceClassName_attribute_EClassifier(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEClassifier_class(problem,interpretation,source);
	StringElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationinstanceClassName_attribute_EClassifier(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationinstanceClassName_attribute_EClassifier(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []instanceTypeName attribute EClassifier(source,target)
 */
private pattern mustInRelationinstanceTypeName_attribute_EClassifier(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"instanceTypeName attribute EClassifier");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>instanceTypeName attribute EClassifier(source,target)
 */
private pattern mayInRelationinstanceTypeName_attribute_EClassifier(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEClassifier_class(problem,interpretation,source);
	StringElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationinstanceTypeName_attribute_EClassifier(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationinstanceTypeName_attribute_EClassifier(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []serializable attribute EDataType(source,target)
 */
private pattern mustInRelationserializable_attribute_EDataType(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"serializable attribute EDataType");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>serializable attribute EDataType(source,target)
 */
private pattern mayInRelationserializable_attribute_EDataType(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEDataType_class(problem,interpretation,source);
	BooleanElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationserializable_attribute_EDataType(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationserializable_attribute_EDataType(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []value attribute EEnumLiteral(source,target)
 */
private pattern mustInRelationvalue_attribute_EEnumLiteral(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"value attribute EEnumLiteral");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>value attribute EEnumLiteral(source,target)
 */
private pattern mayInRelationvalue_attribute_EEnumLiteral(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEEnumLiteral_class(problem,interpretation,source);
	IntegerElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationvalue_attribute_EEnumLiteral(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationvalue_attribute_EEnumLiteral(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []literal attribute EEnumLiteral(source,target)
 */
private pattern mustInRelationliteral_attribute_EEnumLiteral(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"literal attribute EEnumLiteral");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>literal attribute EEnumLiteral(source,target)
 */
private pattern mayInRelationliteral_attribute_EEnumLiteral(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEEnumLiteral_class(problem,interpretation,source);
	StringElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationliteral_attribute_EEnumLiteral(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationliteral_attribute_EEnumLiteral(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []name attribute ENamedElement(source,target)
 */
private pattern mustInRelationname_attribute_ENamedElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"name attribute ENamedElement");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>name attribute ENamedElement(source,target)
 */
private pattern mayInRelationname_attribute_ENamedElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfENamedElement_class(problem,interpretation,source);
	StringElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationname_attribute_ENamedElement(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationname_attribute_ENamedElement(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []nsURI attribute EPackage(source,target)
 */
private pattern mustInRelationnsURI_attribute_EPackage(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"nsURI attribute EPackage");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>nsURI attribute EPackage(source,target)
 */
private pattern mayInRelationnsURI_attribute_EPackage(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEPackage_class(problem,interpretation,source);
	StringElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationnsURI_attribute_EPackage(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationnsURI_attribute_EPackage(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []nsPrefix attribute EPackage(source,target)
 */
private pattern mustInRelationnsPrefix_attribute_EPackage(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"nsPrefix attribute EPackage");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>nsPrefix attribute EPackage(source,target)
 */
private pattern mayInRelationnsPrefix_attribute_EPackage(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEPackage_class(problem,interpretation,source);
	StringElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationnsPrefix_attribute_EPackage(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationnsPrefix_attribute_EPackage(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []containment attribute EReference(source,target)
 */
private pattern mustInRelationcontainment_attribute_EReference(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"containment attribute EReference");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>containment attribute EReference(source,target)
 */
private pattern mayInRelationcontainment_attribute_EReference(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEReference_class(problem,interpretation,source);
	BooleanElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationcontainment_attribute_EReference(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationcontainment_attribute_EReference(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []container attribute EReference(source,target)
 */
private pattern mustInRelationcontainer_attribute_EReference(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"container attribute EReference");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>container attribute EReference(source,target)
 */
private pattern mayInRelationcontainer_attribute_EReference(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEReference_class(problem,interpretation,source);
	BooleanElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationcontainer_attribute_EReference(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationcontainer_attribute_EReference(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []resolveProxies attribute EReference(source,target)
 */
private pattern mustInRelationresolveProxies_attribute_EReference(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"resolveProxies attribute EReference");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>resolveProxies attribute EReference(source,target)
 */
private pattern mayInRelationresolveProxies_attribute_EReference(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEReference_class(problem,interpretation,source);
	BooleanElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationresolveProxies_attribute_EReference(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationresolveProxies_attribute_EReference(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []changeable attribute EStructuralFeature(source,target)
 */
private pattern mustInRelationchangeable_attribute_EStructuralFeature(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"changeable attribute EStructuralFeature");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>changeable attribute EStructuralFeature(source,target)
 */
private pattern mayInRelationchangeable_attribute_EStructuralFeature(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEStructuralFeature_class(problem,interpretation,source);
	BooleanElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationchangeable_attribute_EStructuralFeature(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationchangeable_attribute_EStructuralFeature(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []volatile attribute EStructuralFeature(source,target)
 */
private pattern mustInRelationvolatile_attribute_EStructuralFeature(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"volatile attribute EStructuralFeature");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>volatile attribute EStructuralFeature(source,target)
 */
private pattern mayInRelationvolatile_attribute_EStructuralFeature(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEStructuralFeature_class(problem,interpretation,source);
	BooleanElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationvolatile_attribute_EStructuralFeature(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationvolatile_attribute_EStructuralFeature(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []transient attribute EStructuralFeature(source,target)
 */
private pattern mustInRelationtransient_attribute_EStructuralFeature(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"transient attribute EStructuralFeature");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>transient attribute EStructuralFeature(source,target)
 */
private pattern mayInRelationtransient_attribute_EStructuralFeature(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEStructuralFeature_class(problem,interpretation,source);
	BooleanElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationtransient_attribute_EStructuralFeature(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationtransient_attribute_EStructuralFeature(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []defaultValueLiteral attribute EStructuralFeature(source,target)
 */
private pattern mustInRelationdefaultValueLiteral_attribute_EStructuralFeature(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"defaultValueLiteral attribute EStructuralFeature");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>defaultValueLiteral attribute EStructuralFeature(source,target)
 */
private pattern mayInRelationdefaultValueLiteral_attribute_EStructuralFeature(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEStructuralFeature_class(problem,interpretation,source);
	StringElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationdefaultValueLiteral_attribute_EStructuralFeature(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationdefaultValueLiteral_attribute_EStructuralFeature(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []unsettable attribute EStructuralFeature(source,target)
 */
private pattern mustInRelationunsettable_attribute_EStructuralFeature(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"unsettable attribute EStructuralFeature");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>unsettable attribute EStructuralFeature(source,target)
 */
private pattern mayInRelationunsettable_attribute_EStructuralFeature(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEStructuralFeature_class(problem,interpretation,source);
	BooleanElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationunsettable_attribute_EStructuralFeature(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationunsettable_attribute_EStructuralFeature(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []derived attribute EStructuralFeature(source,target)
 */
private pattern mustInRelationderived_attribute_EStructuralFeature(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"derived attribute EStructuralFeature");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>derived attribute EStructuralFeature(source,target)
 */
private pattern mayInRelationderived_attribute_EStructuralFeature(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEStructuralFeature_class(problem,interpretation,source);
	BooleanElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationderived_attribute_EStructuralFeature(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationderived_attribute_EStructuralFeature(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []ordered attribute ETypedElement(source,target)
 */
private pattern mustInRelationordered_attribute_ETypedElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"ordered attribute ETypedElement");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>ordered attribute ETypedElement(source,target)
 */
private pattern mayInRelationordered_attribute_ETypedElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfETypedElement_class(problem,interpretation,source);
	BooleanElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationordered_attribute_ETypedElement(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationordered_attribute_ETypedElement(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []unique attribute ETypedElement(source,target)
 */
private pattern mustInRelationunique_attribute_ETypedElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"unique attribute ETypedElement");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>unique attribute ETypedElement(source,target)
 */
private pattern mayInRelationunique_attribute_ETypedElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfETypedElement_class(problem,interpretation,source);
	BooleanElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationunique_attribute_ETypedElement(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationunique_attribute_ETypedElement(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []lowerBound attribute ETypedElement(source,target)
 */
private pattern mustInRelationlowerBound_attribute_ETypedElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"lowerBound attribute ETypedElement");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>lowerBound attribute ETypedElement(source,target)
 */
private pattern mayInRelationlowerBound_attribute_ETypedElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfETypedElement_class(problem,interpretation,source);
	IntegerElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationlowerBound_attribute_ETypedElement(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationlowerBound_attribute_ETypedElement(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []upperBound attribute ETypedElement(source,target)
 */
private pattern mustInRelationupperBound_attribute_ETypedElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"upperBound attribute ETypedElement");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>upperBound attribute ETypedElement(source,target)
 */
private pattern mayInRelationupperBound_attribute_ETypedElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfETypedElement_class(problem,interpretation,source);
	IntegerElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationupperBound_attribute_ETypedElement(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationupperBound_attribute_ETypedElement(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []many attribute ETypedElement(source,target)
 */
private pattern mustInRelationmany_attribute_ETypedElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"many attribute ETypedElement");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>many attribute ETypedElement(source,target)
 */
private pattern mayInRelationmany_attribute_ETypedElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfETypedElement_class(problem,interpretation,source);
	BooleanElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationmany_attribute_ETypedElement(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationmany_attribute_ETypedElement(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []required attribute ETypedElement(source,target)
 */
private pattern mustInRelationrequired_attribute_ETypedElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"required attribute ETypedElement");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>required attribute ETypedElement(source,target)
 */
private pattern mayInRelationrequired_attribute_ETypedElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfETypedElement_class(problem,interpretation,source);
	BooleanElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationrequired_attribute_ETypedElement(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationrequired_attribute_ETypedElement(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []key attribute EStringToStringMapEntry(source,target)
 */
private pattern mustInRelationkey_attribute_EStringToStringMapEntry(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"key attribute EStringToStringMapEntry");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>key attribute EStringToStringMapEntry(source,target)
 */
private pattern mayInRelationkey_attribute_EStringToStringMapEntry(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEStringToStringMapEntry_class(problem,interpretation,source);
	StringElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationkey_attribute_EStringToStringMapEntry(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationkey_attribute_EStringToStringMapEntry(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []value attribute EStringToStringMapEntry(source,target)
 */
private pattern mustInRelationvalue_attribute_EStringToStringMapEntry(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"value attribute EStringToStringMapEntry");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>value attribute EStringToStringMapEntry(source,target)
 */
private pattern mayInRelationvalue_attribute_EStringToStringMapEntry(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEStringToStringMapEntry_class(problem,interpretation,source);
	StringElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationvalue_attribute_EStringToStringMapEntry(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationvalue_attribute_EStringToStringMapEntry(problem,interpretation,source,target);
}

//////////
// 1.3 Relation Definition Indexers
//////////

//////////
// 1.4 Containment Indexer
//////////
private pattern mustContains2(source: DefinedElement, target: DefinedElement) {
	find mustContains4(_,_,source,target);
}
	
private pattern mustContains4(problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target: DefinedElement)
	{ find mustInRelationdetails_reference_EAnnotation(problem,interpretation,source,target); }or
	
	{ find mustInRelationcontents_reference_EAnnotation(problem,interpretation,source,target); }or
	
	{ find mustInRelationeOperations_reference_EClass(problem,interpretation,source,target); }or
	
	{ find mustInRelationeStructuralFeatures_reference_EClass(problem,interpretation,source,target); }or
	
	{ find mustInRelationeGenericSuperTypes_reference_EClass(problem,interpretation,source,target); }or
	
	{ find mustInRelationeTypeParameters_reference_EClassifier(problem,interpretation,source,target); }or
	
	{ find mustInRelationeLiterals_reference_EEnum(problem,interpretation,source,target); }or
	
	{ find mustInRelationeAnnotations_reference_EModelElement(problem,interpretation,source,target); }or
	
	{ find mustInRelationeTypeParameters_reference_EOperation(problem,interpretation,source,target); }or
	
	{ find mustInRelationeParameters_reference_EOperation(problem,interpretation,source,target); }or
	
	{ find mustInRelationeGenericExceptions_reference_EOperation(problem,interpretation,source,target); }or
	
	{ find mustInRelationeClassifiers_reference_EPackage(problem,interpretation,source,target); }or
	
	{ find mustInRelationeSubpackages_reference_EPackage(problem,interpretation,source,target); }or
	
	{ find mustInRelationeGenericType_reference_ETypedElement(problem,interpretation,source,target); }or
	
	{ find mustInRelationeUpperBound_reference_EGenericType(problem,interpretation,source,target); }or
	
	{ find mustInRelationeTypeArguments_reference_EGenericType(problem,interpretation,source,target); }or
	
	{ find mustInRelationeLowerBound_reference_EGenericType(problem,interpretation,source,target); }or
	
	{ find mustInRelationeBounds_reference_ETypeParameter(problem,interpretation,source,target); }

private pattern mustTransitiveContains(source,target) {
	find mustContains2+(source,target);
}

//////////
// 2. Invalidation Indexers
//////////
// 2.1 Invalidated by WF Queries
//////////

//////////
// 3. Unfinishedness Indexers
//////////
// 3.1 Unfinishedness Measured by Multiplicity
//////////
pattern unfinishedLowerMultiplicity_eAttributeType_reference_EAttribute(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eAttributeType reference EAttribute");
	find mustInstanceOfEAttribute_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationeAttributeType_reference_EAttribute(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_eReferenceType_reference_EReference(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eReferenceType reference EReference");
	find mustInstanceOfEReference_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationeReferenceType_reference_EReference(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_eRawType_reference_EGenericType(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eRawType reference EGenericType");
	find mustInstanceOfEGenericType_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationeRawType_reference_EGenericType(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}

//////////
// 3.2 Unfinishedness Measured by WF Queries
//////////

//////////
// 4. Refinement Indexers
//////////
// 4.1 Object constructors
//////////
private pattern hasElementInContainment(problem:LogicProblem, interpretation:PartialInterpretation)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfEModelElement_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfEEnum_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfEAttribute_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfEObject_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfEClass_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfEClassifier_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfEEnumLiteral_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfEPackage_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfEOperation_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfEReference_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfEAnnotation_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfETypedElement_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfEStructuralFeature_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfEDataType_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfEParameter_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfENamedElement_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfEGenericType_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfETypeParameter_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfEModelElement_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfEModelElement_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfENamedElement_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfENamedElement_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfEPackage_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfEPackage_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}
pattern createObject_EAttribute_class_by_eStructuralFeatures_reference_EClass_with_eContainingClass_reference_EStructuralFeature(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"EAttribute class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"eStructuralFeatures reference EClass");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"eContainingClass reference EStructuralFeature");
	find mustInstanceOfEClass_class(problem,interpretation,container);
	find mayInstanceOfEAttribute_class(problem,interpretation,newObject);
	find mayInRelationeStructuralFeatures_reference_EClass(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_EAttribute_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"EAttribute class");
	find mayInstanceOfEAttribute_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_EAnnotation_class_by_eAnnotations_reference_EModelElement_with_eModelElement_reference_EAnnotation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"EAnnotation class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"eAnnotations reference EModelElement");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"eModelElement reference EAnnotation");
	find mustInstanceOfEModelElement_class(problem,interpretation,container);
	find mayInstanceOfEAnnotation_class(problem,interpretation,newObject);
	find mayInRelationeAnnotations_reference_EModelElement(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_EAnnotation_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"EAnnotation class");
	find mayInstanceOfEAnnotation_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_EReference_class_by_eStructuralFeatures_reference_EClass_with_eContainingClass_reference_EStructuralFeature(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"EReference class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"eStructuralFeatures reference EClass");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"eContainingClass reference EStructuralFeature");
	find mustInstanceOfEClass_class(problem,interpretation,container);
	find mayInstanceOfEReference_class(problem,interpretation,newObject);
	find mayInRelationeStructuralFeatures_reference_EClass(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_EReference_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"EReference class");
	find mayInstanceOfEReference_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_EObject_class_by_contents_reference_EAnnotation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"EObject class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"contents reference EAnnotation");
	find mustInstanceOfEAnnotation_class(problem,interpretation,container);
	find mayInstanceOfEObject_class(problem,interpretation,newObject);
	find mayInRelationcontents_reference_EAnnotation(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_EObject_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"EObject class");
	find mayInstanceOfEObject_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_EParameter_class_by_eParameters_reference_EOperation_with_eOperation_reference_EParameter(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"EParameter class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"eParameters reference EOperation");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"eOperation reference EParameter");
	find mustInstanceOfEOperation_class(problem,interpretation,container);
	find mayInstanceOfEParameter_class(problem,interpretation,newObject);
	find mayInRelationeParameters_reference_EOperation(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_EParameter_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"EParameter class");
	find mayInstanceOfEParameter_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_EPackage_class_UndefinedPart_by_eSubpackages_reference_EPackage_with_eSuperPackage_reference_EPackage(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"EPackage class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"eSubpackages reference EPackage");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"eSuperPackage reference EPackage");
	find mustInstanceOfEPackage_class(problem,interpretation,container);
	find mayInstanceOfEPackage_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationeSubpackages_reference_EPackage(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_EPackage_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"EPackage class UndefinedPart");
	find mayInstanceOfEPackage_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_EStringToStringMapEntry_class_by_details_reference_EAnnotation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"EStringToStringMapEntry class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"details reference EAnnotation");
	find mustInstanceOfEAnnotation_class(problem,interpretation,container);
	find mayInstanceOfEStringToStringMapEntry_class(problem,interpretation,newObject);
	find mayInRelationdetails_reference_EAnnotation(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_EStringToStringMapEntry_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"EStringToStringMapEntry class");
	find mayInstanceOfEStringToStringMapEntry_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_EEnum_class_by_eClassifiers_reference_EPackage_with_ePackage_reference_EClassifier(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"EEnum class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"eClassifiers reference EPackage");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"ePackage reference EClassifier");
	find mustInstanceOfEPackage_class(problem,interpretation,container);
	find mayInstanceOfEEnum_class(problem,interpretation,newObject);
	find mayInRelationeClassifiers_reference_EPackage(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_EEnum_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"EEnum class");
	find mayInstanceOfEEnum_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_EEnumLiteral_class_by_eLiterals_reference_EEnum_with_eEnum_reference_EEnumLiteral(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"EEnumLiteral class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"eLiterals reference EEnum");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"eEnum reference EEnumLiteral");
	find mustInstanceOfEEnum_class(problem,interpretation,container);
	find mayInstanceOfEEnumLiteral_class(problem,interpretation,newObject);
	find mayInRelationeLiterals_reference_EEnum(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_EEnumLiteral_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"EEnumLiteral class");
	find mayInstanceOfEEnumLiteral_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_EGenericType_class_by_eGenericSuperTypes_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"EGenericType class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"eGenericSuperTypes reference EClass");
	find mustInstanceOfEClass_class(problem,interpretation,container);
	find mayInstanceOfEGenericType_class(problem,interpretation,newObject);
	find mayInRelationeGenericSuperTypes_reference_EClass(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_EGenericType_class_by_eGenericExceptions_reference_EOperation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"EGenericType class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"eGenericExceptions reference EOperation");
	find mustInstanceOfEOperation_class(problem,interpretation,container);
	find mayInstanceOfEGenericType_class(problem,interpretation,newObject);
	find mayInRelationeGenericExceptions_reference_EOperation(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_EGenericType_class_by_eGenericType_reference_ETypedElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"EGenericType class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"eGenericType reference ETypedElement");
	find mustInstanceOfETypedElement_class(problem,interpretation,container);
	find mayInstanceOfEGenericType_class(problem,interpretation,newObject);
	find mayInRelationeGenericType_reference_ETypedElement(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_EGenericType_class_by_eUpperBound_reference_EGenericType(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"EGenericType class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"eUpperBound reference EGenericType");
	find mustInstanceOfEGenericType_class(problem,interpretation,container);
	find mayInstanceOfEGenericType_class(problem,interpretation,newObject);
	find mayInRelationeUpperBound_reference_EGenericType(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_EGenericType_class_by_eTypeArguments_reference_EGenericType(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"EGenericType class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"eTypeArguments reference EGenericType");
	find mustInstanceOfEGenericType_class(problem,interpretation,container);
	find mayInstanceOfEGenericType_class(problem,interpretation,newObject);
	find mayInRelationeTypeArguments_reference_EGenericType(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_EGenericType_class_by_eLowerBound_reference_EGenericType(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"EGenericType class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"eLowerBound reference EGenericType");
	find mustInstanceOfEGenericType_class(problem,interpretation,container);
	find mayInstanceOfEGenericType_class(problem,interpretation,newObject);
	find mayInRelationeLowerBound_reference_EGenericType(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_EGenericType_class_by_eBounds_reference_ETypeParameter(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"EGenericType class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"eBounds reference ETypeParameter");
	find mustInstanceOfETypeParameter_class(problem,interpretation,container);
	find mayInstanceOfEGenericType_class(problem,interpretation,newObject);
	find mayInRelationeBounds_reference_ETypeParameter(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_EGenericType_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"EGenericType class");
	find mayInstanceOfEGenericType_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_EOperation_class_by_eOperations_reference_EClass_with_eContainingClass_reference_EOperation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"EOperation class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"eOperations reference EClass");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"eContainingClass reference EOperation");
	find mustInstanceOfEClass_class(problem,interpretation,container);
	find mayInstanceOfEOperation_class(problem,interpretation,newObject);
	find mayInRelationeOperations_reference_EClass(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_EOperation_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"EOperation class");
	find mayInstanceOfEOperation_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_EDataType_class_by_eClassifiers_reference_EPackage_with_ePackage_reference_EClassifier(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"EDataType class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"eClassifiers reference EPackage");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"ePackage reference EClassifier");
	find mustInstanceOfEPackage_class(problem,interpretation,container);
	find mayInstanceOfEDataType_class(problem,interpretation,newObject);
	find mayInRelationeClassifiers_reference_EPackage(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_EDataType_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"EDataType class");
	find mayInstanceOfEDataType_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_EClass_class_by_eClassifiers_reference_EPackage_with_ePackage_reference_EClassifier(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"EClass class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"eClassifiers reference EPackage");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"ePackage reference EClassifier");
	find mustInstanceOfEPackage_class(problem,interpretation,container);
	find mayInstanceOfEClass_class(problem,interpretation,newObject);
	find mayInRelationeClassifiers_reference_EPackage(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_EClass_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"EClass class");
	find mayInstanceOfEClass_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_ETypeParameter_class_by_eTypeParameters_reference_EClassifier(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"ETypeParameter class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"eTypeParameters reference EClassifier");
	find mustInstanceOfEClassifier_class(problem,interpretation,container);
	find mayInstanceOfETypeParameter_class(problem,interpretation,newObject);
	find mayInRelationeTypeParameters_reference_EClassifier(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_ETypeParameter_class_by_eTypeParameters_reference_EOperation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"ETypeParameter class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"eTypeParameters reference EOperation");
	find mustInstanceOfEOperation_class(problem,interpretation,container);
	find mayInstanceOfETypeParameter_class(problem,interpretation,newObject);
	find mayInRelationeTypeParameters_reference_EOperation(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_ETypeParameter_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"ETypeParameter class");
	find mayInstanceOfETypeParameter_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}

//////////
// 4.2 Type refinement
//////////
pattern refineTypeTo_EAttribute_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfEAttribute_class(problem,interpretation,element);
	neg find mustInstanceOfEAttribute_class(problem,interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEEnumLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEOperation_class(problem,interpretation,element);
	neg find mustInstanceOfEPackage_class(problem,interpretation,element);
	neg find mustInstanceOfETypeParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEReference_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfEParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEClassifier_class(problem,interpretation,element);
}
pattern refineTypeTo_EAnnotation_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfENamedElement_class(problem,interpretation,element);
}
pattern refineTypeTo_EReference_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfEReference_class(problem,interpretation,element);
	neg find mustInstanceOfEAttribute_class(problem,interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEEnumLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEOperation_class(problem,interpretation,element);
	neg find mustInstanceOfEPackage_class(problem,interpretation,element);
	neg find mustInstanceOfETypeParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEReference_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfEParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEClassifier_class(problem,interpretation,element);
}
pattern refineTypeTo_EObject_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfEModelElement_class(problem,interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
}
pattern refineTypeTo_EParameter_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfEParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEEnumLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEOperation_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEStructuralFeature_class(problem,interpretation,element);
	neg find mustInstanceOfEPackage_class(problem,interpretation,element);
	neg find mustInstanceOfETypeParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfEParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEClassifier_class(problem,interpretation,element);
}
pattern refineTypeTo_EPackage_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfEPackage_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfEPackage_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEEnumLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfETypeParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfETypedElement_class(problem,interpretation,element);
	neg find mustInstanceOfEClassifier_class(problem,interpretation,element);
}
pattern refineTypeTo_EStringToStringMapEntry_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEModelElement_class(problem,interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
}
pattern refineTypeTo_EEnum_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfEEnum_class(problem,interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEEnumLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfEEnum_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEClass_class(problem,interpretation,element);
	neg find mustInstanceOfEPackage_class(problem,interpretation,element);
	neg find mustInstanceOfETypeParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfETypedElement_class(problem,interpretation,element);
}
pattern refineTypeTo_EEnumLiteral_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfEEnumLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEEnumLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEPackage_class(problem,interpretation,element);
	neg find mustInstanceOfETypeParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfETypedElement_class(problem,interpretation,element);
	neg find mustInstanceOfEClassifier_class(problem,interpretation,element);
}
pattern refineTypeTo_EGenericType_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEModelElement_class(problem,interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
}
pattern refineTypeTo_EOperation_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfEOperation_class(problem,interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEEnumLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEOperation_class(problem,interpretation,element);
	neg find mustInstanceOfEStructuralFeature_class(problem,interpretation,element);
	neg find mustInstanceOfEPackage_class(problem,interpretation,element);
	neg find mustInstanceOfETypeParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfEParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEClassifier_class(problem,interpretation,element);
}
pattern refineTypeTo_EDataType_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfEDataType_class(problem,interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEEnum_class(problem,interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEEnumLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEDataType_class(problem,interpretation,element);
	neg find mustInstanceOfEPackage_class(problem,interpretation,element);
	neg find mustInstanceOfEClass_class(problem,interpretation,element);
	neg find mustInstanceOfETypeParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfETypedElement_class(problem,interpretation,element);
}
pattern refineTypeTo_EClass_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfEClass_class(problem,interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEEnumLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEDataType_class(problem,interpretation,element);
	neg find mustInstanceOfEPackage_class(problem,interpretation,element);
	neg find mustInstanceOfEClass_class(problem,interpretation,element);
	neg find mustInstanceOfETypeParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfETypedElement_class(problem,interpretation,element);
}
pattern refineTypeTo_ETypeParameter_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfETypeParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEEnumLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEPackage_class(problem,interpretation,element);
	neg find mustInstanceOfETypeParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfETypedElement_class(problem,interpretation,element);
	neg find mustInstanceOfEClassifier_class(problem,interpretation,element);
}

//////////
// 4.3 Relation refinement
//////////
pattern refineRelation_eAttributeType_reference_EAttribute(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eAttributeType reference EAttribute");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEAttribute_class(problem,interpretation,from);
	find mustInstanceOfEDataType_class(problem,interpretation,to);
	find mayInRelationeAttributeType_reference_EAttribute(problem,interpretation,from,to);
	neg find mustInRelationeAttributeType_reference_EAttribute(problem,interpretation,from,to);
}
pattern refineRelation_references_reference_EAnnotation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"references reference EAnnotation");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEAnnotation_class(problem,interpretation,from);
	find mustInstanceOfEObject_class(problem,interpretation,to);
	find mayInRelationreferences_reference_EAnnotation(problem,interpretation,from,to);
	neg find mustInRelationreferences_reference_EAnnotation(problem,interpretation,from,to);
}
pattern refineRelation_eSuperTypes_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eSuperTypes reference EClass");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEClass_class(problem,interpretation,from);
	find mustInstanceOfEClass_class(problem,interpretation,to);
	find mayInRelationeSuperTypes_reference_EClass(problem,interpretation,from,to);
	neg find mustInRelationeSuperTypes_reference_EClass(problem,interpretation,from,to);
}
pattern refineRelation_eAllAttributes_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eAllAttributes reference EClass");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEClass_class(problem,interpretation,from);
	find mustInstanceOfEAttribute_class(problem,interpretation,to);
	find mayInRelationeAllAttributes_reference_EClass(problem,interpretation,from,to);
	neg find mustInRelationeAllAttributes_reference_EClass(problem,interpretation,from,to);
}
pattern refineRelation_eAllReferences_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eAllReferences reference EClass");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEClass_class(problem,interpretation,from);
	find mustInstanceOfEReference_class(problem,interpretation,to);
	find mayInRelationeAllReferences_reference_EClass(problem,interpretation,from,to);
	neg find mustInRelationeAllReferences_reference_EClass(problem,interpretation,from,to);
}
pattern refineRelation_eReferences_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eReferences reference EClass");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEClass_class(problem,interpretation,from);
	find mustInstanceOfEReference_class(problem,interpretation,to);
	find mayInRelationeReferences_reference_EClass(problem,interpretation,from,to);
	neg find mustInRelationeReferences_reference_EClass(problem,interpretation,from,to);
}
pattern refineRelation_eAttributes_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eAttributes reference EClass");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEClass_class(problem,interpretation,from);
	find mustInstanceOfEAttribute_class(problem,interpretation,to);
	find mayInRelationeAttributes_reference_EClass(problem,interpretation,from,to);
	neg find mustInRelationeAttributes_reference_EClass(problem,interpretation,from,to);
}
pattern refineRelation_eAllContainments_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eAllContainments reference EClass");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEClass_class(problem,interpretation,from);
	find mustInstanceOfEReference_class(problem,interpretation,to);
	find mayInRelationeAllContainments_reference_EClass(problem,interpretation,from,to);
	neg find mustInRelationeAllContainments_reference_EClass(problem,interpretation,from,to);
}
pattern refineRelation_eAllOperations_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eAllOperations reference EClass");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEClass_class(problem,interpretation,from);
	find mustInstanceOfEOperation_class(problem,interpretation,to);
	find mayInRelationeAllOperations_reference_EClass(problem,interpretation,from,to);
	neg find mustInRelationeAllOperations_reference_EClass(problem,interpretation,from,to);
}
pattern refineRelation_eAllStructuralFeatures_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eAllStructuralFeatures reference EClass");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEClass_class(problem,interpretation,from);
	find mustInstanceOfEStructuralFeature_class(problem,interpretation,to);
	find mayInRelationeAllStructuralFeatures_reference_EClass(problem,interpretation,from,to);
	neg find mustInRelationeAllStructuralFeatures_reference_EClass(problem,interpretation,from,to);
}
pattern refineRelation_eAllSuperTypes_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eAllSuperTypes reference EClass");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEClass_class(problem,interpretation,from);
	find mustInstanceOfEClass_class(problem,interpretation,to);
	find mayInRelationeAllSuperTypes_reference_EClass(problem,interpretation,from,to);
	neg find mustInRelationeAllSuperTypes_reference_EClass(problem,interpretation,from,to);
}
pattern refineRelation_eIDAttribute_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eIDAttribute reference EClass");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEClass_class(problem,interpretation,from);
	find mustInstanceOfEAttribute_class(problem,interpretation,to);
	find mayInRelationeIDAttribute_reference_EClass(problem,interpretation,from,to);
	neg find mustInRelationeIDAttribute_reference_EClass(problem,interpretation,from,to);
}
pattern refineRelation_eAllGenericSuperTypes_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eAllGenericSuperTypes reference EClass");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEClass_class(problem,interpretation,from);
	find mustInstanceOfEGenericType_class(problem,interpretation,to);
	find mayInRelationeAllGenericSuperTypes_reference_EClass(problem,interpretation,from,to);
	neg find mustInRelationeAllGenericSuperTypes_reference_EClass(problem,interpretation,from,to);
}
pattern refineRelation_eExceptions_reference_EOperation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eExceptions reference EOperation");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEOperation_class(problem,interpretation,from);
	find mustInstanceOfEClassifier_class(problem,interpretation,to);
	find mayInRelationeExceptions_reference_EOperation(problem,interpretation,from,to);
	neg find mustInRelationeExceptions_reference_EOperation(problem,interpretation,from,to);
}
pattern refineRelation_eOpposite_reference_EReference(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eOpposite reference EReference");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEReference_class(problem,interpretation,from);
	find mustInstanceOfEReference_class(problem,interpretation,to);
	find mayInRelationeOpposite_reference_EReference(problem,interpretation,from,to);
	neg find mustInRelationeOpposite_reference_EReference(problem,interpretation,from,to);
}
pattern refineRelation_eReferenceType_reference_EReference(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eReferenceType reference EReference");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEReference_class(problem,interpretation,from);
	find mustInstanceOfEClass_class(problem,interpretation,to);
	find mayInRelationeReferenceType_reference_EReference(problem,interpretation,from,to);
	neg find mustInRelationeReferenceType_reference_EReference(problem,interpretation,from,to);
}
pattern refineRelation_eKeys_reference_EReference(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eKeys reference EReference");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEReference_class(problem,interpretation,from);
	find mustInstanceOfEAttribute_class(problem,interpretation,to);
	find mayInRelationeKeys_reference_EReference(problem,interpretation,from,to);
	neg find mustInRelationeKeys_reference_EReference(problem,interpretation,from,to);
}
pattern refineRelation_eType_reference_ETypedElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eType reference ETypedElement");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfETypedElement_class(problem,interpretation,from);
	find mustInstanceOfEClassifier_class(problem,interpretation,to);
	find mayInRelationeType_reference_ETypedElement(problem,interpretation,from,to);
	neg find mustInRelationeType_reference_ETypedElement(problem,interpretation,from,to);
}
pattern refineRelation_eRawType_reference_EGenericType(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eRawType reference EGenericType");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEGenericType_class(problem,interpretation,from);
	find mustInstanceOfEClassifier_class(problem,interpretation,to);
	find mayInRelationeRawType_reference_EGenericType(problem,interpretation,from,to);
	neg find mustInRelationeRawType_reference_EGenericType(problem,interpretation,from,to);
}
pattern refineRelation_eTypeParameter_reference_EGenericType(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eTypeParameter reference EGenericType");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEGenericType_class(problem,interpretation,from);
	find mustInstanceOfETypeParameter_class(problem,interpretation,to);
	find mayInRelationeTypeParameter_reference_EGenericType(problem,interpretation,from,to);
	neg find mustInRelationeTypeParameter_reference_EGenericType(problem,interpretation,from,to);
}
pattern refineRelation_eClassifier_reference_EGenericType(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eClassifier reference EGenericType");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEGenericType_class(problem,interpretation,from);
	find mustInstanceOfEClassifier_class(problem,interpretation,to);
	find mayInRelationeClassifier_reference_EGenericType(problem,interpretation,from,to);
	neg find mustInRelationeClassifier_reference_EGenericType(problem,interpretation,from,to);
}
pattern refineRelation_iD_attribute_EAttribute(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"iD attribute EAttribute");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEAttribute_class(problem,interpretation,from);
	BooleanElement(to);
	find mayInRelationiD_attribute_EAttribute(problem,interpretation,from,to);
	neg find mustInRelationiD_attribute_EAttribute(problem,interpretation,from,to);
}
pattern refineRelation_source_attribute_EAnnotation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"source attribute EAnnotation");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEAnnotation_class(problem,interpretation,from);
	StringElement(to);
	find mayInRelationsource_attribute_EAnnotation(problem,interpretation,from,to);
	neg find mustInRelationsource_attribute_EAnnotation(problem,interpretation,from,to);
}
pattern refineRelation_abstract_attribute_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"abstract attribute EClass");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEClass_class(problem,interpretation,from);
	BooleanElement(to);
	find mayInRelationabstract_attribute_EClass(problem,interpretation,from,to);
	neg find mustInRelationabstract_attribute_EClass(problem,interpretation,from,to);
}
pattern refineRelation_interface_attribute_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"interface attribute EClass");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEClass_class(problem,interpretation,from);
	BooleanElement(to);
	find mayInRelationinterface_attribute_EClass(problem,interpretation,from,to);
	neg find mustInRelationinterface_attribute_EClass(problem,interpretation,from,to);
}
pattern refineRelation_instanceClassName_attribute_EClassifier(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"instanceClassName attribute EClassifier");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEClassifier_class(problem,interpretation,from);
	StringElement(to);
	find mayInRelationinstanceClassName_attribute_EClassifier(problem,interpretation,from,to);
	neg find mustInRelationinstanceClassName_attribute_EClassifier(problem,interpretation,from,to);
}
pattern refineRelation_instanceTypeName_attribute_EClassifier(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"instanceTypeName attribute EClassifier");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEClassifier_class(problem,interpretation,from);
	StringElement(to);
	find mayInRelationinstanceTypeName_attribute_EClassifier(problem,interpretation,from,to);
	neg find mustInRelationinstanceTypeName_attribute_EClassifier(problem,interpretation,from,to);
}
pattern refineRelation_serializable_attribute_EDataType(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"serializable attribute EDataType");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEDataType_class(problem,interpretation,from);
	BooleanElement(to);
	find mayInRelationserializable_attribute_EDataType(problem,interpretation,from,to);
	neg find mustInRelationserializable_attribute_EDataType(problem,interpretation,from,to);
}
pattern refineRelation_value_attribute_EEnumLiteral(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"value attribute EEnumLiteral");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEEnumLiteral_class(problem,interpretation,from);
	IntegerElement(to);
	find mayInRelationvalue_attribute_EEnumLiteral(problem,interpretation,from,to);
	neg find mustInRelationvalue_attribute_EEnumLiteral(problem,interpretation,from,to);
}
pattern refineRelation_literal_attribute_EEnumLiteral(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"literal attribute EEnumLiteral");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEEnumLiteral_class(problem,interpretation,from);
	StringElement(to);
	find mayInRelationliteral_attribute_EEnumLiteral(problem,interpretation,from,to);
	neg find mustInRelationliteral_attribute_EEnumLiteral(problem,interpretation,from,to);
}
pattern refineRelation_name_attribute_ENamedElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"name attribute ENamedElement");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfENamedElement_class(problem,interpretation,from);
	StringElement(to);
	find mayInRelationname_attribute_ENamedElement(problem,interpretation,from,to);
	neg find mustInRelationname_attribute_ENamedElement(problem,interpretation,from,to);
}
pattern refineRelation_nsURI_attribute_EPackage(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"nsURI attribute EPackage");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEPackage_class(problem,interpretation,from);
	StringElement(to);
	find mayInRelationnsURI_attribute_EPackage(problem,interpretation,from,to);
	neg find mustInRelationnsURI_attribute_EPackage(problem,interpretation,from,to);
}
pattern refineRelation_nsPrefix_attribute_EPackage(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"nsPrefix attribute EPackage");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEPackage_class(problem,interpretation,from);
	StringElement(to);
	find mayInRelationnsPrefix_attribute_EPackage(problem,interpretation,from,to);
	neg find mustInRelationnsPrefix_attribute_EPackage(problem,interpretation,from,to);
}
pattern refineRelation_containment_attribute_EReference(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"containment attribute EReference");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEReference_class(problem,interpretation,from);
	BooleanElement(to);
	find mayInRelationcontainment_attribute_EReference(problem,interpretation,from,to);
	neg find mustInRelationcontainment_attribute_EReference(problem,interpretation,from,to);
}
pattern refineRelation_container_attribute_EReference(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"container attribute EReference");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEReference_class(problem,interpretation,from);
	BooleanElement(to);
	find mayInRelationcontainer_attribute_EReference(problem,interpretation,from,to);
	neg find mustInRelationcontainer_attribute_EReference(problem,interpretation,from,to);
}
pattern refineRelation_resolveProxies_attribute_EReference(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"resolveProxies attribute EReference");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEReference_class(problem,interpretation,from);
	BooleanElement(to);
	find mayInRelationresolveProxies_attribute_EReference(problem,interpretation,from,to);
	neg find mustInRelationresolveProxies_attribute_EReference(problem,interpretation,from,to);
}
pattern refineRelation_changeable_attribute_EStructuralFeature(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"changeable attribute EStructuralFeature");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEStructuralFeature_class(problem,interpretation,from);
	BooleanElement(to);
	find mayInRelationchangeable_attribute_EStructuralFeature(problem,interpretation,from,to);
	neg find mustInRelationchangeable_attribute_EStructuralFeature(problem,interpretation,from,to);
}
pattern refineRelation_volatile_attribute_EStructuralFeature(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"volatile attribute EStructuralFeature");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEStructuralFeature_class(problem,interpretation,from);
	BooleanElement(to);
	find mayInRelationvolatile_attribute_EStructuralFeature(problem,interpretation,from,to);
	neg find mustInRelationvolatile_attribute_EStructuralFeature(problem,interpretation,from,to);
}
pattern refineRelation_transient_attribute_EStructuralFeature(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"transient attribute EStructuralFeature");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEStructuralFeature_class(problem,interpretation,from);
	BooleanElement(to);
	find mayInRelationtransient_attribute_EStructuralFeature(problem,interpretation,from,to);
	neg find mustInRelationtransient_attribute_EStructuralFeature(problem,interpretation,from,to);
}
pattern refineRelation_defaultValueLiteral_attribute_EStructuralFeature(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"defaultValueLiteral attribute EStructuralFeature");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEStructuralFeature_class(problem,interpretation,from);
	StringElement(to);
	find mayInRelationdefaultValueLiteral_attribute_EStructuralFeature(problem,interpretation,from,to);
	neg find mustInRelationdefaultValueLiteral_attribute_EStructuralFeature(problem,interpretation,from,to);
}
pattern refineRelation_unsettable_attribute_EStructuralFeature(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"unsettable attribute EStructuralFeature");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEStructuralFeature_class(problem,interpretation,from);
	BooleanElement(to);
	find mayInRelationunsettable_attribute_EStructuralFeature(problem,interpretation,from,to);
	neg find mustInRelationunsettable_attribute_EStructuralFeature(problem,interpretation,from,to);
}
pattern refineRelation_derived_attribute_EStructuralFeature(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"derived attribute EStructuralFeature");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEStructuralFeature_class(problem,interpretation,from);
	BooleanElement(to);
	find mayInRelationderived_attribute_EStructuralFeature(problem,interpretation,from,to);
	neg find mustInRelationderived_attribute_EStructuralFeature(problem,interpretation,from,to);
}
pattern refineRelation_ordered_attribute_ETypedElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"ordered attribute ETypedElement");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfETypedElement_class(problem,interpretation,from);
	BooleanElement(to);
	find mayInRelationordered_attribute_ETypedElement(problem,interpretation,from,to);
	neg find mustInRelationordered_attribute_ETypedElement(problem,interpretation,from,to);
}
pattern refineRelation_unique_attribute_ETypedElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"unique attribute ETypedElement");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfETypedElement_class(problem,interpretation,from);
	BooleanElement(to);
	find mayInRelationunique_attribute_ETypedElement(problem,interpretation,from,to);
	neg find mustInRelationunique_attribute_ETypedElement(problem,interpretation,from,to);
}
pattern refineRelation_lowerBound_attribute_ETypedElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"lowerBound attribute ETypedElement");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfETypedElement_class(problem,interpretation,from);
	IntegerElement(to);
	find mayInRelationlowerBound_attribute_ETypedElement(problem,interpretation,from,to);
	neg find mustInRelationlowerBound_attribute_ETypedElement(problem,interpretation,from,to);
}
pattern refineRelation_upperBound_attribute_ETypedElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"upperBound attribute ETypedElement");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfETypedElement_class(problem,interpretation,from);
	IntegerElement(to);
	find mayInRelationupperBound_attribute_ETypedElement(problem,interpretation,from,to);
	neg find mustInRelationupperBound_attribute_ETypedElement(problem,interpretation,from,to);
}
pattern refineRelation_many_attribute_ETypedElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"many attribute ETypedElement");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfETypedElement_class(problem,interpretation,from);
	BooleanElement(to);
	find mayInRelationmany_attribute_ETypedElement(problem,interpretation,from,to);
	neg find mustInRelationmany_attribute_ETypedElement(problem,interpretation,from,to);
}
pattern refineRelation_required_attribute_ETypedElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"required attribute ETypedElement");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfETypedElement_class(problem,interpretation,from);
	BooleanElement(to);
	find mayInRelationrequired_attribute_ETypedElement(problem,interpretation,from,to);
	neg find mustInRelationrequired_attribute_ETypedElement(problem,interpretation,from,to);
}
pattern refineRelation_key_attribute_EStringToStringMapEntry(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"key attribute EStringToStringMapEntry");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,from);
	StringElement(to);
	find mayInRelationkey_attribute_EStringToStringMapEntry(problem,interpretation,from,to);
	neg find mustInRelationkey_attribute_EStringToStringMapEntry(problem,interpretation,from,to);
}
pattern refineRelation_value_attribute_EStringToStringMapEntry(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"value attribute EStringToStringMapEntry");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,from);
	StringElement(to);
	find mayInRelationvalue_attribute_EStringToStringMapEntry(problem,interpretation,from,to);
	neg find mustInRelationvalue_attribute_EStringToStringMapEntry(problem,interpretation,from,to);
}
import epackage "http://www.bme.hu/mit/inf/dslreasoner/viatrasolver/partialinterpretationlanguage"
import epackage "http://www.bme.hu/mit/inf/dslreasoner/logic/model/problem"
import epackage "http://www.bme.hu/mit/inf/dslreasoner/logic/model/language"

//////////
// 0. Util
//////////
private pattern interpretation(problem:LogicProblem, interpretation:PartialInterpretation) {
	PartialInterpretation.problem(interpretation,problem);
}
	
/////////////////////////
// 0.1 Existence
/////////////////////////
private pattern mustExist(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	find interpretation(problem,interpretation);
	LogicProblem.elements(problem,element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
}

private pattern mayExist(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
    find mustExist(problem,interpretation,element);
} or {
    find interpretation(problem,interpretation);
    neg find elementCloseWorld(element);
    PartialInterpretation.openWorldElements(interpretation,element);
}

private pattern elementCloseWorld(element:DefinedElement) {
	PartialInterpretation.openWorldElements(i,element);
    PartialInterpretation.maxNewElements(i,0);
} or {
	Scope.targetTypeInterpretation(scope,interpretation);
	PartialTypeInterpratation.elements(interpretation,element);
	Scope.maxNewElements(scope,0);
}

////////////////////////
// 0.2 Equivalence
////////////////////////
pattern mayEquivalent(problem:LogicProblem, interpretation:PartialInterpretation, a: DefinedElement, b: DefinedElement) {
	find mayExist(problem,interpretation,a);
	find mayExist(problem,interpretation,b);
	a == b;
}

////////////////////////
// 0.3 Required Patterns by TypeIndexer
////////////////////////
private pattern typeInterpretation(problem:LogicProblem, interpretation:PartialInterpretation, type:TypeDeclaration, typeInterpretation:PartialComplexTypeInterpretation) {
	find interpretation(problem,interpretation);
	LogicProblem.types(problem,type);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
}

private pattern directInstanceOf(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement, type:Type) {
	find interpretation(problem,interpretation);
	LogicProblem.types(problem,type);
	TypeDefinition.elements(type,element);
} or {
	find interpretation(problem,interpretation);
	find typeInterpretation(problem,interpretation,type,typeInterpretation);
	PartialComplexTypeInterpretation.elements(typeInterpretation,element);
}

private pattern isPrimitive(element: PrimitiveElement) {
	PrimitiveElement(element);
}

//////////
// 1. Problem-Specific Base Indexers
//////////
// 1.1 Type Indexers
//////////
// 1.1.1 primitive Type Indexers
//////////

//////////
// 1.1.2 domain-specific Type Indexers
//////////
/**
 * An element must be an instance of type "FunctionalElement class".
 */
private pattern mustInstanceOfFunctionalElement_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalElement class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalElement_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalElement class");
}

/**
 * An element may be an instance of type "FunctionalElement class".
 */
private pattern mayInstanceOfFunctionalElement_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunction_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalElement_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunction_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalElement_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalElement_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalArchitectureModel class".
 */
private pattern mustInstanceOfFunctionalArchitectureModel_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalArchitectureModel class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalArchitectureModel_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalArchitectureModel class");
}

/**
 * An element may be an instance of type "FunctionalArchitectureModel class".
 */
private pattern mayInstanceOfFunctionalArchitectureModel_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalArchitectureModel_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalArchitectureModel_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Function class".
 */
private pattern mustInstanceOfFunction_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Function class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunction_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Function class");
}

/**
 * An element may be an instance of type "Function class".
 */
private pattern mayInstanceOfFunction_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunction_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunction_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunction_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FAMTerminator class".
 */
private pattern mustInstanceOfFAMTerminator_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FAMTerminator class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFAMTerminator_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FAMTerminator class");
}

/**
 * An element may be an instance of type "FAMTerminator class".
 */
private pattern mayInstanceOfFAMTerminator_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find scopeDisallowsNewFAMTerminator_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find scopeDisallowsNewFAMTerminator_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFAMTerminator_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "InformationLink class".
 */
private pattern mustInstanceOfInformationLink_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"InformationLink class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewInformationLink_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"InformationLink class");
}

/**
 * An element may be an instance of type "InformationLink class".
 */
private pattern mayInstanceOfInformationLink_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find scopeDisallowsNewInformationLink_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find scopeDisallowsNewInformationLink_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfInformationLink_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalInterface class".
 */
private pattern mustInstanceOfFunctionalInterface_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalInterface class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalInterface_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalInterface class");
}

/**
 * An element may be an instance of type "FunctionalInterface class".
 */
private pattern mayInstanceOfFunctionalInterface_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalInterface_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalInterface_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalInterface_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalInput class".
 */
private pattern mustInstanceOfFunctionalInput_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalInput class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalInput_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalInput class");
}

/**
 * An element may be an instance of type "FunctionalInput class".
 */
private pattern mayInstanceOfFunctionalInput_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalInput_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalInput_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalInput_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalOutput class".
 */
private pattern mustInstanceOfFunctionalOutput_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalOutput class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalOutput_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalOutput class");
}

/**
 * An element may be an instance of type "FunctionalOutput class".
 */
private pattern mayInstanceOfFunctionalOutput_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalOutput_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalOutput_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalOutput_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalData class".
 */
private pattern mustInstanceOfFunctionalData_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalData class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalData_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalData class");
}

/**
 * An element may be an instance of type "FunctionalData class".
 */
private pattern mayInstanceOfFunctionalData_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalData_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalData_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalData_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionType enum".
 */
private pattern mustInstanceOfFunctionType_enum(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionType enum");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionType_enum(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionType enum");
}

/**
 * An element may be an instance of type "FunctionType enum".
 */
private pattern mayInstanceOfFunctionType_enum(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfFunctionType_enum(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalArchitectureModel class DefinedPart".
 */
private pattern mustInstanceOfFunctionalArchitectureModel_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalArchitectureModel class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalArchitectureModel_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalArchitectureModel class DefinedPart");
}

/**
 * An element may be an instance of type "FunctionalArchitectureModel class DefinedPart".
 */
private pattern mayInstanceOfFunctionalArchitectureModel_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfFunctionalArchitectureModel_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalArchitectureModel class UndefinedPart".
 */
private pattern mustInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalArchitectureModel class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalArchitectureModel_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalArchitectureModel class UndefinedPart");
}

/**
 * An element may be an instance of type "FunctionalArchitectureModel class UndefinedPart".
 */
private pattern mayInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalArchitectureModel_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalArchitectureModel_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem,interpretation,element); }

//////////
// 1.2 Relation Declaration Indexers
//////////
/**
 * Matcher for detecting tuples t where []interface reference FunctionalElement(source,target)
 */
private pattern mustInRelationinterface_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"interface reference FunctionalElement");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>interface reference FunctionalElement(source,target)
 */
private pattern mayInRelationinterface_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalElement_class(problem,interpretation,source);
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationinterface_reference_FunctionalElement(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationelement_reference_FunctionalInterface(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationinterface_reference_FunctionalElement(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []model reference FunctionalElement(source,target)
 */
private pattern mustInRelationmodel_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"model reference FunctionalElement");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>model reference FunctionalElement(source,target)
 */
private pattern mayInRelationmodel_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalElement_class(problem,interpretation,source);
	find mayInstanceOfFunctionalArchitectureModel_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationmodel_reference_FunctionalElement(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationmodel_reference_FunctionalElement(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []parent reference FunctionalElement(source,target)
 */
private pattern mustInRelationparent_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"parent reference FunctionalElement");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>parent reference FunctionalElement(source,target)
 */
private pattern mayInRelationparent_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalElement_class(problem,interpretation,source);
	find mayInstanceOfFunction_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationparent_reference_FunctionalElement(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationparent_reference_FunctionalElement(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []rootElements reference FunctionalArchitectureModel(source,target)
 */
private pattern mustInRelationrootElements_reference_FunctionalArchitectureModel(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"rootElements reference FunctionalArchitectureModel");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>rootElements reference FunctionalArchitectureModel(source,target)
 */
private pattern mayInRelationrootElements_reference_FunctionalArchitectureModel(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalArchitectureModel_class(problem,interpretation,source);
	find mayInstanceOfFunctionalElement_class(problem,interpretation,target);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationrootElements_reference_FunctionalArchitectureModel(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []subElements reference Function(source,target)
 */
private pattern mustInRelationsubElements_reference_Function(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"subElements reference Function");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>subElements reference Function(source,target)
 */
private pattern mayInRelationsubElements_reference_Function(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunction_class(problem,interpretation,source);
	find mayInstanceOfFunctionalElement_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationparent_reference_FunctionalElement(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationsubElements_reference_Function(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []data reference FAMTerminator(source,target)
 */
private pattern mustInRelationdata_reference_FAMTerminator(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"data reference FAMTerminator");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>data reference FAMTerminator(source,target)
 */
private pattern mayInRelationdata_reference_FAMTerminator(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFAMTerminator_class(problem,interpretation,source);
	find mayInstanceOfFunctionalData_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationdata_reference_FAMTerminator(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationterminator_reference_FunctionalData(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationdata_reference_FAMTerminator(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []from reference InformationLink(source,target)
 */
private pattern mustInRelationfrom_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"from reference InformationLink");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>from reference InformationLink(source,target)
 */
private pattern mayInRelationfrom_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfInformationLink_class(problem,interpretation,source);
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationfrom_reference_InformationLink(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationfrom_reference_InformationLink(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []to reference InformationLink(source,target)
 */
private pattern mustInRelationto_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"to reference InformationLink");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>to reference InformationLink(source,target)
 */
private pattern mayInRelationto_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfInformationLink_class(problem,interpretation,source);
	find mayInstanceOfFunctionalInput_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationto_reference_InformationLink(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationto_reference_InformationLink(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []data reference FunctionalInterface(source,target)
 */
private pattern mustInRelationdata_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"data reference FunctionalInterface");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>data reference FunctionalInterface(source,target)
 */
private pattern mayInRelationdata_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,source);
	find mayInstanceOfFunctionalData_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationinterface_reference_FunctionalData(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationdata_reference_FunctionalInterface(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []element reference FunctionalInterface(source,target)
 */
private pattern mustInRelationelement_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"element reference FunctionalInterface");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>element reference FunctionalInterface(source,target)
 */
private pattern mayInRelationelement_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,source);
	find mayInstanceOfFunctionalElement_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationelement_reference_FunctionalInterface(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationinterface_reference_FunctionalElement(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationelement_reference_FunctionalInterface(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []IncomingLinks reference FunctionalInput(source,target)
 */
private pattern mustInRelationIncomingLinks_reference_FunctionalInput(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"IncomingLinks reference FunctionalInput");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>IncomingLinks reference FunctionalInput(source,target)
 */
private pattern mayInRelationIncomingLinks_reference_FunctionalInput(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalInput_class(problem,interpretation,source);
	find mayInstanceOfInformationLink_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationto_reference_InformationLink(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
} or {
	find mustInRelationIncomingLinks_reference_FunctionalInput(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []outgoingLinks reference FunctionalOutput(source,target)
 */
private pattern mustInRelationoutgoingLinks_reference_FunctionalOutput(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"outgoingLinks reference FunctionalOutput");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>outgoingLinks reference FunctionalOutput(source,target)
 */
private pattern mayInRelationoutgoingLinks_reference_FunctionalOutput(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,source);
	find mayInstanceOfInformationLink_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationfrom_reference_InformationLink(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationoutgoingLinks_reference_FunctionalOutput(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []terminator reference FunctionalData(source,target)
 */
private pattern mustInRelationterminator_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"terminator reference FunctionalData");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>terminator reference FunctionalData(source,target)
 */
private pattern mayInRelationterminator_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalData_class(problem,interpretation,source);
	find mayInstanceOfFAMTerminator_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationterminator_reference_FunctionalData(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationdata_reference_FAMTerminator(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationterminator_reference_FunctionalData(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []interface reference FunctionalData(source,target)
 */
private pattern mustInRelationinterface_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"interface reference FunctionalData");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>interface reference FunctionalData(source,target)
 */
private pattern mayInRelationinterface_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalData_class(problem,interpretation,source);
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationinterface_reference_FunctionalData(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationinterface_reference_FunctionalData(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []type attribute Function(source,target)
 */
private pattern mustInRelationtype_attribute_Function(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"type attribute Function");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>type attribute Function(source,target)
 */
private pattern mayInRelationtype_attribute_Function(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunction_class(problem,interpretation,source);
	find mayInstanceOfFunctionType_enum(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationtype_attribute_Function(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationtype_attribute_Function(problem,interpretation,source,target);
}

//////////
// 1.3 Relation Definition Indexers
//////////

//////////
// 1.4 Containment Indexer
//////////
private pattern mustContains2(source: DefinedElement, target: DefinedElement) {
	find mustContains4(_,_,source,target);
}
	
private pattern mustContains4(problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target: DefinedElement)
	{ find mustInRelationinterface_reference_FunctionalElement(problem,interpretation,source,target); }or
	
	{ find mustInRelationrootElements_reference_FunctionalArchitectureModel(problem,interpretation,source,target); }or
	
	{ find mustInRelationsubElements_reference_Function(problem,interpretation,source,target); }or
	
	{ find mustInRelationdata_reference_FunctionalInterface(problem,interpretation,source,target); }or
	
	{ find mustInRelationoutgoingLinks_reference_FunctionalOutput(problem,interpretation,source,target); }or
	
	{ find mustInRelationterminator_reference_FunctionalData(problem,interpretation,source,target); }

private pattern mustTransitiveContains(source,target) {
	find mustContains2+(source,target);
}

//////////
// 2. Invalidation Indexers
//////////
// 2.1 Invalidated by WF Queries
//////////

//////////
// 3. Unfinishedness Indexers
//////////
// 3.1 Unfinishedness Measured by Multiplicity
//////////
pattern unfinishedLowerMultiplicity_model_reference_FunctionalElement(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"model reference FunctionalElement");
	find mustInstanceOfFunctionalElement_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationmodel_reference_FunctionalElement(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_to_reference_InformationLink(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"to reference InformationLink");
	find mustInstanceOfInformationLink_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationto_reference_InformationLink(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_type_attribute_Function(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"type attribute Function");
	find mustInstanceOfFunction_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationtype_attribute_Function(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}

//////////
// 3.2 Unfinishedness Measured by WF Queries
//////////

//////////
// 4. Refinement Indexers
//////////
// 4.1 Object constructors
//////////
private pattern hasElementInContainment(problem:LogicProblem, interpretation:PartialInterpretation)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalInput_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFAMTerminator_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunction_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfInformationLink_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalElement_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalOutput_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalData_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalInterface_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalArchitectureModel_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}
pattern createObject_FunctionalInterface_class_by_interface_reference_FunctionalElement_with_element_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalInterface class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"interface reference FunctionalElement");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"element reference FunctionalInterface");
	find mustInstanceOfFunctionalElement_class(problem,interpretation,container);
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,newObject);
	find mayInRelationinterface_reference_FunctionalElement(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalInterface_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalInterface class");
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_InformationLink_class_by_outgoingLinks_reference_FunctionalOutput_with_from_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"InformationLink class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"outgoingLinks reference FunctionalOutput");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"from reference InformationLink");
	find mustInstanceOfFunctionalOutput_class(problem,interpretation,container);
	find mayInstanceOfInformationLink_class(problem,interpretation,newObject);
	find mayInRelationoutgoingLinks_reference_FunctionalOutput(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_InformationLink_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"InformationLink class");
	find mayInstanceOfInformationLink_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FAMTerminator_class_by_terminator_reference_FunctionalData_with_data_reference_FAMTerminator(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FAMTerminator class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"terminator reference FunctionalData");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"data reference FAMTerminator");
	find mustInstanceOfFunctionalData_class(problem,interpretation,container);
	find mayInstanceOfFAMTerminator_class(problem,interpretation,newObject);
	find mayInRelationterminator_reference_FunctionalData(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FAMTerminator_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FAMTerminator class");
	find mayInstanceOfFAMTerminator_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalInput_class_by_data_reference_FunctionalInterface_with_interface_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalInput class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"data reference FunctionalInterface");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"interface reference FunctionalData");
	find mustInstanceOfFunctionalInterface_class(problem,interpretation,container);
	find mayInstanceOfFunctionalInput_class(problem,interpretation,newObject);
	find mayInRelationdata_reference_FunctionalInterface(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalInput_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalInput class");
	find mayInstanceOfFunctionalInput_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalArchitectureModel_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalArchitectureModel class UndefinedPart");
	find mayInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Function_class_by_rootElements_reference_FunctionalArchitectureModel(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Function class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"rootElements reference FunctionalArchitectureModel");
	find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,container);
	find mayInstanceOfFunction_class(problem,interpretation,newObject);
	find mayInRelationrootElements_reference_FunctionalArchitectureModel(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Function_class_by_subElements_reference_Function_with_parent_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Function class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"subElements reference Function");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"parent reference FunctionalElement");
	find mustInstanceOfFunction_class(problem,interpretation,container);
	find mayInstanceOfFunction_class(problem,interpretation,newObject);
	find mayInRelationsubElements_reference_Function(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Function_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Function class");
	find mayInstanceOfFunction_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalOutput_class_by_data_reference_FunctionalInterface_with_interface_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalOutput class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"data reference FunctionalInterface");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"interface reference FunctionalData");
	find mustInstanceOfFunctionalInterface_class(problem,interpretation,container);
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,newObject);
	find mayInRelationdata_reference_FunctionalInterface(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalOutput_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalOutput class");
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}

//////////
// 4.2 Type refinement
//////////
pattern refineTypeTo_FunctionalInterface_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
}
pattern refineTypeTo_InformationLink_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
}
pattern refineTypeTo_FAMTerminator_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
}
pattern refineTypeTo_FunctionalInput_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
}
pattern refineTypeTo_FunctionalArchitectureModel_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
}
pattern refineTypeTo_Function_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunction_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunction_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
}
pattern refineTypeTo_FunctionalOutput_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
}

//////////
// 4.3 Relation refinement
//////////
pattern refineRelation_model_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"model reference FunctionalElement");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFunctionalElement_class(problem,interpretation,from);
	find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,to);
	find mayInRelationmodel_reference_FunctionalElement(problem,interpretation,from,to);
	neg find mustInRelationmodel_reference_FunctionalElement(problem,interpretation,from,to);
}
pattern refineRelation_IncomingLinks_reference_FunctionalInput_and_to_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation, oppositeInterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"IncomingLinks reference FunctionalInput");
	PartialInterpretation.partialrelationinterpretation(interpretation,oppositeInterpretation);
	PartialRelationInterpretation.interpretationOf.name(oppositeInterpretation,"to reference InformationLink");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFunctionalInput_class(problem,interpretation,from);
	find mustInstanceOfInformationLink_class(problem,interpretation,to);
	find mayInRelationIncomingLinks_reference_FunctionalInput(problem,interpretation,from,to);
	neg find mustInRelationIncomingLinks_reference_FunctionalInput(problem,interpretation,from,to);
}
pattern refineRelation_type_attribute_Function(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"type attribute Function");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFunction_class(problem,interpretation,from);
	find mustInstanceOfFunctionType_enum(problem,interpretation,to);
	find mayInRelationtype_attribute_Function(problem,interpretation,from,to);
	neg find mustInRelationtype_attribute_Function(problem,interpretation,from,to);
}
import epackage "http://www.bme.hu/mit/inf/dslreasoner/viatrasolver/partialinterpretationlanguage"
import epackage "http://www.bme.hu/mit/inf/dslreasoner/logic/model/problem"
import epackage "http://www.bme.hu/mit/inf/dslreasoner/logic/model/language"

//////////
// 0. Util
//////////
private pattern interpretation(problem:LogicProblem, interpretation:PartialInterpretation) {
	PartialInterpretation.problem(interpretation,problem);
}
	
/////////////////////////
// 0.1 Existence
/////////////////////////
private pattern mustExist(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	find interpretation(problem,interpretation);
	LogicProblem.elements(problem,element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
}

private pattern mayExist(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
    find mustExist(problem,interpretation,element);
} or {
    find interpretation(problem,interpretation);
    neg find elementCloseWorld(element);
    PartialInterpretation.openWorldElements(interpretation,element);
}

private pattern elementCloseWorld(element:DefinedElement) {
	PartialInterpretation.openWorldElements(i,element);
    PartialInterpretation.maxNewElements(i,0);
} or {
	Scope.targetTypeInterpretation(scope,interpretation);
	PartialTypeInterpratation.elements(interpretation,element);
	Scope.maxNewElements(scope,0);
}

////////////////////////
// 0.2 Equivalence
////////////////////////
pattern mayEquivalent(problem:LogicProblem, interpretation:PartialInterpretation, a: DefinedElement, b: DefinedElement) {
	find mayExist(problem,interpretation,a);
	find mayExist(problem,interpretation,b);
	a == b;
}

////////////////////////
// 0.3 Required Patterns by TypeIndexer
////////////////////////
private pattern typeInterpretation(problem:LogicProblem, interpretation:PartialInterpretation, type:TypeDeclaration, typeInterpretation:PartialComplexTypeInterpretation) {
	find interpretation(problem,interpretation);
	LogicProblem.types(problem,type);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
}

private pattern directInstanceOf(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement, type:Type) {
	find interpretation(problem,interpretation);
	LogicProblem.types(problem,type);
	TypeDefinition.elements(type,element);
} or {
	find interpretation(problem,interpretation);
	find typeInterpretation(problem,interpretation,type,typeInterpretation);
	PartialComplexTypeInterpretation.elements(typeInterpretation,element);
}

private pattern isPrimitive(element: PrimitiveElement) {
	PrimitiveElement(element);
}

//////////
// 1. Problem-Specific Base Indexers
//////////
// 1.1 Type Indexers
//////////
// 1.1.1 primitive Type Indexers
//////////

//////////
// 1.1.2 domain-specific Type Indexers
//////////
/**
 * An element must be an instance of type "FunctionalElement class".
 */
private pattern mustInstanceOfFunctionalElement_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalElement class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalElement_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalElement class");
}

/**
 * An element may be an instance of type "FunctionalElement class".
 */
private pattern mayInstanceOfFunctionalElement_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunction_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalElement_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunction_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalElement_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalElement_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalArchitectureModel class".
 */
private pattern mustInstanceOfFunctionalArchitectureModel_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalArchitectureModel class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalArchitectureModel_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalArchitectureModel class");
}

/**
 * An element may be an instance of type "FunctionalArchitectureModel class".
 */
private pattern mayInstanceOfFunctionalArchitectureModel_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalArchitectureModel_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalArchitectureModel_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Function class".
 */
private pattern mustInstanceOfFunction_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Function class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunction_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Function class");
}

/**
 * An element may be an instance of type "Function class".
 */
private pattern mayInstanceOfFunction_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunction_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunction_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunction_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FAMTerminator class".
 */
private pattern mustInstanceOfFAMTerminator_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FAMTerminator class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFAMTerminator_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FAMTerminator class");
}

/**
 * An element may be an instance of type "FAMTerminator class".
 */
private pattern mayInstanceOfFAMTerminator_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find scopeDisallowsNewFAMTerminator_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find scopeDisallowsNewFAMTerminator_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFAMTerminator_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "InformationLink class".
 */
private pattern mustInstanceOfInformationLink_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"InformationLink class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewInformationLink_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"InformationLink class");
}

/**
 * An element may be an instance of type "InformationLink class".
 */
private pattern mayInstanceOfInformationLink_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find scopeDisallowsNewInformationLink_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find scopeDisallowsNewInformationLink_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfInformationLink_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalInterface class".
 */
private pattern mustInstanceOfFunctionalInterface_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalInterface class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalInterface_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalInterface class");
}

/**
 * An element may be an instance of type "FunctionalInterface class".
 */
private pattern mayInstanceOfFunctionalInterface_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalInterface_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalInterface_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalInterface_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalInput class".
 */
private pattern mustInstanceOfFunctionalInput_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalInput class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalInput_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalInput class");
}

/**
 * An element may be an instance of type "FunctionalInput class".
 */
private pattern mayInstanceOfFunctionalInput_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalInput_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalInput_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalInput_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalOutput class".
 */
private pattern mustInstanceOfFunctionalOutput_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalOutput class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalOutput_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalOutput class");
}

/**
 * An element may be an instance of type "FunctionalOutput class".
 */
private pattern mayInstanceOfFunctionalOutput_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalOutput_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalOutput_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalOutput_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalData class".
 */
private pattern mustInstanceOfFunctionalData_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalData class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalData_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalData class");
}

/**
 * An element may be an instance of type "FunctionalData class".
 */
private pattern mayInstanceOfFunctionalData_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalData_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalData_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalData_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionType enum".
 */
private pattern mustInstanceOfFunctionType_enum(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionType enum");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionType_enum(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionType enum");
}

/**
 * An element may be an instance of type "FunctionType enum".
 */
private pattern mayInstanceOfFunctionType_enum(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfFunctionType_enum(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalArchitectureModel class DefinedPart".
 */
private pattern mustInstanceOfFunctionalArchitectureModel_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalArchitectureModel class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalArchitectureModel_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalArchitectureModel class DefinedPart");
}

/**
 * An element may be an instance of type "FunctionalArchitectureModel class DefinedPart".
 */
private pattern mayInstanceOfFunctionalArchitectureModel_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfFunctionalArchitectureModel_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalArchitectureModel class UndefinedPart".
 */
private pattern mustInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalArchitectureModel class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalArchitectureModel_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalArchitectureModel class UndefinedPart");
}

/**
 * An element may be an instance of type "FunctionalArchitectureModel class UndefinedPart".
 */
private pattern mayInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalArchitectureModel_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalArchitectureModel_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem,interpretation,element); }

//////////
// 1.2 Relation Declaration Indexers
//////////
/**
 * Matcher for detecting tuples t where []interface reference FunctionalElement(source,target)
 */
private pattern mustInRelationinterface_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"interface reference FunctionalElement");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>interface reference FunctionalElement(source,target)
 */
private pattern mayInRelationinterface_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalElement_class(problem,interpretation,source);
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationinterface_reference_FunctionalElement(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationelement_reference_FunctionalInterface(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationinterface_reference_FunctionalElement(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []model reference FunctionalElement(source,target)
 */
private pattern mustInRelationmodel_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"model reference FunctionalElement");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>model reference FunctionalElement(source,target)
 */
private pattern mayInRelationmodel_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalElement_class(problem,interpretation,source);
	find mayInstanceOfFunctionalArchitectureModel_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationmodel_reference_FunctionalElement(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationmodel_reference_FunctionalElement(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []parent reference FunctionalElement(source,target)
 */
private pattern mustInRelationparent_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"parent reference FunctionalElement");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>parent reference FunctionalElement(source,target)
 */
private pattern mayInRelationparent_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalElement_class(problem,interpretation,source);
	find mayInstanceOfFunction_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationparent_reference_FunctionalElement(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationparent_reference_FunctionalElement(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []rootElements reference FunctionalArchitectureModel(source,target)
 */
private pattern mustInRelationrootElements_reference_FunctionalArchitectureModel(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"rootElements reference FunctionalArchitectureModel");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>rootElements reference FunctionalArchitectureModel(source,target)
 */
private pattern mayInRelationrootElements_reference_FunctionalArchitectureModel(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalArchitectureModel_class(problem,interpretation,source);
	find mayInstanceOfFunctionalElement_class(problem,interpretation,target);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationrootElements_reference_FunctionalArchitectureModel(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []subElements reference Function(source,target)
 */
private pattern mustInRelationsubElements_reference_Function(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"subElements reference Function");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>subElements reference Function(source,target)
 */
private pattern mayInRelationsubElements_reference_Function(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunction_class(problem,interpretation,source);
	find mayInstanceOfFunctionalElement_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationparent_reference_FunctionalElement(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationsubElements_reference_Function(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []data reference FAMTerminator(source,target)
 */
private pattern mustInRelationdata_reference_FAMTerminator(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"data reference FAMTerminator");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>data reference FAMTerminator(source,target)
 */
private pattern mayInRelationdata_reference_FAMTerminator(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFAMTerminator_class(problem,interpretation,source);
	find mayInstanceOfFunctionalData_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationdata_reference_FAMTerminator(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationterminator_reference_FunctionalData(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationdata_reference_FAMTerminator(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []from reference InformationLink(source,target)
 */
private pattern mustInRelationfrom_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"from reference InformationLink");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>from reference InformationLink(source,target)
 */
private pattern mayInRelationfrom_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfInformationLink_class(problem,interpretation,source);
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationfrom_reference_InformationLink(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationfrom_reference_InformationLink(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []to reference InformationLink(source,target)
 */
private pattern mustInRelationto_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"to reference InformationLink");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>to reference InformationLink(source,target)
 */
private pattern mayInRelationto_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfInformationLink_class(problem,interpretation,source);
	find mayInstanceOfFunctionalInput_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationto_reference_InformationLink(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationto_reference_InformationLink(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []data reference FunctionalInterface(source,target)
 */
private pattern mustInRelationdata_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"data reference FunctionalInterface");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>data reference FunctionalInterface(source,target)
 */
private pattern mayInRelationdata_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,source);
	find mayInstanceOfFunctionalData_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationinterface_reference_FunctionalData(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationdata_reference_FunctionalInterface(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []element reference FunctionalInterface(source,target)
 */
private pattern mustInRelationelement_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"element reference FunctionalInterface");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>element reference FunctionalInterface(source,target)
 */
private pattern mayInRelationelement_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,source);
	find mayInstanceOfFunctionalElement_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationelement_reference_FunctionalInterface(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationinterface_reference_FunctionalElement(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationelement_reference_FunctionalInterface(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []IncomingLinks reference FunctionalInput(source,target)
 */
private pattern mustInRelationIncomingLinks_reference_FunctionalInput(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"IncomingLinks reference FunctionalInput");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>IncomingLinks reference FunctionalInput(source,target)
 */
private pattern mayInRelationIncomingLinks_reference_FunctionalInput(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalInput_class(problem,interpretation,source);
	find mayInstanceOfInformationLink_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationto_reference_InformationLink(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
} or {
	find mustInRelationIncomingLinks_reference_FunctionalInput(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []outgoingLinks reference FunctionalOutput(source,target)
 */
private pattern mustInRelationoutgoingLinks_reference_FunctionalOutput(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"outgoingLinks reference FunctionalOutput");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>outgoingLinks reference FunctionalOutput(source,target)
 */
private pattern mayInRelationoutgoingLinks_reference_FunctionalOutput(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,source);
	find mayInstanceOfInformationLink_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationfrom_reference_InformationLink(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationoutgoingLinks_reference_FunctionalOutput(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []terminator reference FunctionalData(source,target)
 */
private pattern mustInRelationterminator_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"terminator reference FunctionalData");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>terminator reference FunctionalData(source,target)
 */
private pattern mayInRelationterminator_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalData_class(problem,interpretation,source);
	find mayInstanceOfFAMTerminator_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationterminator_reference_FunctionalData(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationdata_reference_FAMTerminator(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationterminator_reference_FunctionalData(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []interface reference FunctionalData(source,target)
 */
private pattern mustInRelationinterface_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"interface reference FunctionalData");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>interface reference FunctionalData(source,target)
 */
private pattern mayInRelationinterface_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalData_class(problem,interpretation,source);
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationinterface_reference_FunctionalData(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationinterface_reference_FunctionalData(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []type attribute Function(source,target)
 */
private pattern mustInRelationtype_attribute_Function(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"type attribute Function");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>type attribute Function(source,target)
 */
private pattern mayInRelationtype_attribute_Function(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunction_class(problem,interpretation,source);
	find mayInstanceOfFunctionType_enum(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationtype_attribute_Function(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationtype_attribute_Function(problem,interpretation,source,target);
}

//////////
// 1.3 Relation Definition Indexers
//////////

//////////
// 1.4 Containment Indexer
//////////
private pattern mustContains2(source: DefinedElement, target: DefinedElement) {
	find mustContains4(_,_,source,target);
}
	
private pattern mustContains4(problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target: DefinedElement)
	{ find mustInRelationinterface_reference_FunctionalElement(problem,interpretation,source,target); }or
	
	{ find mustInRelationrootElements_reference_FunctionalArchitectureModel(problem,interpretation,source,target); }or
	
	{ find mustInRelationsubElements_reference_Function(problem,interpretation,source,target); }or
	
	{ find mustInRelationdata_reference_FunctionalInterface(problem,interpretation,source,target); }or
	
	{ find mustInRelationoutgoingLinks_reference_FunctionalOutput(problem,interpretation,source,target); }or
	
	{ find mustInRelationterminator_reference_FunctionalData(problem,interpretation,source,target); }

private pattern mustTransitiveContains(source,target) {
	find mustContains2+(source,target);
}

//////////
// 2. Invalidation Indexers
//////////
// 2.1 Invalidated by WF Queries
//////////

//////////
// 3. Unfinishedness Indexers
//////////
// 3.1 Unfinishedness Measured by Multiplicity
//////////
pattern unfinishedLowerMultiplicity_model_reference_FunctionalElement(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"model reference FunctionalElement");
	find mustInstanceOfFunctionalElement_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationmodel_reference_FunctionalElement(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_to_reference_InformationLink(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"to reference InformationLink");
	find mustInstanceOfInformationLink_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationto_reference_InformationLink(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_type_attribute_Function(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"type attribute Function");
	find mustInstanceOfFunction_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationtype_attribute_Function(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}

//////////
// 3.2 Unfinishedness Measured by WF Queries
//////////

//////////
// 4. Refinement Indexers
//////////
// 4.1 Object constructors
//////////
private pattern hasElementInContainment(problem:LogicProblem, interpretation:PartialInterpretation)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalInput_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFAMTerminator_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunction_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfInformationLink_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalElement_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalOutput_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalData_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalInterface_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalArchitectureModel_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}
pattern createObject_FunctionalInterface_class_by_interface_reference_FunctionalElement_with_element_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalInterface class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"interface reference FunctionalElement");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"element reference FunctionalInterface");
	find mustInstanceOfFunctionalElement_class(problem,interpretation,container);
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,newObject);
	find mayInRelationinterface_reference_FunctionalElement(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalInterface_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalInterface class");
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalOutput_class_by_data_reference_FunctionalInterface_with_interface_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalOutput class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"data reference FunctionalInterface");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"interface reference FunctionalData");
	find mustInstanceOfFunctionalInterface_class(problem,interpretation,container);
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,newObject);
	find mayInRelationdata_reference_FunctionalInterface(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalOutput_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalOutput class");
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalArchitectureModel_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalArchitectureModel class UndefinedPart");
	find mayInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_InformationLink_class_by_outgoingLinks_reference_FunctionalOutput_with_from_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"InformationLink class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"outgoingLinks reference FunctionalOutput");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"from reference InformationLink");
	find mustInstanceOfFunctionalOutput_class(problem,interpretation,container);
	find mayInstanceOfInformationLink_class(problem,interpretation,newObject);
	find mayInRelationoutgoingLinks_reference_FunctionalOutput(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_InformationLink_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"InformationLink class");
	find mayInstanceOfInformationLink_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Function_class_by_rootElements_reference_FunctionalArchitectureModel(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Function class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"rootElements reference FunctionalArchitectureModel");
	find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,container);
	find mayInstanceOfFunction_class(problem,interpretation,newObject);
	find mayInRelationrootElements_reference_FunctionalArchitectureModel(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Function_class_by_subElements_reference_Function_with_parent_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Function class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"subElements reference Function");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"parent reference FunctionalElement");
	find mustInstanceOfFunction_class(problem,interpretation,container);
	find mayInstanceOfFunction_class(problem,interpretation,newObject);
	find mayInRelationsubElements_reference_Function(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Function_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Function class");
	find mayInstanceOfFunction_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalInput_class_by_data_reference_FunctionalInterface_with_interface_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalInput class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"data reference FunctionalInterface");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"interface reference FunctionalData");
	find mustInstanceOfFunctionalInterface_class(problem,interpretation,container);
	find mayInstanceOfFunctionalInput_class(problem,interpretation,newObject);
	find mayInRelationdata_reference_FunctionalInterface(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalInput_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalInput class");
	find mayInstanceOfFunctionalInput_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FAMTerminator_class_by_terminator_reference_FunctionalData_with_data_reference_FAMTerminator(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FAMTerminator class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"terminator reference FunctionalData");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"data reference FAMTerminator");
	find mustInstanceOfFunctionalData_class(problem,interpretation,container);
	find mayInstanceOfFAMTerminator_class(problem,interpretation,newObject);
	find mayInRelationterminator_reference_FunctionalData(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FAMTerminator_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FAMTerminator class");
	find mayInstanceOfFAMTerminator_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}

//////////
// 4.2 Type refinement
//////////
pattern refineTypeTo_FunctionalInterface_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
}
pattern refineTypeTo_FunctionalOutput_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
}
pattern refineTypeTo_FunctionalArchitectureModel_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
}
pattern refineTypeTo_InformationLink_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
}
pattern refineTypeTo_Function_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunction_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunction_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
}
pattern refineTypeTo_FunctionalInput_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
}
pattern refineTypeTo_FAMTerminator_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
}

//////////
// 4.3 Relation refinement
//////////
pattern refineRelation_model_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"model reference FunctionalElement");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFunctionalElement_class(problem,interpretation,from);
	find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,to);
	find mayInRelationmodel_reference_FunctionalElement(problem,interpretation,from,to);
	neg find mustInRelationmodel_reference_FunctionalElement(problem,interpretation,from,to);
}
pattern refineRelation_IncomingLinks_reference_FunctionalInput_and_to_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation, oppositeInterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"IncomingLinks reference FunctionalInput");
	PartialInterpretation.partialrelationinterpretation(interpretation,oppositeInterpretation);
	PartialRelationInterpretation.interpretationOf.name(oppositeInterpretation,"to reference InformationLink");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFunctionalInput_class(problem,interpretation,from);
	find mustInstanceOfInformationLink_class(problem,interpretation,to);
	find mayInRelationIncomingLinks_reference_FunctionalInput(problem,interpretation,from,to);
	neg find mustInRelationIncomingLinks_reference_FunctionalInput(problem,interpretation,from,to);
}
pattern refineRelation_type_attribute_Function(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"type attribute Function");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFunction_class(problem,interpretation,from);
	find mustInstanceOfFunctionType_enum(problem,interpretation,to);
	find mayInRelationtype_attribute_Function(problem,interpretation,from,to);
	neg find mustInRelationtype_attribute_Function(problem,interpretation,from,to);
}
import epackage "http://www.bme.hu/mit/inf/dslreasoner/viatrasolver/partialinterpretationlanguage"
import epackage "http://www.bme.hu/mit/inf/dslreasoner/logic/model/problem"
import epackage "http://www.bme.hu/mit/inf/dslreasoner/logic/model/language"

//////////
// 0. Util
//////////
private pattern interpretation(problem:LogicProblem, interpretation:PartialInterpretation) {
	PartialInterpretation.problem(interpretation,problem);
}
	
/////////////////////////
// 0.1 Existence
/////////////////////////
private pattern mustExist(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	find interpretation(problem,interpretation);
	LogicProblem.elements(problem,element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
}

private pattern mayExist(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
    find mustExist(problem,interpretation,element);
} or {
    find interpretation(problem,interpretation);
    neg find elementCloseWorld(element);
    PartialInterpretation.openWorldElements(interpretation,element);
}

private pattern elementCloseWorld(element:DefinedElement) {
	PartialInterpretation.openWorldElements(i,element);
    PartialInterpretation.maxNewElements(i,0);
} or {
	Scope.targetTypeInterpretation(scope,interpretation);
	PartialTypeInterpratation.elements(interpretation,element);
	Scope.maxNewElements(scope,0);
}

////////////////////////
// 0.2 Equivalence
////////////////////////
pattern mayEquivalent(problem:LogicProblem, interpretation:PartialInterpretation, a: DefinedElement, b: DefinedElement) {
	find mayExist(problem,interpretation,a);
	find mayExist(problem,interpretation,b);
	a == b;
}

////////////////////////
// 0.3 Required Patterns by TypeIndexer
////////////////////////
private pattern typeInterpretation(problem:LogicProblem, interpretation:PartialInterpretation, type:TypeDeclaration, typeInterpretation:PartialComplexTypeInterpretation) {
	find interpretation(problem,interpretation);
	LogicProblem.types(problem,type);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
}

private pattern directInstanceOf(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement, type:Type) {
	find interpretation(problem,interpretation);
	LogicProblem.types(problem,type);
	TypeDefinition.elements(type,element);
} or {
	find interpretation(problem,interpretation);
	find typeInterpretation(problem,interpretation,type,typeInterpretation);
	PartialComplexTypeInterpretation.elements(typeInterpretation,element);
}

private pattern isPrimitive(element: PrimitiveElement) {
	PrimitiveElement(element);
}

//////////
// 1. Problem-Specific Base Indexers
//////////
// 1.1 Type Indexers
//////////
// 1.1.1 primitive Type Indexers
//////////

//////////
// 1.1.2 domain-specific Type Indexers
//////////
/**
 * An element must be an instance of type "EAttribute class".
 */
private pattern mustInstanceOfEAttribute_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"EAttribute class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewEAttribute_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"EAttribute class");
}

/**
 * An element may be an instance of type "EAttribute class".
 */
private pattern mayInstanceOfEAttribute_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfEParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEPackage_class(problem,interpretation,element);
	neg find mustInstanceOfEEnumLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfEReference_class(problem,interpretation,element);
	neg find mustInstanceOfEOperation_class(problem,interpretation,element);
	neg find mustInstanceOfEClassifier_class(problem,interpretation,element);
	neg find mustInstanceOfETypeParameter_class(problem,interpretation,element);
	neg find scopeDisallowsNewEAttribute_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfEParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEPackage_class(problem,interpretation,element);
	neg find mustInstanceOfEEnumLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfEReference_class(problem,interpretation,element);
	neg find mustInstanceOfEOperation_class(problem,interpretation,element);
	neg find mustInstanceOfEClassifier_class(problem,interpretation,element);
	neg find mustInstanceOfETypeParameter_class(problem,interpretation,element);
	neg find scopeDisallowsNewEAttribute_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfEAttribute_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "EAnnotation class".
 */
private pattern mustInstanceOfEAnnotation_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"EAnnotation class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewEAnnotation_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"EAnnotation class");
}

/**
 * An element may be an instance of type "EAnnotation class".
 */
private pattern mayInstanceOfEAnnotation_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfENamedElement_class(problem,interpretation,element);
	neg find scopeDisallowsNewEAnnotation_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfENamedElement_class(problem,interpretation,element);
	neg find scopeDisallowsNewEAnnotation_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfEAnnotation_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "EClass class".
 */
private pattern mustInstanceOfEClass_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"EClass class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewEClass_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"EClass class");
}

/**
 * An element may be an instance of type "EClass class".
 */
private pattern mayInstanceOfEClass_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEPackage_class(problem,interpretation,element);
	neg find mustInstanceOfEEnumLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfEDataType_class(problem,interpretation,element);
	neg find mustInstanceOfETypedElement_class(problem,interpretation,element);
	neg find mustInstanceOfETypeParameter_class(problem,interpretation,element);
	neg find scopeDisallowsNewEClass_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEPackage_class(problem,interpretation,element);
	neg find mustInstanceOfEEnumLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfEDataType_class(problem,interpretation,element);
	neg find mustInstanceOfETypedElement_class(problem,interpretation,element);
	neg find mustInstanceOfETypeParameter_class(problem,interpretation,element);
	neg find scopeDisallowsNewEClass_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfEClass_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "EClassifier class".
 */
private pattern mustInstanceOfEClassifier_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"EClassifier class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewEClassifier_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"EClassifier class");
}

/**
 * An element may be an instance of type "EClassifier class".
 */
private pattern mayInstanceOfEClassifier_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEClass_class(problem,interpretation,element);
	neg find mustInstanceOfEPackage_class(problem,interpretation,element);
	neg find mustInstanceOfEEnumLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfEDataType_class(problem,interpretation,element);
	neg find mustInstanceOfETypedElement_class(problem,interpretation,element);
	neg find mustInstanceOfETypeParameter_class(problem,interpretation,element);
	neg find scopeDisallowsNewEClassifier_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEClass_class(problem,interpretation,element);
	neg find mustInstanceOfEPackage_class(problem,interpretation,element);
	neg find mustInstanceOfEEnumLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfEDataType_class(problem,interpretation,element);
	neg find mustInstanceOfETypedElement_class(problem,interpretation,element);
	neg find mustInstanceOfETypeParameter_class(problem,interpretation,element);
	neg find scopeDisallowsNewEClassifier_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfEClassifier_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "EDataType class".
 */
private pattern mustInstanceOfEDataType_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"EDataType class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewEDataType_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"EDataType class");
}

/**
 * An element may be an instance of type "EDataType class".
 */
private pattern mayInstanceOfEDataType_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEClass_class(problem,interpretation,element);
	neg find mustInstanceOfEPackage_class(problem,interpretation,element);
	neg find mustInstanceOfEEnum_class(problem,interpretation,element);
	neg find mustInstanceOfEEnumLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfETypedElement_class(problem,interpretation,element);
	neg find mustInstanceOfETypeParameter_class(problem,interpretation,element);
	neg find scopeDisallowsNewEDataType_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEClass_class(problem,interpretation,element);
	neg find mustInstanceOfEPackage_class(problem,interpretation,element);
	neg find mustInstanceOfEEnum_class(problem,interpretation,element);
	neg find mustInstanceOfEEnumLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfETypedElement_class(problem,interpretation,element);
	neg find mustInstanceOfETypeParameter_class(problem,interpretation,element);
	neg find scopeDisallowsNewEDataType_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfEDataType_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "EEnum class".
 */
private pattern mustInstanceOfEEnum_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"EEnum class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewEEnum_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"EEnum class");
}

/**
 * An element may be an instance of type "EEnum class".
 */
private pattern mayInstanceOfEEnum_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEClass_class(problem,interpretation,element);
	neg find mustInstanceOfEPackage_class(problem,interpretation,element);
	neg find mustInstanceOfEEnumLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfETypeParameter_class(problem,interpretation,element);
	neg find mustInstanceOfETypedElement_class(problem,interpretation,element);
	neg find scopeDisallowsNewEEnum_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEClass_class(problem,interpretation,element);
	neg find mustInstanceOfEPackage_class(problem,interpretation,element);
	neg find mustInstanceOfEEnumLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfETypeParameter_class(problem,interpretation,element);
	neg find mustInstanceOfETypedElement_class(problem,interpretation,element);
	neg find scopeDisallowsNewEEnum_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfEEnum_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "EEnumLiteral class".
 */
private pattern mustInstanceOfEEnumLiteral_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"EEnumLiteral class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewEEnumLiteral_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"EEnumLiteral class");
}

/**
 * An element may be an instance of type "EEnumLiteral class".
 */
private pattern mayInstanceOfEEnumLiteral_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEPackage_class(problem,interpretation,element);
	neg find mustInstanceOfEClassifier_class(problem,interpretation,element);
	neg find mustInstanceOfETypedElement_class(problem,interpretation,element);
	neg find mustInstanceOfETypeParameter_class(problem,interpretation,element);
	neg find scopeDisallowsNewEEnumLiteral_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEPackage_class(problem,interpretation,element);
	neg find mustInstanceOfEClassifier_class(problem,interpretation,element);
	neg find mustInstanceOfETypedElement_class(problem,interpretation,element);
	neg find mustInstanceOfETypeParameter_class(problem,interpretation,element);
	neg find scopeDisallowsNewEEnumLiteral_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfEEnumLiteral_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "EModelElement class".
 */
private pattern mustInstanceOfEModelElement_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"EModelElement class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewEModelElement_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"EModelElement class");
}

/**
 * An element may be an instance of type "EModelElement class".
 */
private pattern mayInstanceOfEModelElement_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEModelElement_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfENamedElement_class(problem,interpretation,element);
	neg find scopeDisallowsNewEModelElement_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEModelElement_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfENamedElement_class(problem,interpretation,element);
	neg find scopeDisallowsNewEModelElement_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfEModelElement_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "ENamedElement class".
 */
private pattern mustInstanceOfENamedElement_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"ENamedElement class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewENamedElement_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"ENamedElement class");
}

/**
 * An element may be an instance of type "ENamedElement class".
 */
private pattern mayInstanceOfENamedElement_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEPackage_class(problem,interpretation,element);
	neg find mustInstanceOfEModelElement_class_UndefinedPart(problem,interpretation,element);
	neg find scopeDisallowsNewENamedElement_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEPackage_class(problem,interpretation,element);
	neg find mustInstanceOfEModelElement_class_UndefinedPart(problem,interpretation,element);
	neg find scopeDisallowsNewENamedElement_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfENamedElement_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "EObject class".
 */
private pattern mustInstanceOfEObject_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"EObject class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewEObject_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"EObject class");
}

/**
 * An element may be an instance of type "EObject class".
 */
private pattern mayInstanceOfEObject_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEModelElement_class(problem,interpretation,element);
	neg find scopeDisallowsNewEObject_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEModelElement_class(problem,interpretation,element);
	neg find scopeDisallowsNewEObject_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfEObject_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "EOperation class".
 */
private pattern mustInstanceOfEOperation_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"EOperation class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewEOperation_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"EOperation class");
}

/**
 * An element may be an instance of type "EOperation class".
 */
private pattern mayInstanceOfEOperation_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEStructuralFeature_class(problem,interpretation,element);
	neg find mustInstanceOfEPackage_class(problem,interpretation,element);
	neg find mustInstanceOfEEnumLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfEClassifier_class(problem,interpretation,element);
	neg find mustInstanceOfETypeParameter_class(problem,interpretation,element);
	neg find scopeDisallowsNewEOperation_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEStructuralFeature_class(problem,interpretation,element);
	neg find mustInstanceOfEPackage_class(problem,interpretation,element);
	neg find mustInstanceOfEEnumLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfEClassifier_class(problem,interpretation,element);
	neg find mustInstanceOfETypeParameter_class(problem,interpretation,element);
	neg find scopeDisallowsNewEOperation_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfEOperation_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "EPackage class".
 */
private pattern mustInstanceOfEPackage_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"EPackage class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewEPackage_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"EPackage class");
}

/**
 * An element may be an instance of type "EPackage class".
 */
private pattern mayInstanceOfEPackage_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEModelElement_class_UndefinedPart(problem,interpretation,element);
	neg find scopeDisallowsNewEPackage_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEModelElement_class_UndefinedPart(problem,interpretation,element);
	neg find scopeDisallowsNewEPackage_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfEPackage_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "EParameter class".
 */
private pattern mustInstanceOfEParameter_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"EParameter class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewEParameter_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"EParameter class");
}

/**
 * An element may be an instance of type "EParameter class".
 */
private pattern mayInstanceOfEParameter_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEPackage_class(problem,interpretation,element);
	neg find mustInstanceOfEStructuralFeature_class(problem,interpretation,element);
	neg find mustInstanceOfEEnumLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfEOperation_class(problem,interpretation,element);
	neg find mustInstanceOfEClassifier_class(problem,interpretation,element);
	neg find mustInstanceOfETypeParameter_class(problem,interpretation,element);
	neg find scopeDisallowsNewEParameter_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEPackage_class(problem,interpretation,element);
	neg find mustInstanceOfEStructuralFeature_class(problem,interpretation,element);
	neg find mustInstanceOfEEnumLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfEOperation_class(problem,interpretation,element);
	neg find mustInstanceOfEClassifier_class(problem,interpretation,element);
	neg find mustInstanceOfETypeParameter_class(problem,interpretation,element);
	neg find scopeDisallowsNewEParameter_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfEParameter_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "EReference class".
 */
private pattern mustInstanceOfEReference_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"EReference class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewEReference_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"EReference class");
}

/**
 * An element may be an instance of type "EReference class".
 */
private pattern mayInstanceOfEReference_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEAttribute_class(problem,interpretation,element);
	neg find mustInstanceOfEPackage_class(problem,interpretation,element);
	neg find mustInstanceOfEEnumLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfEOperation_class(problem,interpretation,element);
	neg find mustInstanceOfEClassifier_class(problem,interpretation,element);
	neg find mustInstanceOfETypeParameter_class(problem,interpretation,element);
	neg find scopeDisallowsNewEReference_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEAttribute_class(problem,interpretation,element);
	neg find mustInstanceOfEPackage_class(problem,interpretation,element);
	neg find mustInstanceOfEEnumLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfEOperation_class(problem,interpretation,element);
	neg find mustInstanceOfEClassifier_class(problem,interpretation,element);
	neg find mustInstanceOfETypeParameter_class(problem,interpretation,element);
	neg find scopeDisallowsNewEReference_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfEReference_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "EStructuralFeature class".
 */
private pattern mustInstanceOfEStructuralFeature_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"EStructuralFeature class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewEStructuralFeature_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"EStructuralFeature class");
}

/**
 * An element may be an instance of type "EStructuralFeature class".
 */
private pattern mayInstanceOfEStructuralFeature_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfEParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEAttribute_class(problem,interpretation,element);
	neg find mustInstanceOfEPackage_class(problem,interpretation,element);
	neg find mustInstanceOfEEnumLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfEReference_class(problem,interpretation,element);
	neg find mustInstanceOfEOperation_class(problem,interpretation,element);
	neg find mustInstanceOfEClassifier_class(problem,interpretation,element);
	neg find mustInstanceOfETypeParameter_class(problem,interpretation,element);
	neg find scopeDisallowsNewEStructuralFeature_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfEParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEAttribute_class(problem,interpretation,element);
	neg find mustInstanceOfEPackage_class(problem,interpretation,element);
	neg find mustInstanceOfEEnumLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfEReference_class(problem,interpretation,element);
	neg find mustInstanceOfEOperation_class(problem,interpretation,element);
	neg find mustInstanceOfEClassifier_class(problem,interpretation,element);
	neg find mustInstanceOfETypeParameter_class(problem,interpretation,element);
	neg find scopeDisallowsNewEStructuralFeature_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfEStructuralFeature_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "ETypedElement class".
 */
private pattern mustInstanceOfETypedElement_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"ETypedElement class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewETypedElement_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"ETypedElement class");
}

/**
 * An element may be an instance of type "ETypedElement class".
 */
private pattern mayInstanceOfETypedElement_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEStructuralFeature_class(problem,interpretation,element);
	neg find mustInstanceOfEPackage_class(problem,interpretation,element);
	neg find mustInstanceOfEEnumLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfEOperation_class(problem,interpretation,element);
	neg find mustInstanceOfEClassifier_class(problem,interpretation,element);
	neg find mustInstanceOfETypeParameter_class(problem,interpretation,element);
	neg find scopeDisallowsNewETypedElement_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEStructuralFeature_class(problem,interpretation,element);
	neg find mustInstanceOfEPackage_class(problem,interpretation,element);
	neg find mustInstanceOfEEnumLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfEOperation_class(problem,interpretation,element);
	neg find mustInstanceOfEClassifier_class(problem,interpretation,element);
	neg find mustInstanceOfETypeParameter_class(problem,interpretation,element);
	neg find scopeDisallowsNewETypedElement_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfETypedElement_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "EStringToStringMapEntry class".
 */
private pattern mustInstanceOfEStringToStringMapEntry_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"EStringToStringMapEntry class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewEStringToStringMapEntry_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"EStringToStringMapEntry class");
}

/**
 * An element may be an instance of type "EStringToStringMapEntry class".
 */
private pattern mayInstanceOfEStringToStringMapEntry_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEModelElement_class(problem,interpretation,element);
	neg find scopeDisallowsNewEStringToStringMapEntry_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEModelElement_class(problem,interpretation,element);
	neg find scopeDisallowsNewEStringToStringMapEntry_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "EGenericType class".
 */
private pattern mustInstanceOfEGenericType_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"EGenericType class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewEGenericType_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"EGenericType class");
}

/**
 * An element may be an instance of type "EGenericType class".
 */
private pattern mayInstanceOfEGenericType_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEModelElement_class(problem,interpretation,element);
	neg find scopeDisallowsNewEGenericType_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEModelElement_class(problem,interpretation,element);
	neg find scopeDisallowsNewEGenericType_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfEGenericType_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "ETypeParameter class".
 */
private pattern mustInstanceOfETypeParameter_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"ETypeParameter class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewETypeParameter_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"ETypeParameter class");
}

/**
 * An element may be an instance of type "ETypeParameter class".
 */
private pattern mayInstanceOfETypeParameter_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEPackage_class(problem,interpretation,element);
	neg find mustInstanceOfEEnumLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfEClassifier_class(problem,interpretation,element);
	neg find mustInstanceOfETypedElement_class(problem,interpretation,element);
	neg find scopeDisallowsNewETypeParameter_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEPackage_class(problem,interpretation,element);
	neg find mustInstanceOfEEnumLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfEClassifier_class(problem,interpretation,element);
	neg find mustInstanceOfETypedElement_class(problem,interpretation,element);
	neg find scopeDisallowsNewETypeParameter_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfETypeParameter_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "EModelElement class DefinedPart".
 */
private pattern mustInstanceOfEModelElement_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"EModelElement class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewEModelElement_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"EModelElement class DefinedPart");
}

/**
 * An element may be an instance of type "EModelElement class DefinedPart".
 */
private pattern mayInstanceOfEModelElement_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfEModelElement_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "EModelElement class UndefinedPart".
 */
private pattern mustInstanceOfEModelElement_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"EModelElement class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewEModelElement_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"EModelElement class UndefinedPart");
}

/**
 * An element may be an instance of type "EModelElement class UndefinedPart".
 */
private pattern mayInstanceOfEModelElement_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfENamedElement_class(problem,interpretation,element);
	neg find scopeDisallowsNewEModelElement_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfENamedElement_class(problem,interpretation,element);
	neg find scopeDisallowsNewEModelElement_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfEModelElement_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "ENamedElement class DefinedPart".
 */
private pattern mustInstanceOfENamedElement_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"ENamedElement class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewENamedElement_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"ENamedElement class DefinedPart");
}

/**
 * An element may be an instance of type "ENamedElement class DefinedPart".
 */
private pattern mayInstanceOfENamedElement_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfENamedElement_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "ENamedElement class UndefinedPart".
 */
private pattern mustInstanceOfENamedElement_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"ENamedElement class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewENamedElement_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"ENamedElement class UndefinedPart");
}

/**
 * An element may be an instance of type "ENamedElement class UndefinedPart".
 */
private pattern mayInstanceOfENamedElement_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEPackage_class(problem,interpretation,element);
	neg find mustInstanceOfEEnumLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfEClassifier_class(problem,interpretation,element);
	neg find mustInstanceOfETypeParameter_class(problem,interpretation,element);
	neg find mustInstanceOfETypedElement_class(problem,interpretation,element);
	neg find scopeDisallowsNewENamedElement_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEPackage_class(problem,interpretation,element);
	neg find mustInstanceOfEEnumLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfEClassifier_class(problem,interpretation,element);
	neg find mustInstanceOfETypeParameter_class(problem,interpretation,element);
	neg find mustInstanceOfETypedElement_class(problem,interpretation,element);
	neg find scopeDisallowsNewENamedElement_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfENamedElement_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "EPackage class DefinedPart".
 */
private pattern mustInstanceOfEPackage_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"EPackage class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewEPackage_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"EPackage class DefinedPart");
}

/**
 * An element may be an instance of type "EPackage class DefinedPart".
 */
private pattern mayInstanceOfEPackage_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfEPackage_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "EPackage class UndefinedPart".
 */
private pattern mustInstanceOfEPackage_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"EPackage class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewEPackage_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"EPackage class UndefinedPart");
}

/**
 * An element may be an instance of type "EPackage class UndefinedPart".
 */
private pattern mayInstanceOfEPackage_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEEnumLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfEClassifier_class(problem,interpretation,element);
	neg find mustInstanceOfETypedElement_class(problem,interpretation,element);
	neg find mustInstanceOfETypeParameter_class(problem,interpretation,element);
	neg find scopeDisallowsNewEPackage_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEEnumLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfEClassifier_class(problem,interpretation,element);
	neg find mustInstanceOfETypedElement_class(problem,interpretation,element);
	neg find mustInstanceOfETypeParameter_class(problem,interpretation,element);
	neg find scopeDisallowsNewEPackage_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfEPackage_class_UndefinedPart(problem,interpretation,element); }

//////////
// 1.2 Relation Declaration Indexers
//////////
/**
 * Matcher for detecting tuples t where []eAttributeType reference EAttribute(source,target)
 */
private pattern mustInRelationeAttributeType_reference_EAttribute(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eAttributeType reference EAttribute");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eAttributeType reference EAttribute(source,target)
 */
private pattern mayInRelationeAttributeType_reference_EAttribute(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEAttribute_class(problem,interpretation,source);
	find mayInstanceOfEDataType_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationeAttributeType_reference_EAttribute(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationeAttributeType_reference_EAttribute(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []details reference EAnnotation(source,target)
 */
private pattern mustInRelationdetails_reference_EAnnotation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"details reference EAnnotation");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>details reference EAnnotation(source,target)
 */
private pattern mayInRelationdetails_reference_EAnnotation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEAnnotation_class(problem,interpretation,source);
	find mayInstanceOfEStringToStringMapEntry_class(problem,interpretation,target);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationdetails_reference_EAnnotation(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eModelElement reference EAnnotation(source,target)
 */
private pattern mustInRelationeModelElement_reference_EAnnotation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eModelElement reference EAnnotation");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eModelElement reference EAnnotation(source,target)
 */
private pattern mayInRelationeModelElement_reference_EAnnotation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEAnnotation_class(problem,interpretation,source);
	find mayInstanceOfEModelElement_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationeModelElement_reference_EAnnotation(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationeModelElement_reference_EAnnotation(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []contents reference EAnnotation(source,target)
 */
private pattern mustInRelationcontents_reference_EAnnotation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"contents reference EAnnotation");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>contents reference EAnnotation(source,target)
 */
private pattern mayInRelationcontents_reference_EAnnotation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEAnnotation_class(problem,interpretation,source);
	find mayInstanceOfEObject_class(problem,interpretation,target);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationcontents_reference_EAnnotation(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []references reference EAnnotation(source,target)
 */
private pattern mustInRelationreferences_reference_EAnnotation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"references reference EAnnotation");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>references reference EAnnotation(source,target)
 */
private pattern mayInRelationreferences_reference_EAnnotation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEAnnotation_class(problem,interpretation,source);
	find mayInstanceOfEObject_class(problem,interpretation,target);
} or {
	find mustInRelationreferences_reference_EAnnotation(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eSuperTypes reference EClass(source,target)
 */
private pattern mustInRelationeSuperTypes_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eSuperTypes reference EClass");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eSuperTypes reference EClass(source,target)
 */
private pattern mayInRelationeSuperTypes_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEClass_class(problem,interpretation,source);
	find mayInstanceOfEClass_class(problem,interpretation,target);
} or {
	find mustInRelationeSuperTypes_reference_EClass(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eOperations reference EClass(source,target)
 */
private pattern mustInRelationeOperations_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eOperations reference EClass");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eOperations reference EClass(source,target)
 */
private pattern mayInRelationeOperations_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEClass_class(problem,interpretation,source);
	find mayInstanceOfEOperation_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationeContainingClass_reference_EOperation(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationeOperations_reference_EClass(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eAllAttributes reference EClass(source,target)
 */
private pattern mustInRelationeAllAttributes_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eAllAttributes reference EClass");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eAllAttributes reference EClass(source,target)
 */
private pattern mayInRelationeAllAttributes_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEClass_class(problem,interpretation,source);
	find mayInstanceOfEAttribute_class(problem,interpretation,target);
} or {
	find mustInRelationeAllAttributes_reference_EClass(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eAllReferences reference EClass(source,target)
 */
private pattern mustInRelationeAllReferences_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eAllReferences reference EClass");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eAllReferences reference EClass(source,target)
 */
private pattern mayInRelationeAllReferences_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEClass_class(problem,interpretation,source);
	find mayInstanceOfEReference_class(problem,interpretation,target);
} or {
	find mustInRelationeAllReferences_reference_EClass(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eReferences reference EClass(source,target)
 */
private pattern mustInRelationeReferences_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eReferences reference EClass");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eReferences reference EClass(source,target)
 */
private pattern mayInRelationeReferences_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEClass_class(problem,interpretation,source);
	find mayInstanceOfEReference_class(problem,interpretation,target);
} or {
	find mustInRelationeReferences_reference_EClass(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eAttributes reference EClass(source,target)
 */
private pattern mustInRelationeAttributes_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eAttributes reference EClass");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eAttributes reference EClass(source,target)
 */
private pattern mayInRelationeAttributes_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEClass_class(problem,interpretation,source);
	find mayInstanceOfEAttribute_class(problem,interpretation,target);
} or {
	find mustInRelationeAttributes_reference_EClass(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eAllContainments reference EClass(source,target)
 */
private pattern mustInRelationeAllContainments_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eAllContainments reference EClass");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eAllContainments reference EClass(source,target)
 */
private pattern mayInRelationeAllContainments_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEClass_class(problem,interpretation,source);
	find mayInstanceOfEReference_class(problem,interpretation,target);
} or {
	find mustInRelationeAllContainments_reference_EClass(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eAllOperations reference EClass(source,target)
 */
private pattern mustInRelationeAllOperations_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eAllOperations reference EClass");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eAllOperations reference EClass(source,target)
 */
private pattern mayInRelationeAllOperations_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEClass_class(problem,interpretation,source);
	find mayInstanceOfEOperation_class(problem,interpretation,target);
} or {
	find mustInRelationeAllOperations_reference_EClass(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eAllStructuralFeatures reference EClass(source,target)
 */
private pattern mustInRelationeAllStructuralFeatures_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eAllStructuralFeatures reference EClass");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eAllStructuralFeatures reference EClass(source,target)
 */
private pattern mayInRelationeAllStructuralFeatures_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEClass_class(problem,interpretation,source);
	find mayInstanceOfEStructuralFeature_class(problem,interpretation,target);
} or {
	find mustInRelationeAllStructuralFeatures_reference_EClass(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eAllSuperTypes reference EClass(source,target)
 */
private pattern mustInRelationeAllSuperTypes_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eAllSuperTypes reference EClass");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eAllSuperTypes reference EClass(source,target)
 */
private pattern mayInRelationeAllSuperTypes_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEClass_class(problem,interpretation,source);
	find mayInstanceOfEClass_class(problem,interpretation,target);
} or {
	find mustInRelationeAllSuperTypes_reference_EClass(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eIDAttribute reference EClass(source,target)
 */
private pattern mustInRelationeIDAttribute_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eIDAttribute reference EClass");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eIDAttribute reference EClass(source,target)
 */
private pattern mayInRelationeIDAttribute_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEClass_class(problem,interpretation,source);
	find mayInstanceOfEAttribute_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationeIDAttribute_reference_EClass(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationeIDAttribute_reference_EClass(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eStructuralFeatures reference EClass(source,target)
 */
private pattern mustInRelationeStructuralFeatures_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eStructuralFeatures reference EClass");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eStructuralFeatures reference EClass(source,target)
 */
private pattern mayInRelationeStructuralFeatures_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEClass_class(problem,interpretation,source);
	find mayInstanceOfEStructuralFeature_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationeContainingClass_reference_EStructuralFeature(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationeStructuralFeatures_reference_EClass(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eGenericSuperTypes reference EClass(source,target)
 */
private pattern mustInRelationeGenericSuperTypes_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eGenericSuperTypes reference EClass");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eGenericSuperTypes reference EClass(source,target)
 */
private pattern mayInRelationeGenericSuperTypes_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEClass_class(problem,interpretation,source);
	find mayInstanceOfEGenericType_class(problem,interpretation,target);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationeGenericSuperTypes_reference_EClass(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eAllGenericSuperTypes reference EClass(source,target)
 */
private pattern mustInRelationeAllGenericSuperTypes_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eAllGenericSuperTypes reference EClass");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eAllGenericSuperTypes reference EClass(source,target)
 */
private pattern mayInRelationeAllGenericSuperTypes_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEClass_class(problem,interpretation,source);
	find mayInstanceOfEGenericType_class(problem,interpretation,target);
} or {
	find mustInRelationeAllGenericSuperTypes_reference_EClass(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []ePackage reference EClassifier(source,target)
 */
private pattern mustInRelationePackage_reference_EClassifier(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"ePackage reference EClassifier");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>ePackage reference EClassifier(source,target)
 */
private pattern mayInRelationePackage_reference_EClassifier(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEClassifier_class(problem,interpretation,source);
	find mayInstanceOfEPackage_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationePackage_reference_EClassifier(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationePackage_reference_EClassifier(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eTypeParameters reference EClassifier(source,target)
 */
private pattern mustInRelationeTypeParameters_reference_EClassifier(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eTypeParameters reference EClassifier");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eTypeParameters reference EClassifier(source,target)
 */
private pattern mayInRelationeTypeParameters_reference_EClassifier(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEClassifier_class(problem,interpretation,source);
	find mayInstanceOfETypeParameter_class(problem,interpretation,target);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationeTypeParameters_reference_EClassifier(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eLiterals reference EEnum(source,target)
 */
private pattern mustInRelationeLiterals_reference_EEnum(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eLiterals reference EEnum");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eLiterals reference EEnum(source,target)
 */
private pattern mayInRelationeLiterals_reference_EEnum(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEEnum_class(problem,interpretation,source);
	find mayInstanceOfEEnumLiteral_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationeEnum_reference_EEnumLiteral(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationeLiterals_reference_EEnum(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eEnum reference EEnumLiteral(source,target)
 */
private pattern mustInRelationeEnum_reference_EEnumLiteral(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eEnum reference EEnumLiteral");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eEnum reference EEnumLiteral(source,target)
 */
private pattern mayInRelationeEnum_reference_EEnumLiteral(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEEnumLiteral_class(problem,interpretation,source);
	find mayInstanceOfEEnum_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationeEnum_reference_EEnumLiteral(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationeEnum_reference_EEnumLiteral(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eAnnotations reference EModelElement(source,target)
 */
private pattern mustInRelationeAnnotations_reference_EModelElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eAnnotations reference EModelElement");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eAnnotations reference EModelElement(source,target)
 */
private pattern mayInRelationeAnnotations_reference_EModelElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEModelElement_class(problem,interpretation,source);
	find mayInstanceOfEAnnotation_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationeModelElement_reference_EAnnotation(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationeAnnotations_reference_EModelElement(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eContainingClass reference EOperation(source,target)
 */
private pattern mustInRelationeContainingClass_reference_EOperation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eContainingClass reference EOperation");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eContainingClass reference EOperation(source,target)
 */
private pattern mayInRelationeContainingClass_reference_EOperation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEOperation_class(problem,interpretation,source);
	find mayInstanceOfEClass_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationeContainingClass_reference_EOperation(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationeContainingClass_reference_EOperation(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eTypeParameters reference EOperation(source,target)
 */
private pattern mustInRelationeTypeParameters_reference_EOperation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eTypeParameters reference EOperation");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eTypeParameters reference EOperation(source,target)
 */
private pattern mayInRelationeTypeParameters_reference_EOperation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEOperation_class(problem,interpretation,source);
	find mayInstanceOfETypeParameter_class(problem,interpretation,target);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationeTypeParameters_reference_EOperation(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eParameters reference EOperation(source,target)
 */
private pattern mustInRelationeParameters_reference_EOperation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eParameters reference EOperation");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eParameters reference EOperation(source,target)
 */
private pattern mayInRelationeParameters_reference_EOperation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEOperation_class(problem,interpretation,source);
	find mayInstanceOfEParameter_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationeOperation_reference_EParameter(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationeParameters_reference_EOperation(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eExceptions reference EOperation(source,target)
 */
private pattern mustInRelationeExceptions_reference_EOperation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eExceptions reference EOperation");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eExceptions reference EOperation(source,target)
 */
private pattern mayInRelationeExceptions_reference_EOperation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEOperation_class(problem,interpretation,source);
	find mayInstanceOfEClassifier_class(problem,interpretation,target);
} or {
	find mustInRelationeExceptions_reference_EOperation(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eGenericExceptions reference EOperation(source,target)
 */
private pattern mustInRelationeGenericExceptions_reference_EOperation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eGenericExceptions reference EOperation");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eGenericExceptions reference EOperation(source,target)
 */
private pattern mayInRelationeGenericExceptions_reference_EOperation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEOperation_class(problem,interpretation,source);
	find mayInstanceOfEGenericType_class(problem,interpretation,target);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationeGenericExceptions_reference_EOperation(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eClassifiers reference EPackage(source,target)
 */
private pattern mustInRelationeClassifiers_reference_EPackage(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eClassifiers reference EPackage");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eClassifiers reference EPackage(source,target)
 */
private pattern mayInRelationeClassifiers_reference_EPackage(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEPackage_class(problem,interpretation,source);
	find mayInstanceOfEClassifier_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationePackage_reference_EClassifier(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationeClassifiers_reference_EPackage(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eSubpackages reference EPackage(source,target)
 */
private pattern mustInRelationeSubpackages_reference_EPackage(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eSubpackages reference EPackage");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eSubpackages reference EPackage(source,target)
 */
private pattern mayInRelationeSubpackages_reference_EPackage(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEPackage_class(problem,interpretation,source);
	find mayInstanceOfEPackage_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationeSuperPackage_reference_EPackage(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationeSubpackages_reference_EPackage(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eSuperPackage reference EPackage(source,target)
 */
private pattern mustInRelationeSuperPackage_reference_EPackage(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eSuperPackage reference EPackage");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eSuperPackage reference EPackage(source,target)
 */
private pattern mayInRelationeSuperPackage_reference_EPackage(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEPackage_class(problem,interpretation,source);
	find mayInstanceOfEPackage_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationeSuperPackage_reference_EPackage(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationeSuperPackage_reference_EPackage(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eOperation reference EParameter(source,target)
 */
private pattern mustInRelationeOperation_reference_EParameter(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eOperation reference EParameter");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eOperation reference EParameter(source,target)
 */
private pattern mayInRelationeOperation_reference_EParameter(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEParameter_class(problem,interpretation,source);
	find mayInstanceOfEOperation_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationeOperation_reference_EParameter(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationeOperation_reference_EParameter(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eOpposite reference EReference(source,target)
 */
private pattern mustInRelationeOpposite_reference_EReference(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eOpposite reference EReference");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eOpposite reference EReference(source,target)
 */
private pattern mayInRelationeOpposite_reference_EReference(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEReference_class(problem,interpretation,source);
	find mayInstanceOfEReference_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationeOpposite_reference_EReference(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationeOpposite_reference_EReference(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eReferenceType reference EReference(source,target)
 */
private pattern mustInRelationeReferenceType_reference_EReference(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eReferenceType reference EReference");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eReferenceType reference EReference(source,target)
 */
private pattern mayInRelationeReferenceType_reference_EReference(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEReference_class(problem,interpretation,source);
	find mayInstanceOfEClass_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationeReferenceType_reference_EReference(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationeReferenceType_reference_EReference(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eKeys reference EReference(source,target)
 */
private pattern mustInRelationeKeys_reference_EReference(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eKeys reference EReference");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eKeys reference EReference(source,target)
 */
private pattern mayInRelationeKeys_reference_EReference(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEReference_class(problem,interpretation,source);
	find mayInstanceOfEAttribute_class(problem,interpretation,target);
} or {
	find mustInRelationeKeys_reference_EReference(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eContainingClass reference EStructuralFeature(source,target)
 */
private pattern mustInRelationeContainingClass_reference_EStructuralFeature(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eContainingClass reference EStructuralFeature");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eContainingClass reference EStructuralFeature(source,target)
 */
private pattern mayInRelationeContainingClass_reference_EStructuralFeature(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEStructuralFeature_class(problem,interpretation,source);
	find mayInstanceOfEClass_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationeContainingClass_reference_EStructuralFeature(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationeContainingClass_reference_EStructuralFeature(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eType reference ETypedElement(source,target)
 */
private pattern mustInRelationeType_reference_ETypedElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eType reference ETypedElement");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eType reference ETypedElement(source,target)
 */
private pattern mayInRelationeType_reference_ETypedElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfETypedElement_class(problem,interpretation,source);
	find mayInstanceOfEClassifier_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationeType_reference_ETypedElement(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationeType_reference_ETypedElement(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eGenericType reference ETypedElement(source,target)
 */
private pattern mustInRelationeGenericType_reference_ETypedElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eGenericType reference ETypedElement");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eGenericType reference ETypedElement(source,target)
 */
private pattern mayInRelationeGenericType_reference_ETypedElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfETypedElement_class(problem,interpretation,source);
	find mayInstanceOfEGenericType_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationeGenericType_reference_ETypedElement(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationeGenericType_reference_ETypedElement(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eUpperBound reference EGenericType(source,target)
 */
private pattern mustInRelationeUpperBound_reference_EGenericType(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eUpperBound reference EGenericType");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eUpperBound reference EGenericType(source,target)
 */
private pattern mayInRelationeUpperBound_reference_EGenericType(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEGenericType_class(problem,interpretation,source);
	find mayInstanceOfEGenericType_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationeUpperBound_reference_EGenericType(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationeUpperBound_reference_EGenericType(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eTypeArguments reference EGenericType(source,target)
 */
private pattern mustInRelationeTypeArguments_reference_EGenericType(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eTypeArguments reference EGenericType");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eTypeArguments reference EGenericType(source,target)
 */
private pattern mayInRelationeTypeArguments_reference_EGenericType(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEGenericType_class(problem,interpretation,source);
	find mayInstanceOfEGenericType_class(problem,interpretation,target);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationeTypeArguments_reference_EGenericType(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eRawType reference EGenericType(source,target)
 */
private pattern mustInRelationeRawType_reference_EGenericType(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eRawType reference EGenericType");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eRawType reference EGenericType(source,target)
 */
private pattern mayInRelationeRawType_reference_EGenericType(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEGenericType_class(problem,interpretation,source);
	find mayInstanceOfEClassifier_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationeRawType_reference_EGenericType(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationeRawType_reference_EGenericType(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eLowerBound reference EGenericType(source,target)
 */
private pattern mustInRelationeLowerBound_reference_EGenericType(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eLowerBound reference EGenericType");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eLowerBound reference EGenericType(source,target)
 */
private pattern mayInRelationeLowerBound_reference_EGenericType(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEGenericType_class(problem,interpretation,source);
	find mayInstanceOfEGenericType_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationeLowerBound_reference_EGenericType(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationeLowerBound_reference_EGenericType(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eTypeParameter reference EGenericType(source,target)
 */
private pattern mustInRelationeTypeParameter_reference_EGenericType(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eTypeParameter reference EGenericType");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eTypeParameter reference EGenericType(source,target)
 */
private pattern mayInRelationeTypeParameter_reference_EGenericType(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEGenericType_class(problem,interpretation,source);
	find mayInstanceOfETypeParameter_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationeTypeParameter_reference_EGenericType(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationeTypeParameter_reference_EGenericType(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eClassifier reference EGenericType(source,target)
 */
private pattern mustInRelationeClassifier_reference_EGenericType(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eClassifier reference EGenericType");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eClassifier reference EGenericType(source,target)
 */
private pattern mayInRelationeClassifier_reference_EGenericType(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEGenericType_class(problem,interpretation,source);
	find mayInstanceOfEClassifier_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationeClassifier_reference_EGenericType(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationeClassifier_reference_EGenericType(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eBounds reference ETypeParameter(source,target)
 */
private pattern mustInRelationeBounds_reference_ETypeParameter(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eBounds reference ETypeParameter");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eBounds reference ETypeParameter(source,target)
 */
private pattern mayInRelationeBounds_reference_ETypeParameter(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfETypeParameter_class(problem,interpretation,source);
	find mayInstanceOfEGenericType_class(problem,interpretation,target);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationeBounds_reference_ETypeParameter(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []iD attribute EAttribute(source,target)
 */
private pattern mustInRelationiD_attribute_EAttribute(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"iD attribute EAttribute");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>iD attribute EAttribute(source,target)
 */
private pattern mayInRelationiD_attribute_EAttribute(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEAttribute_class(problem,interpretation,source);
	BooleanElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationiD_attribute_EAttribute(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationiD_attribute_EAttribute(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []source attribute EAnnotation(source,target)
 */
private pattern mustInRelationsource_attribute_EAnnotation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"source attribute EAnnotation");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>source attribute EAnnotation(source,target)
 */
private pattern mayInRelationsource_attribute_EAnnotation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEAnnotation_class(problem,interpretation,source);
	StringElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationsource_attribute_EAnnotation(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationsource_attribute_EAnnotation(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []abstract attribute EClass(source,target)
 */
private pattern mustInRelationabstract_attribute_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"abstract attribute EClass");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>abstract attribute EClass(source,target)
 */
private pattern mayInRelationabstract_attribute_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEClass_class(problem,interpretation,source);
	BooleanElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationabstract_attribute_EClass(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationabstract_attribute_EClass(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []interface attribute EClass(source,target)
 */
private pattern mustInRelationinterface_attribute_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"interface attribute EClass");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>interface attribute EClass(source,target)
 */
private pattern mayInRelationinterface_attribute_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEClass_class(problem,interpretation,source);
	BooleanElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationinterface_attribute_EClass(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationinterface_attribute_EClass(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []instanceClassName attribute EClassifier(source,target)
 */
private pattern mustInRelationinstanceClassName_attribute_EClassifier(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"instanceClassName attribute EClassifier");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>instanceClassName attribute EClassifier(source,target)
 */
private pattern mayInRelationinstanceClassName_attribute_EClassifier(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEClassifier_class(problem,interpretation,source);
	StringElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationinstanceClassName_attribute_EClassifier(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationinstanceClassName_attribute_EClassifier(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []instanceTypeName attribute EClassifier(source,target)
 */
private pattern mustInRelationinstanceTypeName_attribute_EClassifier(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"instanceTypeName attribute EClassifier");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>instanceTypeName attribute EClassifier(source,target)
 */
private pattern mayInRelationinstanceTypeName_attribute_EClassifier(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEClassifier_class(problem,interpretation,source);
	StringElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationinstanceTypeName_attribute_EClassifier(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationinstanceTypeName_attribute_EClassifier(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []serializable attribute EDataType(source,target)
 */
private pattern mustInRelationserializable_attribute_EDataType(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"serializable attribute EDataType");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>serializable attribute EDataType(source,target)
 */
private pattern mayInRelationserializable_attribute_EDataType(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEDataType_class(problem,interpretation,source);
	BooleanElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationserializable_attribute_EDataType(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationserializable_attribute_EDataType(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []value attribute EEnumLiteral(source,target)
 */
private pattern mustInRelationvalue_attribute_EEnumLiteral(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"value attribute EEnumLiteral");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>value attribute EEnumLiteral(source,target)
 */
private pattern mayInRelationvalue_attribute_EEnumLiteral(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEEnumLiteral_class(problem,interpretation,source);
	IntegerElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationvalue_attribute_EEnumLiteral(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationvalue_attribute_EEnumLiteral(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []literal attribute EEnumLiteral(source,target)
 */
private pattern mustInRelationliteral_attribute_EEnumLiteral(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"literal attribute EEnumLiteral");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>literal attribute EEnumLiteral(source,target)
 */
private pattern mayInRelationliteral_attribute_EEnumLiteral(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEEnumLiteral_class(problem,interpretation,source);
	StringElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationliteral_attribute_EEnumLiteral(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationliteral_attribute_EEnumLiteral(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []name attribute ENamedElement(source,target)
 */
private pattern mustInRelationname_attribute_ENamedElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"name attribute ENamedElement");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>name attribute ENamedElement(source,target)
 */
private pattern mayInRelationname_attribute_ENamedElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfENamedElement_class(problem,interpretation,source);
	StringElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationname_attribute_ENamedElement(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationname_attribute_ENamedElement(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []nsURI attribute EPackage(source,target)
 */
private pattern mustInRelationnsURI_attribute_EPackage(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"nsURI attribute EPackage");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>nsURI attribute EPackage(source,target)
 */
private pattern mayInRelationnsURI_attribute_EPackage(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEPackage_class(problem,interpretation,source);
	StringElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationnsURI_attribute_EPackage(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationnsURI_attribute_EPackage(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []nsPrefix attribute EPackage(source,target)
 */
private pattern mustInRelationnsPrefix_attribute_EPackage(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"nsPrefix attribute EPackage");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>nsPrefix attribute EPackage(source,target)
 */
private pattern mayInRelationnsPrefix_attribute_EPackage(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEPackage_class(problem,interpretation,source);
	StringElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationnsPrefix_attribute_EPackage(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationnsPrefix_attribute_EPackage(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []containment attribute EReference(source,target)
 */
private pattern mustInRelationcontainment_attribute_EReference(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"containment attribute EReference");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>containment attribute EReference(source,target)
 */
private pattern mayInRelationcontainment_attribute_EReference(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEReference_class(problem,interpretation,source);
	BooleanElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationcontainment_attribute_EReference(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationcontainment_attribute_EReference(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []container attribute EReference(source,target)
 */
private pattern mustInRelationcontainer_attribute_EReference(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"container attribute EReference");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>container attribute EReference(source,target)
 */
private pattern mayInRelationcontainer_attribute_EReference(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEReference_class(problem,interpretation,source);
	BooleanElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationcontainer_attribute_EReference(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationcontainer_attribute_EReference(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []resolveProxies attribute EReference(source,target)
 */
private pattern mustInRelationresolveProxies_attribute_EReference(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"resolveProxies attribute EReference");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>resolveProxies attribute EReference(source,target)
 */
private pattern mayInRelationresolveProxies_attribute_EReference(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEReference_class(problem,interpretation,source);
	BooleanElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationresolveProxies_attribute_EReference(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationresolveProxies_attribute_EReference(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []changeable attribute EStructuralFeature(source,target)
 */
private pattern mustInRelationchangeable_attribute_EStructuralFeature(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"changeable attribute EStructuralFeature");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>changeable attribute EStructuralFeature(source,target)
 */
private pattern mayInRelationchangeable_attribute_EStructuralFeature(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEStructuralFeature_class(problem,interpretation,source);
	BooleanElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationchangeable_attribute_EStructuralFeature(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationchangeable_attribute_EStructuralFeature(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []volatile attribute EStructuralFeature(source,target)
 */
private pattern mustInRelationvolatile_attribute_EStructuralFeature(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"volatile attribute EStructuralFeature");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>volatile attribute EStructuralFeature(source,target)
 */
private pattern mayInRelationvolatile_attribute_EStructuralFeature(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEStructuralFeature_class(problem,interpretation,source);
	BooleanElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationvolatile_attribute_EStructuralFeature(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationvolatile_attribute_EStructuralFeature(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []transient attribute EStructuralFeature(source,target)
 */
private pattern mustInRelationtransient_attribute_EStructuralFeature(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"transient attribute EStructuralFeature");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>transient attribute EStructuralFeature(source,target)
 */
private pattern mayInRelationtransient_attribute_EStructuralFeature(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEStructuralFeature_class(problem,interpretation,source);
	BooleanElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationtransient_attribute_EStructuralFeature(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationtransient_attribute_EStructuralFeature(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []defaultValueLiteral attribute EStructuralFeature(source,target)
 */
private pattern mustInRelationdefaultValueLiteral_attribute_EStructuralFeature(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"defaultValueLiteral attribute EStructuralFeature");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>defaultValueLiteral attribute EStructuralFeature(source,target)
 */
private pattern mayInRelationdefaultValueLiteral_attribute_EStructuralFeature(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEStructuralFeature_class(problem,interpretation,source);
	StringElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationdefaultValueLiteral_attribute_EStructuralFeature(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationdefaultValueLiteral_attribute_EStructuralFeature(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []unsettable attribute EStructuralFeature(source,target)
 */
private pattern mustInRelationunsettable_attribute_EStructuralFeature(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"unsettable attribute EStructuralFeature");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>unsettable attribute EStructuralFeature(source,target)
 */
private pattern mayInRelationunsettable_attribute_EStructuralFeature(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEStructuralFeature_class(problem,interpretation,source);
	BooleanElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationunsettable_attribute_EStructuralFeature(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationunsettable_attribute_EStructuralFeature(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []derived attribute EStructuralFeature(source,target)
 */
private pattern mustInRelationderived_attribute_EStructuralFeature(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"derived attribute EStructuralFeature");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>derived attribute EStructuralFeature(source,target)
 */
private pattern mayInRelationderived_attribute_EStructuralFeature(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEStructuralFeature_class(problem,interpretation,source);
	BooleanElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationderived_attribute_EStructuralFeature(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationderived_attribute_EStructuralFeature(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []ordered attribute ETypedElement(source,target)
 */
private pattern mustInRelationordered_attribute_ETypedElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"ordered attribute ETypedElement");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>ordered attribute ETypedElement(source,target)
 */
private pattern mayInRelationordered_attribute_ETypedElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfETypedElement_class(problem,interpretation,source);
	BooleanElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationordered_attribute_ETypedElement(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationordered_attribute_ETypedElement(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []unique attribute ETypedElement(source,target)
 */
private pattern mustInRelationunique_attribute_ETypedElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"unique attribute ETypedElement");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>unique attribute ETypedElement(source,target)
 */
private pattern mayInRelationunique_attribute_ETypedElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfETypedElement_class(problem,interpretation,source);
	BooleanElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationunique_attribute_ETypedElement(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationunique_attribute_ETypedElement(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []lowerBound attribute ETypedElement(source,target)
 */
private pattern mustInRelationlowerBound_attribute_ETypedElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"lowerBound attribute ETypedElement");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>lowerBound attribute ETypedElement(source,target)
 */
private pattern mayInRelationlowerBound_attribute_ETypedElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfETypedElement_class(problem,interpretation,source);
	IntegerElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationlowerBound_attribute_ETypedElement(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationlowerBound_attribute_ETypedElement(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []upperBound attribute ETypedElement(source,target)
 */
private pattern mustInRelationupperBound_attribute_ETypedElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"upperBound attribute ETypedElement");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>upperBound attribute ETypedElement(source,target)
 */
private pattern mayInRelationupperBound_attribute_ETypedElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfETypedElement_class(problem,interpretation,source);
	IntegerElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationupperBound_attribute_ETypedElement(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationupperBound_attribute_ETypedElement(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []many attribute ETypedElement(source,target)
 */
private pattern mustInRelationmany_attribute_ETypedElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"many attribute ETypedElement");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>many attribute ETypedElement(source,target)
 */
private pattern mayInRelationmany_attribute_ETypedElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfETypedElement_class(problem,interpretation,source);
	BooleanElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationmany_attribute_ETypedElement(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationmany_attribute_ETypedElement(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []required attribute ETypedElement(source,target)
 */
private pattern mustInRelationrequired_attribute_ETypedElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"required attribute ETypedElement");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>required attribute ETypedElement(source,target)
 */
private pattern mayInRelationrequired_attribute_ETypedElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfETypedElement_class(problem,interpretation,source);
	BooleanElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationrequired_attribute_ETypedElement(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationrequired_attribute_ETypedElement(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []key attribute EStringToStringMapEntry(source,target)
 */
private pattern mustInRelationkey_attribute_EStringToStringMapEntry(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"key attribute EStringToStringMapEntry");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>key attribute EStringToStringMapEntry(source,target)
 */
private pattern mayInRelationkey_attribute_EStringToStringMapEntry(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEStringToStringMapEntry_class(problem,interpretation,source);
	StringElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationkey_attribute_EStringToStringMapEntry(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationkey_attribute_EStringToStringMapEntry(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []value attribute EStringToStringMapEntry(source,target)
 */
private pattern mustInRelationvalue_attribute_EStringToStringMapEntry(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"value attribute EStringToStringMapEntry");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>value attribute EStringToStringMapEntry(source,target)
 */
private pattern mayInRelationvalue_attribute_EStringToStringMapEntry(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEStringToStringMapEntry_class(problem,interpretation,source);
	StringElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationvalue_attribute_EStringToStringMapEntry(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationvalue_attribute_EStringToStringMapEntry(problem,interpretation,source,target);
}

//////////
// 1.3 Relation Definition Indexers
//////////

//////////
// 1.4 Containment Indexer
//////////
private pattern mustContains2(source: DefinedElement, target: DefinedElement) {
	find mustContains4(_,_,source,target);
}
	
private pattern mustContains4(problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target: DefinedElement)
	{ find mustInRelationdetails_reference_EAnnotation(problem,interpretation,source,target); }or
	
	{ find mustInRelationcontents_reference_EAnnotation(problem,interpretation,source,target); }or
	
	{ find mustInRelationeOperations_reference_EClass(problem,interpretation,source,target); }or
	
	{ find mustInRelationeStructuralFeatures_reference_EClass(problem,interpretation,source,target); }or
	
	{ find mustInRelationeGenericSuperTypes_reference_EClass(problem,interpretation,source,target); }or
	
	{ find mustInRelationeTypeParameters_reference_EClassifier(problem,interpretation,source,target); }or
	
	{ find mustInRelationeLiterals_reference_EEnum(problem,interpretation,source,target); }or
	
	{ find mustInRelationeAnnotations_reference_EModelElement(problem,interpretation,source,target); }or
	
	{ find mustInRelationeTypeParameters_reference_EOperation(problem,interpretation,source,target); }or
	
	{ find mustInRelationeParameters_reference_EOperation(problem,interpretation,source,target); }or
	
	{ find mustInRelationeGenericExceptions_reference_EOperation(problem,interpretation,source,target); }or
	
	{ find mustInRelationeClassifiers_reference_EPackage(problem,interpretation,source,target); }or
	
	{ find mustInRelationeSubpackages_reference_EPackage(problem,interpretation,source,target); }or
	
	{ find mustInRelationeGenericType_reference_ETypedElement(problem,interpretation,source,target); }or
	
	{ find mustInRelationeUpperBound_reference_EGenericType(problem,interpretation,source,target); }or
	
	{ find mustInRelationeTypeArguments_reference_EGenericType(problem,interpretation,source,target); }or
	
	{ find mustInRelationeLowerBound_reference_EGenericType(problem,interpretation,source,target); }or
	
	{ find mustInRelationeBounds_reference_ETypeParameter(problem,interpretation,source,target); }

private pattern mustTransitiveContains(source,target) {
	find mustContains2+(source,target);
}

//////////
// 2. Invalidation Indexers
//////////
// 2.1 Invalidated by WF Queries
//////////

//////////
// 3. Unfinishedness Indexers
//////////
// 3.1 Unfinishedness Measured by Multiplicity
//////////
pattern unfinishedLowerMultiplicity_eAttributeType_reference_EAttribute(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eAttributeType reference EAttribute");
	find mustInstanceOfEAttribute_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationeAttributeType_reference_EAttribute(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_eReferenceType_reference_EReference(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eReferenceType reference EReference");
	find mustInstanceOfEReference_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationeReferenceType_reference_EReference(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_eRawType_reference_EGenericType(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eRawType reference EGenericType");
	find mustInstanceOfEGenericType_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationeRawType_reference_EGenericType(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}

//////////
// 3.2 Unfinishedness Measured by WF Queries
//////////

//////////
// 4. Refinement Indexers
//////////
// 4.1 Object constructors
//////////
private pattern hasElementInContainment(problem:LogicProblem, interpretation:PartialInterpretation)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfETypeParameter_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfETypedElement_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfEClass_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfEStructuralFeature_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfEAnnotation_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfEAttribute_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfEObject_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfEClassifier_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfEGenericType_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfEEnumLiteral_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfEDataType_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfEOperation_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfEPackage_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfEParameter_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfEModelElement_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfEReference_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfEEnum_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfENamedElement_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfEModelElement_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfEModelElement_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfENamedElement_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfENamedElement_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfEPackage_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfEPackage_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}
pattern createObject_EAnnotation_class_by_eAnnotations_reference_EModelElement_with_eModelElement_reference_EAnnotation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"EAnnotation class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"eAnnotations reference EModelElement");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"eModelElement reference EAnnotation");
	find mustInstanceOfEModelElement_class(problem,interpretation,container);
	find mayInstanceOfEAnnotation_class(problem,interpretation,newObject);
	find mayInRelationeAnnotations_reference_EModelElement(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_EAnnotation_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"EAnnotation class");
	find mayInstanceOfEAnnotation_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_EClass_class_by_eClassifiers_reference_EPackage_with_ePackage_reference_EClassifier(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"EClass class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"eClassifiers reference EPackage");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"ePackage reference EClassifier");
	find mustInstanceOfEPackage_class(problem,interpretation,container);
	find mayInstanceOfEClass_class(problem,interpretation,newObject);
	find mayInRelationeClassifiers_reference_EPackage(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_EClass_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"EClass class");
	find mayInstanceOfEClass_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_EEnum_class_by_eClassifiers_reference_EPackage_with_ePackage_reference_EClassifier(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"EEnum class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"eClassifiers reference EPackage");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"ePackage reference EClassifier");
	find mustInstanceOfEPackage_class(problem,interpretation,container);
	find mayInstanceOfEEnum_class(problem,interpretation,newObject);
	find mayInRelationeClassifiers_reference_EPackage(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_EEnum_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"EEnum class");
	find mayInstanceOfEEnum_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_EReference_class_by_eStructuralFeatures_reference_EClass_with_eContainingClass_reference_EStructuralFeature(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"EReference class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"eStructuralFeatures reference EClass");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"eContainingClass reference EStructuralFeature");
	find mustInstanceOfEClass_class(problem,interpretation,container);
	find mayInstanceOfEReference_class(problem,interpretation,newObject);
	find mayInRelationeStructuralFeatures_reference_EClass(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_EReference_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"EReference class");
	find mayInstanceOfEReference_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_EOperation_class_by_eOperations_reference_EClass_with_eContainingClass_reference_EOperation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"EOperation class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"eOperations reference EClass");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"eContainingClass reference EOperation");
	find mustInstanceOfEClass_class(problem,interpretation,container);
	find mayInstanceOfEOperation_class(problem,interpretation,newObject);
	find mayInRelationeOperations_reference_EClass(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_EOperation_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"EOperation class");
	find mayInstanceOfEOperation_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_ETypeParameter_class_by_eTypeParameters_reference_EClassifier(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"ETypeParameter class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"eTypeParameters reference EClassifier");
	find mustInstanceOfEClassifier_class(problem,interpretation,container);
	find mayInstanceOfETypeParameter_class(problem,interpretation,newObject);
	find mayInRelationeTypeParameters_reference_EClassifier(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_ETypeParameter_class_by_eTypeParameters_reference_EOperation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"ETypeParameter class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"eTypeParameters reference EOperation");
	find mustInstanceOfEOperation_class(problem,interpretation,container);
	find mayInstanceOfETypeParameter_class(problem,interpretation,newObject);
	find mayInRelationeTypeParameters_reference_EOperation(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_ETypeParameter_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"ETypeParameter class");
	find mayInstanceOfETypeParameter_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_EPackage_class_UndefinedPart_by_eSubpackages_reference_EPackage_with_eSuperPackage_reference_EPackage(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"EPackage class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"eSubpackages reference EPackage");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"eSuperPackage reference EPackage");
	find mustInstanceOfEPackage_class(problem,interpretation,container);
	find mayInstanceOfEPackage_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationeSubpackages_reference_EPackage(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_EPackage_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"EPackage class UndefinedPart");
	find mayInstanceOfEPackage_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_EStringToStringMapEntry_class_by_details_reference_EAnnotation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"EStringToStringMapEntry class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"details reference EAnnotation");
	find mustInstanceOfEAnnotation_class(problem,interpretation,container);
	find mayInstanceOfEStringToStringMapEntry_class(problem,interpretation,newObject);
	find mayInRelationdetails_reference_EAnnotation(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_EStringToStringMapEntry_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"EStringToStringMapEntry class");
	find mayInstanceOfEStringToStringMapEntry_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_EObject_class_by_contents_reference_EAnnotation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"EObject class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"contents reference EAnnotation");
	find mustInstanceOfEAnnotation_class(problem,interpretation,container);
	find mayInstanceOfEObject_class(problem,interpretation,newObject);
	find mayInRelationcontents_reference_EAnnotation(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_EObject_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"EObject class");
	find mayInstanceOfEObject_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_EGenericType_class_by_eGenericSuperTypes_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"EGenericType class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"eGenericSuperTypes reference EClass");
	find mustInstanceOfEClass_class(problem,interpretation,container);
	find mayInstanceOfEGenericType_class(problem,interpretation,newObject);
	find mayInRelationeGenericSuperTypes_reference_EClass(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_EGenericType_class_by_eGenericExceptions_reference_EOperation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"EGenericType class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"eGenericExceptions reference EOperation");
	find mustInstanceOfEOperation_class(problem,interpretation,container);
	find mayInstanceOfEGenericType_class(problem,interpretation,newObject);
	find mayInRelationeGenericExceptions_reference_EOperation(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_EGenericType_class_by_eGenericType_reference_ETypedElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"EGenericType class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"eGenericType reference ETypedElement");
	find mustInstanceOfETypedElement_class(problem,interpretation,container);
	find mayInstanceOfEGenericType_class(problem,interpretation,newObject);
	find mayInRelationeGenericType_reference_ETypedElement(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_EGenericType_class_by_eUpperBound_reference_EGenericType(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"EGenericType class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"eUpperBound reference EGenericType");
	find mustInstanceOfEGenericType_class(problem,interpretation,container);
	find mayInstanceOfEGenericType_class(problem,interpretation,newObject);
	find mayInRelationeUpperBound_reference_EGenericType(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_EGenericType_class_by_eTypeArguments_reference_EGenericType(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"EGenericType class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"eTypeArguments reference EGenericType");
	find mustInstanceOfEGenericType_class(problem,interpretation,container);
	find mayInstanceOfEGenericType_class(problem,interpretation,newObject);
	find mayInRelationeTypeArguments_reference_EGenericType(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_EGenericType_class_by_eLowerBound_reference_EGenericType(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"EGenericType class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"eLowerBound reference EGenericType");
	find mustInstanceOfEGenericType_class(problem,interpretation,container);
	find mayInstanceOfEGenericType_class(problem,interpretation,newObject);
	find mayInRelationeLowerBound_reference_EGenericType(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_EGenericType_class_by_eBounds_reference_ETypeParameter(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"EGenericType class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"eBounds reference ETypeParameter");
	find mustInstanceOfETypeParameter_class(problem,interpretation,container);
	find mayInstanceOfEGenericType_class(problem,interpretation,newObject);
	find mayInRelationeBounds_reference_ETypeParameter(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_EGenericType_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"EGenericType class");
	find mayInstanceOfEGenericType_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_EParameter_class_by_eParameters_reference_EOperation_with_eOperation_reference_EParameter(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"EParameter class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"eParameters reference EOperation");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"eOperation reference EParameter");
	find mustInstanceOfEOperation_class(problem,interpretation,container);
	find mayInstanceOfEParameter_class(problem,interpretation,newObject);
	find mayInRelationeParameters_reference_EOperation(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_EParameter_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"EParameter class");
	find mayInstanceOfEParameter_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_EAttribute_class_by_eStructuralFeatures_reference_EClass_with_eContainingClass_reference_EStructuralFeature(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"EAttribute class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"eStructuralFeatures reference EClass");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"eContainingClass reference EStructuralFeature");
	find mustInstanceOfEClass_class(problem,interpretation,container);
	find mayInstanceOfEAttribute_class(problem,interpretation,newObject);
	find mayInRelationeStructuralFeatures_reference_EClass(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_EAttribute_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"EAttribute class");
	find mayInstanceOfEAttribute_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_EEnumLiteral_class_by_eLiterals_reference_EEnum_with_eEnum_reference_EEnumLiteral(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"EEnumLiteral class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"eLiterals reference EEnum");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"eEnum reference EEnumLiteral");
	find mustInstanceOfEEnum_class(problem,interpretation,container);
	find mayInstanceOfEEnumLiteral_class(problem,interpretation,newObject);
	find mayInRelationeLiterals_reference_EEnum(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_EEnumLiteral_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"EEnumLiteral class");
	find mayInstanceOfEEnumLiteral_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_EDataType_class_by_eClassifiers_reference_EPackage_with_ePackage_reference_EClassifier(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"EDataType class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"eClassifiers reference EPackage");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"ePackage reference EClassifier");
	find mustInstanceOfEPackage_class(problem,interpretation,container);
	find mayInstanceOfEDataType_class(problem,interpretation,newObject);
	find mayInRelationeClassifiers_reference_EPackage(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_EDataType_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"EDataType class");
	find mayInstanceOfEDataType_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}

//////////
// 4.2 Type refinement
//////////
pattern refineTypeTo_EAnnotation_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfENamedElement_class(problem,interpretation,element);
}
pattern refineTypeTo_EClass_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfEClass_class(problem,interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEClass_class(problem,interpretation,element);
	neg find mustInstanceOfEPackage_class(problem,interpretation,element);
	neg find mustInstanceOfEEnumLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfEDataType_class(problem,interpretation,element);
	neg find mustInstanceOfETypedElement_class(problem,interpretation,element);
	neg find mustInstanceOfETypeParameter_class(problem,interpretation,element);
}
pattern refineTypeTo_EEnum_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfEEnum_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEClass_class(problem,interpretation,element);
	neg find mustInstanceOfEPackage_class(problem,interpretation,element);
	neg find mustInstanceOfEEnum_class(problem,interpretation,element);
	neg find mustInstanceOfEEnumLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfETypeParameter_class(problem,interpretation,element);
	neg find mustInstanceOfETypedElement_class(problem,interpretation,element);
}
pattern refineTypeTo_EReference_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfEReference_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEAttribute_class(problem,interpretation,element);
	neg find mustInstanceOfEPackage_class(problem,interpretation,element);
	neg find mustInstanceOfEEnumLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfEReference_class(problem,interpretation,element);
	neg find mustInstanceOfEOperation_class(problem,interpretation,element);
	neg find mustInstanceOfEClassifier_class(problem,interpretation,element);
	neg find mustInstanceOfETypeParameter_class(problem,interpretation,element);
}
pattern refineTypeTo_EOperation_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfEOperation_class(problem,interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEStructuralFeature_class(problem,interpretation,element);
	neg find mustInstanceOfEPackage_class(problem,interpretation,element);
	neg find mustInstanceOfEEnumLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfEOperation_class(problem,interpretation,element);
	neg find mustInstanceOfEClassifier_class(problem,interpretation,element);
	neg find mustInstanceOfETypeParameter_class(problem,interpretation,element);
}
pattern refineTypeTo_ETypeParameter_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfETypeParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEPackage_class(problem,interpretation,element);
	neg find mustInstanceOfEEnumLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfEClassifier_class(problem,interpretation,element);
	neg find mustInstanceOfETypedElement_class(problem,interpretation,element);
	neg find mustInstanceOfETypeParameter_class(problem,interpretation,element);
}
pattern refineTypeTo_EPackage_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfEPackage_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfEPackage_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEEnumLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfEClassifier_class(problem,interpretation,element);
	neg find mustInstanceOfETypedElement_class(problem,interpretation,element);
	neg find mustInstanceOfETypeParameter_class(problem,interpretation,element);
}
pattern refineTypeTo_EStringToStringMapEntry_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEModelElement_class(problem,interpretation,element);
}
pattern refineTypeTo_EObject_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEModelElement_class(problem,interpretation,element);
}
pattern refineTypeTo_EGenericType_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEModelElement_class(problem,interpretation,element);
}
pattern refineTypeTo_EParameter_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfEParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEPackage_class(problem,interpretation,element);
	neg find mustInstanceOfEStructuralFeature_class(problem,interpretation,element);
	neg find mustInstanceOfEEnumLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfEOperation_class(problem,interpretation,element);
	neg find mustInstanceOfEClassifier_class(problem,interpretation,element);
	neg find mustInstanceOfETypeParameter_class(problem,interpretation,element);
}
pattern refineTypeTo_EAttribute_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfEAttribute_class(problem,interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfEParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEPackage_class(problem,interpretation,element);
	neg find mustInstanceOfEAttribute_class(problem,interpretation,element);
	neg find mustInstanceOfEEnumLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfEReference_class(problem,interpretation,element);
	neg find mustInstanceOfEOperation_class(problem,interpretation,element);
	neg find mustInstanceOfEClassifier_class(problem,interpretation,element);
	neg find mustInstanceOfETypeParameter_class(problem,interpretation,element);
}
pattern refineTypeTo_EEnumLiteral_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfEEnumLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEPackage_class(problem,interpretation,element);
	neg find mustInstanceOfEEnumLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfEClassifier_class(problem,interpretation,element);
	neg find mustInstanceOfETypedElement_class(problem,interpretation,element);
	neg find mustInstanceOfETypeParameter_class(problem,interpretation,element);
}
pattern refineTypeTo_EDataType_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfEDataType_class(problem,interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEClass_class(problem,interpretation,element);
	neg find mustInstanceOfEPackage_class(problem,interpretation,element);
	neg find mustInstanceOfEEnum_class(problem,interpretation,element);
	neg find mustInstanceOfEEnumLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfEDataType_class(problem,interpretation,element);
	neg find mustInstanceOfETypedElement_class(problem,interpretation,element);
	neg find mustInstanceOfETypeParameter_class(problem,interpretation,element);
}

//////////
// 4.3 Relation refinement
//////////
pattern refineRelation_eAttributeType_reference_EAttribute(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eAttributeType reference EAttribute");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEAttribute_class(problem,interpretation,from);
	find mustInstanceOfEDataType_class(problem,interpretation,to);
	find mayInRelationeAttributeType_reference_EAttribute(problem,interpretation,from,to);
	neg find mustInRelationeAttributeType_reference_EAttribute(problem,interpretation,from,to);
}
pattern refineRelation_references_reference_EAnnotation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"references reference EAnnotation");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEAnnotation_class(problem,interpretation,from);
	find mustInstanceOfEObject_class(problem,interpretation,to);
	find mayInRelationreferences_reference_EAnnotation(problem,interpretation,from,to);
	neg find mustInRelationreferences_reference_EAnnotation(problem,interpretation,from,to);
}
pattern refineRelation_eSuperTypes_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eSuperTypes reference EClass");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEClass_class(problem,interpretation,from);
	find mustInstanceOfEClass_class(problem,interpretation,to);
	find mayInRelationeSuperTypes_reference_EClass(problem,interpretation,from,to);
	neg find mustInRelationeSuperTypes_reference_EClass(problem,interpretation,from,to);
}
pattern refineRelation_eAllAttributes_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eAllAttributes reference EClass");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEClass_class(problem,interpretation,from);
	find mustInstanceOfEAttribute_class(problem,interpretation,to);
	find mayInRelationeAllAttributes_reference_EClass(problem,interpretation,from,to);
	neg find mustInRelationeAllAttributes_reference_EClass(problem,interpretation,from,to);
}
pattern refineRelation_eAllReferences_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eAllReferences reference EClass");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEClass_class(problem,interpretation,from);
	find mustInstanceOfEReference_class(problem,interpretation,to);
	find mayInRelationeAllReferences_reference_EClass(problem,interpretation,from,to);
	neg find mustInRelationeAllReferences_reference_EClass(problem,interpretation,from,to);
}
pattern refineRelation_eReferences_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eReferences reference EClass");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEClass_class(problem,interpretation,from);
	find mustInstanceOfEReference_class(problem,interpretation,to);
	find mayInRelationeReferences_reference_EClass(problem,interpretation,from,to);
	neg find mustInRelationeReferences_reference_EClass(problem,interpretation,from,to);
}
pattern refineRelation_eAttributes_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eAttributes reference EClass");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEClass_class(problem,interpretation,from);
	find mustInstanceOfEAttribute_class(problem,interpretation,to);
	find mayInRelationeAttributes_reference_EClass(problem,interpretation,from,to);
	neg find mustInRelationeAttributes_reference_EClass(problem,interpretation,from,to);
}
pattern refineRelation_eAllContainments_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eAllContainments reference EClass");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEClass_class(problem,interpretation,from);
	find mustInstanceOfEReference_class(problem,interpretation,to);
	find mayInRelationeAllContainments_reference_EClass(problem,interpretation,from,to);
	neg find mustInRelationeAllContainments_reference_EClass(problem,interpretation,from,to);
}
pattern refineRelation_eAllOperations_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eAllOperations reference EClass");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEClass_class(problem,interpretation,from);
	find mustInstanceOfEOperation_class(problem,interpretation,to);
	find mayInRelationeAllOperations_reference_EClass(problem,interpretation,from,to);
	neg find mustInRelationeAllOperations_reference_EClass(problem,interpretation,from,to);
}
pattern refineRelation_eAllStructuralFeatures_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eAllStructuralFeatures reference EClass");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEClass_class(problem,interpretation,from);
	find mustInstanceOfEStructuralFeature_class(problem,interpretation,to);
	find mayInRelationeAllStructuralFeatures_reference_EClass(problem,interpretation,from,to);
	neg find mustInRelationeAllStructuralFeatures_reference_EClass(problem,interpretation,from,to);
}
pattern refineRelation_eAllSuperTypes_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eAllSuperTypes reference EClass");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEClass_class(problem,interpretation,from);
	find mustInstanceOfEClass_class(problem,interpretation,to);
	find mayInRelationeAllSuperTypes_reference_EClass(problem,interpretation,from,to);
	neg find mustInRelationeAllSuperTypes_reference_EClass(problem,interpretation,from,to);
}
pattern refineRelation_eIDAttribute_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eIDAttribute reference EClass");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEClass_class(problem,interpretation,from);
	find mustInstanceOfEAttribute_class(problem,interpretation,to);
	find mayInRelationeIDAttribute_reference_EClass(problem,interpretation,from,to);
	neg find mustInRelationeIDAttribute_reference_EClass(problem,interpretation,from,to);
}
pattern refineRelation_eAllGenericSuperTypes_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eAllGenericSuperTypes reference EClass");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEClass_class(problem,interpretation,from);
	find mustInstanceOfEGenericType_class(problem,interpretation,to);
	find mayInRelationeAllGenericSuperTypes_reference_EClass(problem,interpretation,from,to);
	neg find mustInRelationeAllGenericSuperTypes_reference_EClass(problem,interpretation,from,to);
}
pattern refineRelation_eExceptions_reference_EOperation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eExceptions reference EOperation");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEOperation_class(problem,interpretation,from);
	find mustInstanceOfEClassifier_class(problem,interpretation,to);
	find mayInRelationeExceptions_reference_EOperation(problem,interpretation,from,to);
	neg find mustInRelationeExceptions_reference_EOperation(problem,interpretation,from,to);
}
pattern refineRelation_eOpposite_reference_EReference(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eOpposite reference EReference");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEReference_class(problem,interpretation,from);
	find mustInstanceOfEReference_class(problem,interpretation,to);
	find mayInRelationeOpposite_reference_EReference(problem,interpretation,from,to);
	neg find mustInRelationeOpposite_reference_EReference(problem,interpretation,from,to);
}
pattern refineRelation_eReferenceType_reference_EReference(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eReferenceType reference EReference");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEReference_class(problem,interpretation,from);
	find mustInstanceOfEClass_class(problem,interpretation,to);
	find mayInRelationeReferenceType_reference_EReference(problem,interpretation,from,to);
	neg find mustInRelationeReferenceType_reference_EReference(problem,interpretation,from,to);
}
pattern refineRelation_eKeys_reference_EReference(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eKeys reference EReference");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEReference_class(problem,interpretation,from);
	find mustInstanceOfEAttribute_class(problem,interpretation,to);
	find mayInRelationeKeys_reference_EReference(problem,interpretation,from,to);
	neg find mustInRelationeKeys_reference_EReference(problem,interpretation,from,to);
}
pattern refineRelation_eType_reference_ETypedElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eType reference ETypedElement");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfETypedElement_class(problem,interpretation,from);
	find mustInstanceOfEClassifier_class(problem,interpretation,to);
	find mayInRelationeType_reference_ETypedElement(problem,interpretation,from,to);
	neg find mustInRelationeType_reference_ETypedElement(problem,interpretation,from,to);
}
pattern refineRelation_eRawType_reference_EGenericType(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eRawType reference EGenericType");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEGenericType_class(problem,interpretation,from);
	find mustInstanceOfEClassifier_class(problem,interpretation,to);
	find mayInRelationeRawType_reference_EGenericType(problem,interpretation,from,to);
	neg find mustInRelationeRawType_reference_EGenericType(problem,interpretation,from,to);
}
pattern refineRelation_eTypeParameter_reference_EGenericType(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eTypeParameter reference EGenericType");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEGenericType_class(problem,interpretation,from);
	find mustInstanceOfETypeParameter_class(problem,interpretation,to);
	find mayInRelationeTypeParameter_reference_EGenericType(problem,interpretation,from,to);
	neg find mustInRelationeTypeParameter_reference_EGenericType(problem,interpretation,from,to);
}
pattern refineRelation_eClassifier_reference_EGenericType(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eClassifier reference EGenericType");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEGenericType_class(problem,interpretation,from);
	find mustInstanceOfEClassifier_class(problem,interpretation,to);
	find mayInRelationeClassifier_reference_EGenericType(problem,interpretation,from,to);
	neg find mustInRelationeClassifier_reference_EGenericType(problem,interpretation,from,to);
}
pattern refineRelation_iD_attribute_EAttribute(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"iD attribute EAttribute");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEAttribute_class(problem,interpretation,from);
	BooleanElement(to);
	find mayInRelationiD_attribute_EAttribute(problem,interpretation,from,to);
	neg find mustInRelationiD_attribute_EAttribute(problem,interpretation,from,to);
}
pattern refineRelation_source_attribute_EAnnotation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"source attribute EAnnotation");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEAnnotation_class(problem,interpretation,from);
	StringElement(to);
	find mayInRelationsource_attribute_EAnnotation(problem,interpretation,from,to);
	neg find mustInRelationsource_attribute_EAnnotation(problem,interpretation,from,to);
}
pattern refineRelation_abstract_attribute_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"abstract attribute EClass");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEClass_class(problem,interpretation,from);
	BooleanElement(to);
	find mayInRelationabstract_attribute_EClass(problem,interpretation,from,to);
	neg find mustInRelationabstract_attribute_EClass(problem,interpretation,from,to);
}
pattern refineRelation_interface_attribute_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"interface attribute EClass");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEClass_class(problem,interpretation,from);
	BooleanElement(to);
	find mayInRelationinterface_attribute_EClass(problem,interpretation,from,to);
	neg find mustInRelationinterface_attribute_EClass(problem,interpretation,from,to);
}
pattern refineRelation_instanceClassName_attribute_EClassifier(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"instanceClassName attribute EClassifier");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEClassifier_class(problem,interpretation,from);
	StringElement(to);
	find mayInRelationinstanceClassName_attribute_EClassifier(problem,interpretation,from,to);
	neg find mustInRelationinstanceClassName_attribute_EClassifier(problem,interpretation,from,to);
}
pattern refineRelation_instanceTypeName_attribute_EClassifier(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"instanceTypeName attribute EClassifier");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEClassifier_class(problem,interpretation,from);
	StringElement(to);
	find mayInRelationinstanceTypeName_attribute_EClassifier(problem,interpretation,from,to);
	neg find mustInRelationinstanceTypeName_attribute_EClassifier(problem,interpretation,from,to);
}
pattern refineRelation_serializable_attribute_EDataType(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"serializable attribute EDataType");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEDataType_class(problem,interpretation,from);
	BooleanElement(to);
	find mayInRelationserializable_attribute_EDataType(problem,interpretation,from,to);
	neg find mustInRelationserializable_attribute_EDataType(problem,interpretation,from,to);
}
pattern refineRelation_value_attribute_EEnumLiteral(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"value attribute EEnumLiteral");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEEnumLiteral_class(problem,interpretation,from);
	IntegerElement(to);
	find mayInRelationvalue_attribute_EEnumLiteral(problem,interpretation,from,to);
	neg find mustInRelationvalue_attribute_EEnumLiteral(problem,interpretation,from,to);
}
pattern refineRelation_literal_attribute_EEnumLiteral(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"literal attribute EEnumLiteral");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEEnumLiteral_class(problem,interpretation,from);
	StringElement(to);
	find mayInRelationliteral_attribute_EEnumLiteral(problem,interpretation,from,to);
	neg find mustInRelationliteral_attribute_EEnumLiteral(problem,interpretation,from,to);
}
pattern refineRelation_name_attribute_ENamedElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"name attribute ENamedElement");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfENamedElement_class(problem,interpretation,from);
	StringElement(to);
	find mayInRelationname_attribute_ENamedElement(problem,interpretation,from,to);
	neg find mustInRelationname_attribute_ENamedElement(problem,interpretation,from,to);
}
pattern refineRelation_nsURI_attribute_EPackage(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"nsURI attribute EPackage");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEPackage_class(problem,interpretation,from);
	StringElement(to);
	find mayInRelationnsURI_attribute_EPackage(problem,interpretation,from,to);
	neg find mustInRelationnsURI_attribute_EPackage(problem,interpretation,from,to);
}
pattern refineRelation_nsPrefix_attribute_EPackage(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"nsPrefix attribute EPackage");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEPackage_class(problem,interpretation,from);
	StringElement(to);
	find mayInRelationnsPrefix_attribute_EPackage(problem,interpretation,from,to);
	neg find mustInRelationnsPrefix_attribute_EPackage(problem,interpretation,from,to);
}
pattern refineRelation_containment_attribute_EReference(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"containment attribute EReference");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEReference_class(problem,interpretation,from);
	BooleanElement(to);
	find mayInRelationcontainment_attribute_EReference(problem,interpretation,from,to);
	neg find mustInRelationcontainment_attribute_EReference(problem,interpretation,from,to);
}
pattern refineRelation_container_attribute_EReference(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"container attribute EReference");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEReference_class(problem,interpretation,from);
	BooleanElement(to);
	find mayInRelationcontainer_attribute_EReference(problem,interpretation,from,to);
	neg find mustInRelationcontainer_attribute_EReference(problem,interpretation,from,to);
}
pattern refineRelation_resolveProxies_attribute_EReference(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"resolveProxies attribute EReference");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEReference_class(problem,interpretation,from);
	BooleanElement(to);
	find mayInRelationresolveProxies_attribute_EReference(problem,interpretation,from,to);
	neg find mustInRelationresolveProxies_attribute_EReference(problem,interpretation,from,to);
}
pattern refineRelation_changeable_attribute_EStructuralFeature(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"changeable attribute EStructuralFeature");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEStructuralFeature_class(problem,interpretation,from);
	BooleanElement(to);
	find mayInRelationchangeable_attribute_EStructuralFeature(problem,interpretation,from,to);
	neg find mustInRelationchangeable_attribute_EStructuralFeature(problem,interpretation,from,to);
}
pattern refineRelation_volatile_attribute_EStructuralFeature(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"volatile attribute EStructuralFeature");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEStructuralFeature_class(problem,interpretation,from);
	BooleanElement(to);
	find mayInRelationvolatile_attribute_EStructuralFeature(problem,interpretation,from,to);
	neg find mustInRelationvolatile_attribute_EStructuralFeature(problem,interpretation,from,to);
}
pattern refineRelation_transient_attribute_EStructuralFeature(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"transient attribute EStructuralFeature");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEStructuralFeature_class(problem,interpretation,from);
	BooleanElement(to);
	find mayInRelationtransient_attribute_EStructuralFeature(problem,interpretation,from,to);
	neg find mustInRelationtransient_attribute_EStructuralFeature(problem,interpretation,from,to);
}
pattern refineRelation_defaultValueLiteral_attribute_EStructuralFeature(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"defaultValueLiteral attribute EStructuralFeature");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEStructuralFeature_class(problem,interpretation,from);
	StringElement(to);
	find mayInRelationdefaultValueLiteral_attribute_EStructuralFeature(problem,interpretation,from,to);
	neg find mustInRelationdefaultValueLiteral_attribute_EStructuralFeature(problem,interpretation,from,to);
}
pattern refineRelation_unsettable_attribute_EStructuralFeature(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"unsettable attribute EStructuralFeature");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEStructuralFeature_class(problem,interpretation,from);
	BooleanElement(to);
	find mayInRelationunsettable_attribute_EStructuralFeature(problem,interpretation,from,to);
	neg find mustInRelationunsettable_attribute_EStructuralFeature(problem,interpretation,from,to);
}
pattern refineRelation_derived_attribute_EStructuralFeature(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"derived attribute EStructuralFeature");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEStructuralFeature_class(problem,interpretation,from);
	BooleanElement(to);
	find mayInRelationderived_attribute_EStructuralFeature(problem,interpretation,from,to);
	neg find mustInRelationderived_attribute_EStructuralFeature(problem,interpretation,from,to);
}
pattern refineRelation_ordered_attribute_ETypedElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"ordered attribute ETypedElement");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfETypedElement_class(problem,interpretation,from);
	BooleanElement(to);
	find mayInRelationordered_attribute_ETypedElement(problem,interpretation,from,to);
	neg find mustInRelationordered_attribute_ETypedElement(problem,interpretation,from,to);
}
pattern refineRelation_unique_attribute_ETypedElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"unique attribute ETypedElement");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfETypedElement_class(problem,interpretation,from);
	BooleanElement(to);
	find mayInRelationunique_attribute_ETypedElement(problem,interpretation,from,to);
	neg find mustInRelationunique_attribute_ETypedElement(problem,interpretation,from,to);
}
pattern refineRelation_lowerBound_attribute_ETypedElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"lowerBound attribute ETypedElement");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfETypedElement_class(problem,interpretation,from);
	IntegerElement(to);
	find mayInRelationlowerBound_attribute_ETypedElement(problem,interpretation,from,to);
	neg find mustInRelationlowerBound_attribute_ETypedElement(problem,interpretation,from,to);
}
pattern refineRelation_upperBound_attribute_ETypedElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"upperBound attribute ETypedElement");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfETypedElement_class(problem,interpretation,from);
	IntegerElement(to);
	find mayInRelationupperBound_attribute_ETypedElement(problem,interpretation,from,to);
	neg find mustInRelationupperBound_attribute_ETypedElement(problem,interpretation,from,to);
}
pattern refineRelation_many_attribute_ETypedElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"many attribute ETypedElement");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfETypedElement_class(problem,interpretation,from);
	BooleanElement(to);
	find mayInRelationmany_attribute_ETypedElement(problem,interpretation,from,to);
	neg find mustInRelationmany_attribute_ETypedElement(problem,interpretation,from,to);
}
pattern refineRelation_required_attribute_ETypedElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"required attribute ETypedElement");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfETypedElement_class(problem,interpretation,from);
	BooleanElement(to);
	find mayInRelationrequired_attribute_ETypedElement(problem,interpretation,from,to);
	neg find mustInRelationrequired_attribute_ETypedElement(problem,interpretation,from,to);
}
pattern refineRelation_key_attribute_EStringToStringMapEntry(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"key attribute EStringToStringMapEntry");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,from);
	StringElement(to);
	find mayInRelationkey_attribute_EStringToStringMapEntry(problem,interpretation,from,to);
	neg find mustInRelationkey_attribute_EStringToStringMapEntry(problem,interpretation,from,to);
}
pattern refineRelation_value_attribute_EStringToStringMapEntry(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"value attribute EStringToStringMapEntry");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,from);
	StringElement(to);
	find mayInRelationvalue_attribute_EStringToStringMapEntry(problem,interpretation,from,to);
	neg find mustInRelationvalue_attribute_EStringToStringMapEntry(problem,interpretation,from,to);
}
import epackage "http://www.bme.hu/mit/inf/dslreasoner/viatrasolver/partialinterpretationlanguage"
import epackage "http://www.bme.hu/mit/inf/dslreasoner/logic/model/problem"
import epackage "http://www.bme.hu/mit/inf/dslreasoner/logic/model/language"

//////////
// 0. Util
//////////
private pattern interpretation(problem:LogicProblem, interpretation:PartialInterpretation) {
	PartialInterpretation.problem(interpretation,problem);
}
	
/////////////////////////
// 0.1 Existence
/////////////////////////
private pattern mustExist(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	find interpretation(problem,interpretation);
	LogicProblem.elements(problem,element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
}

private pattern mayExist(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
    find mustExist(problem,interpretation,element);
} or {
    find interpretation(problem,interpretation);
    neg find elementCloseWorld(element);
    PartialInterpretation.openWorldElements(interpretation,element);
}

private pattern elementCloseWorld(element:DefinedElement) {
	PartialInterpretation.openWorldElements(i,element);
    PartialInterpretation.maxNewElements(i,0);
} or {
	Scope.targetTypeInterpretation(scope,interpretation);
	PartialTypeInterpratation.elements(interpretation,element);
	Scope.maxNewElements(scope,0);
}

////////////////////////
// 0.2 Equivalence
////////////////////////
pattern mayEquivalent(problem:LogicProblem, interpretation:PartialInterpretation, a: DefinedElement, b: DefinedElement) {
	find mayExist(problem,interpretation,a);
	find mayExist(problem,interpretation,b);
	a == b;
}

////////////////////////
// 0.3 Required Patterns by TypeIndexer
////////////////////////
private pattern typeInterpretation(problem:LogicProblem, interpretation:PartialInterpretation, type:TypeDeclaration, typeInterpretation:PartialComplexTypeInterpretation) {
	find interpretation(problem,interpretation);
	LogicProblem.types(problem,type);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
}

private pattern directInstanceOf(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement, type:Type) {
	find interpretation(problem,interpretation);
	LogicProblem.types(problem,type);
	TypeDefinition.elements(type,element);
} or {
	find interpretation(problem,interpretation);
	find typeInterpretation(problem,interpretation,type,typeInterpretation);
	PartialComplexTypeInterpretation.elements(typeInterpretation,element);
}

private pattern isPrimitive(element: PrimitiveElement) {
	PrimitiveElement(element);
}

//////////
// 1. Problem-Specific Base Indexers
//////////
// 1.1 Type Indexers
//////////
// 1.1.1 primitive Type Indexers
//////////

//////////
// 1.1.2 domain-specific Type Indexers
//////////
/**
 * An element must be an instance of type "EAttribute class".
 */
private pattern mustInstanceOfEAttribute_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"EAttribute class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewEAttribute_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"EAttribute class");
}

/**
 * An element may be an instance of type "EAttribute class".
 */
private pattern mayInstanceOfEAttribute_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfEEnumLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfEReference_class(problem,interpretation,element);
	neg find mustInstanceOfETypeParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEClassifier_class(problem,interpretation,element);
	neg find mustInstanceOfEPackage_class(problem,interpretation,element);
	neg find mustInstanceOfEOperation_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find scopeDisallowsNewEAttribute_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfEEnumLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfEReference_class(problem,interpretation,element);
	neg find mustInstanceOfETypeParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEClassifier_class(problem,interpretation,element);
	neg find mustInstanceOfEPackage_class(problem,interpretation,element);
	neg find mustInstanceOfEOperation_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find scopeDisallowsNewEAttribute_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfEAttribute_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "EAnnotation class".
 */
private pattern mustInstanceOfEAnnotation_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"EAnnotation class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewEAnnotation_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"EAnnotation class");
}

/**
 * An element may be an instance of type "EAnnotation class".
 */
private pattern mayInstanceOfEAnnotation_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfENamedElement_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find scopeDisallowsNewEAnnotation_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfENamedElement_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find scopeDisallowsNewEAnnotation_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfEAnnotation_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "EClass class".
 */
private pattern mustInstanceOfEClass_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"EClass class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewEClass_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"EClass class");
}

/**
 * An element may be an instance of type "EClass class".
 */
private pattern mayInstanceOfEClass_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfEEnumLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfETypeParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfETypedElement_class(problem,interpretation,element);
	neg find mustInstanceOfEDataType_class(problem,interpretation,element);
	neg find mustInstanceOfEPackage_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find scopeDisallowsNewEClass_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfEEnumLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfETypeParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfETypedElement_class(problem,interpretation,element);
	neg find mustInstanceOfEDataType_class(problem,interpretation,element);
	neg find mustInstanceOfEPackage_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find scopeDisallowsNewEClass_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfEClass_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "EClassifier class".
 */
private pattern mustInstanceOfEClassifier_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"EClassifier class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewEClassifier_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"EClassifier class");
}

/**
 * An element may be an instance of type "EClassifier class".
 */
private pattern mayInstanceOfEClassifier_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEEnumLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfEClass_class(problem,interpretation,element);
	neg find mustInstanceOfETypeParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEDataType_class(problem,interpretation,element);
	neg find mustInstanceOfETypedElement_class(problem,interpretation,element);
	neg find mustInstanceOfEPackage_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find scopeDisallowsNewEClassifier_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEEnumLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfEClass_class(problem,interpretation,element);
	neg find mustInstanceOfETypeParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEDataType_class(problem,interpretation,element);
	neg find mustInstanceOfETypedElement_class(problem,interpretation,element);
	neg find mustInstanceOfEPackage_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find scopeDisallowsNewEClassifier_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfEClassifier_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "EDataType class".
 */
private pattern mustInstanceOfEDataType_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"EDataType class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewEDataType_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"EDataType class");
}

/**
 * An element may be an instance of type "EDataType class".
 */
private pattern mayInstanceOfEDataType_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfEEnumLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEEnum_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfEClass_class(problem,interpretation,element);
	neg find mustInstanceOfETypeParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfETypedElement_class(problem,interpretation,element);
	neg find mustInstanceOfEPackage_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find scopeDisallowsNewEDataType_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfEEnumLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEEnum_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfEClass_class(problem,interpretation,element);
	neg find mustInstanceOfETypeParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfETypedElement_class(problem,interpretation,element);
	neg find mustInstanceOfEPackage_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find scopeDisallowsNewEDataType_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfEDataType_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "EEnum class".
 */
private pattern mustInstanceOfEEnum_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"EEnum class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewEEnum_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"EEnum class");
}

/**
 * An element may be an instance of type "EEnum class".
 */
private pattern mayInstanceOfEEnum_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEEnumLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfEClass_class(problem,interpretation,element);
	neg find mustInstanceOfETypeParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfETypedElement_class(problem,interpretation,element);
	neg find mustInstanceOfEPackage_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find scopeDisallowsNewEEnum_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEEnumLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfEClass_class(problem,interpretation,element);
	neg find mustInstanceOfETypeParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfETypedElement_class(problem,interpretation,element);
	neg find mustInstanceOfEPackage_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find scopeDisallowsNewEEnum_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfEEnum_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "EEnumLiteral class".
 */
private pattern mustInstanceOfEEnumLiteral_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"EEnumLiteral class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewEEnumLiteral_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"EEnumLiteral class");
}

/**
 * An element may be an instance of type "EEnumLiteral class".
 */
private pattern mayInstanceOfEEnumLiteral_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfETypeParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfETypedElement_class(problem,interpretation,element);
	neg find mustInstanceOfEClassifier_class(problem,interpretation,element);
	neg find mustInstanceOfEPackage_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find scopeDisallowsNewEEnumLiteral_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfETypeParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfETypedElement_class(problem,interpretation,element);
	neg find mustInstanceOfEClassifier_class(problem,interpretation,element);
	neg find mustInstanceOfEPackage_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find scopeDisallowsNewEEnumLiteral_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfEEnumLiteral_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "EModelElement class".
 */
private pattern mustInstanceOfEModelElement_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"EModelElement class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewEModelElement_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"EModelElement class");
}

/**
 * An element may be an instance of type "EModelElement class".
 */
private pattern mayInstanceOfEModelElement_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfENamedElement_class(problem,interpretation,element);
	neg find mustInstanceOfEModelElement_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find scopeDisallowsNewEModelElement_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfENamedElement_class(problem,interpretation,element);
	neg find mustInstanceOfEModelElement_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find scopeDisallowsNewEModelElement_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfEModelElement_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "ENamedElement class".
 */
private pattern mustInstanceOfENamedElement_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"ENamedElement class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewENamedElement_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"ENamedElement class");
}

/**
 * An element may be an instance of type "ENamedElement class".
 */
private pattern mayInstanceOfENamedElement_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfEModelElement_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfEPackage_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find scopeDisallowsNewENamedElement_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfEModelElement_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfEPackage_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find scopeDisallowsNewENamedElement_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfENamedElement_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "EObject class".
 */
private pattern mustInstanceOfEObject_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"EObject class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewEObject_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"EObject class");
}

/**
 * An element may be an instance of type "EObject class".
 */
private pattern mayInstanceOfEObject_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEModelElement_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find scopeDisallowsNewEObject_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEModelElement_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find scopeDisallowsNewEObject_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfEObject_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "EOperation class".
 */
private pattern mustInstanceOfEOperation_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"EOperation class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewEOperation_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"EOperation class");
}

/**
 * An element may be an instance of type "EOperation class".
 */
private pattern mayInstanceOfEOperation_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEEnumLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfETypeParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEClassifier_class(problem,interpretation,element);
	neg find mustInstanceOfEStructuralFeature_class(problem,interpretation,element);
	neg find mustInstanceOfEPackage_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find scopeDisallowsNewEOperation_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEEnumLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfETypeParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEClassifier_class(problem,interpretation,element);
	neg find mustInstanceOfEStructuralFeature_class(problem,interpretation,element);
	neg find mustInstanceOfEPackage_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find scopeDisallowsNewEOperation_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfEOperation_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "EPackage class".
 */
private pattern mustInstanceOfEPackage_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"EPackage class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewEPackage_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"EPackage class");
}

/**
 * An element may be an instance of type "EPackage class".
 */
private pattern mayInstanceOfEPackage_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfEModelElement_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find scopeDisallowsNewEPackage_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfEModelElement_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find scopeDisallowsNewEPackage_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfEPackage_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "EParameter class".
 */
private pattern mustInstanceOfEParameter_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"EParameter class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewEParameter_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"EParameter class");
}

/**
 * An element may be an instance of type "EParameter class".
 */
private pattern mayInstanceOfEParameter_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEEnumLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfETypeParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEClassifier_class(problem,interpretation,element);
	neg find mustInstanceOfEStructuralFeature_class(problem,interpretation,element);
	neg find mustInstanceOfEPackage_class(problem,interpretation,element);
	neg find mustInstanceOfEOperation_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find scopeDisallowsNewEParameter_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEEnumLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfETypeParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEClassifier_class(problem,interpretation,element);
	neg find mustInstanceOfEStructuralFeature_class(problem,interpretation,element);
	neg find mustInstanceOfEPackage_class(problem,interpretation,element);
	neg find mustInstanceOfEOperation_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find scopeDisallowsNewEParameter_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfEParameter_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "EReference class".
 */
private pattern mustInstanceOfEReference_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"EReference class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewEReference_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"EReference class");
}

/**
 * An element may be an instance of type "EReference class".
 */
private pattern mayInstanceOfEReference_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEEnumLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfEAttribute_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfETypeParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEClassifier_class(problem,interpretation,element);
	neg find mustInstanceOfEPackage_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEOperation_class(problem,interpretation,element);
	neg find scopeDisallowsNewEReference_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEEnumLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfEAttribute_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfETypeParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEClassifier_class(problem,interpretation,element);
	neg find mustInstanceOfEPackage_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEOperation_class(problem,interpretation,element);
	neg find scopeDisallowsNewEReference_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfEReference_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "EStructuralFeature class".
 */
private pattern mustInstanceOfEStructuralFeature_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"EStructuralFeature class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewEStructuralFeature_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"EStructuralFeature class");
}

/**
 * An element may be an instance of type "EStructuralFeature class".
 */
private pattern mayInstanceOfEStructuralFeature_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfEEnumLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEAttribute_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfEReference_class(problem,interpretation,element);
	neg find mustInstanceOfETypeParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEClassifier_class(problem,interpretation,element);
	neg find mustInstanceOfEPackage_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEOperation_class(problem,interpretation,element);
	neg find scopeDisallowsNewEStructuralFeature_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfEEnumLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEAttribute_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfEReference_class(problem,interpretation,element);
	neg find mustInstanceOfETypeParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEClassifier_class(problem,interpretation,element);
	neg find mustInstanceOfEPackage_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEOperation_class(problem,interpretation,element);
	neg find scopeDisallowsNewEStructuralFeature_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfEStructuralFeature_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "ETypedElement class".
 */
private pattern mustInstanceOfETypedElement_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"ETypedElement class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewETypedElement_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"ETypedElement class");
}

/**
 * An element may be an instance of type "ETypedElement class".
 */
private pattern mayInstanceOfETypedElement_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEEnumLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfETypeParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEClassifier_class(problem,interpretation,element);
	neg find mustInstanceOfEStructuralFeature_class(problem,interpretation,element);
	neg find mustInstanceOfEPackage_class(problem,interpretation,element);
	neg find mustInstanceOfEOperation_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find scopeDisallowsNewETypedElement_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEEnumLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfETypeParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEClassifier_class(problem,interpretation,element);
	neg find mustInstanceOfEStructuralFeature_class(problem,interpretation,element);
	neg find mustInstanceOfEPackage_class(problem,interpretation,element);
	neg find mustInstanceOfEOperation_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find scopeDisallowsNewETypedElement_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfETypedElement_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "EStringToStringMapEntry class".
 */
private pattern mustInstanceOfEStringToStringMapEntry_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"EStringToStringMapEntry class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewEStringToStringMapEntry_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"EStringToStringMapEntry class");
}

/**
 * An element may be an instance of type "EStringToStringMapEntry class".
 */
private pattern mayInstanceOfEStringToStringMapEntry_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfEModelElement_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find scopeDisallowsNewEStringToStringMapEntry_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfEModelElement_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find scopeDisallowsNewEStringToStringMapEntry_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "EGenericType class".
 */
private pattern mustInstanceOfEGenericType_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"EGenericType class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewEGenericType_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"EGenericType class");
}

/**
 * An element may be an instance of type "EGenericType class".
 */
private pattern mayInstanceOfEGenericType_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfEModelElement_class(problem,interpretation,element);
	neg find scopeDisallowsNewEGenericType_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfEModelElement_class(problem,interpretation,element);
	neg find scopeDisallowsNewEGenericType_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfEGenericType_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "ETypeParameter class".
 */
private pattern mustInstanceOfETypeParameter_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"ETypeParameter class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewETypeParameter_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"ETypeParameter class");
}

/**
 * An element may be an instance of type "ETypeParameter class".
 */
private pattern mayInstanceOfETypeParameter_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEEnumLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfETypedElement_class(problem,interpretation,element);
	neg find mustInstanceOfEClassifier_class(problem,interpretation,element);
	neg find mustInstanceOfEPackage_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find scopeDisallowsNewETypeParameter_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEEnumLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfETypedElement_class(problem,interpretation,element);
	neg find mustInstanceOfEClassifier_class(problem,interpretation,element);
	neg find mustInstanceOfEPackage_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find scopeDisallowsNewETypeParameter_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfETypeParameter_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "EModelElement class DefinedPart".
 */
private pattern mustInstanceOfEModelElement_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"EModelElement class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewEModelElement_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"EModelElement class DefinedPart");
}

/**
 * An element may be an instance of type "EModelElement class DefinedPart".
 */
private pattern mayInstanceOfEModelElement_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfEModelElement_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "EModelElement class UndefinedPart".
 */
private pattern mustInstanceOfEModelElement_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"EModelElement class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewEModelElement_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"EModelElement class UndefinedPart");
}

/**
 * An element may be an instance of type "EModelElement class UndefinedPart".
 */
private pattern mayInstanceOfEModelElement_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfENamedElement_class(problem,interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find scopeDisallowsNewEModelElement_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfENamedElement_class(problem,interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find scopeDisallowsNewEModelElement_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfEModelElement_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "ENamedElement class DefinedPart".
 */
private pattern mustInstanceOfENamedElement_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"ENamedElement class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewENamedElement_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"ENamedElement class DefinedPart");
}

/**
 * An element may be an instance of type "ENamedElement class DefinedPart".
 */
private pattern mayInstanceOfENamedElement_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfENamedElement_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "ENamedElement class UndefinedPart".
 */
private pattern mustInstanceOfENamedElement_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"ENamedElement class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewENamedElement_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"ENamedElement class UndefinedPart");
}

/**
 * An element may be an instance of type "ENamedElement class UndefinedPart".
 */
private pattern mayInstanceOfENamedElement_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEEnumLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfETypeParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfETypedElement_class(problem,interpretation,element);
	neg find mustInstanceOfEClassifier_class(problem,interpretation,element);
	neg find mustInstanceOfEPackage_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find scopeDisallowsNewENamedElement_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEEnumLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfETypeParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfETypedElement_class(problem,interpretation,element);
	neg find mustInstanceOfEClassifier_class(problem,interpretation,element);
	neg find mustInstanceOfEPackage_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find scopeDisallowsNewENamedElement_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfENamedElement_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "EPackage class DefinedPart".
 */
private pattern mustInstanceOfEPackage_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"EPackage class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewEPackage_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"EPackage class DefinedPart");
}

/**
 * An element may be an instance of type "EPackage class DefinedPart".
 */
private pattern mayInstanceOfEPackage_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfEPackage_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "EPackage class UndefinedPart".
 */
private pattern mustInstanceOfEPackage_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"EPackage class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewEPackage_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"EPackage class UndefinedPart");
}

/**
 * An element may be an instance of type "EPackage class UndefinedPart".
 */
private pattern mayInstanceOfEPackage_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfEEnumLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfETypeParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEClassifier_class(problem,interpretation,element);
	neg find mustInstanceOfETypedElement_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find scopeDisallowsNewEPackage_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfEEnumLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfETypeParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEClassifier_class(problem,interpretation,element);
	neg find mustInstanceOfETypedElement_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find scopeDisallowsNewEPackage_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfEPackage_class_UndefinedPart(problem,interpretation,element); }

//////////
// 1.2 Relation Declaration Indexers
//////////
/**
 * Matcher for detecting tuples t where []eAttributeType reference EAttribute(source,target)
 */
private pattern mustInRelationeAttributeType_reference_EAttribute(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eAttributeType reference EAttribute");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eAttributeType reference EAttribute(source,target)
 */
private pattern mayInRelationeAttributeType_reference_EAttribute(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEAttribute_class(problem,interpretation,source);
	find mayInstanceOfEDataType_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationeAttributeType_reference_EAttribute(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationeAttributeType_reference_EAttribute(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []details reference EAnnotation(source,target)
 */
private pattern mustInRelationdetails_reference_EAnnotation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"details reference EAnnotation");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>details reference EAnnotation(source,target)
 */
private pattern mayInRelationdetails_reference_EAnnotation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEAnnotation_class(problem,interpretation,source);
	find mayInstanceOfEStringToStringMapEntry_class(problem,interpretation,target);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationdetails_reference_EAnnotation(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eModelElement reference EAnnotation(source,target)
 */
private pattern mustInRelationeModelElement_reference_EAnnotation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eModelElement reference EAnnotation");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eModelElement reference EAnnotation(source,target)
 */
private pattern mayInRelationeModelElement_reference_EAnnotation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEAnnotation_class(problem,interpretation,source);
	find mayInstanceOfEModelElement_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationeModelElement_reference_EAnnotation(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationeModelElement_reference_EAnnotation(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []contents reference EAnnotation(source,target)
 */
private pattern mustInRelationcontents_reference_EAnnotation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"contents reference EAnnotation");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>contents reference EAnnotation(source,target)
 */
private pattern mayInRelationcontents_reference_EAnnotation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEAnnotation_class(problem,interpretation,source);
	find mayInstanceOfEObject_class(problem,interpretation,target);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationcontents_reference_EAnnotation(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []references reference EAnnotation(source,target)
 */
private pattern mustInRelationreferences_reference_EAnnotation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"references reference EAnnotation");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>references reference EAnnotation(source,target)
 */
private pattern mayInRelationreferences_reference_EAnnotation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEAnnotation_class(problem,interpretation,source);
	find mayInstanceOfEObject_class(problem,interpretation,target);
} or {
	find mustInRelationreferences_reference_EAnnotation(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eSuperTypes reference EClass(source,target)
 */
private pattern mustInRelationeSuperTypes_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eSuperTypes reference EClass");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eSuperTypes reference EClass(source,target)
 */
private pattern mayInRelationeSuperTypes_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEClass_class(problem,interpretation,source);
	find mayInstanceOfEClass_class(problem,interpretation,target);
} or {
	find mustInRelationeSuperTypes_reference_EClass(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eOperations reference EClass(source,target)
 */
private pattern mustInRelationeOperations_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eOperations reference EClass");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eOperations reference EClass(source,target)
 */
private pattern mayInRelationeOperations_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEClass_class(problem,interpretation,source);
	find mayInstanceOfEOperation_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationeContainingClass_reference_EOperation(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationeOperations_reference_EClass(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eAllAttributes reference EClass(source,target)
 */
private pattern mustInRelationeAllAttributes_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eAllAttributes reference EClass");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eAllAttributes reference EClass(source,target)
 */
private pattern mayInRelationeAllAttributes_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEClass_class(problem,interpretation,source);
	find mayInstanceOfEAttribute_class(problem,interpretation,target);
} or {
	find mustInRelationeAllAttributes_reference_EClass(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eAllReferences reference EClass(source,target)
 */
private pattern mustInRelationeAllReferences_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eAllReferences reference EClass");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eAllReferences reference EClass(source,target)
 */
private pattern mayInRelationeAllReferences_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEClass_class(problem,interpretation,source);
	find mayInstanceOfEReference_class(problem,interpretation,target);
} or {
	find mustInRelationeAllReferences_reference_EClass(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eReferences reference EClass(source,target)
 */
private pattern mustInRelationeReferences_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eReferences reference EClass");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eReferences reference EClass(source,target)
 */
private pattern mayInRelationeReferences_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEClass_class(problem,interpretation,source);
	find mayInstanceOfEReference_class(problem,interpretation,target);
} or {
	find mustInRelationeReferences_reference_EClass(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eAttributes reference EClass(source,target)
 */
private pattern mustInRelationeAttributes_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eAttributes reference EClass");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eAttributes reference EClass(source,target)
 */
private pattern mayInRelationeAttributes_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEClass_class(problem,interpretation,source);
	find mayInstanceOfEAttribute_class(problem,interpretation,target);
} or {
	find mustInRelationeAttributes_reference_EClass(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eAllContainments reference EClass(source,target)
 */
private pattern mustInRelationeAllContainments_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eAllContainments reference EClass");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eAllContainments reference EClass(source,target)
 */
private pattern mayInRelationeAllContainments_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEClass_class(problem,interpretation,source);
	find mayInstanceOfEReference_class(problem,interpretation,target);
} or {
	find mustInRelationeAllContainments_reference_EClass(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eAllOperations reference EClass(source,target)
 */
private pattern mustInRelationeAllOperations_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eAllOperations reference EClass");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eAllOperations reference EClass(source,target)
 */
private pattern mayInRelationeAllOperations_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEClass_class(problem,interpretation,source);
	find mayInstanceOfEOperation_class(problem,interpretation,target);
} or {
	find mustInRelationeAllOperations_reference_EClass(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eAllStructuralFeatures reference EClass(source,target)
 */
private pattern mustInRelationeAllStructuralFeatures_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eAllStructuralFeatures reference EClass");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eAllStructuralFeatures reference EClass(source,target)
 */
private pattern mayInRelationeAllStructuralFeatures_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEClass_class(problem,interpretation,source);
	find mayInstanceOfEStructuralFeature_class(problem,interpretation,target);
} or {
	find mustInRelationeAllStructuralFeatures_reference_EClass(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eAllSuperTypes reference EClass(source,target)
 */
private pattern mustInRelationeAllSuperTypes_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eAllSuperTypes reference EClass");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eAllSuperTypes reference EClass(source,target)
 */
private pattern mayInRelationeAllSuperTypes_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEClass_class(problem,interpretation,source);
	find mayInstanceOfEClass_class(problem,interpretation,target);
} or {
	find mustInRelationeAllSuperTypes_reference_EClass(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eIDAttribute reference EClass(source,target)
 */
private pattern mustInRelationeIDAttribute_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eIDAttribute reference EClass");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eIDAttribute reference EClass(source,target)
 */
private pattern mayInRelationeIDAttribute_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEClass_class(problem,interpretation,source);
	find mayInstanceOfEAttribute_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationeIDAttribute_reference_EClass(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationeIDAttribute_reference_EClass(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eStructuralFeatures reference EClass(source,target)
 */
private pattern mustInRelationeStructuralFeatures_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eStructuralFeatures reference EClass");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eStructuralFeatures reference EClass(source,target)
 */
private pattern mayInRelationeStructuralFeatures_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEClass_class(problem,interpretation,source);
	find mayInstanceOfEStructuralFeature_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationeContainingClass_reference_EStructuralFeature(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationeStructuralFeatures_reference_EClass(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eGenericSuperTypes reference EClass(source,target)
 */
private pattern mustInRelationeGenericSuperTypes_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eGenericSuperTypes reference EClass");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eGenericSuperTypes reference EClass(source,target)
 */
private pattern mayInRelationeGenericSuperTypes_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEClass_class(problem,interpretation,source);
	find mayInstanceOfEGenericType_class(problem,interpretation,target);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationeGenericSuperTypes_reference_EClass(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eAllGenericSuperTypes reference EClass(source,target)
 */
private pattern mustInRelationeAllGenericSuperTypes_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eAllGenericSuperTypes reference EClass");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eAllGenericSuperTypes reference EClass(source,target)
 */
private pattern mayInRelationeAllGenericSuperTypes_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEClass_class(problem,interpretation,source);
	find mayInstanceOfEGenericType_class(problem,interpretation,target);
} or {
	find mustInRelationeAllGenericSuperTypes_reference_EClass(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []ePackage reference EClassifier(source,target)
 */
private pattern mustInRelationePackage_reference_EClassifier(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"ePackage reference EClassifier");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>ePackage reference EClassifier(source,target)
 */
private pattern mayInRelationePackage_reference_EClassifier(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEClassifier_class(problem,interpretation,source);
	find mayInstanceOfEPackage_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationePackage_reference_EClassifier(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationePackage_reference_EClassifier(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eTypeParameters reference EClassifier(source,target)
 */
private pattern mustInRelationeTypeParameters_reference_EClassifier(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eTypeParameters reference EClassifier");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eTypeParameters reference EClassifier(source,target)
 */
private pattern mayInRelationeTypeParameters_reference_EClassifier(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEClassifier_class(problem,interpretation,source);
	find mayInstanceOfETypeParameter_class(problem,interpretation,target);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationeTypeParameters_reference_EClassifier(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eLiterals reference EEnum(source,target)
 */
private pattern mustInRelationeLiterals_reference_EEnum(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eLiterals reference EEnum");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eLiterals reference EEnum(source,target)
 */
private pattern mayInRelationeLiterals_reference_EEnum(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEEnum_class(problem,interpretation,source);
	find mayInstanceOfEEnumLiteral_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationeEnum_reference_EEnumLiteral(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationeLiterals_reference_EEnum(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eEnum reference EEnumLiteral(source,target)
 */
private pattern mustInRelationeEnum_reference_EEnumLiteral(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eEnum reference EEnumLiteral");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eEnum reference EEnumLiteral(source,target)
 */
private pattern mayInRelationeEnum_reference_EEnumLiteral(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEEnumLiteral_class(problem,interpretation,source);
	find mayInstanceOfEEnum_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationeEnum_reference_EEnumLiteral(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationeEnum_reference_EEnumLiteral(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eAnnotations reference EModelElement(source,target)
 */
private pattern mustInRelationeAnnotations_reference_EModelElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eAnnotations reference EModelElement");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eAnnotations reference EModelElement(source,target)
 */
private pattern mayInRelationeAnnotations_reference_EModelElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEModelElement_class(problem,interpretation,source);
	find mayInstanceOfEAnnotation_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationeModelElement_reference_EAnnotation(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationeAnnotations_reference_EModelElement(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eContainingClass reference EOperation(source,target)
 */
private pattern mustInRelationeContainingClass_reference_EOperation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eContainingClass reference EOperation");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eContainingClass reference EOperation(source,target)
 */
private pattern mayInRelationeContainingClass_reference_EOperation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEOperation_class(problem,interpretation,source);
	find mayInstanceOfEClass_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationeContainingClass_reference_EOperation(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationeContainingClass_reference_EOperation(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eTypeParameters reference EOperation(source,target)
 */
private pattern mustInRelationeTypeParameters_reference_EOperation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eTypeParameters reference EOperation");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eTypeParameters reference EOperation(source,target)
 */
private pattern mayInRelationeTypeParameters_reference_EOperation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEOperation_class(problem,interpretation,source);
	find mayInstanceOfETypeParameter_class(problem,interpretation,target);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationeTypeParameters_reference_EOperation(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eParameters reference EOperation(source,target)
 */
private pattern mustInRelationeParameters_reference_EOperation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eParameters reference EOperation");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eParameters reference EOperation(source,target)
 */
private pattern mayInRelationeParameters_reference_EOperation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEOperation_class(problem,interpretation,source);
	find mayInstanceOfEParameter_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationeOperation_reference_EParameter(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationeParameters_reference_EOperation(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eExceptions reference EOperation(source,target)
 */
private pattern mustInRelationeExceptions_reference_EOperation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eExceptions reference EOperation");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eExceptions reference EOperation(source,target)
 */
private pattern mayInRelationeExceptions_reference_EOperation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEOperation_class(problem,interpretation,source);
	find mayInstanceOfEClassifier_class(problem,interpretation,target);
} or {
	find mustInRelationeExceptions_reference_EOperation(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eGenericExceptions reference EOperation(source,target)
 */
private pattern mustInRelationeGenericExceptions_reference_EOperation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eGenericExceptions reference EOperation");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eGenericExceptions reference EOperation(source,target)
 */
private pattern mayInRelationeGenericExceptions_reference_EOperation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEOperation_class(problem,interpretation,source);
	find mayInstanceOfEGenericType_class(problem,interpretation,target);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationeGenericExceptions_reference_EOperation(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eClassifiers reference EPackage(source,target)
 */
private pattern mustInRelationeClassifiers_reference_EPackage(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eClassifiers reference EPackage");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eClassifiers reference EPackage(source,target)
 */
private pattern mayInRelationeClassifiers_reference_EPackage(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEPackage_class(problem,interpretation,source);
	find mayInstanceOfEClassifier_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationePackage_reference_EClassifier(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationeClassifiers_reference_EPackage(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eSubpackages reference EPackage(source,target)
 */
private pattern mustInRelationeSubpackages_reference_EPackage(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eSubpackages reference EPackage");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eSubpackages reference EPackage(source,target)
 */
private pattern mayInRelationeSubpackages_reference_EPackage(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEPackage_class(problem,interpretation,source);
	find mayInstanceOfEPackage_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationeSuperPackage_reference_EPackage(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationeSubpackages_reference_EPackage(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eSuperPackage reference EPackage(source,target)
 */
private pattern mustInRelationeSuperPackage_reference_EPackage(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eSuperPackage reference EPackage");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eSuperPackage reference EPackage(source,target)
 */
private pattern mayInRelationeSuperPackage_reference_EPackage(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEPackage_class(problem,interpretation,source);
	find mayInstanceOfEPackage_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationeSuperPackage_reference_EPackage(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationeSuperPackage_reference_EPackage(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eOperation reference EParameter(source,target)
 */
private pattern mustInRelationeOperation_reference_EParameter(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eOperation reference EParameter");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eOperation reference EParameter(source,target)
 */
private pattern mayInRelationeOperation_reference_EParameter(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEParameter_class(problem,interpretation,source);
	find mayInstanceOfEOperation_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationeOperation_reference_EParameter(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationeOperation_reference_EParameter(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eOpposite reference EReference(source,target)
 */
private pattern mustInRelationeOpposite_reference_EReference(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eOpposite reference EReference");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eOpposite reference EReference(source,target)
 */
private pattern mayInRelationeOpposite_reference_EReference(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEReference_class(problem,interpretation,source);
	find mayInstanceOfEReference_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationeOpposite_reference_EReference(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationeOpposite_reference_EReference(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eReferenceType reference EReference(source,target)
 */
private pattern mustInRelationeReferenceType_reference_EReference(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eReferenceType reference EReference");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eReferenceType reference EReference(source,target)
 */
private pattern mayInRelationeReferenceType_reference_EReference(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEReference_class(problem,interpretation,source);
	find mayInstanceOfEClass_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationeReferenceType_reference_EReference(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationeReferenceType_reference_EReference(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eKeys reference EReference(source,target)
 */
private pattern mustInRelationeKeys_reference_EReference(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eKeys reference EReference");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eKeys reference EReference(source,target)
 */
private pattern mayInRelationeKeys_reference_EReference(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEReference_class(problem,interpretation,source);
	find mayInstanceOfEAttribute_class(problem,interpretation,target);
} or {
	find mustInRelationeKeys_reference_EReference(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eContainingClass reference EStructuralFeature(source,target)
 */
private pattern mustInRelationeContainingClass_reference_EStructuralFeature(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eContainingClass reference EStructuralFeature");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eContainingClass reference EStructuralFeature(source,target)
 */
private pattern mayInRelationeContainingClass_reference_EStructuralFeature(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEStructuralFeature_class(problem,interpretation,source);
	find mayInstanceOfEClass_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationeContainingClass_reference_EStructuralFeature(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationeContainingClass_reference_EStructuralFeature(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eType reference ETypedElement(source,target)
 */
private pattern mustInRelationeType_reference_ETypedElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eType reference ETypedElement");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eType reference ETypedElement(source,target)
 */
private pattern mayInRelationeType_reference_ETypedElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfETypedElement_class(problem,interpretation,source);
	find mayInstanceOfEClassifier_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationeType_reference_ETypedElement(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationeType_reference_ETypedElement(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eGenericType reference ETypedElement(source,target)
 */
private pattern mustInRelationeGenericType_reference_ETypedElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eGenericType reference ETypedElement");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eGenericType reference ETypedElement(source,target)
 */
private pattern mayInRelationeGenericType_reference_ETypedElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfETypedElement_class(problem,interpretation,source);
	find mayInstanceOfEGenericType_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationeGenericType_reference_ETypedElement(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationeGenericType_reference_ETypedElement(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eUpperBound reference EGenericType(source,target)
 */
private pattern mustInRelationeUpperBound_reference_EGenericType(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eUpperBound reference EGenericType");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eUpperBound reference EGenericType(source,target)
 */
private pattern mayInRelationeUpperBound_reference_EGenericType(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEGenericType_class(problem,interpretation,source);
	find mayInstanceOfEGenericType_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationeUpperBound_reference_EGenericType(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationeUpperBound_reference_EGenericType(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eTypeArguments reference EGenericType(source,target)
 */
private pattern mustInRelationeTypeArguments_reference_EGenericType(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eTypeArguments reference EGenericType");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eTypeArguments reference EGenericType(source,target)
 */
private pattern mayInRelationeTypeArguments_reference_EGenericType(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEGenericType_class(problem,interpretation,source);
	find mayInstanceOfEGenericType_class(problem,interpretation,target);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationeTypeArguments_reference_EGenericType(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eRawType reference EGenericType(source,target)
 */
private pattern mustInRelationeRawType_reference_EGenericType(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eRawType reference EGenericType");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eRawType reference EGenericType(source,target)
 */
private pattern mayInRelationeRawType_reference_EGenericType(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEGenericType_class(problem,interpretation,source);
	find mayInstanceOfEClassifier_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationeRawType_reference_EGenericType(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationeRawType_reference_EGenericType(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eLowerBound reference EGenericType(source,target)
 */
private pattern mustInRelationeLowerBound_reference_EGenericType(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eLowerBound reference EGenericType");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eLowerBound reference EGenericType(source,target)
 */
private pattern mayInRelationeLowerBound_reference_EGenericType(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEGenericType_class(problem,interpretation,source);
	find mayInstanceOfEGenericType_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationeLowerBound_reference_EGenericType(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationeLowerBound_reference_EGenericType(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eTypeParameter reference EGenericType(source,target)
 */
private pattern mustInRelationeTypeParameter_reference_EGenericType(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eTypeParameter reference EGenericType");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eTypeParameter reference EGenericType(source,target)
 */
private pattern mayInRelationeTypeParameter_reference_EGenericType(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEGenericType_class(problem,interpretation,source);
	find mayInstanceOfETypeParameter_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationeTypeParameter_reference_EGenericType(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationeTypeParameter_reference_EGenericType(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eClassifier reference EGenericType(source,target)
 */
private pattern mustInRelationeClassifier_reference_EGenericType(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eClassifier reference EGenericType");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eClassifier reference EGenericType(source,target)
 */
private pattern mayInRelationeClassifier_reference_EGenericType(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEGenericType_class(problem,interpretation,source);
	find mayInstanceOfEClassifier_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationeClassifier_reference_EGenericType(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationeClassifier_reference_EGenericType(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eBounds reference ETypeParameter(source,target)
 */
private pattern mustInRelationeBounds_reference_ETypeParameter(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eBounds reference ETypeParameter");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eBounds reference ETypeParameter(source,target)
 */
private pattern mayInRelationeBounds_reference_ETypeParameter(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfETypeParameter_class(problem,interpretation,source);
	find mayInstanceOfEGenericType_class(problem,interpretation,target);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationeBounds_reference_ETypeParameter(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []iD attribute EAttribute(source,target)
 */
private pattern mustInRelationiD_attribute_EAttribute(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"iD attribute EAttribute");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>iD attribute EAttribute(source,target)
 */
private pattern mayInRelationiD_attribute_EAttribute(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEAttribute_class(problem,interpretation,source);
	BooleanElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationiD_attribute_EAttribute(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationiD_attribute_EAttribute(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []source attribute EAnnotation(source,target)
 */
private pattern mustInRelationsource_attribute_EAnnotation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"source attribute EAnnotation");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>source attribute EAnnotation(source,target)
 */
private pattern mayInRelationsource_attribute_EAnnotation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEAnnotation_class(problem,interpretation,source);
	StringElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationsource_attribute_EAnnotation(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationsource_attribute_EAnnotation(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []abstract attribute EClass(source,target)
 */
private pattern mustInRelationabstract_attribute_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"abstract attribute EClass");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>abstract attribute EClass(source,target)
 */
private pattern mayInRelationabstract_attribute_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEClass_class(problem,interpretation,source);
	BooleanElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationabstract_attribute_EClass(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationabstract_attribute_EClass(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []interface attribute EClass(source,target)
 */
private pattern mustInRelationinterface_attribute_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"interface attribute EClass");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>interface attribute EClass(source,target)
 */
private pattern mayInRelationinterface_attribute_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEClass_class(problem,interpretation,source);
	BooleanElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationinterface_attribute_EClass(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationinterface_attribute_EClass(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []instanceClassName attribute EClassifier(source,target)
 */
private pattern mustInRelationinstanceClassName_attribute_EClassifier(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"instanceClassName attribute EClassifier");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>instanceClassName attribute EClassifier(source,target)
 */
private pattern mayInRelationinstanceClassName_attribute_EClassifier(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEClassifier_class(problem,interpretation,source);
	StringElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationinstanceClassName_attribute_EClassifier(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationinstanceClassName_attribute_EClassifier(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []instanceTypeName attribute EClassifier(source,target)
 */
private pattern mustInRelationinstanceTypeName_attribute_EClassifier(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"instanceTypeName attribute EClassifier");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>instanceTypeName attribute EClassifier(source,target)
 */
private pattern mayInRelationinstanceTypeName_attribute_EClassifier(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEClassifier_class(problem,interpretation,source);
	StringElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationinstanceTypeName_attribute_EClassifier(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationinstanceTypeName_attribute_EClassifier(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []serializable attribute EDataType(source,target)
 */
private pattern mustInRelationserializable_attribute_EDataType(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"serializable attribute EDataType");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>serializable attribute EDataType(source,target)
 */
private pattern mayInRelationserializable_attribute_EDataType(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEDataType_class(problem,interpretation,source);
	BooleanElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationserializable_attribute_EDataType(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationserializable_attribute_EDataType(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []value attribute EEnumLiteral(source,target)
 */
private pattern mustInRelationvalue_attribute_EEnumLiteral(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"value attribute EEnumLiteral");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>value attribute EEnumLiteral(source,target)
 */
private pattern mayInRelationvalue_attribute_EEnumLiteral(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEEnumLiteral_class(problem,interpretation,source);
	IntegerElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationvalue_attribute_EEnumLiteral(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationvalue_attribute_EEnumLiteral(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []literal attribute EEnumLiteral(source,target)
 */
private pattern mustInRelationliteral_attribute_EEnumLiteral(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"literal attribute EEnumLiteral");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>literal attribute EEnumLiteral(source,target)
 */
private pattern mayInRelationliteral_attribute_EEnumLiteral(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEEnumLiteral_class(problem,interpretation,source);
	StringElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationliteral_attribute_EEnumLiteral(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationliteral_attribute_EEnumLiteral(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []name attribute ENamedElement(source,target)
 */
private pattern mustInRelationname_attribute_ENamedElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"name attribute ENamedElement");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>name attribute ENamedElement(source,target)
 */
private pattern mayInRelationname_attribute_ENamedElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfENamedElement_class(problem,interpretation,source);
	StringElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationname_attribute_ENamedElement(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationname_attribute_ENamedElement(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []nsURI attribute EPackage(source,target)
 */
private pattern mustInRelationnsURI_attribute_EPackage(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"nsURI attribute EPackage");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>nsURI attribute EPackage(source,target)
 */
private pattern mayInRelationnsURI_attribute_EPackage(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEPackage_class(problem,interpretation,source);
	StringElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationnsURI_attribute_EPackage(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationnsURI_attribute_EPackage(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []nsPrefix attribute EPackage(source,target)
 */
private pattern mustInRelationnsPrefix_attribute_EPackage(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"nsPrefix attribute EPackage");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>nsPrefix attribute EPackage(source,target)
 */
private pattern mayInRelationnsPrefix_attribute_EPackage(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEPackage_class(problem,interpretation,source);
	StringElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationnsPrefix_attribute_EPackage(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationnsPrefix_attribute_EPackage(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []containment attribute EReference(source,target)
 */
private pattern mustInRelationcontainment_attribute_EReference(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"containment attribute EReference");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>containment attribute EReference(source,target)
 */
private pattern mayInRelationcontainment_attribute_EReference(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEReference_class(problem,interpretation,source);
	BooleanElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationcontainment_attribute_EReference(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationcontainment_attribute_EReference(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []container attribute EReference(source,target)
 */
private pattern mustInRelationcontainer_attribute_EReference(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"container attribute EReference");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>container attribute EReference(source,target)
 */
private pattern mayInRelationcontainer_attribute_EReference(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEReference_class(problem,interpretation,source);
	BooleanElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationcontainer_attribute_EReference(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationcontainer_attribute_EReference(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []resolveProxies attribute EReference(source,target)
 */
private pattern mustInRelationresolveProxies_attribute_EReference(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"resolveProxies attribute EReference");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>resolveProxies attribute EReference(source,target)
 */
private pattern mayInRelationresolveProxies_attribute_EReference(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEReference_class(problem,interpretation,source);
	BooleanElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationresolveProxies_attribute_EReference(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationresolveProxies_attribute_EReference(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []changeable attribute EStructuralFeature(source,target)
 */
private pattern mustInRelationchangeable_attribute_EStructuralFeature(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"changeable attribute EStructuralFeature");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>changeable attribute EStructuralFeature(source,target)
 */
private pattern mayInRelationchangeable_attribute_EStructuralFeature(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEStructuralFeature_class(problem,interpretation,source);
	BooleanElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationchangeable_attribute_EStructuralFeature(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationchangeable_attribute_EStructuralFeature(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []volatile attribute EStructuralFeature(source,target)
 */
private pattern mustInRelationvolatile_attribute_EStructuralFeature(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"volatile attribute EStructuralFeature");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>volatile attribute EStructuralFeature(source,target)
 */
private pattern mayInRelationvolatile_attribute_EStructuralFeature(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEStructuralFeature_class(problem,interpretation,source);
	BooleanElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationvolatile_attribute_EStructuralFeature(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationvolatile_attribute_EStructuralFeature(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []transient attribute EStructuralFeature(source,target)
 */
private pattern mustInRelationtransient_attribute_EStructuralFeature(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"transient attribute EStructuralFeature");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>transient attribute EStructuralFeature(source,target)
 */
private pattern mayInRelationtransient_attribute_EStructuralFeature(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEStructuralFeature_class(problem,interpretation,source);
	BooleanElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationtransient_attribute_EStructuralFeature(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationtransient_attribute_EStructuralFeature(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []defaultValueLiteral attribute EStructuralFeature(source,target)
 */
private pattern mustInRelationdefaultValueLiteral_attribute_EStructuralFeature(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"defaultValueLiteral attribute EStructuralFeature");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>defaultValueLiteral attribute EStructuralFeature(source,target)
 */
private pattern mayInRelationdefaultValueLiteral_attribute_EStructuralFeature(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEStructuralFeature_class(problem,interpretation,source);
	StringElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationdefaultValueLiteral_attribute_EStructuralFeature(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationdefaultValueLiteral_attribute_EStructuralFeature(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []unsettable attribute EStructuralFeature(source,target)
 */
private pattern mustInRelationunsettable_attribute_EStructuralFeature(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"unsettable attribute EStructuralFeature");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>unsettable attribute EStructuralFeature(source,target)
 */
private pattern mayInRelationunsettable_attribute_EStructuralFeature(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEStructuralFeature_class(problem,interpretation,source);
	BooleanElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationunsettable_attribute_EStructuralFeature(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationunsettable_attribute_EStructuralFeature(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []derived attribute EStructuralFeature(source,target)
 */
private pattern mustInRelationderived_attribute_EStructuralFeature(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"derived attribute EStructuralFeature");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>derived attribute EStructuralFeature(source,target)
 */
private pattern mayInRelationderived_attribute_EStructuralFeature(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEStructuralFeature_class(problem,interpretation,source);
	BooleanElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationderived_attribute_EStructuralFeature(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationderived_attribute_EStructuralFeature(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []ordered attribute ETypedElement(source,target)
 */
private pattern mustInRelationordered_attribute_ETypedElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"ordered attribute ETypedElement");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>ordered attribute ETypedElement(source,target)
 */
private pattern mayInRelationordered_attribute_ETypedElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfETypedElement_class(problem,interpretation,source);
	BooleanElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationordered_attribute_ETypedElement(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationordered_attribute_ETypedElement(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []unique attribute ETypedElement(source,target)
 */
private pattern mustInRelationunique_attribute_ETypedElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"unique attribute ETypedElement");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>unique attribute ETypedElement(source,target)
 */
private pattern mayInRelationunique_attribute_ETypedElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfETypedElement_class(problem,interpretation,source);
	BooleanElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationunique_attribute_ETypedElement(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationunique_attribute_ETypedElement(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []lowerBound attribute ETypedElement(source,target)
 */
private pattern mustInRelationlowerBound_attribute_ETypedElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"lowerBound attribute ETypedElement");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>lowerBound attribute ETypedElement(source,target)
 */
private pattern mayInRelationlowerBound_attribute_ETypedElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfETypedElement_class(problem,interpretation,source);
	IntegerElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationlowerBound_attribute_ETypedElement(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationlowerBound_attribute_ETypedElement(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []upperBound attribute ETypedElement(source,target)
 */
private pattern mustInRelationupperBound_attribute_ETypedElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"upperBound attribute ETypedElement");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>upperBound attribute ETypedElement(source,target)
 */
private pattern mayInRelationupperBound_attribute_ETypedElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfETypedElement_class(problem,interpretation,source);
	IntegerElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationupperBound_attribute_ETypedElement(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationupperBound_attribute_ETypedElement(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []many attribute ETypedElement(source,target)
 */
private pattern mustInRelationmany_attribute_ETypedElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"many attribute ETypedElement");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>many attribute ETypedElement(source,target)
 */
private pattern mayInRelationmany_attribute_ETypedElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfETypedElement_class(problem,interpretation,source);
	BooleanElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationmany_attribute_ETypedElement(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationmany_attribute_ETypedElement(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []required attribute ETypedElement(source,target)
 */
private pattern mustInRelationrequired_attribute_ETypedElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"required attribute ETypedElement");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>required attribute ETypedElement(source,target)
 */
private pattern mayInRelationrequired_attribute_ETypedElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfETypedElement_class(problem,interpretation,source);
	BooleanElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationrequired_attribute_ETypedElement(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationrequired_attribute_ETypedElement(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []key attribute EStringToStringMapEntry(source,target)
 */
private pattern mustInRelationkey_attribute_EStringToStringMapEntry(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"key attribute EStringToStringMapEntry");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>key attribute EStringToStringMapEntry(source,target)
 */
private pattern mayInRelationkey_attribute_EStringToStringMapEntry(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEStringToStringMapEntry_class(problem,interpretation,source);
	StringElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationkey_attribute_EStringToStringMapEntry(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationkey_attribute_EStringToStringMapEntry(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []value attribute EStringToStringMapEntry(source,target)
 */
private pattern mustInRelationvalue_attribute_EStringToStringMapEntry(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"value attribute EStringToStringMapEntry");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>value attribute EStringToStringMapEntry(source,target)
 */
private pattern mayInRelationvalue_attribute_EStringToStringMapEntry(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEStringToStringMapEntry_class(problem,interpretation,source);
	StringElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationvalue_attribute_EStringToStringMapEntry(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationvalue_attribute_EStringToStringMapEntry(problem,interpretation,source,target);
}

//////////
// 1.3 Relation Definition Indexers
//////////

//////////
// 1.4 Containment Indexer
//////////
private pattern mustContains2(source: DefinedElement, target: DefinedElement) {
	find mustContains4(_,_,source,target);
}
	
private pattern mustContains4(problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target: DefinedElement)
	{ find mustInRelationdetails_reference_EAnnotation(problem,interpretation,source,target); }or
	
	{ find mustInRelationcontents_reference_EAnnotation(problem,interpretation,source,target); }or
	
	{ find mustInRelationeOperations_reference_EClass(problem,interpretation,source,target); }or
	
	{ find mustInRelationeStructuralFeatures_reference_EClass(problem,interpretation,source,target); }or
	
	{ find mustInRelationeGenericSuperTypes_reference_EClass(problem,interpretation,source,target); }or
	
	{ find mustInRelationeTypeParameters_reference_EClassifier(problem,interpretation,source,target); }or
	
	{ find mustInRelationeLiterals_reference_EEnum(problem,interpretation,source,target); }or
	
	{ find mustInRelationeAnnotations_reference_EModelElement(problem,interpretation,source,target); }or
	
	{ find mustInRelationeTypeParameters_reference_EOperation(problem,interpretation,source,target); }or
	
	{ find mustInRelationeParameters_reference_EOperation(problem,interpretation,source,target); }or
	
	{ find mustInRelationeGenericExceptions_reference_EOperation(problem,interpretation,source,target); }or
	
	{ find mustInRelationeClassifiers_reference_EPackage(problem,interpretation,source,target); }or
	
	{ find mustInRelationeSubpackages_reference_EPackage(problem,interpretation,source,target); }or
	
	{ find mustInRelationeGenericType_reference_ETypedElement(problem,interpretation,source,target); }or
	
	{ find mustInRelationeUpperBound_reference_EGenericType(problem,interpretation,source,target); }or
	
	{ find mustInRelationeTypeArguments_reference_EGenericType(problem,interpretation,source,target); }or
	
	{ find mustInRelationeLowerBound_reference_EGenericType(problem,interpretation,source,target); }or
	
	{ find mustInRelationeBounds_reference_ETypeParameter(problem,interpretation,source,target); }

private pattern mustTransitiveContains(source,target) {
	find mustContains2+(source,target);
}

//////////
// 2. Invalidation Indexers
//////////
// 2.1 Invalidated by WF Queries
//////////

//////////
// 3. Unfinishedness Indexers
//////////
// 3.1 Unfinishedness Measured by Multiplicity
//////////
pattern unfinishedLowerMultiplicity_eAttributeType_reference_EAttribute(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eAttributeType reference EAttribute");
	find mustInstanceOfEAttribute_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationeAttributeType_reference_EAttribute(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_eReferenceType_reference_EReference(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eReferenceType reference EReference");
	find mustInstanceOfEReference_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationeReferenceType_reference_EReference(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_eRawType_reference_EGenericType(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eRawType reference EGenericType");
	find mustInstanceOfEGenericType_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationeRawType_reference_EGenericType(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}

//////////
// 3.2 Unfinishedness Measured by WF Queries
//////////

//////////
// 4. Refinement Indexers
//////////
// 4.1 Object constructors
//////////
private pattern hasElementInContainment(problem:LogicProblem, interpretation:PartialInterpretation)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfETypeParameter_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfETypedElement_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfEClass_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfEStructuralFeature_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfEAnnotation_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfEAttribute_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfEObject_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfEClassifier_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfEGenericType_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfEEnumLiteral_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfEDataType_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfEOperation_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfEPackage_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfEParameter_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfEModelElement_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfEReference_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfEEnum_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfENamedElement_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfEModelElement_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfEModelElement_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfENamedElement_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfENamedElement_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfEPackage_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfEPackage_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}
pattern createObject_EEnum_class_by_eClassifiers_reference_EPackage_with_ePackage_reference_EClassifier(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"EEnum class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"eClassifiers reference EPackage");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"ePackage reference EClassifier");
	find mustInstanceOfEPackage_class(problem,interpretation,container);
	find mayInstanceOfEEnum_class(problem,interpretation,newObject);
	find mayInRelationeClassifiers_reference_EPackage(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_EEnum_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"EEnum class");
	find mayInstanceOfEEnum_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_EAttribute_class_by_eStructuralFeatures_reference_EClass_with_eContainingClass_reference_EStructuralFeature(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"EAttribute class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"eStructuralFeatures reference EClass");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"eContainingClass reference EStructuralFeature");
	find mustInstanceOfEClass_class(problem,interpretation,container);
	find mayInstanceOfEAttribute_class(problem,interpretation,newObject);
	find mayInRelationeStructuralFeatures_reference_EClass(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_EAttribute_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"EAttribute class");
	find mayInstanceOfEAttribute_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_EObject_class_by_contents_reference_EAnnotation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"EObject class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"contents reference EAnnotation");
	find mustInstanceOfEAnnotation_class(problem,interpretation,container);
	find mayInstanceOfEObject_class(problem,interpretation,newObject);
	find mayInRelationcontents_reference_EAnnotation(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_EObject_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"EObject class");
	find mayInstanceOfEObject_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_EReference_class_by_eStructuralFeatures_reference_EClass_with_eContainingClass_reference_EStructuralFeature(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"EReference class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"eStructuralFeatures reference EClass");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"eContainingClass reference EStructuralFeature");
	find mustInstanceOfEClass_class(problem,interpretation,container);
	find mayInstanceOfEReference_class(problem,interpretation,newObject);
	find mayInRelationeStructuralFeatures_reference_EClass(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_EReference_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"EReference class");
	find mayInstanceOfEReference_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_EPackage_class_UndefinedPart_by_eSubpackages_reference_EPackage_with_eSuperPackage_reference_EPackage(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"EPackage class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"eSubpackages reference EPackage");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"eSuperPackage reference EPackage");
	find mustInstanceOfEPackage_class(problem,interpretation,container);
	find mayInstanceOfEPackage_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationeSubpackages_reference_EPackage(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_EPackage_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"EPackage class UndefinedPart");
	find mayInstanceOfEPackage_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_EAnnotation_class_by_eAnnotations_reference_EModelElement_with_eModelElement_reference_EAnnotation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"EAnnotation class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"eAnnotations reference EModelElement");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"eModelElement reference EAnnotation");
	find mustInstanceOfEModelElement_class(problem,interpretation,container);
	find mayInstanceOfEAnnotation_class(problem,interpretation,newObject);
	find mayInRelationeAnnotations_reference_EModelElement(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_EAnnotation_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"EAnnotation class");
	find mayInstanceOfEAnnotation_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_EParameter_class_by_eParameters_reference_EOperation_with_eOperation_reference_EParameter(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"EParameter class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"eParameters reference EOperation");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"eOperation reference EParameter");
	find mustInstanceOfEOperation_class(problem,interpretation,container);
	find mayInstanceOfEParameter_class(problem,interpretation,newObject);
	find mayInRelationeParameters_reference_EOperation(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_EParameter_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"EParameter class");
	find mayInstanceOfEParameter_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_EDataType_class_by_eClassifiers_reference_EPackage_with_ePackage_reference_EClassifier(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"EDataType class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"eClassifiers reference EPackage");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"ePackage reference EClassifier");
	find mustInstanceOfEPackage_class(problem,interpretation,container);
	find mayInstanceOfEDataType_class(problem,interpretation,newObject);
	find mayInRelationeClassifiers_reference_EPackage(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_EDataType_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"EDataType class");
	find mayInstanceOfEDataType_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_EOperation_class_by_eOperations_reference_EClass_with_eContainingClass_reference_EOperation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"EOperation class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"eOperations reference EClass");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"eContainingClass reference EOperation");
	find mustInstanceOfEClass_class(problem,interpretation,container);
	find mayInstanceOfEOperation_class(problem,interpretation,newObject);
	find mayInRelationeOperations_reference_EClass(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_EOperation_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"EOperation class");
	find mayInstanceOfEOperation_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_EStringToStringMapEntry_class_by_details_reference_EAnnotation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"EStringToStringMapEntry class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"details reference EAnnotation");
	find mustInstanceOfEAnnotation_class(problem,interpretation,container);
	find mayInstanceOfEStringToStringMapEntry_class(problem,interpretation,newObject);
	find mayInRelationdetails_reference_EAnnotation(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_EStringToStringMapEntry_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"EStringToStringMapEntry class");
	find mayInstanceOfEStringToStringMapEntry_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_EEnumLiteral_class_by_eLiterals_reference_EEnum_with_eEnum_reference_EEnumLiteral(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"EEnumLiteral class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"eLiterals reference EEnum");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"eEnum reference EEnumLiteral");
	find mustInstanceOfEEnum_class(problem,interpretation,container);
	find mayInstanceOfEEnumLiteral_class(problem,interpretation,newObject);
	find mayInRelationeLiterals_reference_EEnum(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_EEnumLiteral_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"EEnumLiteral class");
	find mayInstanceOfEEnumLiteral_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_EClass_class_by_eClassifiers_reference_EPackage_with_ePackage_reference_EClassifier(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"EClass class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"eClassifiers reference EPackage");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"ePackage reference EClassifier");
	find mustInstanceOfEPackage_class(problem,interpretation,container);
	find mayInstanceOfEClass_class(problem,interpretation,newObject);
	find mayInRelationeClassifiers_reference_EPackage(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_EClass_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"EClass class");
	find mayInstanceOfEClass_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_ETypeParameter_class_by_eTypeParameters_reference_EClassifier(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"ETypeParameter class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"eTypeParameters reference EClassifier");
	find mustInstanceOfEClassifier_class(problem,interpretation,container);
	find mayInstanceOfETypeParameter_class(problem,interpretation,newObject);
	find mayInRelationeTypeParameters_reference_EClassifier(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_ETypeParameter_class_by_eTypeParameters_reference_EOperation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"ETypeParameter class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"eTypeParameters reference EOperation");
	find mustInstanceOfEOperation_class(problem,interpretation,container);
	find mayInstanceOfETypeParameter_class(problem,interpretation,newObject);
	find mayInRelationeTypeParameters_reference_EOperation(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_ETypeParameter_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"ETypeParameter class");
	find mayInstanceOfETypeParameter_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_EGenericType_class_by_eGenericSuperTypes_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"EGenericType class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"eGenericSuperTypes reference EClass");
	find mustInstanceOfEClass_class(problem,interpretation,container);
	find mayInstanceOfEGenericType_class(problem,interpretation,newObject);
	find mayInRelationeGenericSuperTypes_reference_EClass(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_EGenericType_class_by_eGenericExceptions_reference_EOperation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"EGenericType class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"eGenericExceptions reference EOperation");
	find mustInstanceOfEOperation_class(problem,interpretation,container);
	find mayInstanceOfEGenericType_class(problem,interpretation,newObject);
	find mayInRelationeGenericExceptions_reference_EOperation(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_EGenericType_class_by_eGenericType_reference_ETypedElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"EGenericType class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"eGenericType reference ETypedElement");
	find mustInstanceOfETypedElement_class(problem,interpretation,container);
	find mayInstanceOfEGenericType_class(problem,interpretation,newObject);
	find mayInRelationeGenericType_reference_ETypedElement(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_EGenericType_class_by_eUpperBound_reference_EGenericType(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"EGenericType class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"eUpperBound reference EGenericType");
	find mustInstanceOfEGenericType_class(problem,interpretation,container);
	find mayInstanceOfEGenericType_class(problem,interpretation,newObject);
	find mayInRelationeUpperBound_reference_EGenericType(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_EGenericType_class_by_eTypeArguments_reference_EGenericType(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"EGenericType class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"eTypeArguments reference EGenericType");
	find mustInstanceOfEGenericType_class(problem,interpretation,container);
	find mayInstanceOfEGenericType_class(problem,interpretation,newObject);
	find mayInRelationeTypeArguments_reference_EGenericType(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_EGenericType_class_by_eLowerBound_reference_EGenericType(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"EGenericType class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"eLowerBound reference EGenericType");
	find mustInstanceOfEGenericType_class(problem,interpretation,container);
	find mayInstanceOfEGenericType_class(problem,interpretation,newObject);
	find mayInRelationeLowerBound_reference_EGenericType(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_EGenericType_class_by_eBounds_reference_ETypeParameter(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"EGenericType class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"eBounds reference ETypeParameter");
	find mustInstanceOfETypeParameter_class(problem,interpretation,container);
	find mayInstanceOfEGenericType_class(problem,interpretation,newObject);
	find mayInRelationeBounds_reference_ETypeParameter(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_EGenericType_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"EGenericType class");
	find mayInstanceOfEGenericType_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}

//////////
// 4.2 Type refinement
//////////
pattern refineTypeTo_EEnum_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfEEnum_class(problem,interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEEnumLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfEEnum_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfEClass_class(problem,interpretation,element);
	neg find mustInstanceOfETypeParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfETypedElement_class(problem,interpretation,element);
	neg find mustInstanceOfEPackage_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
}
pattern refineTypeTo_EAttribute_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfEAttribute_class(problem,interpretation,element);
	neg find mustInstanceOfEEnumLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEAttribute_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfEReference_class(problem,interpretation,element);
	neg find mustInstanceOfETypeParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEClassifier_class(problem,interpretation,element);
	neg find mustInstanceOfEPackage_class(problem,interpretation,element);
	neg find mustInstanceOfEOperation_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
}
pattern refineTypeTo_EObject_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfEModelElement_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
}
pattern refineTypeTo_EReference_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfEReference_class(problem,interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEEnumLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfEAttribute_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfEReference_class(problem,interpretation,element);
	neg find mustInstanceOfETypeParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEClassifier_class(problem,interpretation,element);
	neg find mustInstanceOfEPackage_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEOperation_class(problem,interpretation,element);
}
pattern refineTypeTo_EPackage_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfEPackage_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfEEnumLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfEPackage_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfETypeParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEClassifier_class(problem,interpretation,element);
	neg find mustInstanceOfETypedElement_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
}
pattern refineTypeTo_EAnnotation_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfENamedElement_class(problem,interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
}
pattern refineTypeTo_EParameter_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfEParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEEnumLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfETypeParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEClassifier_class(problem,interpretation,element);
	neg find mustInstanceOfEStructuralFeature_class(problem,interpretation,element);
	neg find mustInstanceOfEPackage_class(problem,interpretation,element);
	neg find mustInstanceOfEOperation_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
}
pattern refineTypeTo_EDataType_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfEDataType_class(problem,interpretation,element);
	neg find mustInstanceOfEEnumLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEEnum_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfEClass_class(problem,interpretation,element);
	neg find mustInstanceOfETypeParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfETypedElement_class(problem,interpretation,element);
	neg find mustInstanceOfEDataType_class(problem,interpretation,element);
	neg find mustInstanceOfEPackage_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
}
pattern refineTypeTo_EOperation_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfEOperation_class(problem,interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEEnumLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfETypeParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEClassifier_class(problem,interpretation,element);
	neg find mustInstanceOfEStructuralFeature_class(problem,interpretation,element);
	neg find mustInstanceOfEPackage_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEOperation_class(problem,interpretation,element);
}
pattern refineTypeTo_EStringToStringMapEntry_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfEModelElement_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
}
pattern refineTypeTo_EEnumLiteral_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfEEnumLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfEEnumLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfETypeParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfETypedElement_class(problem,interpretation,element);
	neg find mustInstanceOfEClassifier_class(problem,interpretation,element);
	neg find mustInstanceOfEPackage_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
}
pattern refineTypeTo_EClass_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfEClass_class(problem,interpretation,element);
	neg find mustInstanceOfEEnumLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfEClass_class(problem,interpretation,element);
	neg find mustInstanceOfETypeParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfETypedElement_class(problem,interpretation,element);
	neg find mustInstanceOfEDataType_class(problem,interpretation,element);
	neg find mustInstanceOfEPackage_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
}
pattern refineTypeTo_ETypeParameter_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfETypeParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEEnumLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfETypeParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfETypedElement_class(problem,interpretation,element);
	neg find mustInstanceOfEClassifier_class(problem,interpretation,element);
	neg find mustInstanceOfEPackage_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
}
pattern refineTypeTo_EGenericType_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfEModelElement_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
}

//////////
// 4.3 Relation refinement
//////////
pattern refineRelation_eAttributeType_reference_EAttribute(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eAttributeType reference EAttribute");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEAttribute_class(problem,interpretation,from);
	find mustInstanceOfEDataType_class(problem,interpretation,to);
	find mayInRelationeAttributeType_reference_EAttribute(problem,interpretation,from,to);
	neg find mustInRelationeAttributeType_reference_EAttribute(problem,interpretation,from,to);
}
pattern refineRelation_references_reference_EAnnotation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"references reference EAnnotation");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEAnnotation_class(problem,interpretation,from);
	find mustInstanceOfEObject_class(problem,interpretation,to);
	find mayInRelationreferences_reference_EAnnotation(problem,interpretation,from,to);
	neg find mustInRelationreferences_reference_EAnnotation(problem,interpretation,from,to);
}
pattern refineRelation_eSuperTypes_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eSuperTypes reference EClass");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEClass_class(problem,interpretation,from);
	find mustInstanceOfEClass_class(problem,interpretation,to);
	find mayInRelationeSuperTypes_reference_EClass(problem,interpretation,from,to);
	neg find mustInRelationeSuperTypes_reference_EClass(problem,interpretation,from,to);
}
pattern refineRelation_eAllAttributes_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eAllAttributes reference EClass");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEClass_class(problem,interpretation,from);
	find mustInstanceOfEAttribute_class(problem,interpretation,to);
	find mayInRelationeAllAttributes_reference_EClass(problem,interpretation,from,to);
	neg find mustInRelationeAllAttributes_reference_EClass(problem,interpretation,from,to);
}
pattern refineRelation_eAllReferences_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eAllReferences reference EClass");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEClass_class(problem,interpretation,from);
	find mustInstanceOfEReference_class(problem,interpretation,to);
	find mayInRelationeAllReferences_reference_EClass(problem,interpretation,from,to);
	neg find mustInRelationeAllReferences_reference_EClass(problem,interpretation,from,to);
}
pattern refineRelation_eReferences_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eReferences reference EClass");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEClass_class(problem,interpretation,from);
	find mustInstanceOfEReference_class(problem,interpretation,to);
	find mayInRelationeReferences_reference_EClass(problem,interpretation,from,to);
	neg find mustInRelationeReferences_reference_EClass(problem,interpretation,from,to);
}
pattern refineRelation_eAttributes_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eAttributes reference EClass");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEClass_class(problem,interpretation,from);
	find mustInstanceOfEAttribute_class(problem,interpretation,to);
	find mayInRelationeAttributes_reference_EClass(problem,interpretation,from,to);
	neg find mustInRelationeAttributes_reference_EClass(problem,interpretation,from,to);
}
pattern refineRelation_eAllContainments_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eAllContainments reference EClass");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEClass_class(problem,interpretation,from);
	find mustInstanceOfEReference_class(problem,interpretation,to);
	find mayInRelationeAllContainments_reference_EClass(problem,interpretation,from,to);
	neg find mustInRelationeAllContainments_reference_EClass(problem,interpretation,from,to);
}
pattern refineRelation_eAllOperations_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eAllOperations reference EClass");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEClass_class(problem,interpretation,from);
	find mustInstanceOfEOperation_class(problem,interpretation,to);
	find mayInRelationeAllOperations_reference_EClass(problem,interpretation,from,to);
	neg find mustInRelationeAllOperations_reference_EClass(problem,interpretation,from,to);
}
pattern refineRelation_eAllStructuralFeatures_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eAllStructuralFeatures reference EClass");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEClass_class(problem,interpretation,from);
	find mustInstanceOfEStructuralFeature_class(problem,interpretation,to);
	find mayInRelationeAllStructuralFeatures_reference_EClass(problem,interpretation,from,to);
	neg find mustInRelationeAllStructuralFeatures_reference_EClass(problem,interpretation,from,to);
}
pattern refineRelation_eAllSuperTypes_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eAllSuperTypes reference EClass");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEClass_class(problem,interpretation,from);
	find mustInstanceOfEClass_class(problem,interpretation,to);
	find mayInRelationeAllSuperTypes_reference_EClass(problem,interpretation,from,to);
	neg find mustInRelationeAllSuperTypes_reference_EClass(problem,interpretation,from,to);
}
pattern refineRelation_eIDAttribute_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eIDAttribute reference EClass");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEClass_class(problem,interpretation,from);
	find mustInstanceOfEAttribute_class(problem,interpretation,to);
	find mayInRelationeIDAttribute_reference_EClass(problem,interpretation,from,to);
	neg find mustInRelationeIDAttribute_reference_EClass(problem,interpretation,from,to);
}
pattern refineRelation_eAllGenericSuperTypes_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eAllGenericSuperTypes reference EClass");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEClass_class(problem,interpretation,from);
	find mustInstanceOfEGenericType_class(problem,interpretation,to);
	find mayInRelationeAllGenericSuperTypes_reference_EClass(problem,interpretation,from,to);
	neg find mustInRelationeAllGenericSuperTypes_reference_EClass(problem,interpretation,from,to);
}
pattern refineRelation_eExceptions_reference_EOperation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eExceptions reference EOperation");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEOperation_class(problem,interpretation,from);
	find mustInstanceOfEClassifier_class(problem,interpretation,to);
	find mayInRelationeExceptions_reference_EOperation(problem,interpretation,from,to);
	neg find mustInRelationeExceptions_reference_EOperation(problem,interpretation,from,to);
}
pattern refineRelation_eOpposite_reference_EReference(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eOpposite reference EReference");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEReference_class(problem,interpretation,from);
	find mustInstanceOfEReference_class(problem,interpretation,to);
	find mayInRelationeOpposite_reference_EReference(problem,interpretation,from,to);
	neg find mustInRelationeOpposite_reference_EReference(problem,interpretation,from,to);
}
pattern refineRelation_eReferenceType_reference_EReference(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eReferenceType reference EReference");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEReference_class(problem,interpretation,from);
	find mustInstanceOfEClass_class(problem,interpretation,to);
	find mayInRelationeReferenceType_reference_EReference(problem,interpretation,from,to);
	neg find mustInRelationeReferenceType_reference_EReference(problem,interpretation,from,to);
}
pattern refineRelation_eKeys_reference_EReference(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eKeys reference EReference");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEReference_class(problem,interpretation,from);
	find mustInstanceOfEAttribute_class(problem,interpretation,to);
	find mayInRelationeKeys_reference_EReference(problem,interpretation,from,to);
	neg find mustInRelationeKeys_reference_EReference(problem,interpretation,from,to);
}
pattern refineRelation_eType_reference_ETypedElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eType reference ETypedElement");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfETypedElement_class(problem,interpretation,from);
	find mustInstanceOfEClassifier_class(problem,interpretation,to);
	find mayInRelationeType_reference_ETypedElement(problem,interpretation,from,to);
	neg find mustInRelationeType_reference_ETypedElement(problem,interpretation,from,to);
}
pattern refineRelation_eRawType_reference_EGenericType(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eRawType reference EGenericType");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEGenericType_class(problem,interpretation,from);
	find mustInstanceOfEClassifier_class(problem,interpretation,to);
	find mayInRelationeRawType_reference_EGenericType(problem,interpretation,from,to);
	neg find mustInRelationeRawType_reference_EGenericType(problem,interpretation,from,to);
}
pattern refineRelation_eTypeParameter_reference_EGenericType(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eTypeParameter reference EGenericType");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEGenericType_class(problem,interpretation,from);
	find mustInstanceOfETypeParameter_class(problem,interpretation,to);
	find mayInRelationeTypeParameter_reference_EGenericType(problem,interpretation,from,to);
	neg find mustInRelationeTypeParameter_reference_EGenericType(problem,interpretation,from,to);
}
pattern refineRelation_eClassifier_reference_EGenericType(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eClassifier reference EGenericType");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEGenericType_class(problem,interpretation,from);
	find mustInstanceOfEClassifier_class(problem,interpretation,to);
	find mayInRelationeClassifier_reference_EGenericType(problem,interpretation,from,to);
	neg find mustInRelationeClassifier_reference_EGenericType(problem,interpretation,from,to);
}
pattern refineRelation_iD_attribute_EAttribute(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"iD attribute EAttribute");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEAttribute_class(problem,interpretation,from);
	BooleanElement(to);
	find mayInRelationiD_attribute_EAttribute(problem,interpretation,from,to);
	neg find mustInRelationiD_attribute_EAttribute(problem,interpretation,from,to);
}
pattern refineRelation_source_attribute_EAnnotation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"source attribute EAnnotation");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEAnnotation_class(problem,interpretation,from);
	StringElement(to);
	find mayInRelationsource_attribute_EAnnotation(problem,interpretation,from,to);
	neg find mustInRelationsource_attribute_EAnnotation(problem,interpretation,from,to);
}
pattern refineRelation_abstract_attribute_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"abstract attribute EClass");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEClass_class(problem,interpretation,from);
	BooleanElement(to);
	find mayInRelationabstract_attribute_EClass(problem,interpretation,from,to);
	neg find mustInRelationabstract_attribute_EClass(problem,interpretation,from,to);
}
pattern refineRelation_interface_attribute_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"interface attribute EClass");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEClass_class(problem,interpretation,from);
	BooleanElement(to);
	find mayInRelationinterface_attribute_EClass(problem,interpretation,from,to);
	neg find mustInRelationinterface_attribute_EClass(problem,interpretation,from,to);
}
pattern refineRelation_instanceClassName_attribute_EClassifier(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"instanceClassName attribute EClassifier");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEClassifier_class(problem,interpretation,from);
	StringElement(to);
	find mayInRelationinstanceClassName_attribute_EClassifier(problem,interpretation,from,to);
	neg find mustInRelationinstanceClassName_attribute_EClassifier(problem,interpretation,from,to);
}
pattern refineRelation_instanceTypeName_attribute_EClassifier(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"instanceTypeName attribute EClassifier");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEClassifier_class(problem,interpretation,from);
	StringElement(to);
	find mayInRelationinstanceTypeName_attribute_EClassifier(problem,interpretation,from,to);
	neg find mustInRelationinstanceTypeName_attribute_EClassifier(problem,interpretation,from,to);
}
pattern refineRelation_serializable_attribute_EDataType(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"serializable attribute EDataType");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEDataType_class(problem,interpretation,from);
	BooleanElement(to);
	find mayInRelationserializable_attribute_EDataType(problem,interpretation,from,to);
	neg find mustInRelationserializable_attribute_EDataType(problem,interpretation,from,to);
}
pattern refineRelation_value_attribute_EEnumLiteral(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"value attribute EEnumLiteral");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEEnumLiteral_class(problem,interpretation,from);
	IntegerElement(to);
	find mayInRelationvalue_attribute_EEnumLiteral(problem,interpretation,from,to);
	neg find mustInRelationvalue_attribute_EEnumLiteral(problem,interpretation,from,to);
}
pattern refineRelation_literal_attribute_EEnumLiteral(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"literal attribute EEnumLiteral");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEEnumLiteral_class(problem,interpretation,from);
	StringElement(to);
	find mayInRelationliteral_attribute_EEnumLiteral(problem,interpretation,from,to);
	neg find mustInRelationliteral_attribute_EEnumLiteral(problem,interpretation,from,to);
}
pattern refineRelation_name_attribute_ENamedElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"name attribute ENamedElement");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfENamedElement_class(problem,interpretation,from);
	StringElement(to);
	find mayInRelationname_attribute_ENamedElement(problem,interpretation,from,to);
	neg find mustInRelationname_attribute_ENamedElement(problem,interpretation,from,to);
}
pattern refineRelation_nsURI_attribute_EPackage(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"nsURI attribute EPackage");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEPackage_class(problem,interpretation,from);
	StringElement(to);
	find mayInRelationnsURI_attribute_EPackage(problem,interpretation,from,to);
	neg find mustInRelationnsURI_attribute_EPackage(problem,interpretation,from,to);
}
pattern refineRelation_nsPrefix_attribute_EPackage(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"nsPrefix attribute EPackage");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEPackage_class(problem,interpretation,from);
	StringElement(to);
	find mayInRelationnsPrefix_attribute_EPackage(problem,interpretation,from,to);
	neg find mustInRelationnsPrefix_attribute_EPackage(problem,interpretation,from,to);
}
pattern refineRelation_containment_attribute_EReference(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"containment attribute EReference");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEReference_class(problem,interpretation,from);
	BooleanElement(to);
	find mayInRelationcontainment_attribute_EReference(problem,interpretation,from,to);
	neg find mustInRelationcontainment_attribute_EReference(problem,interpretation,from,to);
}
pattern refineRelation_container_attribute_EReference(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"container attribute EReference");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEReference_class(problem,interpretation,from);
	BooleanElement(to);
	find mayInRelationcontainer_attribute_EReference(problem,interpretation,from,to);
	neg find mustInRelationcontainer_attribute_EReference(problem,interpretation,from,to);
}
pattern refineRelation_resolveProxies_attribute_EReference(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"resolveProxies attribute EReference");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEReference_class(problem,interpretation,from);
	BooleanElement(to);
	find mayInRelationresolveProxies_attribute_EReference(problem,interpretation,from,to);
	neg find mustInRelationresolveProxies_attribute_EReference(problem,interpretation,from,to);
}
pattern refineRelation_changeable_attribute_EStructuralFeature(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"changeable attribute EStructuralFeature");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEStructuralFeature_class(problem,interpretation,from);
	BooleanElement(to);
	find mayInRelationchangeable_attribute_EStructuralFeature(problem,interpretation,from,to);
	neg find mustInRelationchangeable_attribute_EStructuralFeature(problem,interpretation,from,to);
}
pattern refineRelation_volatile_attribute_EStructuralFeature(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"volatile attribute EStructuralFeature");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEStructuralFeature_class(problem,interpretation,from);
	BooleanElement(to);
	find mayInRelationvolatile_attribute_EStructuralFeature(problem,interpretation,from,to);
	neg find mustInRelationvolatile_attribute_EStructuralFeature(problem,interpretation,from,to);
}
pattern refineRelation_transient_attribute_EStructuralFeature(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"transient attribute EStructuralFeature");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEStructuralFeature_class(problem,interpretation,from);
	BooleanElement(to);
	find mayInRelationtransient_attribute_EStructuralFeature(problem,interpretation,from,to);
	neg find mustInRelationtransient_attribute_EStructuralFeature(problem,interpretation,from,to);
}
pattern refineRelation_defaultValueLiteral_attribute_EStructuralFeature(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"defaultValueLiteral attribute EStructuralFeature");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEStructuralFeature_class(problem,interpretation,from);
	StringElement(to);
	find mayInRelationdefaultValueLiteral_attribute_EStructuralFeature(problem,interpretation,from,to);
	neg find mustInRelationdefaultValueLiteral_attribute_EStructuralFeature(problem,interpretation,from,to);
}
pattern refineRelation_unsettable_attribute_EStructuralFeature(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"unsettable attribute EStructuralFeature");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEStructuralFeature_class(problem,interpretation,from);
	BooleanElement(to);
	find mayInRelationunsettable_attribute_EStructuralFeature(problem,interpretation,from,to);
	neg find mustInRelationunsettable_attribute_EStructuralFeature(problem,interpretation,from,to);
}
pattern refineRelation_derived_attribute_EStructuralFeature(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"derived attribute EStructuralFeature");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEStructuralFeature_class(problem,interpretation,from);
	BooleanElement(to);
	find mayInRelationderived_attribute_EStructuralFeature(problem,interpretation,from,to);
	neg find mustInRelationderived_attribute_EStructuralFeature(problem,interpretation,from,to);
}
pattern refineRelation_ordered_attribute_ETypedElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"ordered attribute ETypedElement");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfETypedElement_class(problem,interpretation,from);
	BooleanElement(to);
	find mayInRelationordered_attribute_ETypedElement(problem,interpretation,from,to);
	neg find mustInRelationordered_attribute_ETypedElement(problem,interpretation,from,to);
}
pattern refineRelation_unique_attribute_ETypedElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"unique attribute ETypedElement");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfETypedElement_class(problem,interpretation,from);
	BooleanElement(to);
	find mayInRelationunique_attribute_ETypedElement(problem,interpretation,from,to);
	neg find mustInRelationunique_attribute_ETypedElement(problem,interpretation,from,to);
}
pattern refineRelation_lowerBound_attribute_ETypedElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"lowerBound attribute ETypedElement");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfETypedElement_class(problem,interpretation,from);
	IntegerElement(to);
	find mayInRelationlowerBound_attribute_ETypedElement(problem,interpretation,from,to);
	neg find mustInRelationlowerBound_attribute_ETypedElement(problem,interpretation,from,to);
}
pattern refineRelation_upperBound_attribute_ETypedElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"upperBound attribute ETypedElement");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfETypedElement_class(problem,interpretation,from);
	IntegerElement(to);
	find mayInRelationupperBound_attribute_ETypedElement(problem,interpretation,from,to);
	neg find mustInRelationupperBound_attribute_ETypedElement(problem,interpretation,from,to);
}
pattern refineRelation_many_attribute_ETypedElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"many attribute ETypedElement");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfETypedElement_class(problem,interpretation,from);
	BooleanElement(to);
	find mayInRelationmany_attribute_ETypedElement(problem,interpretation,from,to);
	neg find mustInRelationmany_attribute_ETypedElement(problem,interpretation,from,to);
}
pattern refineRelation_required_attribute_ETypedElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"required attribute ETypedElement");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfETypedElement_class(problem,interpretation,from);
	BooleanElement(to);
	find mayInRelationrequired_attribute_ETypedElement(problem,interpretation,from,to);
	neg find mustInRelationrequired_attribute_ETypedElement(problem,interpretation,from,to);
}
pattern refineRelation_key_attribute_EStringToStringMapEntry(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"key attribute EStringToStringMapEntry");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,from);
	StringElement(to);
	find mayInRelationkey_attribute_EStringToStringMapEntry(problem,interpretation,from,to);
	neg find mustInRelationkey_attribute_EStringToStringMapEntry(problem,interpretation,from,to);
}
pattern refineRelation_value_attribute_EStringToStringMapEntry(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"value attribute EStringToStringMapEntry");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,from);
	StringElement(to);
	find mayInRelationvalue_attribute_EStringToStringMapEntry(problem,interpretation,from,to);
	neg find mustInRelationvalue_attribute_EStringToStringMapEntry(problem,interpretation,from,to);
}
import epackage "http://www.bme.hu/mit/inf/dslreasoner/viatrasolver/partialinterpretationlanguage"
import epackage "http://www.bme.hu/mit/inf/dslreasoner/logic/model/problem"
import epackage "http://www.bme.hu/mit/inf/dslreasoner/logic/model/language"

//////////
// 0. Util
//////////
private pattern interpretation(problem:LogicProblem, interpretation:PartialInterpretation) {
	PartialInterpretation.problem(interpretation,problem);
}
	
/////////////////////////
// 0.1 Existence
/////////////////////////
private pattern mustExist(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	find interpretation(problem,interpretation);
	LogicProblem.elements(problem,element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
}

private pattern mayExist(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
    find mustExist(problem,interpretation,element);
} or {
    find interpretation(problem,interpretation);
    neg find elementCloseWorld(element);
    PartialInterpretation.openWorldElements(interpretation,element);
}

private pattern elementCloseWorld(element:DefinedElement) {
	PartialInterpretation.openWorldElements(i,element);
    PartialInterpretation.maxNewElements(i,0);
} or {
	Scope.targetTypeInterpretation(scope,interpretation);
	PartialTypeInterpratation.elements(interpretation,element);
	Scope.maxNewElements(scope,0);
}

////////////////////////
// 0.2 Equivalence
////////////////////////
pattern mayEquivalent(problem:LogicProblem, interpretation:PartialInterpretation, a: DefinedElement, b: DefinedElement) {
	find mayExist(problem,interpretation,a);
	find mayExist(problem,interpretation,b);
	a == b;
}

////////////////////////
// 0.3 Required Patterns by TypeIndexer
////////////////////////
private pattern typeInterpretation(problem:LogicProblem, interpretation:PartialInterpretation, type:TypeDeclaration, typeInterpretation:PartialComplexTypeInterpretation) {
	find interpretation(problem,interpretation);
	LogicProblem.types(problem,type);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
}

private pattern directInstanceOf(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement, type:Type) {
	find interpretation(problem,interpretation);
	LogicProblem.types(problem,type);
	TypeDefinition.elements(type,element);
} or {
	find interpretation(problem,interpretation);
	find typeInterpretation(problem,interpretation,type,typeInterpretation);
	PartialComplexTypeInterpretation.elements(typeInterpretation,element);
}

private pattern isPrimitive(element: PrimitiveElement) {
	PrimitiveElement(element);
}

//////////
// 1. Problem-Specific Base Indexers
//////////
// 1.1 Type Indexers
//////////
// 1.1.1 primitive Type Indexers
//////////

//////////
// 1.1.2 domain-specific Type Indexers
//////////
/**
 * An element must be an instance of type "EAttribute class".
 */
private pattern mustInstanceOfEAttribute_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"EAttribute class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewEAttribute_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"EAttribute class");
}

/**
 * An element may be an instance of type "EAttribute class".
 */
private pattern mayInstanceOfEAttribute_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEOperation_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEEnumLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfEPackage_class(problem,interpretation,element);
	neg find mustInstanceOfETypeParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEClassifier_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfEReference_class(problem,interpretation,element);
	neg find scopeDisallowsNewEAttribute_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEOperation_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEEnumLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfEPackage_class(problem,interpretation,element);
	neg find mustInstanceOfETypeParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEClassifier_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfEReference_class(problem,interpretation,element);
	neg find scopeDisallowsNewEAttribute_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfEAttribute_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "EAnnotation class".
 */
private pattern mustInstanceOfEAnnotation_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"EAnnotation class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewEAnnotation_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"EAnnotation class");
}

/**
 * An element may be an instance of type "EAnnotation class".
 */
private pattern mayInstanceOfEAnnotation_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfENamedElement_class(problem,interpretation,element);
	neg find scopeDisallowsNewEAnnotation_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfENamedElement_class(problem,interpretation,element);
	neg find scopeDisallowsNewEAnnotation_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfEAnnotation_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "EClass class".
 */
private pattern mustInstanceOfEClass_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"EClass class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewEClass_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"EClass class");
}

/**
 * An element may be an instance of type "EClass class".
 */
private pattern mayInstanceOfEClass_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEDataType_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEEnumLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfEPackage_class(problem,interpretation,element);
	neg find mustInstanceOfETypeParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfETypedElement_class(problem,interpretation,element);
	neg find scopeDisallowsNewEClass_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEDataType_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEEnumLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfEPackage_class(problem,interpretation,element);
	neg find mustInstanceOfETypeParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfETypedElement_class(problem,interpretation,element);
	neg find scopeDisallowsNewEClass_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfEClass_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "EClassifier class".
 */
private pattern mustInstanceOfEClassifier_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"EClassifier class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewEClassifier_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"EClassifier class");
}

/**
 * An element may be an instance of type "EClassifier class".
 */
private pattern mayInstanceOfEClassifier_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEDataType_class(problem,interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEPackage_class(problem,interpretation,element);
	neg find mustInstanceOfEEnumLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfETypeParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfETypedElement_class(problem,interpretation,element);
	neg find mustInstanceOfEClass_class(problem,interpretation,element);
	neg find scopeDisallowsNewEClassifier_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEDataType_class(problem,interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEPackage_class(problem,interpretation,element);
	neg find mustInstanceOfEEnumLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfETypeParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfETypedElement_class(problem,interpretation,element);
	neg find mustInstanceOfEClass_class(problem,interpretation,element);
	neg find scopeDisallowsNewEClassifier_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfEClassifier_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "EDataType class".
 */
private pattern mustInstanceOfEDataType_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"EDataType class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewEDataType_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"EDataType class");
}

/**
 * An element may be an instance of type "EDataType class".
 */
private pattern mayInstanceOfEDataType_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEEnumLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfEPackage_class(problem,interpretation,element);
	neg find mustInstanceOfETypeParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfEEnum_class(problem,interpretation,element);
	neg find mustInstanceOfETypedElement_class(problem,interpretation,element);
	neg find mustInstanceOfEClass_class(problem,interpretation,element);
	neg find scopeDisallowsNewEDataType_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEEnumLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfEPackage_class(problem,interpretation,element);
	neg find mustInstanceOfETypeParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfEEnum_class(problem,interpretation,element);
	neg find mustInstanceOfETypedElement_class(problem,interpretation,element);
	neg find mustInstanceOfEClass_class(problem,interpretation,element);
	neg find scopeDisallowsNewEDataType_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfEDataType_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "EEnum class".
 */
private pattern mustInstanceOfEEnum_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"EEnum class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewEEnum_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"EEnum class");
}

/**
 * An element may be an instance of type "EEnum class".
 */
private pattern mayInstanceOfEEnum_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEPackage_class(problem,interpretation,element);
	neg find mustInstanceOfEEnumLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfETypeParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfETypedElement_class(problem,interpretation,element);
	neg find mustInstanceOfEClass_class(problem,interpretation,element);
	neg find scopeDisallowsNewEEnum_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEPackage_class(problem,interpretation,element);
	neg find mustInstanceOfEEnumLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfETypeParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfETypedElement_class(problem,interpretation,element);
	neg find mustInstanceOfEClass_class(problem,interpretation,element);
	neg find scopeDisallowsNewEEnum_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfEEnum_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "EEnumLiteral class".
 */
private pattern mustInstanceOfEEnumLiteral_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"EEnumLiteral class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewEEnumLiteral_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"EEnumLiteral class");
}

/**
 * An element may be an instance of type "EEnumLiteral class".
 */
private pattern mayInstanceOfEEnumLiteral_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEPackage_class(problem,interpretation,element);
	neg find mustInstanceOfETypeParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEClassifier_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfETypedElement_class(problem,interpretation,element);
	neg find scopeDisallowsNewEEnumLiteral_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEPackage_class(problem,interpretation,element);
	neg find mustInstanceOfETypeParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEClassifier_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfETypedElement_class(problem,interpretation,element);
	neg find scopeDisallowsNewEEnumLiteral_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfEEnumLiteral_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "EModelElement class".
 */
private pattern mustInstanceOfEModelElement_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"EModelElement class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewEModelElement_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"EModelElement class");
}

/**
 * An element may be an instance of type "EModelElement class".
 */
private pattern mayInstanceOfEModelElement_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEModelElement_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfENamedElement_class(problem,interpretation,element);
	neg find scopeDisallowsNewEModelElement_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEModelElement_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfENamedElement_class(problem,interpretation,element);
	neg find scopeDisallowsNewEModelElement_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfEModelElement_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "ENamedElement class".
 */
private pattern mustInstanceOfENamedElement_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"ENamedElement class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewENamedElement_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"ENamedElement class");
}

/**
 * An element may be an instance of type "ENamedElement class".
 */
private pattern mayInstanceOfENamedElement_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEPackage_class(problem,interpretation,element);
	neg find mustInstanceOfEModelElement_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find scopeDisallowsNewENamedElement_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEPackage_class(problem,interpretation,element);
	neg find mustInstanceOfEModelElement_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find scopeDisallowsNewENamedElement_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfENamedElement_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "EObject class".
 */
private pattern mustInstanceOfEObject_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"EObject class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewEObject_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"EObject class");
}

/**
 * An element may be an instance of type "EObject class".
 */
private pattern mayInstanceOfEObject_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEModelElement_class(problem,interpretation,element);
	neg find scopeDisallowsNewEObject_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEModelElement_class(problem,interpretation,element);
	neg find scopeDisallowsNewEObject_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfEObject_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "EOperation class".
 */
private pattern mustInstanceOfEOperation_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"EOperation class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewEOperation_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"EOperation class");
}

/**
 * An element may be an instance of type "EOperation class".
 */
private pattern mayInstanceOfEOperation_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEPackage_class(problem,interpretation,element);
	neg find mustInstanceOfEEnumLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfETypeParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEClassifier_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfEStructuralFeature_class(problem,interpretation,element);
	neg find scopeDisallowsNewEOperation_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEPackage_class(problem,interpretation,element);
	neg find mustInstanceOfEEnumLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfETypeParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEClassifier_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfEStructuralFeature_class(problem,interpretation,element);
	neg find scopeDisallowsNewEOperation_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfEOperation_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "EPackage class".
 */
private pattern mustInstanceOfEPackage_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"EPackage class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewEPackage_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"EPackage class");
}

/**
 * An element may be an instance of type "EPackage class".
 */
private pattern mayInstanceOfEPackage_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEModelElement_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find scopeDisallowsNewEPackage_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEModelElement_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find scopeDisallowsNewEPackage_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfEPackage_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "EParameter class".
 */
private pattern mustInstanceOfEParameter_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"EParameter class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewEParameter_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"EParameter class");
}

/**
 * An element may be an instance of type "EParameter class".
 */
private pattern mayInstanceOfEParameter_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEOperation_class(problem,interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEEnumLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfEPackage_class(problem,interpretation,element);
	neg find mustInstanceOfETypeParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEClassifier_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfEStructuralFeature_class(problem,interpretation,element);
	neg find scopeDisallowsNewEParameter_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEOperation_class(problem,interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEEnumLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfEPackage_class(problem,interpretation,element);
	neg find mustInstanceOfETypeParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEClassifier_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfEStructuralFeature_class(problem,interpretation,element);
	neg find scopeDisallowsNewEParameter_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfEParameter_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "EReference class".
 */
private pattern mustInstanceOfEReference_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"EReference class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewEReference_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"EReference class");
}

/**
 * An element may be an instance of type "EReference class".
 */
private pattern mayInstanceOfEReference_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEOperation_class(problem,interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEEnumLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfEPackage_class(problem,interpretation,element);
	neg find mustInstanceOfETypeParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEClassifier_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfEAttribute_class(problem,interpretation,element);
	neg find scopeDisallowsNewEReference_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEOperation_class(problem,interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEEnumLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfEPackage_class(problem,interpretation,element);
	neg find mustInstanceOfETypeParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEClassifier_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfEAttribute_class(problem,interpretation,element);
	neg find scopeDisallowsNewEReference_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfEReference_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "EStructuralFeature class".
 */
private pattern mustInstanceOfEStructuralFeature_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"EStructuralFeature class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewEStructuralFeature_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"EStructuralFeature class");
}

/**
 * An element may be an instance of type "EStructuralFeature class".
 */
private pattern mayInstanceOfEStructuralFeature_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEOperation_class(problem,interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEEnumLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfEPackage_class(problem,interpretation,element);
	neg find mustInstanceOfETypeParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEClassifier_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfEReference_class(problem,interpretation,element);
	neg find mustInstanceOfEAttribute_class(problem,interpretation,element);
	neg find scopeDisallowsNewEStructuralFeature_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEOperation_class(problem,interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEEnumLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfEPackage_class(problem,interpretation,element);
	neg find mustInstanceOfETypeParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEClassifier_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfEReference_class(problem,interpretation,element);
	neg find mustInstanceOfEAttribute_class(problem,interpretation,element);
	neg find scopeDisallowsNewEStructuralFeature_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfEStructuralFeature_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "ETypedElement class".
 */
private pattern mustInstanceOfETypedElement_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"ETypedElement class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewETypedElement_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"ETypedElement class");
}

/**
 * An element may be an instance of type "ETypedElement class".
 */
private pattern mayInstanceOfETypedElement_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEOperation_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEPackage_class(problem,interpretation,element);
	neg find mustInstanceOfEEnumLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfETypeParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEClassifier_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfEStructuralFeature_class(problem,interpretation,element);
	neg find scopeDisallowsNewETypedElement_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEOperation_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEPackage_class(problem,interpretation,element);
	neg find mustInstanceOfEEnumLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfETypeParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEClassifier_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfEStructuralFeature_class(problem,interpretation,element);
	neg find scopeDisallowsNewETypedElement_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfETypedElement_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "EStringToStringMapEntry class".
 */
private pattern mustInstanceOfEStringToStringMapEntry_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"EStringToStringMapEntry class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewEStringToStringMapEntry_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"EStringToStringMapEntry class");
}

/**
 * An element may be an instance of type "EStringToStringMapEntry class".
 */
private pattern mayInstanceOfEStringToStringMapEntry_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEModelElement_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find scopeDisallowsNewEStringToStringMapEntry_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEModelElement_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find scopeDisallowsNewEStringToStringMapEntry_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "EGenericType class".
 */
private pattern mustInstanceOfEGenericType_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"EGenericType class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewEGenericType_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"EGenericType class");
}

/**
 * An element may be an instance of type "EGenericType class".
 */
private pattern mayInstanceOfEGenericType_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEModelElement_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find scopeDisallowsNewEGenericType_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEModelElement_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find scopeDisallowsNewEGenericType_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfEGenericType_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "ETypeParameter class".
 */
private pattern mustInstanceOfETypeParameter_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"ETypeParameter class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewETypeParameter_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"ETypeParameter class");
}

/**
 * An element may be an instance of type "ETypeParameter class".
 */
private pattern mayInstanceOfETypeParameter_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEPackage_class(problem,interpretation,element);
	neg find mustInstanceOfEEnumLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfEClassifier_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfETypedElement_class(problem,interpretation,element);
	neg find scopeDisallowsNewETypeParameter_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEPackage_class(problem,interpretation,element);
	neg find mustInstanceOfEEnumLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfEClassifier_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfETypedElement_class(problem,interpretation,element);
	neg find scopeDisallowsNewETypeParameter_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfETypeParameter_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "EModelElement class DefinedPart".
 */
private pattern mustInstanceOfEModelElement_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"EModelElement class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewEModelElement_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"EModelElement class DefinedPart");
}

/**
 * An element may be an instance of type "EModelElement class DefinedPart".
 */
private pattern mayInstanceOfEModelElement_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfEModelElement_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "EModelElement class UndefinedPart".
 */
private pattern mustInstanceOfEModelElement_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"EModelElement class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewEModelElement_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"EModelElement class UndefinedPart");
}

/**
 * An element may be an instance of type "EModelElement class UndefinedPart".
 */
private pattern mayInstanceOfEModelElement_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfENamedElement_class(problem,interpretation,element);
	neg find scopeDisallowsNewEModelElement_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfENamedElement_class(problem,interpretation,element);
	neg find scopeDisallowsNewEModelElement_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfEModelElement_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "ENamedElement class DefinedPart".
 */
private pattern mustInstanceOfENamedElement_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"ENamedElement class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewENamedElement_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"ENamedElement class DefinedPart");
}

/**
 * An element may be an instance of type "ENamedElement class DefinedPart".
 */
private pattern mayInstanceOfENamedElement_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfENamedElement_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "ENamedElement class UndefinedPart".
 */
private pattern mustInstanceOfENamedElement_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"ENamedElement class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewENamedElement_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"ENamedElement class UndefinedPart");
}

/**
 * An element may be an instance of type "ENamedElement class UndefinedPart".
 */
private pattern mayInstanceOfENamedElement_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEEnumLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfEPackage_class(problem,interpretation,element);
	neg find mustInstanceOfETypeParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEClassifier_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfETypedElement_class(problem,interpretation,element);
	neg find scopeDisallowsNewENamedElement_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEEnumLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfEPackage_class(problem,interpretation,element);
	neg find mustInstanceOfETypeParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEClassifier_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfETypedElement_class(problem,interpretation,element);
	neg find scopeDisallowsNewENamedElement_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfENamedElement_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "EPackage class DefinedPart".
 */
private pattern mustInstanceOfEPackage_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"EPackage class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewEPackage_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"EPackage class DefinedPart");
}

/**
 * An element may be an instance of type "EPackage class DefinedPart".
 */
private pattern mayInstanceOfEPackage_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfEPackage_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "EPackage class UndefinedPart".
 */
private pattern mustInstanceOfEPackage_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"EPackage class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewEPackage_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"EPackage class UndefinedPart");
}

/**
 * An element may be an instance of type "EPackage class UndefinedPart".
 */
private pattern mayInstanceOfEPackage_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEEnumLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfETypeParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEClassifier_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfETypedElement_class(problem,interpretation,element);
	neg find scopeDisallowsNewEPackage_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEEnumLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfETypeParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEClassifier_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfETypedElement_class(problem,interpretation,element);
	neg find scopeDisallowsNewEPackage_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfEPackage_class_UndefinedPart(problem,interpretation,element); }

//////////
// 1.2 Relation Declaration Indexers
//////////
/**
 * Matcher for detecting tuples t where []eAttributeType reference EAttribute(source,target)
 */
private pattern mustInRelationeAttributeType_reference_EAttribute(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eAttributeType reference EAttribute");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eAttributeType reference EAttribute(source,target)
 */
private pattern mayInRelationeAttributeType_reference_EAttribute(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEAttribute_class(problem,interpretation,source);
	find mayInstanceOfEDataType_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationeAttributeType_reference_EAttribute(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationeAttributeType_reference_EAttribute(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []details reference EAnnotation(source,target)
 */
private pattern mustInRelationdetails_reference_EAnnotation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"details reference EAnnotation");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>details reference EAnnotation(source,target)
 */
private pattern mayInRelationdetails_reference_EAnnotation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEAnnotation_class(problem,interpretation,source);
	find mayInstanceOfEStringToStringMapEntry_class(problem,interpretation,target);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationdetails_reference_EAnnotation(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eModelElement reference EAnnotation(source,target)
 */
private pattern mustInRelationeModelElement_reference_EAnnotation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eModelElement reference EAnnotation");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eModelElement reference EAnnotation(source,target)
 */
private pattern mayInRelationeModelElement_reference_EAnnotation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEAnnotation_class(problem,interpretation,source);
	find mayInstanceOfEModelElement_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationeModelElement_reference_EAnnotation(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationeModelElement_reference_EAnnotation(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []contents reference EAnnotation(source,target)
 */
private pattern mustInRelationcontents_reference_EAnnotation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"contents reference EAnnotation");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>contents reference EAnnotation(source,target)
 */
private pattern mayInRelationcontents_reference_EAnnotation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEAnnotation_class(problem,interpretation,source);
	find mayInstanceOfEObject_class(problem,interpretation,target);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationcontents_reference_EAnnotation(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []references reference EAnnotation(source,target)
 */
private pattern mustInRelationreferences_reference_EAnnotation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"references reference EAnnotation");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>references reference EAnnotation(source,target)
 */
private pattern mayInRelationreferences_reference_EAnnotation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEAnnotation_class(problem,interpretation,source);
	find mayInstanceOfEObject_class(problem,interpretation,target);
} or {
	find mustInRelationreferences_reference_EAnnotation(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eSuperTypes reference EClass(source,target)
 */
private pattern mustInRelationeSuperTypes_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eSuperTypes reference EClass");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eSuperTypes reference EClass(source,target)
 */
private pattern mayInRelationeSuperTypes_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEClass_class(problem,interpretation,source);
	find mayInstanceOfEClass_class(problem,interpretation,target);
} or {
	find mustInRelationeSuperTypes_reference_EClass(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eOperations reference EClass(source,target)
 */
private pattern mustInRelationeOperations_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eOperations reference EClass");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eOperations reference EClass(source,target)
 */
private pattern mayInRelationeOperations_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEClass_class(problem,interpretation,source);
	find mayInstanceOfEOperation_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationeContainingClass_reference_EOperation(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationeOperations_reference_EClass(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eAllAttributes reference EClass(source,target)
 */
private pattern mustInRelationeAllAttributes_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eAllAttributes reference EClass");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eAllAttributes reference EClass(source,target)
 */
private pattern mayInRelationeAllAttributes_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEClass_class(problem,interpretation,source);
	find mayInstanceOfEAttribute_class(problem,interpretation,target);
} or {
	find mustInRelationeAllAttributes_reference_EClass(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eAllReferences reference EClass(source,target)
 */
private pattern mustInRelationeAllReferences_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eAllReferences reference EClass");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eAllReferences reference EClass(source,target)
 */
private pattern mayInRelationeAllReferences_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEClass_class(problem,interpretation,source);
	find mayInstanceOfEReference_class(problem,interpretation,target);
} or {
	find mustInRelationeAllReferences_reference_EClass(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eReferences reference EClass(source,target)
 */
private pattern mustInRelationeReferences_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eReferences reference EClass");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eReferences reference EClass(source,target)
 */
private pattern mayInRelationeReferences_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEClass_class(problem,interpretation,source);
	find mayInstanceOfEReference_class(problem,interpretation,target);
} or {
	find mustInRelationeReferences_reference_EClass(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eAttributes reference EClass(source,target)
 */
private pattern mustInRelationeAttributes_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eAttributes reference EClass");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eAttributes reference EClass(source,target)
 */
private pattern mayInRelationeAttributes_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEClass_class(problem,interpretation,source);
	find mayInstanceOfEAttribute_class(problem,interpretation,target);
} or {
	find mustInRelationeAttributes_reference_EClass(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eAllContainments reference EClass(source,target)
 */
private pattern mustInRelationeAllContainments_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eAllContainments reference EClass");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eAllContainments reference EClass(source,target)
 */
private pattern mayInRelationeAllContainments_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEClass_class(problem,interpretation,source);
	find mayInstanceOfEReference_class(problem,interpretation,target);
} or {
	find mustInRelationeAllContainments_reference_EClass(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eAllOperations reference EClass(source,target)
 */
private pattern mustInRelationeAllOperations_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eAllOperations reference EClass");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eAllOperations reference EClass(source,target)
 */
private pattern mayInRelationeAllOperations_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEClass_class(problem,interpretation,source);
	find mayInstanceOfEOperation_class(problem,interpretation,target);
} or {
	find mustInRelationeAllOperations_reference_EClass(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eAllStructuralFeatures reference EClass(source,target)
 */
private pattern mustInRelationeAllStructuralFeatures_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eAllStructuralFeatures reference EClass");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eAllStructuralFeatures reference EClass(source,target)
 */
private pattern mayInRelationeAllStructuralFeatures_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEClass_class(problem,interpretation,source);
	find mayInstanceOfEStructuralFeature_class(problem,interpretation,target);
} or {
	find mustInRelationeAllStructuralFeatures_reference_EClass(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eAllSuperTypes reference EClass(source,target)
 */
private pattern mustInRelationeAllSuperTypes_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eAllSuperTypes reference EClass");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eAllSuperTypes reference EClass(source,target)
 */
private pattern mayInRelationeAllSuperTypes_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEClass_class(problem,interpretation,source);
	find mayInstanceOfEClass_class(problem,interpretation,target);
} or {
	find mustInRelationeAllSuperTypes_reference_EClass(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eIDAttribute reference EClass(source,target)
 */
private pattern mustInRelationeIDAttribute_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eIDAttribute reference EClass");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eIDAttribute reference EClass(source,target)
 */
private pattern mayInRelationeIDAttribute_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEClass_class(problem,interpretation,source);
	find mayInstanceOfEAttribute_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationeIDAttribute_reference_EClass(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationeIDAttribute_reference_EClass(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eStructuralFeatures reference EClass(source,target)
 */
private pattern mustInRelationeStructuralFeatures_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eStructuralFeatures reference EClass");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eStructuralFeatures reference EClass(source,target)
 */
private pattern mayInRelationeStructuralFeatures_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEClass_class(problem,interpretation,source);
	find mayInstanceOfEStructuralFeature_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationeContainingClass_reference_EStructuralFeature(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationeStructuralFeatures_reference_EClass(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eGenericSuperTypes reference EClass(source,target)
 */
private pattern mustInRelationeGenericSuperTypes_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eGenericSuperTypes reference EClass");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eGenericSuperTypes reference EClass(source,target)
 */
private pattern mayInRelationeGenericSuperTypes_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEClass_class(problem,interpretation,source);
	find mayInstanceOfEGenericType_class(problem,interpretation,target);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationeGenericSuperTypes_reference_EClass(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eAllGenericSuperTypes reference EClass(source,target)
 */
private pattern mustInRelationeAllGenericSuperTypes_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eAllGenericSuperTypes reference EClass");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eAllGenericSuperTypes reference EClass(source,target)
 */
private pattern mayInRelationeAllGenericSuperTypes_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEClass_class(problem,interpretation,source);
	find mayInstanceOfEGenericType_class(problem,interpretation,target);
} or {
	find mustInRelationeAllGenericSuperTypes_reference_EClass(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []ePackage reference EClassifier(source,target)
 */
private pattern mustInRelationePackage_reference_EClassifier(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"ePackage reference EClassifier");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>ePackage reference EClassifier(source,target)
 */
private pattern mayInRelationePackage_reference_EClassifier(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEClassifier_class(problem,interpretation,source);
	find mayInstanceOfEPackage_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationePackage_reference_EClassifier(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationePackage_reference_EClassifier(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eTypeParameters reference EClassifier(source,target)
 */
private pattern mustInRelationeTypeParameters_reference_EClassifier(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eTypeParameters reference EClassifier");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eTypeParameters reference EClassifier(source,target)
 */
private pattern mayInRelationeTypeParameters_reference_EClassifier(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEClassifier_class(problem,interpretation,source);
	find mayInstanceOfETypeParameter_class(problem,interpretation,target);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationeTypeParameters_reference_EClassifier(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eLiterals reference EEnum(source,target)
 */
private pattern mustInRelationeLiterals_reference_EEnum(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eLiterals reference EEnum");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eLiterals reference EEnum(source,target)
 */
private pattern mayInRelationeLiterals_reference_EEnum(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEEnum_class(problem,interpretation,source);
	find mayInstanceOfEEnumLiteral_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationeEnum_reference_EEnumLiteral(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationeLiterals_reference_EEnum(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eEnum reference EEnumLiteral(source,target)
 */
private pattern mustInRelationeEnum_reference_EEnumLiteral(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eEnum reference EEnumLiteral");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eEnum reference EEnumLiteral(source,target)
 */
private pattern mayInRelationeEnum_reference_EEnumLiteral(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEEnumLiteral_class(problem,interpretation,source);
	find mayInstanceOfEEnum_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationeEnum_reference_EEnumLiteral(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationeEnum_reference_EEnumLiteral(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eAnnotations reference EModelElement(source,target)
 */
private pattern mustInRelationeAnnotations_reference_EModelElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eAnnotations reference EModelElement");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eAnnotations reference EModelElement(source,target)
 */
private pattern mayInRelationeAnnotations_reference_EModelElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEModelElement_class(problem,interpretation,source);
	find mayInstanceOfEAnnotation_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationeModelElement_reference_EAnnotation(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationeAnnotations_reference_EModelElement(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eContainingClass reference EOperation(source,target)
 */
private pattern mustInRelationeContainingClass_reference_EOperation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eContainingClass reference EOperation");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eContainingClass reference EOperation(source,target)
 */
private pattern mayInRelationeContainingClass_reference_EOperation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEOperation_class(problem,interpretation,source);
	find mayInstanceOfEClass_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationeContainingClass_reference_EOperation(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationeContainingClass_reference_EOperation(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eTypeParameters reference EOperation(source,target)
 */
private pattern mustInRelationeTypeParameters_reference_EOperation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eTypeParameters reference EOperation");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eTypeParameters reference EOperation(source,target)
 */
private pattern mayInRelationeTypeParameters_reference_EOperation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEOperation_class(problem,interpretation,source);
	find mayInstanceOfETypeParameter_class(problem,interpretation,target);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationeTypeParameters_reference_EOperation(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eParameters reference EOperation(source,target)
 */
private pattern mustInRelationeParameters_reference_EOperation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eParameters reference EOperation");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eParameters reference EOperation(source,target)
 */
private pattern mayInRelationeParameters_reference_EOperation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEOperation_class(problem,interpretation,source);
	find mayInstanceOfEParameter_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationeOperation_reference_EParameter(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationeParameters_reference_EOperation(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eExceptions reference EOperation(source,target)
 */
private pattern mustInRelationeExceptions_reference_EOperation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eExceptions reference EOperation");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eExceptions reference EOperation(source,target)
 */
private pattern mayInRelationeExceptions_reference_EOperation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEOperation_class(problem,interpretation,source);
	find mayInstanceOfEClassifier_class(problem,interpretation,target);
} or {
	find mustInRelationeExceptions_reference_EOperation(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eGenericExceptions reference EOperation(source,target)
 */
private pattern mustInRelationeGenericExceptions_reference_EOperation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eGenericExceptions reference EOperation");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eGenericExceptions reference EOperation(source,target)
 */
private pattern mayInRelationeGenericExceptions_reference_EOperation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEOperation_class(problem,interpretation,source);
	find mayInstanceOfEGenericType_class(problem,interpretation,target);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationeGenericExceptions_reference_EOperation(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eClassifiers reference EPackage(source,target)
 */
private pattern mustInRelationeClassifiers_reference_EPackage(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eClassifiers reference EPackage");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eClassifiers reference EPackage(source,target)
 */
private pattern mayInRelationeClassifiers_reference_EPackage(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEPackage_class(problem,interpretation,source);
	find mayInstanceOfEClassifier_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationePackage_reference_EClassifier(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationeClassifiers_reference_EPackage(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eSubpackages reference EPackage(source,target)
 */
private pattern mustInRelationeSubpackages_reference_EPackage(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eSubpackages reference EPackage");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eSubpackages reference EPackage(source,target)
 */
private pattern mayInRelationeSubpackages_reference_EPackage(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEPackage_class(problem,interpretation,source);
	find mayInstanceOfEPackage_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationeSuperPackage_reference_EPackage(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationeSubpackages_reference_EPackage(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eSuperPackage reference EPackage(source,target)
 */
private pattern mustInRelationeSuperPackage_reference_EPackage(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eSuperPackage reference EPackage");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eSuperPackage reference EPackage(source,target)
 */
private pattern mayInRelationeSuperPackage_reference_EPackage(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEPackage_class(problem,interpretation,source);
	find mayInstanceOfEPackage_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationeSuperPackage_reference_EPackage(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationeSuperPackage_reference_EPackage(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eOperation reference EParameter(source,target)
 */
private pattern mustInRelationeOperation_reference_EParameter(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eOperation reference EParameter");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eOperation reference EParameter(source,target)
 */
private pattern mayInRelationeOperation_reference_EParameter(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEParameter_class(problem,interpretation,source);
	find mayInstanceOfEOperation_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationeOperation_reference_EParameter(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationeOperation_reference_EParameter(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eOpposite reference EReference(source,target)
 */
private pattern mustInRelationeOpposite_reference_EReference(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eOpposite reference EReference");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eOpposite reference EReference(source,target)
 */
private pattern mayInRelationeOpposite_reference_EReference(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEReference_class(problem,interpretation,source);
	find mayInstanceOfEReference_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationeOpposite_reference_EReference(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationeOpposite_reference_EReference(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eReferenceType reference EReference(source,target)
 */
private pattern mustInRelationeReferenceType_reference_EReference(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eReferenceType reference EReference");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eReferenceType reference EReference(source,target)
 */
private pattern mayInRelationeReferenceType_reference_EReference(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEReference_class(problem,interpretation,source);
	find mayInstanceOfEClass_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationeReferenceType_reference_EReference(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationeReferenceType_reference_EReference(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eKeys reference EReference(source,target)
 */
private pattern mustInRelationeKeys_reference_EReference(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eKeys reference EReference");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eKeys reference EReference(source,target)
 */
private pattern mayInRelationeKeys_reference_EReference(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEReference_class(problem,interpretation,source);
	find mayInstanceOfEAttribute_class(problem,interpretation,target);
} or {
	find mustInRelationeKeys_reference_EReference(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eContainingClass reference EStructuralFeature(source,target)
 */
private pattern mustInRelationeContainingClass_reference_EStructuralFeature(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eContainingClass reference EStructuralFeature");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eContainingClass reference EStructuralFeature(source,target)
 */
private pattern mayInRelationeContainingClass_reference_EStructuralFeature(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEStructuralFeature_class(problem,interpretation,source);
	find mayInstanceOfEClass_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationeContainingClass_reference_EStructuralFeature(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationeContainingClass_reference_EStructuralFeature(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eType reference ETypedElement(source,target)
 */
private pattern mustInRelationeType_reference_ETypedElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eType reference ETypedElement");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eType reference ETypedElement(source,target)
 */
private pattern mayInRelationeType_reference_ETypedElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfETypedElement_class(problem,interpretation,source);
	find mayInstanceOfEClassifier_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationeType_reference_ETypedElement(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationeType_reference_ETypedElement(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eGenericType reference ETypedElement(source,target)
 */
private pattern mustInRelationeGenericType_reference_ETypedElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eGenericType reference ETypedElement");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eGenericType reference ETypedElement(source,target)
 */
private pattern mayInRelationeGenericType_reference_ETypedElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfETypedElement_class(problem,interpretation,source);
	find mayInstanceOfEGenericType_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationeGenericType_reference_ETypedElement(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationeGenericType_reference_ETypedElement(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eUpperBound reference EGenericType(source,target)
 */
private pattern mustInRelationeUpperBound_reference_EGenericType(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eUpperBound reference EGenericType");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eUpperBound reference EGenericType(source,target)
 */
private pattern mayInRelationeUpperBound_reference_EGenericType(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEGenericType_class(problem,interpretation,source);
	find mayInstanceOfEGenericType_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationeUpperBound_reference_EGenericType(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationeUpperBound_reference_EGenericType(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eTypeArguments reference EGenericType(source,target)
 */
private pattern mustInRelationeTypeArguments_reference_EGenericType(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eTypeArguments reference EGenericType");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eTypeArguments reference EGenericType(source,target)
 */
private pattern mayInRelationeTypeArguments_reference_EGenericType(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEGenericType_class(problem,interpretation,source);
	find mayInstanceOfEGenericType_class(problem,interpretation,target);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationeTypeArguments_reference_EGenericType(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eRawType reference EGenericType(source,target)
 */
private pattern mustInRelationeRawType_reference_EGenericType(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eRawType reference EGenericType");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eRawType reference EGenericType(source,target)
 */
private pattern mayInRelationeRawType_reference_EGenericType(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEGenericType_class(problem,interpretation,source);
	find mayInstanceOfEClassifier_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationeRawType_reference_EGenericType(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationeRawType_reference_EGenericType(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eLowerBound reference EGenericType(source,target)
 */
private pattern mustInRelationeLowerBound_reference_EGenericType(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eLowerBound reference EGenericType");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eLowerBound reference EGenericType(source,target)
 */
private pattern mayInRelationeLowerBound_reference_EGenericType(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEGenericType_class(problem,interpretation,source);
	find mayInstanceOfEGenericType_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationeLowerBound_reference_EGenericType(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationeLowerBound_reference_EGenericType(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eTypeParameter reference EGenericType(source,target)
 */
private pattern mustInRelationeTypeParameter_reference_EGenericType(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eTypeParameter reference EGenericType");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eTypeParameter reference EGenericType(source,target)
 */
private pattern mayInRelationeTypeParameter_reference_EGenericType(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEGenericType_class(problem,interpretation,source);
	find mayInstanceOfETypeParameter_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationeTypeParameter_reference_EGenericType(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationeTypeParameter_reference_EGenericType(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eClassifier reference EGenericType(source,target)
 */
private pattern mustInRelationeClassifier_reference_EGenericType(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eClassifier reference EGenericType");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eClassifier reference EGenericType(source,target)
 */
private pattern mayInRelationeClassifier_reference_EGenericType(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEGenericType_class(problem,interpretation,source);
	find mayInstanceOfEClassifier_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationeClassifier_reference_EGenericType(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationeClassifier_reference_EGenericType(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eBounds reference ETypeParameter(source,target)
 */
private pattern mustInRelationeBounds_reference_ETypeParameter(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eBounds reference ETypeParameter");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eBounds reference ETypeParameter(source,target)
 */
private pattern mayInRelationeBounds_reference_ETypeParameter(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfETypeParameter_class(problem,interpretation,source);
	find mayInstanceOfEGenericType_class(problem,interpretation,target);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationeBounds_reference_ETypeParameter(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []iD attribute EAttribute(source,target)
 */
private pattern mustInRelationiD_attribute_EAttribute(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"iD attribute EAttribute");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>iD attribute EAttribute(source,target)
 */
private pattern mayInRelationiD_attribute_EAttribute(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEAttribute_class(problem,interpretation,source);
	BooleanElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationiD_attribute_EAttribute(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationiD_attribute_EAttribute(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []source attribute EAnnotation(source,target)
 */
private pattern mustInRelationsource_attribute_EAnnotation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"source attribute EAnnotation");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>source attribute EAnnotation(source,target)
 */
private pattern mayInRelationsource_attribute_EAnnotation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEAnnotation_class(problem,interpretation,source);
	StringElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationsource_attribute_EAnnotation(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationsource_attribute_EAnnotation(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []abstract attribute EClass(source,target)
 */
private pattern mustInRelationabstract_attribute_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"abstract attribute EClass");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>abstract attribute EClass(source,target)
 */
private pattern mayInRelationabstract_attribute_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEClass_class(problem,interpretation,source);
	BooleanElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationabstract_attribute_EClass(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationabstract_attribute_EClass(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []interface attribute EClass(source,target)
 */
private pattern mustInRelationinterface_attribute_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"interface attribute EClass");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>interface attribute EClass(source,target)
 */
private pattern mayInRelationinterface_attribute_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEClass_class(problem,interpretation,source);
	BooleanElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationinterface_attribute_EClass(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationinterface_attribute_EClass(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []instanceClassName attribute EClassifier(source,target)
 */
private pattern mustInRelationinstanceClassName_attribute_EClassifier(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"instanceClassName attribute EClassifier");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>instanceClassName attribute EClassifier(source,target)
 */
private pattern mayInRelationinstanceClassName_attribute_EClassifier(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEClassifier_class(problem,interpretation,source);
	StringElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationinstanceClassName_attribute_EClassifier(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationinstanceClassName_attribute_EClassifier(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []instanceTypeName attribute EClassifier(source,target)
 */
private pattern mustInRelationinstanceTypeName_attribute_EClassifier(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"instanceTypeName attribute EClassifier");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>instanceTypeName attribute EClassifier(source,target)
 */
private pattern mayInRelationinstanceTypeName_attribute_EClassifier(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEClassifier_class(problem,interpretation,source);
	StringElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationinstanceTypeName_attribute_EClassifier(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationinstanceTypeName_attribute_EClassifier(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []serializable attribute EDataType(source,target)
 */
private pattern mustInRelationserializable_attribute_EDataType(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"serializable attribute EDataType");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>serializable attribute EDataType(source,target)
 */
private pattern mayInRelationserializable_attribute_EDataType(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEDataType_class(problem,interpretation,source);
	BooleanElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationserializable_attribute_EDataType(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationserializable_attribute_EDataType(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []value attribute EEnumLiteral(source,target)
 */
private pattern mustInRelationvalue_attribute_EEnumLiteral(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"value attribute EEnumLiteral");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>value attribute EEnumLiteral(source,target)
 */
private pattern mayInRelationvalue_attribute_EEnumLiteral(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEEnumLiteral_class(problem,interpretation,source);
	IntegerElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationvalue_attribute_EEnumLiteral(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationvalue_attribute_EEnumLiteral(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []literal attribute EEnumLiteral(source,target)
 */
private pattern mustInRelationliteral_attribute_EEnumLiteral(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"literal attribute EEnumLiteral");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>literal attribute EEnumLiteral(source,target)
 */
private pattern mayInRelationliteral_attribute_EEnumLiteral(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEEnumLiteral_class(problem,interpretation,source);
	StringElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationliteral_attribute_EEnumLiteral(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationliteral_attribute_EEnumLiteral(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []name attribute ENamedElement(source,target)
 */
private pattern mustInRelationname_attribute_ENamedElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"name attribute ENamedElement");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>name attribute ENamedElement(source,target)
 */
private pattern mayInRelationname_attribute_ENamedElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfENamedElement_class(problem,interpretation,source);
	StringElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationname_attribute_ENamedElement(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationname_attribute_ENamedElement(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []nsURI attribute EPackage(source,target)
 */
private pattern mustInRelationnsURI_attribute_EPackage(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"nsURI attribute EPackage");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>nsURI attribute EPackage(source,target)
 */
private pattern mayInRelationnsURI_attribute_EPackage(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEPackage_class(problem,interpretation,source);
	StringElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationnsURI_attribute_EPackage(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationnsURI_attribute_EPackage(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []nsPrefix attribute EPackage(source,target)
 */
private pattern mustInRelationnsPrefix_attribute_EPackage(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"nsPrefix attribute EPackage");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>nsPrefix attribute EPackage(source,target)
 */
private pattern mayInRelationnsPrefix_attribute_EPackage(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEPackage_class(problem,interpretation,source);
	StringElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationnsPrefix_attribute_EPackage(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationnsPrefix_attribute_EPackage(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []containment attribute EReference(source,target)
 */
private pattern mustInRelationcontainment_attribute_EReference(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"containment attribute EReference");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>containment attribute EReference(source,target)
 */
private pattern mayInRelationcontainment_attribute_EReference(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEReference_class(problem,interpretation,source);
	BooleanElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationcontainment_attribute_EReference(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationcontainment_attribute_EReference(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []container attribute EReference(source,target)
 */
private pattern mustInRelationcontainer_attribute_EReference(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"container attribute EReference");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>container attribute EReference(source,target)
 */
private pattern mayInRelationcontainer_attribute_EReference(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEReference_class(problem,interpretation,source);
	BooleanElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationcontainer_attribute_EReference(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationcontainer_attribute_EReference(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []resolveProxies attribute EReference(source,target)
 */
private pattern mustInRelationresolveProxies_attribute_EReference(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"resolveProxies attribute EReference");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>resolveProxies attribute EReference(source,target)
 */
private pattern mayInRelationresolveProxies_attribute_EReference(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEReference_class(problem,interpretation,source);
	BooleanElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationresolveProxies_attribute_EReference(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationresolveProxies_attribute_EReference(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []changeable attribute EStructuralFeature(source,target)
 */
private pattern mustInRelationchangeable_attribute_EStructuralFeature(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"changeable attribute EStructuralFeature");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>changeable attribute EStructuralFeature(source,target)
 */
private pattern mayInRelationchangeable_attribute_EStructuralFeature(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEStructuralFeature_class(problem,interpretation,source);
	BooleanElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationchangeable_attribute_EStructuralFeature(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationchangeable_attribute_EStructuralFeature(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []volatile attribute EStructuralFeature(source,target)
 */
private pattern mustInRelationvolatile_attribute_EStructuralFeature(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"volatile attribute EStructuralFeature");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>volatile attribute EStructuralFeature(source,target)
 */
private pattern mayInRelationvolatile_attribute_EStructuralFeature(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEStructuralFeature_class(problem,interpretation,source);
	BooleanElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationvolatile_attribute_EStructuralFeature(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationvolatile_attribute_EStructuralFeature(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []transient attribute EStructuralFeature(source,target)
 */
private pattern mustInRelationtransient_attribute_EStructuralFeature(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"transient attribute EStructuralFeature");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>transient attribute EStructuralFeature(source,target)
 */
private pattern mayInRelationtransient_attribute_EStructuralFeature(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEStructuralFeature_class(problem,interpretation,source);
	BooleanElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationtransient_attribute_EStructuralFeature(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationtransient_attribute_EStructuralFeature(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []defaultValueLiteral attribute EStructuralFeature(source,target)
 */
private pattern mustInRelationdefaultValueLiteral_attribute_EStructuralFeature(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"defaultValueLiteral attribute EStructuralFeature");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>defaultValueLiteral attribute EStructuralFeature(source,target)
 */
private pattern mayInRelationdefaultValueLiteral_attribute_EStructuralFeature(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEStructuralFeature_class(problem,interpretation,source);
	StringElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationdefaultValueLiteral_attribute_EStructuralFeature(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationdefaultValueLiteral_attribute_EStructuralFeature(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []unsettable attribute EStructuralFeature(source,target)
 */
private pattern mustInRelationunsettable_attribute_EStructuralFeature(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"unsettable attribute EStructuralFeature");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>unsettable attribute EStructuralFeature(source,target)
 */
private pattern mayInRelationunsettable_attribute_EStructuralFeature(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEStructuralFeature_class(problem,interpretation,source);
	BooleanElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationunsettable_attribute_EStructuralFeature(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationunsettable_attribute_EStructuralFeature(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []derived attribute EStructuralFeature(source,target)
 */
private pattern mustInRelationderived_attribute_EStructuralFeature(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"derived attribute EStructuralFeature");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>derived attribute EStructuralFeature(source,target)
 */
private pattern mayInRelationderived_attribute_EStructuralFeature(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEStructuralFeature_class(problem,interpretation,source);
	BooleanElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationderived_attribute_EStructuralFeature(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationderived_attribute_EStructuralFeature(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []ordered attribute ETypedElement(source,target)
 */
private pattern mustInRelationordered_attribute_ETypedElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"ordered attribute ETypedElement");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>ordered attribute ETypedElement(source,target)
 */
private pattern mayInRelationordered_attribute_ETypedElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfETypedElement_class(problem,interpretation,source);
	BooleanElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationordered_attribute_ETypedElement(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationordered_attribute_ETypedElement(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []unique attribute ETypedElement(source,target)
 */
private pattern mustInRelationunique_attribute_ETypedElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"unique attribute ETypedElement");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>unique attribute ETypedElement(source,target)
 */
private pattern mayInRelationunique_attribute_ETypedElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfETypedElement_class(problem,interpretation,source);
	BooleanElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationunique_attribute_ETypedElement(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationunique_attribute_ETypedElement(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []lowerBound attribute ETypedElement(source,target)
 */
private pattern mustInRelationlowerBound_attribute_ETypedElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"lowerBound attribute ETypedElement");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>lowerBound attribute ETypedElement(source,target)
 */
private pattern mayInRelationlowerBound_attribute_ETypedElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfETypedElement_class(problem,interpretation,source);
	IntegerElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationlowerBound_attribute_ETypedElement(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationlowerBound_attribute_ETypedElement(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []upperBound attribute ETypedElement(source,target)
 */
private pattern mustInRelationupperBound_attribute_ETypedElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"upperBound attribute ETypedElement");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>upperBound attribute ETypedElement(source,target)
 */
private pattern mayInRelationupperBound_attribute_ETypedElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfETypedElement_class(problem,interpretation,source);
	IntegerElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationupperBound_attribute_ETypedElement(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationupperBound_attribute_ETypedElement(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []many attribute ETypedElement(source,target)
 */
private pattern mustInRelationmany_attribute_ETypedElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"many attribute ETypedElement");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>many attribute ETypedElement(source,target)
 */
private pattern mayInRelationmany_attribute_ETypedElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfETypedElement_class(problem,interpretation,source);
	BooleanElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationmany_attribute_ETypedElement(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationmany_attribute_ETypedElement(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []required attribute ETypedElement(source,target)
 */
private pattern mustInRelationrequired_attribute_ETypedElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"required attribute ETypedElement");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>required attribute ETypedElement(source,target)
 */
private pattern mayInRelationrequired_attribute_ETypedElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfETypedElement_class(problem,interpretation,source);
	BooleanElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationrequired_attribute_ETypedElement(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationrequired_attribute_ETypedElement(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []key attribute EStringToStringMapEntry(source,target)
 */
private pattern mustInRelationkey_attribute_EStringToStringMapEntry(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"key attribute EStringToStringMapEntry");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>key attribute EStringToStringMapEntry(source,target)
 */
private pattern mayInRelationkey_attribute_EStringToStringMapEntry(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEStringToStringMapEntry_class(problem,interpretation,source);
	StringElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationkey_attribute_EStringToStringMapEntry(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationkey_attribute_EStringToStringMapEntry(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []value attribute EStringToStringMapEntry(source,target)
 */
private pattern mustInRelationvalue_attribute_EStringToStringMapEntry(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"value attribute EStringToStringMapEntry");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>value attribute EStringToStringMapEntry(source,target)
 */
private pattern mayInRelationvalue_attribute_EStringToStringMapEntry(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEStringToStringMapEntry_class(problem,interpretation,source);
	StringElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationvalue_attribute_EStringToStringMapEntry(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationvalue_attribute_EStringToStringMapEntry(problem,interpretation,source,target);
}

//////////
// 1.3 Relation Definition Indexers
//////////

//////////
// 1.4 Containment Indexer
//////////
private pattern mustContains2(source: DefinedElement, target: DefinedElement) {
	find mustContains4(_,_,source,target);
}
	
private pattern mustContains4(problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target: DefinedElement)
	{ find mustInRelationdetails_reference_EAnnotation(problem,interpretation,source,target); }or
	
	{ find mustInRelationcontents_reference_EAnnotation(problem,interpretation,source,target); }or
	
	{ find mustInRelationeOperations_reference_EClass(problem,interpretation,source,target); }or
	
	{ find mustInRelationeStructuralFeatures_reference_EClass(problem,interpretation,source,target); }or
	
	{ find mustInRelationeGenericSuperTypes_reference_EClass(problem,interpretation,source,target); }or
	
	{ find mustInRelationeTypeParameters_reference_EClassifier(problem,interpretation,source,target); }or
	
	{ find mustInRelationeLiterals_reference_EEnum(problem,interpretation,source,target); }or
	
	{ find mustInRelationeAnnotations_reference_EModelElement(problem,interpretation,source,target); }or
	
	{ find mustInRelationeTypeParameters_reference_EOperation(problem,interpretation,source,target); }or
	
	{ find mustInRelationeParameters_reference_EOperation(problem,interpretation,source,target); }or
	
	{ find mustInRelationeGenericExceptions_reference_EOperation(problem,interpretation,source,target); }or
	
	{ find mustInRelationeClassifiers_reference_EPackage(problem,interpretation,source,target); }or
	
	{ find mustInRelationeSubpackages_reference_EPackage(problem,interpretation,source,target); }or
	
	{ find mustInRelationeGenericType_reference_ETypedElement(problem,interpretation,source,target); }or
	
	{ find mustInRelationeUpperBound_reference_EGenericType(problem,interpretation,source,target); }or
	
	{ find mustInRelationeTypeArguments_reference_EGenericType(problem,interpretation,source,target); }or
	
	{ find mustInRelationeLowerBound_reference_EGenericType(problem,interpretation,source,target); }or
	
	{ find mustInRelationeBounds_reference_ETypeParameter(problem,interpretation,source,target); }

private pattern mustTransitiveContains(source,target) {
	find mustContains2+(source,target);
}

//////////
// 2. Invalidation Indexers
//////////
// 2.1 Invalidated by WF Queries
//////////

//////////
// 3. Unfinishedness Indexers
//////////
// 3.1 Unfinishedness Measured by Multiplicity
//////////
pattern unfinishedLowerMultiplicity_eAttributeType_reference_EAttribute(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eAttributeType reference EAttribute");
	find mustInstanceOfEAttribute_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationeAttributeType_reference_EAttribute(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_eReferenceType_reference_EReference(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eReferenceType reference EReference");
	find mustInstanceOfEReference_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationeReferenceType_reference_EReference(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_eRawType_reference_EGenericType(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eRawType reference EGenericType");
	find mustInstanceOfEGenericType_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationeRawType_reference_EGenericType(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}

//////////
// 3.2 Unfinishedness Measured by WF Queries
//////////

//////////
// 4. Refinement Indexers
//////////
// 4.1 Object constructors
//////////
private pattern hasElementInContainment(problem:LogicProblem, interpretation:PartialInterpretation)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfEOperation_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfENamedElement_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfEEnumLiteral_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfEGenericType_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfEObject_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfEAttribute_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfEPackage_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfEParameter_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfEDataType_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfEClassifier_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfEStructuralFeature_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfEModelElement_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfEAnnotation_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfETypeParameter_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfEReference_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfEEnum_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfETypedElement_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfEClass_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfEModelElement_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfEModelElement_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfENamedElement_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfENamedElement_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfEPackage_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfEPackage_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}
pattern createObject_EStringToStringMapEntry_class_by_details_reference_EAnnotation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"EStringToStringMapEntry class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"details reference EAnnotation");
	find mustInstanceOfEAnnotation_class(problem,interpretation,container);
	find mayInstanceOfEStringToStringMapEntry_class(problem,interpretation,newObject);
	find mayInRelationdetails_reference_EAnnotation(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_EStringToStringMapEntry_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"EStringToStringMapEntry class");
	find mayInstanceOfEStringToStringMapEntry_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_EGenericType_class_by_eGenericSuperTypes_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"EGenericType class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"eGenericSuperTypes reference EClass");
	find mustInstanceOfEClass_class(problem,interpretation,container);
	find mayInstanceOfEGenericType_class(problem,interpretation,newObject);
	find mayInRelationeGenericSuperTypes_reference_EClass(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_EGenericType_class_by_eGenericExceptions_reference_EOperation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"EGenericType class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"eGenericExceptions reference EOperation");
	find mustInstanceOfEOperation_class(problem,interpretation,container);
	find mayInstanceOfEGenericType_class(problem,interpretation,newObject);
	find mayInRelationeGenericExceptions_reference_EOperation(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_EGenericType_class_by_eGenericType_reference_ETypedElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"EGenericType class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"eGenericType reference ETypedElement");
	find mustInstanceOfETypedElement_class(problem,interpretation,container);
	find mayInstanceOfEGenericType_class(problem,interpretation,newObject);
	find mayInRelationeGenericType_reference_ETypedElement(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_EGenericType_class_by_eUpperBound_reference_EGenericType(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"EGenericType class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"eUpperBound reference EGenericType");
	find mustInstanceOfEGenericType_class(problem,interpretation,container);
	find mayInstanceOfEGenericType_class(problem,interpretation,newObject);
	find mayInRelationeUpperBound_reference_EGenericType(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_EGenericType_class_by_eTypeArguments_reference_EGenericType(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"EGenericType class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"eTypeArguments reference EGenericType");
	find mustInstanceOfEGenericType_class(problem,interpretation,container);
	find mayInstanceOfEGenericType_class(problem,interpretation,newObject);
	find mayInRelationeTypeArguments_reference_EGenericType(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_EGenericType_class_by_eLowerBound_reference_EGenericType(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"EGenericType class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"eLowerBound reference EGenericType");
	find mustInstanceOfEGenericType_class(problem,interpretation,container);
	find mayInstanceOfEGenericType_class(problem,interpretation,newObject);
	find mayInRelationeLowerBound_reference_EGenericType(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_EGenericType_class_by_eBounds_reference_ETypeParameter(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"EGenericType class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"eBounds reference ETypeParameter");
	find mustInstanceOfETypeParameter_class(problem,interpretation,container);
	find mayInstanceOfEGenericType_class(problem,interpretation,newObject);
	find mayInRelationeBounds_reference_ETypeParameter(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_EGenericType_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"EGenericType class");
	find mayInstanceOfEGenericType_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_EEnumLiteral_class_by_eLiterals_reference_EEnum_with_eEnum_reference_EEnumLiteral(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"EEnumLiteral class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"eLiterals reference EEnum");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"eEnum reference EEnumLiteral");
	find mustInstanceOfEEnum_class(problem,interpretation,container);
	find mayInstanceOfEEnumLiteral_class(problem,interpretation,newObject);
	find mayInRelationeLiterals_reference_EEnum(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_EEnumLiteral_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"EEnumLiteral class");
	find mayInstanceOfEEnumLiteral_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_ETypeParameter_class_by_eTypeParameters_reference_EClassifier(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"ETypeParameter class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"eTypeParameters reference EClassifier");
	find mustInstanceOfEClassifier_class(problem,interpretation,container);
	find mayInstanceOfETypeParameter_class(problem,interpretation,newObject);
	find mayInRelationeTypeParameters_reference_EClassifier(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_ETypeParameter_class_by_eTypeParameters_reference_EOperation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"ETypeParameter class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"eTypeParameters reference EOperation");
	find mustInstanceOfEOperation_class(problem,interpretation,container);
	find mayInstanceOfETypeParameter_class(problem,interpretation,newObject);
	find mayInRelationeTypeParameters_reference_EOperation(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_ETypeParameter_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"ETypeParameter class");
	find mayInstanceOfETypeParameter_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_EAttribute_class_by_eStructuralFeatures_reference_EClass_with_eContainingClass_reference_EStructuralFeature(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"EAttribute class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"eStructuralFeatures reference EClass");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"eContainingClass reference EStructuralFeature");
	find mustInstanceOfEClass_class(problem,interpretation,container);
	find mayInstanceOfEAttribute_class(problem,interpretation,newObject);
	find mayInRelationeStructuralFeatures_reference_EClass(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_EAttribute_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"EAttribute class");
	find mayInstanceOfEAttribute_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_EClass_class_by_eClassifiers_reference_EPackage_with_ePackage_reference_EClassifier(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"EClass class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"eClassifiers reference EPackage");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"ePackage reference EClassifier");
	find mustInstanceOfEPackage_class(problem,interpretation,container);
	find mayInstanceOfEClass_class(problem,interpretation,newObject);
	find mayInRelationeClassifiers_reference_EPackage(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_EClass_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"EClass class");
	find mayInstanceOfEClass_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_EDataType_class_by_eClassifiers_reference_EPackage_with_ePackage_reference_EClassifier(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"EDataType class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"eClassifiers reference EPackage");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"ePackage reference EClassifier");
	find mustInstanceOfEPackage_class(problem,interpretation,container);
	find mayInstanceOfEDataType_class(problem,interpretation,newObject);
	find mayInRelationeClassifiers_reference_EPackage(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_EDataType_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"EDataType class");
	find mayInstanceOfEDataType_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_EOperation_class_by_eOperations_reference_EClass_with_eContainingClass_reference_EOperation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"EOperation class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"eOperations reference EClass");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"eContainingClass reference EOperation");
	find mustInstanceOfEClass_class(problem,interpretation,container);
	find mayInstanceOfEOperation_class(problem,interpretation,newObject);
	find mayInRelationeOperations_reference_EClass(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_EOperation_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"EOperation class");
	find mayInstanceOfEOperation_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_EAnnotation_class_by_eAnnotations_reference_EModelElement_with_eModelElement_reference_EAnnotation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"EAnnotation class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"eAnnotations reference EModelElement");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"eModelElement reference EAnnotation");
	find mustInstanceOfEModelElement_class(problem,interpretation,container);
	find mayInstanceOfEAnnotation_class(problem,interpretation,newObject);
	find mayInRelationeAnnotations_reference_EModelElement(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_EAnnotation_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"EAnnotation class");
	find mayInstanceOfEAnnotation_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_EParameter_class_by_eParameters_reference_EOperation_with_eOperation_reference_EParameter(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"EParameter class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"eParameters reference EOperation");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"eOperation reference EParameter");
	find mustInstanceOfEOperation_class(problem,interpretation,container);
	find mayInstanceOfEParameter_class(problem,interpretation,newObject);
	find mayInRelationeParameters_reference_EOperation(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_EParameter_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"EParameter class");
	find mayInstanceOfEParameter_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_EObject_class_by_contents_reference_EAnnotation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"EObject class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"contents reference EAnnotation");
	find mustInstanceOfEAnnotation_class(problem,interpretation,container);
	find mayInstanceOfEObject_class(problem,interpretation,newObject);
	find mayInRelationcontents_reference_EAnnotation(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_EObject_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"EObject class");
	find mayInstanceOfEObject_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_EReference_class_by_eStructuralFeatures_reference_EClass_with_eContainingClass_reference_EStructuralFeature(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"EReference class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"eStructuralFeatures reference EClass");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"eContainingClass reference EStructuralFeature");
	find mustInstanceOfEClass_class(problem,interpretation,container);
	find mayInstanceOfEReference_class(problem,interpretation,newObject);
	find mayInRelationeStructuralFeatures_reference_EClass(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_EReference_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"EReference class");
	find mayInstanceOfEReference_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_EEnum_class_by_eClassifiers_reference_EPackage_with_ePackage_reference_EClassifier(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"EEnum class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"eClassifiers reference EPackage");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"ePackage reference EClassifier");
	find mustInstanceOfEPackage_class(problem,interpretation,container);
	find mayInstanceOfEEnum_class(problem,interpretation,newObject);
	find mayInRelationeClassifiers_reference_EPackage(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_EEnum_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"EEnum class");
	find mayInstanceOfEEnum_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_EPackage_class_UndefinedPart_by_eSubpackages_reference_EPackage_with_eSuperPackage_reference_EPackage(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"EPackage class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"eSubpackages reference EPackage");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"eSuperPackage reference EPackage");
	find mustInstanceOfEPackage_class(problem,interpretation,container);
	find mayInstanceOfEPackage_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationeSubpackages_reference_EPackage(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_EPackage_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"EPackage class UndefinedPart");
	find mayInstanceOfEPackage_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}

//////////
// 4.2 Type refinement
//////////
pattern refineTypeTo_EStringToStringMapEntry_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEModelElement_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
}
pattern refineTypeTo_EGenericType_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEModelElement_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
}
pattern refineTypeTo_EEnumLiteral_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfEEnumLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEEnumLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfEPackage_class(problem,interpretation,element);
	neg find mustInstanceOfETypeParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEClassifier_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfETypedElement_class(problem,interpretation,element);
}
pattern refineTypeTo_ETypeParameter_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfETypeParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEPackage_class(problem,interpretation,element);
	neg find mustInstanceOfEEnumLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfETypeParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEClassifier_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfETypedElement_class(problem,interpretation,element);
}
pattern refineTypeTo_EAttribute_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfEAttribute_class(problem,interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEOperation_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEEnumLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfEPackage_class(problem,interpretation,element);
	neg find mustInstanceOfETypeParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEClassifier_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfEReference_class(problem,interpretation,element);
	neg find mustInstanceOfEAttribute_class(problem,interpretation,element);
}
pattern refineTypeTo_EClass_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfEClass_class(problem,interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEDataType_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEEnumLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfEPackage_class(problem,interpretation,element);
	neg find mustInstanceOfETypeParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfETypedElement_class(problem,interpretation,element);
	neg find mustInstanceOfEClass_class(problem,interpretation,element);
}
pattern refineTypeTo_EDataType_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfEDataType_class(problem,interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEDataType_class(problem,interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEEnumLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfEPackage_class(problem,interpretation,element);
	neg find mustInstanceOfETypeParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfEEnum_class(problem,interpretation,element);
	neg find mustInstanceOfETypedElement_class(problem,interpretation,element);
	neg find mustInstanceOfEClass_class(problem,interpretation,element);
}
pattern refineTypeTo_EOperation_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfEOperation_class(problem,interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEOperation_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEPackage_class(problem,interpretation,element);
	neg find mustInstanceOfEEnumLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfETypeParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEClassifier_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfEStructuralFeature_class(problem,interpretation,element);
}
pattern refineTypeTo_EAnnotation_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfENamedElement_class(problem,interpretation,element);
}
pattern refineTypeTo_EParameter_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfEParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEOperation_class(problem,interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEEnumLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfEPackage_class(problem,interpretation,element);
	neg find mustInstanceOfETypeParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEClassifier_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfEStructuralFeature_class(problem,interpretation,element);
}
pattern refineTypeTo_EObject_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEModelElement_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
}
pattern refineTypeTo_EReference_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfEReference_class(problem,interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEOperation_class(problem,interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEEnumLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfEPackage_class(problem,interpretation,element);
	neg find mustInstanceOfETypeParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEClassifier_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfEReference_class(problem,interpretation,element);
	neg find mustInstanceOfEAttribute_class(problem,interpretation,element);
}
pattern refineTypeTo_EEnum_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfEEnum_class(problem,interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEPackage_class(problem,interpretation,element);
	neg find mustInstanceOfEEnumLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfETypeParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfEEnum_class(problem,interpretation,element);
	neg find mustInstanceOfETypedElement_class(problem,interpretation,element);
	neg find mustInstanceOfEClass_class(problem,interpretation,element);
}
pattern refineTypeTo_EPackage_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfEPackage_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEEnumLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfETypeParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEClassifier_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfETypedElement_class(problem,interpretation,element);
	neg find mustInstanceOfEPackage_class_UndefinedPart(problem,interpretation,element);
}

//////////
// 4.3 Relation refinement
//////////
pattern refineRelation_eAttributeType_reference_EAttribute(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eAttributeType reference EAttribute");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEAttribute_class(problem,interpretation,from);
	find mustInstanceOfEDataType_class(problem,interpretation,to);
	find mayInRelationeAttributeType_reference_EAttribute(problem,interpretation,from,to);
	neg find mustInRelationeAttributeType_reference_EAttribute(problem,interpretation,from,to);
}
pattern refineRelation_references_reference_EAnnotation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"references reference EAnnotation");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEAnnotation_class(problem,interpretation,from);
	find mustInstanceOfEObject_class(problem,interpretation,to);
	find mayInRelationreferences_reference_EAnnotation(problem,interpretation,from,to);
	neg find mustInRelationreferences_reference_EAnnotation(problem,interpretation,from,to);
}
pattern refineRelation_eSuperTypes_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eSuperTypes reference EClass");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEClass_class(problem,interpretation,from);
	find mustInstanceOfEClass_class(problem,interpretation,to);
	find mayInRelationeSuperTypes_reference_EClass(problem,interpretation,from,to);
	neg find mustInRelationeSuperTypes_reference_EClass(problem,interpretation,from,to);
}
pattern refineRelation_eAllAttributes_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eAllAttributes reference EClass");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEClass_class(problem,interpretation,from);
	find mustInstanceOfEAttribute_class(problem,interpretation,to);
	find mayInRelationeAllAttributes_reference_EClass(problem,interpretation,from,to);
	neg find mustInRelationeAllAttributes_reference_EClass(problem,interpretation,from,to);
}
pattern refineRelation_eAllReferences_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eAllReferences reference EClass");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEClass_class(problem,interpretation,from);
	find mustInstanceOfEReference_class(problem,interpretation,to);
	find mayInRelationeAllReferences_reference_EClass(problem,interpretation,from,to);
	neg find mustInRelationeAllReferences_reference_EClass(problem,interpretation,from,to);
}
pattern refineRelation_eReferences_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eReferences reference EClass");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEClass_class(problem,interpretation,from);
	find mustInstanceOfEReference_class(problem,interpretation,to);
	find mayInRelationeReferences_reference_EClass(problem,interpretation,from,to);
	neg find mustInRelationeReferences_reference_EClass(problem,interpretation,from,to);
}
pattern refineRelation_eAttributes_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eAttributes reference EClass");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEClass_class(problem,interpretation,from);
	find mustInstanceOfEAttribute_class(problem,interpretation,to);
	find mayInRelationeAttributes_reference_EClass(problem,interpretation,from,to);
	neg find mustInRelationeAttributes_reference_EClass(problem,interpretation,from,to);
}
pattern refineRelation_eAllContainments_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eAllContainments reference EClass");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEClass_class(problem,interpretation,from);
	find mustInstanceOfEReference_class(problem,interpretation,to);
	find mayInRelationeAllContainments_reference_EClass(problem,interpretation,from,to);
	neg find mustInRelationeAllContainments_reference_EClass(problem,interpretation,from,to);
}
pattern refineRelation_eAllOperations_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eAllOperations reference EClass");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEClass_class(problem,interpretation,from);
	find mustInstanceOfEOperation_class(problem,interpretation,to);
	find mayInRelationeAllOperations_reference_EClass(problem,interpretation,from,to);
	neg find mustInRelationeAllOperations_reference_EClass(problem,interpretation,from,to);
}
pattern refineRelation_eAllStructuralFeatures_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eAllStructuralFeatures reference EClass");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEClass_class(problem,interpretation,from);
	find mustInstanceOfEStructuralFeature_class(problem,interpretation,to);
	find mayInRelationeAllStructuralFeatures_reference_EClass(problem,interpretation,from,to);
	neg find mustInRelationeAllStructuralFeatures_reference_EClass(problem,interpretation,from,to);
}
pattern refineRelation_eAllSuperTypes_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eAllSuperTypes reference EClass");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEClass_class(problem,interpretation,from);
	find mustInstanceOfEClass_class(problem,interpretation,to);
	find mayInRelationeAllSuperTypes_reference_EClass(problem,interpretation,from,to);
	neg find mustInRelationeAllSuperTypes_reference_EClass(problem,interpretation,from,to);
}
pattern refineRelation_eIDAttribute_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eIDAttribute reference EClass");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEClass_class(problem,interpretation,from);
	find mustInstanceOfEAttribute_class(problem,interpretation,to);
	find mayInRelationeIDAttribute_reference_EClass(problem,interpretation,from,to);
	neg find mustInRelationeIDAttribute_reference_EClass(problem,interpretation,from,to);
}
pattern refineRelation_eAllGenericSuperTypes_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eAllGenericSuperTypes reference EClass");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEClass_class(problem,interpretation,from);
	find mustInstanceOfEGenericType_class(problem,interpretation,to);
	find mayInRelationeAllGenericSuperTypes_reference_EClass(problem,interpretation,from,to);
	neg find mustInRelationeAllGenericSuperTypes_reference_EClass(problem,interpretation,from,to);
}
pattern refineRelation_eExceptions_reference_EOperation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eExceptions reference EOperation");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEOperation_class(problem,interpretation,from);
	find mustInstanceOfEClassifier_class(problem,interpretation,to);
	find mayInRelationeExceptions_reference_EOperation(problem,interpretation,from,to);
	neg find mustInRelationeExceptions_reference_EOperation(problem,interpretation,from,to);
}
pattern refineRelation_eOpposite_reference_EReference(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eOpposite reference EReference");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEReference_class(problem,interpretation,from);
	find mustInstanceOfEReference_class(problem,interpretation,to);
	find mayInRelationeOpposite_reference_EReference(problem,interpretation,from,to);
	neg find mustInRelationeOpposite_reference_EReference(problem,interpretation,from,to);
}
pattern refineRelation_eReferenceType_reference_EReference(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eReferenceType reference EReference");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEReference_class(problem,interpretation,from);
	find mustInstanceOfEClass_class(problem,interpretation,to);
	find mayInRelationeReferenceType_reference_EReference(problem,interpretation,from,to);
	neg find mustInRelationeReferenceType_reference_EReference(problem,interpretation,from,to);
}
pattern refineRelation_eKeys_reference_EReference(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eKeys reference EReference");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEReference_class(problem,interpretation,from);
	find mustInstanceOfEAttribute_class(problem,interpretation,to);
	find mayInRelationeKeys_reference_EReference(problem,interpretation,from,to);
	neg find mustInRelationeKeys_reference_EReference(problem,interpretation,from,to);
}
pattern refineRelation_eType_reference_ETypedElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eType reference ETypedElement");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfETypedElement_class(problem,interpretation,from);
	find mustInstanceOfEClassifier_class(problem,interpretation,to);
	find mayInRelationeType_reference_ETypedElement(problem,interpretation,from,to);
	neg find mustInRelationeType_reference_ETypedElement(problem,interpretation,from,to);
}
pattern refineRelation_eRawType_reference_EGenericType(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eRawType reference EGenericType");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEGenericType_class(problem,interpretation,from);
	find mustInstanceOfEClassifier_class(problem,interpretation,to);
	find mayInRelationeRawType_reference_EGenericType(problem,interpretation,from,to);
	neg find mustInRelationeRawType_reference_EGenericType(problem,interpretation,from,to);
}
pattern refineRelation_eTypeParameter_reference_EGenericType(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eTypeParameter reference EGenericType");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEGenericType_class(problem,interpretation,from);
	find mustInstanceOfETypeParameter_class(problem,interpretation,to);
	find mayInRelationeTypeParameter_reference_EGenericType(problem,interpretation,from,to);
	neg find mustInRelationeTypeParameter_reference_EGenericType(problem,interpretation,from,to);
}
pattern refineRelation_eClassifier_reference_EGenericType(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eClassifier reference EGenericType");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEGenericType_class(problem,interpretation,from);
	find mustInstanceOfEClassifier_class(problem,interpretation,to);
	find mayInRelationeClassifier_reference_EGenericType(problem,interpretation,from,to);
	neg find mustInRelationeClassifier_reference_EGenericType(problem,interpretation,from,to);
}
pattern refineRelation_iD_attribute_EAttribute(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"iD attribute EAttribute");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEAttribute_class(problem,interpretation,from);
	BooleanElement(to);
	find mayInRelationiD_attribute_EAttribute(problem,interpretation,from,to);
	neg find mustInRelationiD_attribute_EAttribute(problem,interpretation,from,to);
}
pattern refineRelation_source_attribute_EAnnotation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"source attribute EAnnotation");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEAnnotation_class(problem,interpretation,from);
	StringElement(to);
	find mayInRelationsource_attribute_EAnnotation(problem,interpretation,from,to);
	neg find mustInRelationsource_attribute_EAnnotation(problem,interpretation,from,to);
}
pattern refineRelation_abstract_attribute_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"abstract attribute EClass");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEClass_class(problem,interpretation,from);
	BooleanElement(to);
	find mayInRelationabstract_attribute_EClass(problem,interpretation,from,to);
	neg find mustInRelationabstract_attribute_EClass(problem,interpretation,from,to);
}
pattern refineRelation_interface_attribute_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"interface attribute EClass");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEClass_class(problem,interpretation,from);
	BooleanElement(to);
	find mayInRelationinterface_attribute_EClass(problem,interpretation,from,to);
	neg find mustInRelationinterface_attribute_EClass(problem,interpretation,from,to);
}
pattern refineRelation_instanceClassName_attribute_EClassifier(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"instanceClassName attribute EClassifier");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEClassifier_class(problem,interpretation,from);
	StringElement(to);
	find mayInRelationinstanceClassName_attribute_EClassifier(problem,interpretation,from,to);
	neg find mustInRelationinstanceClassName_attribute_EClassifier(problem,interpretation,from,to);
}
pattern refineRelation_instanceTypeName_attribute_EClassifier(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"instanceTypeName attribute EClassifier");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEClassifier_class(problem,interpretation,from);
	StringElement(to);
	find mayInRelationinstanceTypeName_attribute_EClassifier(problem,interpretation,from,to);
	neg find mustInRelationinstanceTypeName_attribute_EClassifier(problem,interpretation,from,to);
}
pattern refineRelation_serializable_attribute_EDataType(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"serializable attribute EDataType");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEDataType_class(problem,interpretation,from);
	BooleanElement(to);
	find mayInRelationserializable_attribute_EDataType(problem,interpretation,from,to);
	neg find mustInRelationserializable_attribute_EDataType(problem,interpretation,from,to);
}
pattern refineRelation_value_attribute_EEnumLiteral(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"value attribute EEnumLiteral");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEEnumLiteral_class(problem,interpretation,from);
	IntegerElement(to);
	find mayInRelationvalue_attribute_EEnumLiteral(problem,interpretation,from,to);
	neg find mustInRelationvalue_attribute_EEnumLiteral(problem,interpretation,from,to);
}
pattern refineRelation_literal_attribute_EEnumLiteral(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"literal attribute EEnumLiteral");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEEnumLiteral_class(problem,interpretation,from);
	StringElement(to);
	find mayInRelationliteral_attribute_EEnumLiteral(problem,interpretation,from,to);
	neg find mustInRelationliteral_attribute_EEnumLiteral(problem,interpretation,from,to);
}
pattern refineRelation_name_attribute_ENamedElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"name attribute ENamedElement");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfENamedElement_class(problem,interpretation,from);
	StringElement(to);
	find mayInRelationname_attribute_ENamedElement(problem,interpretation,from,to);
	neg find mustInRelationname_attribute_ENamedElement(problem,interpretation,from,to);
}
pattern refineRelation_nsURI_attribute_EPackage(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"nsURI attribute EPackage");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEPackage_class(problem,interpretation,from);
	StringElement(to);
	find mayInRelationnsURI_attribute_EPackage(problem,interpretation,from,to);
	neg find mustInRelationnsURI_attribute_EPackage(problem,interpretation,from,to);
}
pattern refineRelation_nsPrefix_attribute_EPackage(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"nsPrefix attribute EPackage");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEPackage_class(problem,interpretation,from);
	StringElement(to);
	find mayInRelationnsPrefix_attribute_EPackage(problem,interpretation,from,to);
	neg find mustInRelationnsPrefix_attribute_EPackage(problem,interpretation,from,to);
}
pattern refineRelation_containment_attribute_EReference(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"containment attribute EReference");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEReference_class(problem,interpretation,from);
	BooleanElement(to);
	find mayInRelationcontainment_attribute_EReference(problem,interpretation,from,to);
	neg find mustInRelationcontainment_attribute_EReference(problem,interpretation,from,to);
}
pattern refineRelation_container_attribute_EReference(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"container attribute EReference");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEReference_class(problem,interpretation,from);
	BooleanElement(to);
	find mayInRelationcontainer_attribute_EReference(problem,interpretation,from,to);
	neg find mustInRelationcontainer_attribute_EReference(problem,interpretation,from,to);
}
pattern refineRelation_resolveProxies_attribute_EReference(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"resolveProxies attribute EReference");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEReference_class(problem,interpretation,from);
	BooleanElement(to);
	find mayInRelationresolveProxies_attribute_EReference(problem,interpretation,from,to);
	neg find mustInRelationresolveProxies_attribute_EReference(problem,interpretation,from,to);
}
pattern refineRelation_changeable_attribute_EStructuralFeature(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"changeable attribute EStructuralFeature");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEStructuralFeature_class(problem,interpretation,from);
	BooleanElement(to);
	find mayInRelationchangeable_attribute_EStructuralFeature(problem,interpretation,from,to);
	neg find mustInRelationchangeable_attribute_EStructuralFeature(problem,interpretation,from,to);
}
pattern refineRelation_volatile_attribute_EStructuralFeature(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"volatile attribute EStructuralFeature");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEStructuralFeature_class(problem,interpretation,from);
	BooleanElement(to);
	find mayInRelationvolatile_attribute_EStructuralFeature(problem,interpretation,from,to);
	neg find mustInRelationvolatile_attribute_EStructuralFeature(problem,interpretation,from,to);
}
pattern refineRelation_transient_attribute_EStructuralFeature(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"transient attribute EStructuralFeature");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEStructuralFeature_class(problem,interpretation,from);
	BooleanElement(to);
	find mayInRelationtransient_attribute_EStructuralFeature(problem,interpretation,from,to);
	neg find mustInRelationtransient_attribute_EStructuralFeature(problem,interpretation,from,to);
}
pattern refineRelation_defaultValueLiteral_attribute_EStructuralFeature(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"defaultValueLiteral attribute EStructuralFeature");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEStructuralFeature_class(problem,interpretation,from);
	StringElement(to);
	find mayInRelationdefaultValueLiteral_attribute_EStructuralFeature(problem,interpretation,from,to);
	neg find mustInRelationdefaultValueLiteral_attribute_EStructuralFeature(problem,interpretation,from,to);
}
pattern refineRelation_unsettable_attribute_EStructuralFeature(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"unsettable attribute EStructuralFeature");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEStructuralFeature_class(problem,interpretation,from);
	BooleanElement(to);
	find mayInRelationunsettable_attribute_EStructuralFeature(problem,interpretation,from,to);
	neg find mustInRelationunsettable_attribute_EStructuralFeature(problem,interpretation,from,to);
}
pattern refineRelation_derived_attribute_EStructuralFeature(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"derived attribute EStructuralFeature");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEStructuralFeature_class(problem,interpretation,from);
	BooleanElement(to);
	find mayInRelationderived_attribute_EStructuralFeature(problem,interpretation,from,to);
	neg find mustInRelationderived_attribute_EStructuralFeature(problem,interpretation,from,to);
}
pattern refineRelation_ordered_attribute_ETypedElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"ordered attribute ETypedElement");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfETypedElement_class(problem,interpretation,from);
	BooleanElement(to);
	find mayInRelationordered_attribute_ETypedElement(problem,interpretation,from,to);
	neg find mustInRelationordered_attribute_ETypedElement(problem,interpretation,from,to);
}
pattern refineRelation_unique_attribute_ETypedElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"unique attribute ETypedElement");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfETypedElement_class(problem,interpretation,from);
	BooleanElement(to);
	find mayInRelationunique_attribute_ETypedElement(problem,interpretation,from,to);
	neg find mustInRelationunique_attribute_ETypedElement(problem,interpretation,from,to);
}
pattern refineRelation_lowerBound_attribute_ETypedElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"lowerBound attribute ETypedElement");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfETypedElement_class(problem,interpretation,from);
	IntegerElement(to);
	find mayInRelationlowerBound_attribute_ETypedElement(problem,interpretation,from,to);
	neg find mustInRelationlowerBound_attribute_ETypedElement(problem,interpretation,from,to);
}
pattern refineRelation_upperBound_attribute_ETypedElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"upperBound attribute ETypedElement");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfETypedElement_class(problem,interpretation,from);
	IntegerElement(to);
	find mayInRelationupperBound_attribute_ETypedElement(problem,interpretation,from,to);
	neg find mustInRelationupperBound_attribute_ETypedElement(problem,interpretation,from,to);
}
pattern refineRelation_many_attribute_ETypedElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"many attribute ETypedElement");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfETypedElement_class(problem,interpretation,from);
	BooleanElement(to);
	find mayInRelationmany_attribute_ETypedElement(problem,interpretation,from,to);
	neg find mustInRelationmany_attribute_ETypedElement(problem,interpretation,from,to);
}
pattern refineRelation_required_attribute_ETypedElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"required attribute ETypedElement");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfETypedElement_class(problem,interpretation,from);
	BooleanElement(to);
	find mayInRelationrequired_attribute_ETypedElement(problem,interpretation,from,to);
	neg find mustInRelationrequired_attribute_ETypedElement(problem,interpretation,from,to);
}
pattern refineRelation_key_attribute_EStringToStringMapEntry(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"key attribute EStringToStringMapEntry");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,from);
	StringElement(to);
	find mayInRelationkey_attribute_EStringToStringMapEntry(problem,interpretation,from,to);
	neg find mustInRelationkey_attribute_EStringToStringMapEntry(problem,interpretation,from,to);
}
pattern refineRelation_value_attribute_EStringToStringMapEntry(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"value attribute EStringToStringMapEntry");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,from);
	StringElement(to);
	find mayInRelationvalue_attribute_EStringToStringMapEntry(problem,interpretation,from,to);
	neg find mustInRelationvalue_attribute_EStringToStringMapEntry(problem,interpretation,from,to);
}
import epackage "http://www.bme.hu/mit/inf/dslreasoner/viatrasolver/partialinterpretationlanguage"
import epackage "http://www.bme.hu/mit/inf/dslreasoner/logic/model/problem"
import epackage "http://www.bme.hu/mit/inf/dslreasoner/logic/model/language"

//////////
// 0. Util
//////////
private pattern interpretation(problem:LogicProblem, interpretation:PartialInterpretation) {
	PartialInterpretation.problem(interpretation,problem);
}
	
/////////////////////////
// 0.1 Existence
/////////////////////////
private pattern mustExist(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	find interpretation(problem,interpretation);
	LogicProblem.elements(problem,element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
}

private pattern mayExist(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
    find mustExist(problem,interpretation,element);
} or {
    find interpretation(problem,interpretation);
    neg find elementCloseWorld(element);
    PartialInterpretation.openWorldElements(interpretation,element);
}

private pattern elementCloseWorld(element:DefinedElement) {
	PartialInterpretation.openWorldElements(i,element);
    PartialInterpretation.maxNewElements(i,0);
} or {
	Scope.targetTypeInterpretation(scope,interpretation);
	PartialTypeInterpratation.elements(interpretation,element);
	Scope.maxNewElements(scope,0);
}

////////////////////////
// 0.2 Equivalence
////////////////////////
pattern mayEquivalent(problem:LogicProblem, interpretation:PartialInterpretation, a: DefinedElement, b: DefinedElement) {
	find mayExist(problem,interpretation,a);
	find mayExist(problem,interpretation,b);
	a == b;
}

////////////////////////
// 0.3 Required Patterns by TypeIndexer
////////////////////////
private pattern typeInterpretation(problem:LogicProblem, interpretation:PartialInterpretation, type:TypeDeclaration, typeInterpretation:PartialComplexTypeInterpretation) {
	find interpretation(problem,interpretation);
	LogicProblem.types(problem,type);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
}

private pattern directInstanceOf(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement, type:Type) {
	find interpretation(problem,interpretation);
	LogicProblem.types(problem,type);
	TypeDefinition.elements(type,element);
} or {
	find interpretation(problem,interpretation);
	find typeInterpretation(problem,interpretation,type,typeInterpretation);
	PartialComplexTypeInterpretation.elements(typeInterpretation,element);
}

private pattern isPrimitive(element: PrimitiveElement) {
	PrimitiveElement(element);
}

//////////
// 1. Problem-Specific Base Indexers
//////////
// 1.1 Type Indexers
//////////
// 1.1.1 primitive Type Indexers
//////////

//////////
// 1.1.2 domain-specific Type Indexers
//////////
/**
 * An element must be an instance of type "EAttribute class".
 */
private pattern mustInstanceOfEAttribute_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"EAttribute class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewEAttribute_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"EAttribute class");
}

/**
 * An element may be an instance of type "EAttribute class".
 */
private pattern mayInstanceOfEAttribute_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfEPackage_class(problem,interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfETypeParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEReference_class(problem,interpretation,element);
	neg find mustInstanceOfEOperation_class(problem,interpretation,element);
	neg find mustInstanceOfEClassifier_class(problem,interpretation,element);
	neg find mustInstanceOfEEnumLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find scopeDisallowsNewEAttribute_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfEPackage_class(problem,interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfETypeParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEReference_class(problem,interpretation,element);
	neg find mustInstanceOfEOperation_class(problem,interpretation,element);
	neg find mustInstanceOfEClassifier_class(problem,interpretation,element);
	neg find mustInstanceOfEEnumLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find scopeDisallowsNewEAttribute_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfEAttribute_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "EAnnotation class".
 */
private pattern mustInstanceOfEAnnotation_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"EAnnotation class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewEAnnotation_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"EAnnotation class");
}

/**
 * An element may be an instance of type "EAnnotation class".
 */
private pattern mayInstanceOfEAnnotation_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfENamedElement_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find scopeDisallowsNewEAnnotation_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfENamedElement_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find scopeDisallowsNewEAnnotation_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfEAnnotation_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "EClass class".
 */
private pattern mustInstanceOfEClass_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"EClass class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewEClass_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"EClass class");
}

/**
 * An element may be an instance of type "EClass class".
 */
private pattern mayInstanceOfEClass_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEPackage_class(problem,interpretation,element);
	neg find mustInstanceOfETypedElement_class(problem,interpretation,element);
	neg find mustInstanceOfEDataType_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfETypeParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEEnumLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find scopeDisallowsNewEClass_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEPackage_class(problem,interpretation,element);
	neg find mustInstanceOfETypedElement_class(problem,interpretation,element);
	neg find mustInstanceOfEDataType_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfETypeParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEEnumLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find scopeDisallowsNewEClass_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfEClass_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "EClassifier class".
 */
private pattern mustInstanceOfEClassifier_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"EClassifier class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewEClassifier_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"EClassifier class");
}

/**
 * An element may be an instance of type "EClassifier class".
 */
private pattern mayInstanceOfEClassifier_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfEPackage_class(problem,interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEDataType_class(problem,interpretation,element);
	neg find mustInstanceOfETypedElement_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEClass_class(problem,interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfETypeParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEEnumLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find scopeDisallowsNewEClassifier_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfEPackage_class(problem,interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEDataType_class(problem,interpretation,element);
	neg find mustInstanceOfETypedElement_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEClass_class(problem,interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfETypeParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEEnumLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find scopeDisallowsNewEClassifier_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfEClassifier_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "EDataType class".
 */
private pattern mustInstanceOfEDataType_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"EDataType class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewEDataType_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"EDataType class");
}

/**
 * An element may be an instance of type "EDataType class".
 */
private pattern mayInstanceOfEDataType_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEPackage_class(problem,interpretation,element);
	neg find mustInstanceOfEEnum_class(problem,interpretation,element);
	neg find mustInstanceOfETypedElement_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEClass_class(problem,interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfETypeParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEEnumLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find scopeDisallowsNewEDataType_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEPackage_class(problem,interpretation,element);
	neg find mustInstanceOfEEnum_class(problem,interpretation,element);
	neg find mustInstanceOfETypedElement_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEClass_class(problem,interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfETypeParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEEnumLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find scopeDisallowsNewEDataType_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfEDataType_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "EEnum class".
 */
private pattern mustInstanceOfEEnum_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"EEnum class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewEEnum_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"EEnum class");
}

/**
 * An element may be an instance of type "EEnum class".
 */
private pattern mayInstanceOfEEnum_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEPackage_class(problem,interpretation,element);
	neg find mustInstanceOfETypedElement_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEClass_class(problem,interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfETypeParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfEEnumLiteral_class(problem,interpretation,element);
	neg find scopeDisallowsNewEEnum_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEPackage_class(problem,interpretation,element);
	neg find mustInstanceOfETypedElement_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEClass_class(problem,interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfETypeParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfEEnumLiteral_class(problem,interpretation,element);
	neg find scopeDisallowsNewEEnum_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfEEnum_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "EEnumLiteral class".
 */
private pattern mustInstanceOfEEnumLiteral_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"EEnumLiteral class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewEEnumLiteral_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"EEnumLiteral class");
}

/**
 * An element may be an instance of type "EEnumLiteral class".
 */
private pattern mayInstanceOfEEnumLiteral_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEPackage_class(problem,interpretation,element);
	neg find mustInstanceOfETypedElement_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfETypeParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEClassifier_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find scopeDisallowsNewEEnumLiteral_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEPackage_class(problem,interpretation,element);
	neg find mustInstanceOfETypedElement_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfETypeParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEClassifier_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find scopeDisallowsNewEEnumLiteral_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfEEnumLiteral_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "EModelElement class".
 */
private pattern mustInstanceOfEModelElement_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"EModelElement class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewEModelElement_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"EModelElement class");
}

/**
 * An element may be an instance of type "EModelElement class".
 */
private pattern mayInstanceOfEModelElement_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfENamedElement_class(problem,interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEModelElement_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find scopeDisallowsNewEModelElement_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfENamedElement_class(problem,interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEModelElement_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find scopeDisallowsNewEModelElement_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfEModelElement_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "ENamedElement class".
 */
private pattern mustInstanceOfENamedElement_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"ENamedElement class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewENamedElement_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"ENamedElement class");
}

/**
 * An element may be an instance of type "ENamedElement class".
 */
private pattern mayInstanceOfENamedElement_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfEPackage_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEModelElement_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find scopeDisallowsNewENamedElement_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfEPackage_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEModelElement_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find scopeDisallowsNewENamedElement_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfENamedElement_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "EObject class".
 */
private pattern mustInstanceOfEObject_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"EObject class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewEObject_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"EObject class");
}

/**
 * An element may be an instance of type "EObject class".
 */
private pattern mayInstanceOfEObject_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEModelElement_class(problem,interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find scopeDisallowsNewEObject_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEModelElement_class(problem,interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find scopeDisallowsNewEObject_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfEObject_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "EOperation class".
 */
private pattern mustInstanceOfEOperation_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"EOperation class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewEOperation_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"EOperation class");
}

/**
 * An element may be an instance of type "EOperation class".
 */
private pattern mayInstanceOfEOperation_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfEPackage_class(problem,interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfETypeParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEStructuralFeature_class(problem,interpretation,element);
	neg find mustInstanceOfEClassifier_class(problem,interpretation,element);
	neg find mustInstanceOfEEnumLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find scopeDisallowsNewEOperation_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfEPackage_class(problem,interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfETypeParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEStructuralFeature_class(problem,interpretation,element);
	neg find mustInstanceOfEClassifier_class(problem,interpretation,element);
	neg find mustInstanceOfEEnumLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find scopeDisallowsNewEOperation_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfEOperation_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "EPackage class".
 */
private pattern mustInstanceOfEPackage_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"EPackage class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewEPackage_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"EPackage class");
}

/**
 * An element may be an instance of type "EPackage class".
 */
private pattern mayInstanceOfEPackage_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEModelElement_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find scopeDisallowsNewEPackage_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEModelElement_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find scopeDisallowsNewEPackage_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfEPackage_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "EParameter class".
 */
private pattern mustInstanceOfEParameter_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"EParameter class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewEParameter_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"EParameter class");
}

/**
 * An element may be an instance of type "EParameter class".
 */
private pattern mayInstanceOfEParameter_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEPackage_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfETypeParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEOperation_class(problem,interpretation,element);
	neg find mustInstanceOfEStructuralFeature_class(problem,interpretation,element);
	neg find mustInstanceOfEClassifier_class(problem,interpretation,element);
	neg find mustInstanceOfEEnumLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find scopeDisallowsNewEParameter_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEPackage_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfETypeParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEOperation_class(problem,interpretation,element);
	neg find mustInstanceOfEStructuralFeature_class(problem,interpretation,element);
	neg find mustInstanceOfEClassifier_class(problem,interpretation,element);
	neg find mustInstanceOfEEnumLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find scopeDisallowsNewEParameter_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfEParameter_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "EReference class".
 */
private pattern mustInstanceOfEReference_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"EReference class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewEReference_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"EReference class");
}

/**
 * An element may be an instance of type "EReference class".
 */
private pattern mayInstanceOfEReference_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfEPackage_class(problem,interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEAttribute_class(problem,interpretation,element);
	neg find mustInstanceOfEParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfETypeParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEOperation_class(problem,interpretation,element);
	neg find mustInstanceOfEClassifier_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfEEnumLiteral_class(problem,interpretation,element);
	neg find scopeDisallowsNewEReference_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfEPackage_class(problem,interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEAttribute_class(problem,interpretation,element);
	neg find mustInstanceOfEParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfETypeParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEOperation_class(problem,interpretation,element);
	neg find mustInstanceOfEClassifier_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfEEnumLiteral_class(problem,interpretation,element);
	neg find scopeDisallowsNewEReference_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfEReference_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "EStructuralFeature class".
 */
private pattern mustInstanceOfEStructuralFeature_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"EStructuralFeature class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewEStructuralFeature_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"EStructuralFeature class");
}

/**
 * An element may be an instance of type "EStructuralFeature class".
 */
private pattern mayInstanceOfEStructuralFeature_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEPackage_class(problem,interpretation,element);
	neg find mustInstanceOfEAttribute_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfETypeParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEOperation_class(problem,interpretation,element);
	neg find mustInstanceOfEReference_class(problem,interpretation,element);
	neg find mustInstanceOfEClassifier_class(problem,interpretation,element);
	neg find mustInstanceOfEEnumLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find scopeDisallowsNewEStructuralFeature_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEPackage_class(problem,interpretation,element);
	neg find mustInstanceOfEAttribute_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfETypeParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEOperation_class(problem,interpretation,element);
	neg find mustInstanceOfEReference_class(problem,interpretation,element);
	neg find mustInstanceOfEClassifier_class(problem,interpretation,element);
	neg find mustInstanceOfEEnumLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find scopeDisallowsNewEStructuralFeature_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfEStructuralFeature_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "ETypedElement class".
 */
private pattern mustInstanceOfETypedElement_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"ETypedElement class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewETypedElement_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"ETypedElement class");
}

/**
 * An element may be an instance of type "ETypedElement class".
 */
private pattern mayInstanceOfETypedElement_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfEPackage_class(problem,interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfETypeParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEOperation_class(problem,interpretation,element);
	neg find mustInstanceOfEStructuralFeature_class(problem,interpretation,element);
	neg find mustInstanceOfEClassifier_class(problem,interpretation,element);
	neg find mustInstanceOfEEnumLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find scopeDisallowsNewETypedElement_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfEPackage_class(problem,interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfETypeParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEOperation_class(problem,interpretation,element);
	neg find mustInstanceOfEStructuralFeature_class(problem,interpretation,element);
	neg find mustInstanceOfEClassifier_class(problem,interpretation,element);
	neg find mustInstanceOfEEnumLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find scopeDisallowsNewETypedElement_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfETypedElement_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "EStringToStringMapEntry class".
 */
private pattern mustInstanceOfEStringToStringMapEntry_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"EStringToStringMapEntry class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewEStringToStringMapEntry_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"EStringToStringMapEntry class");
}

/**
 * An element may be an instance of type "EStringToStringMapEntry class".
 */
private pattern mayInstanceOfEStringToStringMapEntry_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEModelElement_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find scopeDisallowsNewEStringToStringMapEntry_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEModelElement_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find scopeDisallowsNewEStringToStringMapEntry_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "EGenericType class".
 */
private pattern mustInstanceOfEGenericType_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"EGenericType class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewEGenericType_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"EGenericType class");
}

/**
 * An element may be an instance of type "EGenericType class".
 */
private pattern mayInstanceOfEGenericType_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfEModelElement_class(problem,interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find scopeDisallowsNewEGenericType_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfEModelElement_class(problem,interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find scopeDisallowsNewEGenericType_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfEGenericType_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "ETypeParameter class".
 */
private pattern mustInstanceOfETypeParameter_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"ETypeParameter class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewETypeParameter_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"ETypeParameter class");
}

/**
 * An element may be an instance of type "ETypeParameter class".
 */
private pattern mayInstanceOfETypeParameter_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEPackage_class(problem,interpretation,element);
	neg find mustInstanceOfETypedElement_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEClassifier_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfEEnumLiteral_class(problem,interpretation,element);
	neg find scopeDisallowsNewETypeParameter_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEPackage_class(problem,interpretation,element);
	neg find mustInstanceOfETypedElement_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEClassifier_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfEEnumLiteral_class(problem,interpretation,element);
	neg find scopeDisallowsNewETypeParameter_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfETypeParameter_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "EModelElement class DefinedPart".
 */
private pattern mustInstanceOfEModelElement_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"EModelElement class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewEModelElement_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"EModelElement class DefinedPart");
}

/**
 * An element may be an instance of type "EModelElement class DefinedPart".
 */
private pattern mayInstanceOfEModelElement_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfEModelElement_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "EModelElement class UndefinedPart".
 */
private pattern mustInstanceOfEModelElement_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"EModelElement class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewEModelElement_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"EModelElement class UndefinedPart");
}

/**
 * An element may be an instance of type "EModelElement class UndefinedPart".
 */
private pattern mayInstanceOfEModelElement_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfENamedElement_class(problem,interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find scopeDisallowsNewEModelElement_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfENamedElement_class(problem,interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find scopeDisallowsNewEModelElement_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfEModelElement_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "ENamedElement class DefinedPart".
 */
private pattern mustInstanceOfENamedElement_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"ENamedElement class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewENamedElement_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"ENamedElement class DefinedPart");
}

/**
 * An element may be an instance of type "ENamedElement class DefinedPart".
 */
private pattern mayInstanceOfENamedElement_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfENamedElement_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "ENamedElement class UndefinedPart".
 */
private pattern mustInstanceOfENamedElement_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"ENamedElement class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewENamedElement_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"ENamedElement class UndefinedPart");
}

/**
 * An element may be an instance of type "ENamedElement class UndefinedPart".
 */
private pattern mayInstanceOfENamedElement_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEPackage_class(problem,interpretation,element);
	neg find mustInstanceOfETypedElement_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfETypeParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEClassifier_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfEEnumLiteral_class(problem,interpretation,element);
	neg find scopeDisallowsNewENamedElement_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEPackage_class(problem,interpretation,element);
	neg find mustInstanceOfETypedElement_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfETypeParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEClassifier_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfEEnumLiteral_class(problem,interpretation,element);
	neg find scopeDisallowsNewENamedElement_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfENamedElement_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "EPackage class DefinedPart".
 */
private pattern mustInstanceOfEPackage_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"EPackage class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewEPackage_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"EPackage class DefinedPart");
}

/**
 * An element may be an instance of type "EPackage class DefinedPart".
 */
private pattern mayInstanceOfEPackage_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfEPackage_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "EPackage class UndefinedPart".
 */
private pattern mustInstanceOfEPackage_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"EPackage class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewEPackage_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"EPackage class UndefinedPart");
}

/**
 * An element may be an instance of type "EPackage class UndefinedPart".
 */
private pattern mayInstanceOfEPackage_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfETypedElement_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfETypeParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEClassifier_class(problem,interpretation,element);
	neg find mustInstanceOfEEnumLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find scopeDisallowsNewEPackage_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfETypedElement_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfETypeParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEClassifier_class(problem,interpretation,element);
	neg find mustInstanceOfEEnumLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find scopeDisallowsNewEPackage_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfEPackage_class_UndefinedPart(problem,interpretation,element); }

//////////
// 1.2 Relation Declaration Indexers
//////////
/**
 * Matcher for detecting tuples t where []eAttributeType reference EAttribute(source,target)
 */
private pattern mustInRelationeAttributeType_reference_EAttribute(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eAttributeType reference EAttribute");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eAttributeType reference EAttribute(source,target)
 */
private pattern mayInRelationeAttributeType_reference_EAttribute(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEAttribute_class(problem,interpretation,source);
	find mayInstanceOfEDataType_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationeAttributeType_reference_EAttribute(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationeAttributeType_reference_EAttribute(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []details reference EAnnotation(source,target)
 */
private pattern mustInRelationdetails_reference_EAnnotation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"details reference EAnnotation");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>details reference EAnnotation(source,target)
 */
private pattern mayInRelationdetails_reference_EAnnotation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEAnnotation_class(problem,interpretation,source);
	find mayInstanceOfEStringToStringMapEntry_class(problem,interpretation,target);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationdetails_reference_EAnnotation(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eModelElement reference EAnnotation(source,target)
 */
private pattern mustInRelationeModelElement_reference_EAnnotation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eModelElement reference EAnnotation");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eModelElement reference EAnnotation(source,target)
 */
private pattern mayInRelationeModelElement_reference_EAnnotation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEAnnotation_class(problem,interpretation,source);
	find mayInstanceOfEModelElement_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationeModelElement_reference_EAnnotation(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationeModelElement_reference_EAnnotation(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []contents reference EAnnotation(source,target)
 */
private pattern mustInRelationcontents_reference_EAnnotation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"contents reference EAnnotation");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>contents reference EAnnotation(source,target)
 */
private pattern mayInRelationcontents_reference_EAnnotation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEAnnotation_class(problem,interpretation,source);
	find mayInstanceOfEObject_class(problem,interpretation,target);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationcontents_reference_EAnnotation(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []references reference EAnnotation(source,target)
 */
private pattern mustInRelationreferences_reference_EAnnotation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"references reference EAnnotation");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>references reference EAnnotation(source,target)
 */
private pattern mayInRelationreferences_reference_EAnnotation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEAnnotation_class(problem,interpretation,source);
	find mayInstanceOfEObject_class(problem,interpretation,target);
} or {
	find mustInRelationreferences_reference_EAnnotation(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eSuperTypes reference EClass(source,target)
 */
private pattern mustInRelationeSuperTypes_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eSuperTypes reference EClass");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eSuperTypes reference EClass(source,target)
 */
private pattern mayInRelationeSuperTypes_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEClass_class(problem,interpretation,source);
	find mayInstanceOfEClass_class(problem,interpretation,target);
} or {
	find mustInRelationeSuperTypes_reference_EClass(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eOperations reference EClass(source,target)
 */
private pattern mustInRelationeOperations_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eOperations reference EClass");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eOperations reference EClass(source,target)
 */
private pattern mayInRelationeOperations_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEClass_class(problem,interpretation,source);
	find mayInstanceOfEOperation_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationeContainingClass_reference_EOperation(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationeOperations_reference_EClass(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eAllAttributes reference EClass(source,target)
 */
private pattern mustInRelationeAllAttributes_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eAllAttributes reference EClass");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eAllAttributes reference EClass(source,target)
 */
private pattern mayInRelationeAllAttributes_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEClass_class(problem,interpretation,source);
	find mayInstanceOfEAttribute_class(problem,interpretation,target);
} or {
	find mustInRelationeAllAttributes_reference_EClass(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eAllReferences reference EClass(source,target)
 */
private pattern mustInRelationeAllReferences_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eAllReferences reference EClass");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eAllReferences reference EClass(source,target)
 */
private pattern mayInRelationeAllReferences_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEClass_class(problem,interpretation,source);
	find mayInstanceOfEReference_class(problem,interpretation,target);
} or {
	find mustInRelationeAllReferences_reference_EClass(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eReferences reference EClass(source,target)
 */
private pattern mustInRelationeReferences_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eReferences reference EClass");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eReferences reference EClass(source,target)
 */
private pattern mayInRelationeReferences_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEClass_class(problem,interpretation,source);
	find mayInstanceOfEReference_class(problem,interpretation,target);
} or {
	find mustInRelationeReferences_reference_EClass(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eAttributes reference EClass(source,target)
 */
private pattern mustInRelationeAttributes_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eAttributes reference EClass");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eAttributes reference EClass(source,target)
 */
private pattern mayInRelationeAttributes_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEClass_class(problem,interpretation,source);
	find mayInstanceOfEAttribute_class(problem,interpretation,target);
} or {
	find mustInRelationeAttributes_reference_EClass(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eAllContainments reference EClass(source,target)
 */
private pattern mustInRelationeAllContainments_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eAllContainments reference EClass");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eAllContainments reference EClass(source,target)
 */
private pattern mayInRelationeAllContainments_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEClass_class(problem,interpretation,source);
	find mayInstanceOfEReference_class(problem,interpretation,target);
} or {
	find mustInRelationeAllContainments_reference_EClass(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eAllOperations reference EClass(source,target)
 */
private pattern mustInRelationeAllOperations_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eAllOperations reference EClass");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eAllOperations reference EClass(source,target)
 */
private pattern mayInRelationeAllOperations_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEClass_class(problem,interpretation,source);
	find mayInstanceOfEOperation_class(problem,interpretation,target);
} or {
	find mustInRelationeAllOperations_reference_EClass(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eAllStructuralFeatures reference EClass(source,target)
 */
private pattern mustInRelationeAllStructuralFeatures_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eAllStructuralFeatures reference EClass");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eAllStructuralFeatures reference EClass(source,target)
 */
private pattern mayInRelationeAllStructuralFeatures_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEClass_class(problem,interpretation,source);
	find mayInstanceOfEStructuralFeature_class(problem,interpretation,target);
} or {
	find mustInRelationeAllStructuralFeatures_reference_EClass(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eAllSuperTypes reference EClass(source,target)
 */
private pattern mustInRelationeAllSuperTypes_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eAllSuperTypes reference EClass");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eAllSuperTypes reference EClass(source,target)
 */
private pattern mayInRelationeAllSuperTypes_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEClass_class(problem,interpretation,source);
	find mayInstanceOfEClass_class(problem,interpretation,target);
} or {
	find mustInRelationeAllSuperTypes_reference_EClass(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eIDAttribute reference EClass(source,target)
 */
private pattern mustInRelationeIDAttribute_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eIDAttribute reference EClass");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eIDAttribute reference EClass(source,target)
 */
private pattern mayInRelationeIDAttribute_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEClass_class(problem,interpretation,source);
	find mayInstanceOfEAttribute_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationeIDAttribute_reference_EClass(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationeIDAttribute_reference_EClass(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eStructuralFeatures reference EClass(source,target)
 */
private pattern mustInRelationeStructuralFeatures_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eStructuralFeatures reference EClass");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eStructuralFeatures reference EClass(source,target)
 */
private pattern mayInRelationeStructuralFeatures_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEClass_class(problem,interpretation,source);
	find mayInstanceOfEStructuralFeature_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationeContainingClass_reference_EStructuralFeature(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationeStructuralFeatures_reference_EClass(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eGenericSuperTypes reference EClass(source,target)
 */
private pattern mustInRelationeGenericSuperTypes_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eGenericSuperTypes reference EClass");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eGenericSuperTypes reference EClass(source,target)
 */
private pattern mayInRelationeGenericSuperTypes_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEClass_class(problem,interpretation,source);
	find mayInstanceOfEGenericType_class(problem,interpretation,target);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationeGenericSuperTypes_reference_EClass(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eAllGenericSuperTypes reference EClass(source,target)
 */
private pattern mustInRelationeAllGenericSuperTypes_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eAllGenericSuperTypes reference EClass");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eAllGenericSuperTypes reference EClass(source,target)
 */
private pattern mayInRelationeAllGenericSuperTypes_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEClass_class(problem,interpretation,source);
	find mayInstanceOfEGenericType_class(problem,interpretation,target);
} or {
	find mustInRelationeAllGenericSuperTypes_reference_EClass(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []ePackage reference EClassifier(source,target)
 */
private pattern mustInRelationePackage_reference_EClassifier(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"ePackage reference EClassifier");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>ePackage reference EClassifier(source,target)
 */
private pattern mayInRelationePackage_reference_EClassifier(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEClassifier_class(problem,interpretation,source);
	find mayInstanceOfEPackage_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationePackage_reference_EClassifier(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationePackage_reference_EClassifier(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eTypeParameters reference EClassifier(source,target)
 */
private pattern mustInRelationeTypeParameters_reference_EClassifier(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eTypeParameters reference EClassifier");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eTypeParameters reference EClassifier(source,target)
 */
private pattern mayInRelationeTypeParameters_reference_EClassifier(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEClassifier_class(problem,interpretation,source);
	find mayInstanceOfETypeParameter_class(problem,interpretation,target);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationeTypeParameters_reference_EClassifier(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eLiterals reference EEnum(source,target)
 */
private pattern mustInRelationeLiterals_reference_EEnum(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eLiterals reference EEnum");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eLiterals reference EEnum(source,target)
 */
private pattern mayInRelationeLiterals_reference_EEnum(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEEnum_class(problem,interpretation,source);
	find mayInstanceOfEEnumLiteral_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationeEnum_reference_EEnumLiteral(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationeLiterals_reference_EEnum(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eEnum reference EEnumLiteral(source,target)
 */
private pattern mustInRelationeEnum_reference_EEnumLiteral(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eEnum reference EEnumLiteral");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eEnum reference EEnumLiteral(source,target)
 */
private pattern mayInRelationeEnum_reference_EEnumLiteral(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEEnumLiteral_class(problem,interpretation,source);
	find mayInstanceOfEEnum_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationeEnum_reference_EEnumLiteral(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationeEnum_reference_EEnumLiteral(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eAnnotations reference EModelElement(source,target)
 */
private pattern mustInRelationeAnnotations_reference_EModelElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eAnnotations reference EModelElement");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eAnnotations reference EModelElement(source,target)
 */
private pattern mayInRelationeAnnotations_reference_EModelElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEModelElement_class(problem,interpretation,source);
	find mayInstanceOfEAnnotation_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationeModelElement_reference_EAnnotation(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationeAnnotations_reference_EModelElement(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eContainingClass reference EOperation(source,target)
 */
private pattern mustInRelationeContainingClass_reference_EOperation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eContainingClass reference EOperation");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eContainingClass reference EOperation(source,target)
 */
private pattern mayInRelationeContainingClass_reference_EOperation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEOperation_class(problem,interpretation,source);
	find mayInstanceOfEClass_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationeContainingClass_reference_EOperation(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationeContainingClass_reference_EOperation(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eTypeParameters reference EOperation(source,target)
 */
private pattern mustInRelationeTypeParameters_reference_EOperation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eTypeParameters reference EOperation");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eTypeParameters reference EOperation(source,target)
 */
private pattern mayInRelationeTypeParameters_reference_EOperation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEOperation_class(problem,interpretation,source);
	find mayInstanceOfETypeParameter_class(problem,interpretation,target);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationeTypeParameters_reference_EOperation(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eParameters reference EOperation(source,target)
 */
private pattern mustInRelationeParameters_reference_EOperation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eParameters reference EOperation");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eParameters reference EOperation(source,target)
 */
private pattern mayInRelationeParameters_reference_EOperation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEOperation_class(problem,interpretation,source);
	find mayInstanceOfEParameter_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationeOperation_reference_EParameter(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationeParameters_reference_EOperation(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eExceptions reference EOperation(source,target)
 */
private pattern mustInRelationeExceptions_reference_EOperation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eExceptions reference EOperation");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eExceptions reference EOperation(source,target)
 */
private pattern mayInRelationeExceptions_reference_EOperation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEOperation_class(problem,interpretation,source);
	find mayInstanceOfEClassifier_class(problem,interpretation,target);
} or {
	find mustInRelationeExceptions_reference_EOperation(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eGenericExceptions reference EOperation(source,target)
 */
private pattern mustInRelationeGenericExceptions_reference_EOperation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eGenericExceptions reference EOperation");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eGenericExceptions reference EOperation(source,target)
 */
private pattern mayInRelationeGenericExceptions_reference_EOperation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEOperation_class(problem,interpretation,source);
	find mayInstanceOfEGenericType_class(problem,interpretation,target);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationeGenericExceptions_reference_EOperation(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eClassifiers reference EPackage(source,target)
 */
private pattern mustInRelationeClassifiers_reference_EPackage(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eClassifiers reference EPackage");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eClassifiers reference EPackage(source,target)
 */
private pattern mayInRelationeClassifiers_reference_EPackage(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEPackage_class(problem,interpretation,source);
	find mayInstanceOfEClassifier_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationePackage_reference_EClassifier(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationeClassifiers_reference_EPackage(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eSubpackages reference EPackage(source,target)
 */
private pattern mustInRelationeSubpackages_reference_EPackage(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eSubpackages reference EPackage");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eSubpackages reference EPackage(source,target)
 */
private pattern mayInRelationeSubpackages_reference_EPackage(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEPackage_class(problem,interpretation,source);
	find mayInstanceOfEPackage_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationeSuperPackage_reference_EPackage(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationeSubpackages_reference_EPackage(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eSuperPackage reference EPackage(source,target)
 */
private pattern mustInRelationeSuperPackage_reference_EPackage(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eSuperPackage reference EPackage");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eSuperPackage reference EPackage(source,target)
 */
private pattern mayInRelationeSuperPackage_reference_EPackage(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEPackage_class(problem,interpretation,source);
	find mayInstanceOfEPackage_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationeSuperPackage_reference_EPackage(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationeSuperPackage_reference_EPackage(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eOperation reference EParameter(source,target)
 */
private pattern mustInRelationeOperation_reference_EParameter(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eOperation reference EParameter");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eOperation reference EParameter(source,target)
 */
private pattern mayInRelationeOperation_reference_EParameter(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEParameter_class(problem,interpretation,source);
	find mayInstanceOfEOperation_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationeOperation_reference_EParameter(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationeOperation_reference_EParameter(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eOpposite reference EReference(source,target)
 */
private pattern mustInRelationeOpposite_reference_EReference(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eOpposite reference EReference");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eOpposite reference EReference(source,target)
 */
private pattern mayInRelationeOpposite_reference_EReference(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEReference_class(problem,interpretation,source);
	find mayInstanceOfEReference_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationeOpposite_reference_EReference(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationeOpposite_reference_EReference(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eReferenceType reference EReference(source,target)
 */
private pattern mustInRelationeReferenceType_reference_EReference(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eReferenceType reference EReference");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eReferenceType reference EReference(source,target)
 */
private pattern mayInRelationeReferenceType_reference_EReference(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEReference_class(problem,interpretation,source);
	find mayInstanceOfEClass_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationeReferenceType_reference_EReference(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationeReferenceType_reference_EReference(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eKeys reference EReference(source,target)
 */
private pattern mustInRelationeKeys_reference_EReference(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eKeys reference EReference");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eKeys reference EReference(source,target)
 */
private pattern mayInRelationeKeys_reference_EReference(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEReference_class(problem,interpretation,source);
	find mayInstanceOfEAttribute_class(problem,interpretation,target);
} or {
	find mustInRelationeKeys_reference_EReference(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eContainingClass reference EStructuralFeature(source,target)
 */
private pattern mustInRelationeContainingClass_reference_EStructuralFeature(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eContainingClass reference EStructuralFeature");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eContainingClass reference EStructuralFeature(source,target)
 */
private pattern mayInRelationeContainingClass_reference_EStructuralFeature(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEStructuralFeature_class(problem,interpretation,source);
	find mayInstanceOfEClass_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationeContainingClass_reference_EStructuralFeature(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationeContainingClass_reference_EStructuralFeature(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eType reference ETypedElement(source,target)
 */
private pattern mustInRelationeType_reference_ETypedElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eType reference ETypedElement");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eType reference ETypedElement(source,target)
 */
private pattern mayInRelationeType_reference_ETypedElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfETypedElement_class(problem,interpretation,source);
	find mayInstanceOfEClassifier_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationeType_reference_ETypedElement(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationeType_reference_ETypedElement(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eGenericType reference ETypedElement(source,target)
 */
private pattern mustInRelationeGenericType_reference_ETypedElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eGenericType reference ETypedElement");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eGenericType reference ETypedElement(source,target)
 */
private pattern mayInRelationeGenericType_reference_ETypedElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfETypedElement_class(problem,interpretation,source);
	find mayInstanceOfEGenericType_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationeGenericType_reference_ETypedElement(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationeGenericType_reference_ETypedElement(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eUpperBound reference EGenericType(source,target)
 */
private pattern mustInRelationeUpperBound_reference_EGenericType(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eUpperBound reference EGenericType");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eUpperBound reference EGenericType(source,target)
 */
private pattern mayInRelationeUpperBound_reference_EGenericType(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEGenericType_class(problem,interpretation,source);
	find mayInstanceOfEGenericType_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationeUpperBound_reference_EGenericType(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationeUpperBound_reference_EGenericType(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eTypeArguments reference EGenericType(source,target)
 */
private pattern mustInRelationeTypeArguments_reference_EGenericType(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eTypeArguments reference EGenericType");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eTypeArguments reference EGenericType(source,target)
 */
private pattern mayInRelationeTypeArguments_reference_EGenericType(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEGenericType_class(problem,interpretation,source);
	find mayInstanceOfEGenericType_class(problem,interpretation,target);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationeTypeArguments_reference_EGenericType(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eRawType reference EGenericType(source,target)
 */
private pattern mustInRelationeRawType_reference_EGenericType(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eRawType reference EGenericType");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eRawType reference EGenericType(source,target)
 */
private pattern mayInRelationeRawType_reference_EGenericType(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEGenericType_class(problem,interpretation,source);
	find mayInstanceOfEClassifier_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationeRawType_reference_EGenericType(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationeRawType_reference_EGenericType(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eLowerBound reference EGenericType(source,target)
 */
private pattern mustInRelationeLowerBound_reference_EGenericType(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eLowerBound reference EGenericType");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eLowerBound reference EGenericType(source,target)
 */
private pattern mayInRelationeLowerBound_reference_EGenericType(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEGenericType_class(problem,interpretation,source);
	find mayInstanceOfEGenericType_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationeLowerBound_reference_EGenericType(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationeLowerBound_reference_EGenericType(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eTypeParameter reference EGenericType(source,target)
 */
private pattern mustInRelationeTypeParameter_reference_EGenericType(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eTypeParameter reference EGenericType");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eTypeParameter reference EGenericType(source,target)
 */
private pattern mayInRelationeTypeParameter_reference_EGenericType(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEGenericType_class(problem,interpretation,source);
	find mayInstanceOfETypeParameter_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationeTypeParameter_reference_EGenericType(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationeTypeParameter_reference_EGenericType(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eClassifier reference EGenericType(source,target)
 */
private pattern mustInRelationeClassifier_reference_EGenericType(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eClassifier reference EGenericType");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eClassifier reference EGenericType(source,target)
 */
private pattern mayInRelationeClassifier_reference_EGenericType(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEGenericType_class(problem,interpretation,source);
	find mayInstanceOfEClassifier_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationeClassifier_reference_EGenericType(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationeClassifier_reference_EGenericType(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eBounds reference ETypeParameter(source,target)
 */
private pattern mustInRelationeBounds_reference_ETypeParameter(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eBounds reference ETypeParameter");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eBounds reference ETypeParameter(source,target)
 */
private pattern mayInRelationeBounds_reference_ETypeParameter(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfETypeParameter_class(problem,interpretation,source);
	find mayInstanceOfEGenericType_class(problem,interpretation,target);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationeBounds_reference_ETypeParameter(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []iD attribute EAttribute(source,target)
 */
private pattern mustInRelationiD_attribute_EAttribute(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"iD attribute EAttribute");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>iD attribute EAttribute(source,target)
 */
private pattern mayInRelationiD_attribute_EAttribute(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEAttribute_class(problem,interpretation,source);
	BooleanElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationiD_attribute_EAttribute(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationiD_attribute_EAttribute(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []source attribute EAnnotation(source,target)
 */
private pattern mustInRelationsource_attribute_EAnnotation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"source attribute EAnnotation");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>source attribute EAnnotation(source,target)
 */
private pattern mayInRelationsource_attribute_EAnnotation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEAnnotation_class(problem,interpretation,source);
	StringElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationsource_attribute_EAnnotation(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationsource_attribute_EAnnotation(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []abstract attribute EClass(source,target)
 */
private pattern mustInRelationabstract_attribute_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"abstract attribute EClass");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>abstract attribute EClass(source,target)
 */
private pattern mayInRelationabstract_attribute_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEClass_class(problem,interpretation,source);
	BooleanElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationabstract_attribute_EClass(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationabstract_attribute_EClass(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []interface attribute EClass(source,target)
 */
private pattern mustInRelationinterface_attribute_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"interface attribute EClass");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>interface attribute EClass(source,target)
 */
private pattern mayInRelationinterface_attribute_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEClass_class(problem,interpretation,source);
	BooleanElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationinterface_attribute_EClass(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationinterface_attribute_EClass(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []instanceClassName attribute EClassifier(source,target)
 */
private pattern mustInRelationinstanceClassName_attribute_EClassifier(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"instanceClassName attribute EClassifier");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>instanceClassName attribute EClassifier(source,target)
 */
private pattern mayInRelationinstanceClassName_attribute_EClassifier(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEClassifier_class(problem,interpretation,source);
	StringElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationinstanceClassName_attribute_EClassifier(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationinstanceClassName_attribute_EClassifier(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []instanceTypeName attribute EClassifier(source,target)
 */
private pattern mustInRelationinstanceTypeName_attribute_EClassifier(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"instanceTypeName attribute EClassifier");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>instanceTypeName attribute EClassifier(source,target)
 */
private pattern mayInRelationinstanceTypeName_attribute_EClassifier(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEClassifier_class(problem,interpretation,source);
	StringElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationinstanceTypeName_attribute_EClassifier(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationinstanceTypeName_attribute_EClassifier(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []serializable attribute EDataType(source,target)
 */
private pattern mustInRelationserializable_attribute_EDataType(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"serializable attribute EDataType");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>serializable attribute EDataType(source,target)
 */
private pattern mayInRelationserializable_attribute_EDataType(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEDataType_class(problem,interpretation,source);
	BooleanElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationserializable_attribute_EDataType(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationserializable_attribute_EDataType(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []value attribute EEnumLiteral(source,target)
 */
private pattern mustInRelationvalue_attribute_EEnumLiteral(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"value attribute EEnumLiteral");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>value attribute EEnumLiteral(source,target)
 */
private pattern mayInRelationvalue_attribute_EEnumLiteral(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEEnumLiteral_class(problem,interpretation,source);
	IntegerElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationvalue_attribute_EEnumLiteral(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationvalue_attribute_EEnumLiteral(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []literal attribute EEnumLiteral(source,target)
 */
private pattern mustInRelationliteral_attribute_EEnumLiteral(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"literal attribute EEnumLiteral");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>literal attribute EEnumLiteral(source,target)
 */
private pattern mayInRelationliteral_attribute_EEnumLiteral(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEEnumLiteral_class(problem,interpretation,source);
	StringElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationliteral_attribute_EEnumLiteral(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationliteral_attribute_EEnumLiteral(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []name attribute ENamedElement(source,target)
 */
private pattern mustInRelationname_attribute_ENamedElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"name attribute ENamedElement");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>name attribute ENamedElement(source,target)
 */
private pattern mayInRelationname_attribute_ENamedElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfENamedElement_class(problem,interpretation,source);
	StringElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationname_attribute_ENamedElement(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationname_attribute_ENamedElement(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []nsURI attribute EPackage(source,target)
 */
private pattern mustInRelationnsURI_attribute_EPackage(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"nsURI attribute EPackage");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>nsURI attribute EPackage(source,target)
 */
private pattern mayInRelationnsURI_attribute_EPackage(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEPackage_class(problem,interpretation,source);
	StringElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationnsURI_attribute_EPackage(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationnsURI_attribute_EPackage(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []nsPrefix attribute EPackage(source,target)
 */
private pattern mustInRelationnsPrefix_attribute_EPackage(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"nsPrefix attribute EPackage");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>nsPrefix attribute EPackage(source,target)
 */
private pattern mayInRelationnsPrefix_attribute_EPackage(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEPackage_class(problem,interpretation,source);
	StringElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationnsPrefix_attribute_EPackage(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationnsPrefix_attribute_EPackage(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []containment attribute EReference(source,target)
 */
private pattern mustInRelationcontainment_attribute_EReference(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"containment attribute EReference");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>containment attribute EReference(source,target)
 */
private pattern mayInRelationcontainment_attribute_EReference(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEReference_class(problem,interpretation,source);
	BooleanElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationcontainment_attribute_EReference(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationcontainment_attribute_EReference(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []container attribute EReference(source,target)
 */
private pattern mustInRelationcontainer_attribute_EReference(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"container attribute EReference");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>container attribute EReference(source,target)
 */
private pattern mayInRelationcontainer_attribute_EReference(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEReference_class(problem,interpretation,source);
	BooleanElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationcontainer_attribute_EReference(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationcontainer_attribute_EReference(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []resolveProxies attribute EReference(source,target)
 */
private pattern mustInRelationresolveProxies_attribute_EReference(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"resolveProxies attribute EReference");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>resolveProxies attribute EReference(source,target)
 */
private pattern mayInRelationresolveProxies_attribute_EReference(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEReference_class(problem,interpretation,source);
	BooleanElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationresolveProxies_attribute_EReference(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationresolveProxies_attribute_EReference(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []changeable attribute EStructuralFeature(source,target)
 */
private pattern mustInRelationchangeable_attribute_EStructuralFeature(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"changeable attribute EStructuralFeature");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>changeable attribute EStructuralFeature(source,target)
 */
private pattern mayInRelationchangeable_attribute_EStructuralFeature(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEStructuralFeature_class(problem,interpretation,source);
	BooleanElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationchangeable_attribute_EStructuralFeature(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationchangeable_attribute_EStructuralFeature(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []volatile attribute EStructuralFeature(source,target)
 */
private pattern mustInRelationvolatile_attribute_EStructuralFeature(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"volatile attribute EStructuralFeature");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>volatile attribute EStructuralFeature(source,target)
 */
private pattern mayInRelationvolatile_attribute_EStructuralFeature(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEStructuralFeature_class(problem,interpretation,source);
	BooleanElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationvolatile_attribute_EStructuralFeature(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationvolatile_attribute_EStructuralFeature(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []transient attribute EStructuralFeature(source,target)
 */
private pattern mustInRelationtransient_attribute_EStructuralFeature(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"transient attribute EStructuralFeature");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>transient attribute EStructuralFeature(source,target)
 */
private pattern mayInRelationtransient_attribute_EStructuralFeature(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEStructuralFeature_class(problem,interpretation,source);
	BooleanElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationtransient_attribute_EStructuralFeature(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationtransient_attribute_EStructuralFeature(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []defaultValueLiteral attribute EStructuralFeature(source,target)
 */
private pattern mustInRelationdefaultValueLiteral_attribute_EStructuralFeature(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"defaultValueLiteral attribute EStructuralFeature");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>defaultValueLiteral attribute EStructuralFeature(source,target)
 */
private pattern mayInRelationdefaultValueLiteral_attribute_EStructuralFeature(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEStructuralFeature_class(problem,interpretation,source);
	StringElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationdefaultValueLiteral_attribute_EStructuralFeature(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationdefaultValueLiteral_attribute_EStructuralFeature(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []unsettable attribute EStructuralFeature(source,target)
 */
private pattern mustInRelationunsettable_attribute_EStructuralFeature(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"unsettable attribute EStructuralFeature");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>unsettable attribute EStructuralFeature(source,target)
 */
private pattern mayInRelationunsettable_attribute_EStructuralFeature(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEStructuralFeature_class(problem,interpretation,source);
	BooleanElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationunsettable_attribute_EStructuralFeature(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationunsettable_attribute_EStructuralFeature(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []derived attribute EStructuralFeature(source,target)
 */
private pattern mustInRelationderived_attribute_EStructuralFeature(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"derived attribute EStructuralFeature");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>derived attribute EStructuralFeature(source,target)
 */
private pattern mayInRelationderived_attribute_EStructuralFeature(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEStructuralFeature_class(problem,interpretation,source);
	BooleanElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationderived_attribute_EStructuralFeature(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationderived_attribute_EStructuralFeature(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []ordered attribute ETypedElement(source,target)
 */
private pattern mustInRelationordered_attribute_ETypedElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"ordered attribute ETypedElement");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>ordered attribute ETypedElement(source,target)
 */
private pattern mayInRelationordered_attribute_ETypedElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfETypedElement_class(problem,interpretation,source);
	BooleanElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationordered_attribute_ETypedElement(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationordered_attribute_ETypedElement(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []unique attribute ETypedElement(source,target)
 */
private pattern mustInRelationunique_attribute_ETypedElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"unique attribute ETypedElement");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>unique attribute ETypedElement(source,target)
 */
private pattern mayInRelationunique_attribute_ETypedElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfETypedElement_class(problem,interpretation,source);
	BooleanElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationunique_attribute_ETypedElement(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationunique_attribute_ETypedElement(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []lowerBound attribute ETypedElement(source,target)
 */
private pattern mustInRelationlowerBound_attribute_ETypedElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"lowerBound attribute ETypedElement");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>lowerBound attribute ETypedElement(source,target)
 */
private pattern mayInRelationlowerBound_attribute_ETypedElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfETypedElement_class(problem,interpretation,source);
	IntegerElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationlowerBound_attribute_ETypedElement(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationlowerBound_attribute_ETypedElement(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []upperBound attribute ETypedElement(source,target)
 */
private pattern mustInRelationupperBound_attribute_ETypedElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"upperBound attribute ETypedElement");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>upperBound attribute ETypedElement(source,target)
 */
private pattern mayInRelationupperBound_attribute_ETypedElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfETypedElement_class(problem,interpretation,source);
	IntegerElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationupperBound_attribute_ETypedElement(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationupperBound_attribute_ETypedElement(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []many attribute ETypedElement(source,target)
 */
private pattern mustInRelationmany_attribute_ETypedElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"many attribute ETypedElement");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>many attribute ETypedElement(source,target)
 */
private pattern mayInRelationmany_attribute_ETypedElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfETypedElement_class(problem,interpretation,source);
	BooleanElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationmany_attribute_ETypedElement(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationmany_attribute_ETypedElement(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []required attribute ETypedElement(source,target)
 */
private pattern mustInRelationrequired_attribute_ETypedElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"required attribute ETypedElement");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>required attribute ETypedElement(source,target)
 */
private pattern mayInRelationrequired_attribute_ETypedElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfETypedElement_class(problem,interpretation,source);
	BooleanElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationrequired_attribute_ETypedElement(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationrequired_attribute_ETypedElement(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []key attribute EStringToStringMapEntry(source,target)
 */
private pattern mustInRelationkey_attribute_EStringToStringMapEntry(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"key attribute EStringToStringMapEntry");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>key attribute EStringToStringMapEntry(source,target)
 */
private pattern mayInRelationkey_attribute_EStringToStringMapEntry(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEStringToStringMapEntry_class(problem,interpretation,source);
	StringElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationkey_attribute_EStringToStringMapEntry(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationkey_attribute_EStringToStringMapEntry(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []value attribute EStringToStringMapEntry(source,target)
 */
private pattern mustInRelationvalue_attribute_EStringToStringMapEntry(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"value attribute EStringToStringMapEntry");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>value attribute EStringToStringMapEntry(source,target)
 */
private pattern mayInRelationvalue_attribute_EStringToStringMapEntry(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEStringToStringMapEntry_class(problem,interpretation,source);
	StringElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationvalue_attribute_EStringToStringMapEntry(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationvalue_attribute_EStringToStringMapEntry(problem,interpretation,source,target);
}

//////////
// 1.3 Relation Definition Indexers
//////////

//////////
// 1.4 Containment Indexer
//////////
private pattern mustContains2(source: DefinedElement, target: DefinedElement) {
	find mustContains4(_,_,source,target);
}
	
private pattern mustContains4(problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target: DefinedElement)
	{ find mustInRelationdetails_reference_EAnnotation(problem,interpretation,source,target); }or
	
	{ find mustInRelationcontents_reference_EAnnotation(problem,interpretation,source,target); }or
	
	{ find mustInRelationeOperations_reference_EClass(problem,interpretation,source,target); }or
	
	{ find mustInRelationeStructuralFeatures_reference_EClass(problem,interpretation,source,target); }or
	
	{ find mustInRelationeGenericSuperTypes_reference_EClass(problem,interpretation,source,target); }or
	
	{ find mustInRelationeTypeParameters_reference_EClassifier(problem,interpretation,source,target); }or
	
	{ find mustInRelationeLiterals_reference_EEnum(problem,interpretation,source,target); }or
	
	{ find mustInRelationeAnnotations_reference_EModelElement(problem,interpretation,source,target); }or
	
	{ find mustInRelationeTypeParameters_reference_EOperation(problem,interpretation,source,target); }or
	
	{ find mustInRelationeParameters_reference_EOperation(problem,interpretation,source,target); }or
	
	{ find mustInRelationeGenericExceptions_reference_EOperation(problem,interpretation,source,target); }or
	
	{ find mustInRelationeClassifiers_reference_EPackage(problem,interpretation,source,target); }or
	
	{ find mustInRelationeSubpackages_reference_EPackage(problem,interpretation,source,target); }or
	
	{ find mustInRelationeGenericType_reference_ETypedElement(problem,interpretation,source,target); }or
	
	{ find mustInRelationeUpperBound_reference_EGenericType(problem,interpretation,source,target); }or
	
	{ find mustInRelationeTypeArguments_reference_EGenericType(problem,interpretation,source,target); }or
	
	{ find mustInRelationeLowerBound_reference_EGenericType(problem,interpretation,source,target); }or
	
	{ find mustInRelationeBounds_reference_ETypeParameter(problem,interpretation,source,target); }

private pattern mustTransitiveContains(source,target) {
	find mustContains2+(source,target);
}

//////////
// 2. Invalidation Indexers
//////////
// 2.1 Invalidated by WF Queries
//////////

//////////
// 3. Unfinishedness Indexers
//////////
// 3.1 Unfinishedness Measured by Multiplicity
//////////
pattern unfinishedLowerMultiplicity_eAttributeType_reference_EAttribute(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eAttributeType reference EAttribute");
	find mustInstanceOfEAttribute_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationeAttributeType_reference_EAttribute(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_eReferenceType_reference_EReference(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eReferenceType reference EReference");
	find mustInstanceOfEReference_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationeReferenceType_reference_EReference(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_eRawType_reference_EGenericType(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eRawType reference EGenericType");
	find mustInstanceOfEGenericType_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationeRawType_reference_EGenericType(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}

//////////
// 3.2 Unfinishedness Measured by WF Queries
//////////

//////////
// 4. Refinement Indexers
//////////
// 4.1 Object constructors
//////////
private pattern hasElementInContainment(problem:LogicProblem, interpretation:PartialInterpretation)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfEOperation_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfENamedElement_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfEEnumLiteral_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfEGenericType_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfEObject_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfEAttribute_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfEPackage_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfEParameter_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfEDataType_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfEClassifier_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfEStructuralFeature_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfEModelElement_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfEAnnotation_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfETypeParameter_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfEReference_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfEEnum_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfETypedElement_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfEClass_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfEModelElement_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfEModelElement_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfENamedElement_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfENamedElement_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfEPackage_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfEPackage_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}
pattern createObject_EAnnotation_class_by_eAnnotations_reference_EModelElement_with_eModelElement_reference_EAnnotation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"EAnnotation class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"eAnnotations reference EModelElement");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"eModelElement reference EAnnotation");
	find mustInstanceOfEModelElement_class(problem,interpretation,container);
	find mayInstanceOfEAnnotation_class(problem,interpretation,newObject);
	find mayInRelationeAnnotations_reference_EModelElement(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_EAnnotation_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"EAnnotation class");
	find mayInstanceOfEAnnotation_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_EEnum_class_by_eClassifiers_reference_EPackage_with_ePackage_reference_EClassifier(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"EEnum class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"eClassifiers reference EPackage");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"ePackage reference EClassifier");
	find mustInstanceOfEPackage_class(problem,interpretation,container);
	find mayInstanceOfEEnum_class(problem,interpretation,newObject);
	find mayInRelationeClassifiers_reference_EPackage(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_EEnum_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"EEnum class");
	find mayInstanceOfEEnum_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_EParameter_class_by_eParameters_reference_EOperation_with_eOperation_reference_EParameter(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"EParameter class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"eParameters reference EOperation");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"eOperation reference EParameter");
	find mustInstanceOfEOperation_class(problem,interpretation,container);
	find mayInstanceOfEParameter_class(problem,interpretation,newObject);
	find mayInRelationeParameters_reference_EOperation(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_EParameter_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"EParameter class");
	find mayInstanceOfEParameter_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_EPackage_class_UndefinedPart_by_eSubpackages_reference_EPackage_with_eSuperPackage_reference_EPackage(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"EPackage class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"eSubpackages reference EPackage");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"eSuperPackage reference EPackage");
	find mustInstanceOfEPackage_class(problem,interpretation,container);
	find mayInstanceOfEPackage_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationeSubpackages_reference_EPackage(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_EPackage_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"EPackage class UndefinedPart");
	find mayInstanceOfEPackage_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_EClass_class_by_eClassifiers_reference_EPackage_with_ePackage_reference_EClassifier(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"EClass class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"eClassifiers reference EPackage");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"ePackage reference EClassifier");
	find mustInstanceOfEPackage_class(problem,interpretation,container);
	find mayInstanceOfEClass_class(problem,interpretation,newObject);
	find mayInRelationeClassifiers_reference_EPackage(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_EClass_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"EClass class");
	find mayInstanceOfEClass_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_EOperation_class_by_eOperations_reference_EClass_with_eContainingClass_reference_EOperation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"EOperation class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"eOperations reference EClass");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"eContainingClass reference EOperation");
	find mustInstanceOfEClass_class(problem,interpretation,container);
	find mayInstanceOfEOperation_class(problem,interpretation,newObject);
	find mayInRelationeOperations_reference_EClass(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_EOperation_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"EOperation class");
	find mayInstanceOfEOperation_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_EReference_class_by_eStructuralFeatures_reference_EClass_with_eContainingClass_reference_EStructuralFeature(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"EReference class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"eStructuralFeatures reference EClass");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"eContainingClass reference EStructuralFeature");
	find mustInstanceOfEClass_class(problem,interpretation,container);
	find mayInstanceOfEReference_class(problem,interpretation,newObject);
	find mayInRelationeStructuralFeatures_reference_EClass(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_EReference_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"EReference class");
	find mayInstanceOfEReference_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_EObject_class_by_contents_reference_EAnnotation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"EObject class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"contents reference EAnnotation");
	find mustInstanceOfEAnnotation_class(problem,interpretation,container);
	find mayInstanceOfEObject_class(problem,interpretation,newObject);
	find mayInRelationcontents_reference_EAnnotation(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_EObject_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"EObject class");
	find mayInstanceOfEObject_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_EEnumLiteral_class_by_eLiterals_reference_EEnum_with_eEnum_reference_EEnumLiteral(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"EEnumLiteral class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"eLiterals reference EEnum");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"eEnum reference EEnumLiteral");
	find mustInstanceOfEEnum_class(problem,interpretation,container);
	find mayInstanceOfEEnumLiteral_class(problem,interpretation,newObject);
	find mayInRelationeLiterals_reference_EEnum(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_EEnumLiteral_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"EEnumLiteral class");
	find mayInstanceOfEEnumLiteral_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_EAttribute_class_by_eStructuralFeatures_reference_EClass_with_eContainingClass_reference_EStructuralFeature(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"EAttribute class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"eStructuralFeatures reference EClass");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"eContainingClass reference EStructuralFeature");
	find mustInstanceOfEClass_class(problem,interpretation,container);
	find mayInstanceOfEAttribute_class(problem,interpretation,newObject);
	find mayInRelationeStructuralFeatures_reference_EClass(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_EAttribute_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"EAttribute class");
	find mayInstanceOfEAttribute_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_EDataType_class_by_eClassifiers_reference_EPackage_with_ePackage_reference_EClassifier(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"EDataType class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"eClassifiers reference EPackage");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"ePackage reference EClassifier");
	find mustInstanceOfEPackage_class(problem,interpretation,container);
	find mayInstanceOfEDataType_class(problem,interpretation,newObject);
	find mayInRelationeClassifiers_reference_EPackage(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_EDataType_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"EDataType class");
	find mayInstanceOfEDataType_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_EGenericType_class_by_eGenericSuperTypes_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"EGenericType class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"eGenericSuperTypes reference EClass");
	find mustInstanceOfEClass_class(problem,interpretation,container);
	find mayInstanceOfEGenericType_class(problem,interpretation,newObject);
	find mayInRelationeGenericSuperTypes_reference_EClass(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_EGenericType_class_by_eGenericExceptions_reference_EOperation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"EGenericType class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"eGenericExceptions reference EOperation");
	find mustInstanceOfEOperation_class(problem,interpretation,container);
	find mayInstanceOfEGenericType_class(problem,interpretation,newObject);
	find mayInRelationeGenericExceptions_reference_EOperation(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_EGenericType_class_by_eGenericType_reference_ETypedElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"EGenericType class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"eGenericType reference ETypedElement");
	find mustInstanceOfETypedElement_class(problem,interpretation,container);
	find mayInstanceOfEGenericType_class(problem,interpretation,newObject);
	find mayInRelationeGenericType_reference_ETypedElement(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_EGenericType_class_by_eUpperBound_reference_EGenericType(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"EGenericType class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"eUpperBound reference EGenericType");
	find mustInstanceOfEGenericType_class(problem,interpretation,container);
	find mayInstanceOfEGenericType_class(problem,interpretation,newObject);
	find mayInRelationeUpperBound_reference_EGenericType(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_EGenericType_class_by_eTypeArguments_reference_EGenericType(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"EGenericType class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"eTypeArguments reference EGenericType");
	find mustInstanceOfEGenericType_class(problem,interpretation,container);
	find mayInstanceOfEGenericType_class(problem,interpretation,newObject);
	find mayInRelationeTypeArguments_reference_EGenericType(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_EGenericType_class_by_eLowerBound_reference_EGenericType(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"EGenericType class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"eLowerBound reference EGenericType");
	find mustInstanceOfEGenericType_class(problem,interpretation,container);
	find mayInstanceOfEGenericType_class(problem,interpretation,newObject);
	find mayInRelationeLowerBound_reference_EGenericType(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_EGenericType_class_by_eBounds_reference_ETypeParameter(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"EGenericType class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"eBounds reference ETypeParameter");
	find mustInstanceOfETypeParameter_class(problem,interpretation,container);
	find mayInstanceOfEGenericType_class(problem,interpretation,newObject);
	find mayInRelationeBounds_reference_ETypeParameter(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_EGenericType_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"EGenericType class");
	find mayInstanceOfEGenericType_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_EStringToStringMapEntry_class_by_details_reference_EAnnotation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"EStringToStringMapEntry class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"details reference EAnnotation");
	find mustInstanceOfEAnnotation_class(problem,interpretation,container);
	find mayInstanceOfEStringToStringMapEntry_class(problem,interpretation,newObject);
	find mayInRelationdetails_reference_EAnnotation(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_EStringToStringMapEntry_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"EStringToStringMapEntry class");
	find mayInstanceOfEStringToStringMapEntry_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_ETypeParameter_class_by_eTypeParameters_reference_EClassifier(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"ETypeParameter class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"eTypeParameters reference EClassifier");
	find mustInstanceOfEClassifier_class(problem,interpretation,container);
	find mayInstanceOfETypeParameter_class(problem,interpretation,newObject);
	find mayInRelationeTypeParameters_reference_EClassifier(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_ETypeParameter_class_by_eTypeParameters_reference_EOperation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"ETypeParameter class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"eTypeParameters reference EOperation");
	find mustInstanceOfEOperation_class(problem,interpretation,container);
	find mayInstanceOfETypeParameter_class(problem,interpretation,newObject);
	find mayInRelationeTypeParameters_reference_EOperation(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_ETypeParameter_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"ETypeParameter class");
	find mayInstanceOfETypeParameter_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}

//////////
// 4.2 Type refinement
//////////
pattern refineTypeTo_EAnnotation_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfENamedElement_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
}
pattern refineTypeTo_EEnum_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfEEnum_class(problem,interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEPackage_class(problem,interpretation,element);
	neg find mustInstanceOfEEnum_class(problem,interpretation,element);
	neg find mustInstanceOfETypedElement_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEClass_class(problem,interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfETypeParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfEEnumLiteral_class(problem,interpretation,element);
}
pattern refineTypeTo_EParameter_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfEParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEPackage_class(problem,interpretation,element);
	neg find mustInstanceOfEParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfETypeParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEOperation_class(problem,interpretation,element);
	neg find mustInstanceOfEStructuralFeature_class(problem,interpretation,element);
	neg find mustInstanceOfEClassifier_class(problem,interpretation,element);
	neg find mustInstanceOfEEnumLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
}
pattern refineTypeTo_EPackage_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfEPackage_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfETypedElement_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEPackage_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfETypeParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEClassifier_class(problem,interpretation,element);
	neg find mustInstanceOfEEnumLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
}
pattern refineTypeTo_EClass_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfEClass_class(problem,interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEPackage_class(problem,interpretation,element);
	neg find mustInstanceOfETypedElement_class(problem,interpretation,element);
	neg find mustInstanceOfEDataType_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEClass_class(problem,interpretation,element);
	neg find mustInstanceOfETypeParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEEnumLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
}
pattern refineTypeTo_EOperation_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfEOperation_class(problem,interpretation,element);
	neg find mustInstanceOfEPackage_class(problem,interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfETypeParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEOperation_class(problem,interpretation,element);
	neg find mustInstanceOfEStructuralFeature_class(problem,interpretation,element);
	neg find mustInstanceOfEClassifier_class(problem,interpretation,element);
	neg find mustInstanceOfEEnumLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
}
pattern refineTypeTo_EReference_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfEReference_class(problem,interpretation,element);
	neg find mustInstanceOfEPackage_class(problem,interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEAttribute_class(problem,interpretation,element);
	neg find mustInstanceOfEParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfETypeParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEReference_class(problem,interpretation,element);
	neg find mustInstanceOfEOperation_class(problem,interpretation,element);
	neg find mustInstanceOfEClassifier_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfEEnumLiteral_class(problem,interpretation,element);
}
pattern refineTypeTo_EObject_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEModelElement_class(problem,interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
}
pattern refineTypeTo_EEnumLiteral_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfEEnumLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEPackage_class(problem,interpretation,element);
	neg find mustInstanceOfETypedElement_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfETypeParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEClassifier_class(problem,interpretation,element);
	neg find mustInstanceOfEEnumLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
}
pattern refineTypeTo_EAttribute_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfEAttribute_class(problem,interpretation,element);
	neg find mustInstanceOfEPackage_class(problem,interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEAttribute_class(problem,interpretation,element);
	neg find mustInstanceOfEParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfETypeParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEReference_class(problem,interpretation,element);
	neg find mustInstanceOfEOperation_class(problem,interpretation,element);
	neg find mustInstanceOfEClassifier_class(problem,interpretation,element);
	neg find mustInstanceOfEEnumLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
}
pattern refineTypeTo_EDataType_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfEDataType_class(problem,interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEPackage_class(problem,interpretation,element);
	neg find mustInstanceOfEDataType_class(problem,interpretation,element);
	neg find mustInstanceOfEEnum_class(problem,interpretation,element);
	neg find mustInstanceOfETypedElement_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEClass_class(problem,interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfETypeParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEEnumLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
}
pattern refineTypeTo_EGenericType_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEModelElement_class(problem,interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
}
pattern refineTypeTo_EStringToStringMapEntry_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEModelElement_class(problem,interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
}
pattern refineTypeTo_ETypeParameter_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfETypeParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEPackage_class(problem,interpretation,element);
	neg find mustInstanceOfETypedElement_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfETypeParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEClassifier_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfEEnumLiteral_class(problem,interpretation,element);
}

//////////
// 4.3 Relation refinement
//////////
pattern refineRelation_eAttributeType_reference_EAttribute(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eAttributeType reference EAttribute");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEAttribute_class(problem,interpretation,from);
	find mustInstanceOfEDataType_class(problem,interpretation,to);
	find mayInRelationeAttributeType_reference_EAttribute(problem,interpretation,from,to);
	neg find mustInRelationeAttributeType_reference_EAttribute(problem,interpretation,from,to);
}
pattern refineRelation_references_reference_EAnnotation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"references reference EAnnotation");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEAnnotation_class(problem,interpretation,from);
	find mustInstanceOfEObject_class(problem,interpretation,to);
	find mayInRelationreferences_reference_EAnnotation(problem,interpretation,from,to);
	neg find mustInRelationreferences_reference_EAnnotation(problem,interpretation,from,to);
}
pattern refineRelation_eSuperTypes_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eSuperTypes reference EClass");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEClass_class(problem,interpretation,from);
	find mustInstanceOfEClass_class(problem,interpretation,to);
	find mayInRelationeSuperTypes_reference_EClass(problem,interpretation,from,to);
	neg find mustInRelationeSuperTypes_reference_EClass(problem,interpretation,from,to);
}
pattern refineRelation_eAllAttributes_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eAllAttributes reference EClass");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEClass_class(problem,interpretation,from);
	find mustInstanceOfEAttribute_class(problem,interpretation,to);
	find mayInRelationeAllAttributes_reference_EClass(problem,interpretation,from,to);
	neg find mustInRelationeAllAttributes_reference_EClass(problem,interpretation,from,to);
}
pattern refineRelation_eAllReferences_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eAllReferences reference EClass");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEClass_class(problem,interpretation,from);
	find mustInstanceOfEReference_class(problem,interpretation,to);
	find mayInRelationeAllReferences_reference_EClass(problem,interpretation,from,to);
	neg find mustInRelationeAllReferences_reference_EClass(problem,interpretation,from,to);
}
pattern refineRelation_eReferences_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eReferences reference EClass");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEClass_class(problem,interpretation,from);
	find mustInstanceOfEReference_class(problem,interpretation,to);
	find mayInRelationeReferences_reference_EClass(problem,interpretation,from,to);
	neg find mustInRelationeReferences_reference_EClass(problem,interpretation,from,to);
}
pattern refineRelation_eAttributes_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eAttributes reference EClass");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEClass_class(problem,interpretation,from);
	find mustInstanceOfEAttribute_class(problem,interpretation,to);
	find mayInRelationeAttributes_reference_EClass(problem,interpretation,from,to);
	neg find mustInRelationeAttributes_reference_EClass(problem,interpretation,from,to);
}
pattern refineRelation_eAllContainments_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eAllContainments reference EClass");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEClass_class(problem,interpretation,from);
	find mustInstanceOfEReference_class(problem,interpretation,to);
	find mayInRelationeAllContainments_reference_EClass(problem,interpretation,from,to);
	neg find mustInRelationeAllContainments_reference_EClass(problem,interpretation,from,to);
}
pattern refineRelation_eAllOperations_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eAllOperations reference EClass");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEClass_class(problem,interpretation,from);
	find mustInstanceOfEOperation_class(problem,interpretation,to);
	find mayInRelationeAllOperations_reference_EClass(problem,interpretation,from,to);
	neg find mustInRelationeAllOperations_reference_EClass(problem,interpretation,from,to);
}
pattern refineRelation_eAllStructuralFeatures_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eAllStructuralFeatures reference EClass");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEClass_class(problem,interpretation,from);
	find mustInstanceOfEStructuralFeature_class(problem,interpretation,to);
	find mayInRelationeAllStructuralFeatures_reference_EClass(problem,interpretation,from,to);
	neg find mustInRelationeAllStructuralFeatures_reference_EClass(problem,interpretation,from,to);
}
pattern refineRelation_eAllSuperTypes_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eAllSuperTypes reference EClass");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEClass_class(problem,interpretation,from);
	find mustInstanceOfEClass_class(problem,interpretation,to);
	find mayInRelationeAllSuperTypes_reference_EClass(problem,interpretation,from,to);
	neg find mustInRelationeAllSuperTypes_reference_EClass(problem,interpretation,from,to);
}
pattern refineRelation_eIDAttribute_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eIDAttribute reference EClass");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEClass_class(problem,interpretation,from);
	find mustInstanceOfEAttribute_class(problem,interpretation,to);
	find mayInRelationeIDAttribute_reference_EClass(problem,interpretation,from,to);
	neg find mustInRelationeIDAttribute_reference_EClass(problem,interpretation,from,to);
}
pattern refineRelation_eAllGenericSuperTypes_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eAllGenericSuperTypes reference EClass");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEClass_class(problem,interpretation,from);
	find mustInstanceOfEGenericType_class(problem,interpretation,to);
	find mayInRelationeAllGenericSuperTypes_reference_EClass(problem,interpretation,from,to);
	neg find mustInRelationeAllGenericSuperTypes_reference_EClass(problem,interpretation,from,to);
}
pattern refineRelation_eExceptions_reference_EOperation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eExceptions reference EOperation");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEOperation_class(problem,interpretation,from);
	find mustInstanceOfEClassifier_class(problem,interpretation,to);
	find mayInRelationeExceptions_reference_EOperation(problem,interpretation,from,to);
	neg find mustInRelationeExceptions_reference_EOperation(problem,interpretation,from,to);
}
pattern refineRelation_eOpposite_reference_EReference(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eOpposite reference EReference");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEReference_class(problem,interpretation,from);
	find mustInstanceOfEReference_class(problem,interpretation,to);
	find mayInRelationeOpposite_reference_EReference(problem,interpretation,from,to);
	neg find mustInRelationeOpposite_reference_EReference(problem,interpretation,from,to);
}
pattern refineRelation_eReferenceType_reference_EReference(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eReferenceType reference EReference");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEReference_class(problem,interpretation,from);
	find mustInstanceOfEClass_class(problem,interpretation,to);
	find mayInRelationeReferenceType_reference_EReference(problem,interpretation,from,to);
	neg find mustInRelationeReferenceType_reference_EReference(problem,interpretation,from,to);
}
pattern refineRelation_eKeys_reference_EReference(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eKeys reference EReference");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEReference_class(problem,interpretation,from);
	find mustInstanceOfEAttribute_class(problem,interpretation,to);
	find mayInRelationeKeys_reference_EReference(problem,interpretation,from,to);
	neg find mustInRelationeKeys_reference_EReference(problem,interpretation,from,to);
}
pattern refineRelation_eType_reference_ETypedElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eType reference ETypedElement");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfETypedElement_class(problem,interpretation,from);
	find mustInstanceOfEClassifier_class(problem,interpretation,to);
	find mayInRelationeType_reference_ETypedElement(problem,interpretation,from,to);
	neg find mustInRelationeType_reference_ETypedElement(problem,interpretation,from,to);
}
pattern refineRelation_eRawType_reference_EGenericType(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eRawType reference EGenericType");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEGenericType_class(problem,interpretation,from);
	find mustInstanceOfEClassifier_class(problem,interpretation,to);
	find mayInRelationeRawType_reference_EGenericType(problem,interpretation,from,to);
	neg find mustInRelationeRawType_reference_EGenericType(problem,interpretation,from,to);
}
pattern refineRelation_eTypeParameter_reference_EGenericType(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eTypeParameter reference EGenericType");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEGenericType_class(problem,interpretation,from);
	find mustInstanceOfETypeParameter_class(problem,interpretation,to);
	find mayInRelationeTypeParameter_reference_EGenericType(problem,interpretation,from,to);
	neg find mustInRelationeTypeParameter_reference_EGenericType(problem,interpretation,from,to);
}
pattern refineRelation_eClassifier_reference_EGenericType(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eClassifier reference EGenericType");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEGenericType_class(problem,interpretation,from);
	find mustInstanceOfEClassifier_class(problem,interpretation,to);
	find mayInRelationeClassifier_reference_EGenericType(problem,interpretation,from,to);
	neg find mustInRelationeClassifier_reference_EGenericType(problem,interpretation,from,to);
}
pattern refineRelation_iD_attribute_EAttribute(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"iD attribute EAttribute");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEAttribute_class(problem,interpretation,from);
	BooleanElement(to);
	find mayInRelationiD_attribute_EAttribute(problem,interpretation,from,to);
	neg find mustInRelationiD_attribute_EAttribute(problem,interpretation,from,to);
}
pattern refineRelation_source_attribute_EAnnotation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"source attribute EAnnotation");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEAnnotation_class(problem,interpretation,from);
	StringElement(to);
	find mayInRelationsource_attribute_EAnnotation(problem,interpretation,from,to);
	neg find mustInRelationsource_attribute_EAnnotation(problem,interpretation,from,to);
}
pattern refineRelation_abstract_attribute_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"abstract attribute EClass");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEClass_class(problem,interpretation,from);
	BooleanElement(to);
	find mayInRelationabstract_attribute_EClass(problem,interpretation,from,to);
	neg find mustInRelationabstract_attribute_EClass(problem,interpretation,from,to);
}
pattern refineRelation_interface_attribute_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"interface attribute EClass");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEClass_class(problem,interpretation,from);
	BooleanElement(to);
	find mayInRelationinterface_attribute_EClass(problem,interpretation,from,to);
	neg find mustInRelationinterface_attribute_EClass(problem,interpretation,from,to);
}
pattern refineRelation_instanceClassName_attribute_EClassifier(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"instanceClassName attribute EClassifier");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEClassifier_class(problem,interpretation,from);
	StringElement(to);
	find mayInRelationinstanceClassName_attribute_EClassifier(problem,interpretation,from,to);
	neg find mustInRelationinstanceClassName_attribute_EClassifier(problem,interpretation,from,to);
}
pattern refineRelation_instanceTypeName_attribute_EClassifier(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"instanceTypeName attribute EClassifier");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEClassifier_class(problem,interpretation,from);
	StringElement(to);
	find mayInRelationinstanceTypeName_attribute_EClassifier(problem,interpretation,from,to);
	neg find mustInRelationinstanceTypeName_attribute_EClassifier(problem,interpretation,from,to);
}
pattern refineRelation_serializable_attribute_EDataType(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"serializable attribute EDataType");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEDataType_class(problem,interpretation,from);
	BooleanElement(to);
	find mayInRelationserializable_attribute_EDataType(problem,interpretation,from,to);
	neg find mustInRelationserializable_attribute_EDataType(problem,interpretation,from,to);
}
pattern refineRelation_value_attribute_EEnumLiteral(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"value attribute EEnumLiteral");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEEnumLiteral_class(problem,interpretation,from);
	IntegerElement(to);
	find mayInRelationvalue_attribute_EEnumLiteral(problem,interpretation,from,to);
	neg find mustInRelationvalue_attribute_EEnumLiteral(problem,interpretation,from,to);
}
pattern refineRelation_literal_attribute_EEnumLiteral(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"literal attribute EEnumLiteral");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEEnumLiteral_class(problem,interpretation,from);
	StringElement(to);
	find mayInRelationliteral_attribute_EEnumLiteral(problem,interpretation,from,to);
	neg find mustInRelationliteral_attribute_EEnumLiteral(problem,interpretation,from,to);
}
pattern refineRelation_name_attribute_ENamedElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"name attribute ENamedElement");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfENamedElement_class(problem,interpretation,from);
	StringElement(to);
	find mayInRelationname_attribute_ENamedElement(problem,interpretation,from,to);
	neg find mustInRelationname_attribute_ENamedElement(problem,interpretation,from,to);
}
pattern refineRelation_nsURI_attribute_EPackage(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"nsURI attribute EPackage");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEPackage_class(problem,interpretation,from);
	StringElement(to);
	find mayInRelationnsURI_attribute_EPackage(problem,interpretation,from,to);
	neg find mustInRelationnsURI_attribute_EPackage(problem,interpretation,from,to);
}
pattern refineRelation_nsPrefix_attribute_EPackage(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"nsPrefix attribute EPackage");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEPackage_class(problem,interpretation,from);
	StringElement(to);
	find mayInRelationnsPrefix_attribute_EPackage(problem,interpretation,from,to);
	neg find mustInRelationnsPrefix_attribute_EPackage(problem,interpretation,from,to);
}
pattern refineRelation_containment_attribute_EReference(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"containment attribute EReference");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEReference_class(problem,interpretation,from);
	BooleanElement(to);
	find mayInRelationcontainment_attribute_EReference(problem,interpretation,from,to);
	neg find mustInRelationcontainment_attribute_EReference(problem,interpretation,from,to);
}
pattern refineRelation_container_attribute_EReference(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"container attribute EReference");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEReference_class(problem,interpretation,from);
	BooleanElement(to);
	find mayInRelationcontainer_attribute_EReference(problem,interpretation,from,to);
	neg find mustInRelationcontainer_attribute_EReference(problem,interpretation,from,to);
}
pattern refineRelation_resolveProxies_attribute_EReference(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"resolveProxies attribute EReference");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEReference_class(problem,interpretation,from);
	BooleanElement(to);
	find mayInRelationresolveProxies_attribute_EReference(problem,interpretation,from,to);
	neg find mustInRelationresolveProxies_attribute_EReference(problem,interpretation,from,to);
}
pattern refineRelation_changeable_attribute_EStructuralFeature(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"changeable attribute EStructuralFeature");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEStructuralFeature_class(problem,interpretation,from);
	BooleanElement(to);
	find mayInRelationchangeable_attribute_EStructuralFeature(problem,interpretation,from,to);
	neg find mustInRelationchangeable_attribute_EStructuralFeature(problem,interpretation,from,to);
}
pattern refineRelation_volatile_attribute_EStructuralFeature(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"volatile attribute EStructuralFeature");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEStructuralFeature_class(problem,interpretation,from);
	BooleanElement(to);
	find mayInRelationvolatile_attribute_EStructuralFeature(problem,interpretation,from,to);
	neg find mustInRelationvolatile_attribute_EStructuralFeature(problem,interpretation,from,to);
}
pattern refineRelation_transient_attribute_EStructuralFeature(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"transient attribute EStructuralFeature");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEStructuralFeature_class(problem,interpretation,from);
	BooleanElement(to);
	find mayInRelationtransient_attribute_EStructuralFeature(problem,interpretation,from,to);
	neg find mustInRelationtransient_attribute_EStructuralFeature(problem,interpretation,from,to);
}
pattern refineRelation_defaultValueLiteral_attribute_EStructuralFeature(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"defaultValueLiteral attribute EStructuralFeature");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEStructuralFeature_class(problem,interpretation,from);
	StringElement(to);
	find mayInRelationdefaultValueLiteral_attribute_EStructuralFeature(problem,interpretation,from,to);
	neg find mustInRelationdefaultValueLiteral_attribute_EStructuralFeature(problem,interpretation,from,to);
}
pattern refineRelation_unsettable_attribute_EStructuralFeature(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"unsettable attribute EStructuralFeature");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEStructuralFeature_class(problem,interpretation,from);
	BooleanElement(to);
	find mayInRelationunsettable_attribute_EStructuralFeature(problem,interpretation,from,to);
	neg find mustInRelationunsettable_attribute_EStructuralFeature(problem,interpretation,from,to);
}
pattern refineRelation_derived_attribute_EStructuralFeature(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"derived attribute EStructuralFeature");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEStructuralFeature_class(problem,interpretation,from);
	BooleanElement(to);
	find mayInRelationderived_attribute_EStructuralFeature(problem,interpretation,from,to);
	neg find mustInRelationderived_attribute_EStructuralFeature(problem,interpretation,from,to);
}
pattern refineRelation_ordered_attribute_ETypedElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"ordered attribute ETypedElement");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfETypedElement_class(problem,interpretation,from);
	BooleanElement(to);
	find mayInRelationordered_attribute_ETypedElement(problem,interpretation,from,to);
	neg find mustInRelationordered_attribute_ETypedElement(problem,interpretation,from,to);
}
pattern refineRelation_unique_attribute_ETypedElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"unique attribute ETypedElement");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfETypedElement_class(problem,interpretation,from);
	BooleanElement(to);
	find mayInRelationunique_attribute_ETypedElement(problem,interpretation,from,to);
	neg find mustInRelationunique_attribute_ETypedElement(problem,interpretation,from,to);
}
pattern refineRelation_lowerBound_attribute_ETypedElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"lowerBound attribute ETypedElement");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfETypedElement_class(problem,interpretation,from);
	IntegerElement(to);
	find mayInRelationlowerBound_attribute_ETypedElement(problem,interpretation,from,to);
	neg find mustInRelationlowerBound_attribute_ETypedElement(problem,interpretation,from,to);
}
pattern refineRelation_upperBound_attribute_ETypedElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"upperBound attribute ETypedElement");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfETypedElement_class(problem,interpretation,from);
	IntegerElement(to);
	find mayInRelationupperBound_attribute_ETypedElement(problem,interpretation,from,to);
	neg find mustInRelationupperBound_attribute_ETypedElement(problem,interpretation,from,to);
}
pattern refineRelation_many_attribute_ETypedElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"many attribute ETypedElement");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfETypedElement_class(problem,interpretation,from);
	BooleanElement(to);
	find mayInRelationmany_attribute_ETypedElement(problem,interpretation,from,to);
	neg find mustInRelationmany_attribute_ETypedElement(problem,interpretation,from,to);
}
pattern refineRelation_required_attribute_ETypedElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"required attribute ETypedElement");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfETypedElement_class(problem,interpretation,from);
	BooleanElement(to);
	find mayInRelationrequired_attribute_ETypedElement(problem,interpretation,from,to);
	neg find mustInRelationrequired_attribute_ETypedElement(problem,interpretation,from,to);
}
pattern refineRelation_key_attribute_EStringToStringMapEntry(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"key attribute EStringToStringMapEntry");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,from);
	StringElement(to);
	find mayInRelationkey_attribute_EStringToStringMapEntry(problem,interpretation,from,to);
	neg find mustInRelationkey_attribute_EStringToStringMapEntry(problem,interpretation,from,to);
}
pattern refineRelation_value_attribute_EStringToStringMapEntry(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"value attribute EStringToStringMapEntry");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,from);
	StringElement(to);
	find mayInRelationvalue_attribute_EStringToStringMapEntry(problem,interpretation,from,to);
	neg find mustInRelationvalue_attribute_EStringToStringMapEntry(problem,interpretation,from,to);
}
import epackage "http://www.bme.hu/mit/inf/dslreasoner/viatrasolver/partialinterpretationlanguage"
import epackage "http://www.bme.hu/mit/inf/dslreasoner/logic/model/problem"
import epackage "http://www.bme.hu/mit/inf/dslreasoner/logic/model/language"

//////////
// 0. Util
//////////
private pattern interpretation(problem:LogicProblem, interpretation:PartialInterpretation) {
	PartialInterpretation.problem(interpretation,problem);
}
	
/////////////////////////
// 0.1 Existence
/////////////////////////
private pattern mustExist(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	find interpretation(problem,interpretation);
	LogicProblem.elements(problem,element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
}

private pattern mayExist(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
    find mustExist(problem,interpretation,element);
} or {
    find interpretation(problem,interpretation);
    neg find elementCloseWorld(element);
    PartialInterpretation.openWorldElements(interpretation,element);
}

private pattern elementCloseWorld(element:DefinedElement) {
	PartialInterpretation.openWorldElements(i,element);
    PartialInterpretation.maxNewElements(i,0);
} or {
	Scope.targetTypeInterpretation(scope,interpretation);
	PartialTypeInterpratation.elements(interpretation,element);
	Scope.maxNewElements(scope,0);
}

////////////////////////
// 0.2 Equivalence
////////////////////////
pattern mayEquivalent(problem:LogicProblem, interpretation:PartialInterpretation, a: DefinedElement, b: DefinedElement) {
	find mayExist(problem,interpretation,a);
	find mayExist(problem,interpretation,b);
	a == b;
}

////////////////////////
// 0.3 Required Patterns by TypeIndexer
////////////////////////
private pattern typeInterpretation(problem:LogicProblem, interpretation:PartialInterpretation, type:TypeDeclaration, typeInterpretation:PartialComplexTypeInterpretation) {
	find interpretation(problem,interpretation);
	LogicProblem.types(problem,type);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
}

private pattern directInstanceOf(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement, type:Type) {
	find interpretation(problem,interpretation);
	LogicProblem.types(problem,type);
	TypeDefinition.elements(type,element);
} or {
	find interpretation(problem,interpretation);
	find typeInterpretation(problem,interpretation,type,typeInterpretation);
	PartialComplexTypeInterpretation.elements(typeInterpretation,element);
}

private pattern isPrimitive(element: PrimitiveElement) {
	PrimitiveElement(element);
}

//////////
// 1. Problem-Specific Base Indexers
//////////
// 1.1 Type Indexers
//////////
// 1.1.1 primitive Type Indexers
//////////

//////////
// 1.1.2 domain-specific Type Indexers
//////////
/**
 * An element must be an instance of type "FunctionalElement class".
 */
private pattern mustInstanceOfFunctionalElement_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalElement class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalElement_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalElement class");
}

/**
 * An element may be an instance of type "FunctionalElement class".
 */
private pattern mayInstanceOfFunctionalElement_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunction_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalElement_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunction_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalElement_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalElement_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalArchitectureModel class".
 */
private pattern mustInstanceOfFunctionalArchitectureModel_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalArchitectureModel class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalArchitectureModel_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalArchitectureModel class");
}

/**
 * An element may be an instance of type "FunctionalArchitectureModel class".
 */
private pattern mayInstanceOfFunctionalArchitectureModel_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalArchitectureModel_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalArchitectureModel_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Function class".
 */
private pattern mustInstanceOfFunction_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Function class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunction_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Function class");
}

/**
 * An element may be an instance of type "Function class".
 */
private pattern mayInstanceOfFunction_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunction_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunction_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunction_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FAMTerminator class".
 */
private pattern mustInstanceOfFAMTerminator_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FAMTerminator class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFAMTerminator_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FAMTerminator class");
}

/**
 * An element may be an instance of type "FAMTerminator class".
 */
private pattern mayInstanceOfFAMTerminator_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find scopeDisallowsNewFAMTerminator_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find scopeDisallowsNewFAMTerminator_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFAMTerminator_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "InformationLink class".
 */
private pattern mustInstanceOfInformationLink_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"InformationLink class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewInformationLink_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"InformationLink class");
}

/**
 * An element may be an instance of type "InformationLink class".
 */
private pattern mayInstanceOfInformationLink_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find scopeDisallowsNewInformationLink_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find scopeDisallowsNewInformationLink_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfInformationLink_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalInterface class".
 */
private pattern mustInstanceOfFunctionalInterface_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalInterface class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalInterface_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalInterface class");
}

/**
 * An element may be an instance of type "FunctionalInterface class".
 */
private pattern mayInstanceOfFunctionalInterface_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalInterface_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalInterface_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalInterface_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalInput class".
 */
private pattern mustInstanceOfFunctionalInput_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalInput class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalInput_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalInput class");
}

/**
 * An element may be an instance of type "FunctionalInput class".
 */
private pattern mayInstanceOfFunctionalInput_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalInput_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalInput_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalInput_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalOutput class".
 */
private pattern mustInstanceOfFunctionalOutput_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalOutput class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalOutput_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalOutput class");
}

/**
 * An element may be an instance of type "FunctionalOutput class".
 */
private pattern mayInstanceOfFunctionalOutput_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalOutput_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalOutput_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalOutput_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalData class".
 */
private pattern mustInstanceOfFunctionalData_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalData class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalData_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalData class");
}

/**
 * An element may be an instance of type "FunctionalData class".
 */
private pattern mayInstanceOfFunctionalData_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalData_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalData_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalData_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionType enum".
 */
private pattern mustInstanceOfFunctionType_enum(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionType enum");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionType_enum(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionType enum");
}

/**
 * An element may be an instance of type "FunctionType enum".
 */
private pattern mayInstanceOfFunctionType_enum(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfFunctionType_enum(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalArchitectureModel class DefinedPart".
 */
private pattern mustInstanceOfFunctionalArchitectureModel_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalArchitectureModel class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalArchitectureModel_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalArchitectureModel class DefinedPart");
}

/**
 * An element may be an instance of type "FunctionalArchitectureModel class DefinedPart".
 */
private pattern mayInstanceOfFunctionalArchitectureModel_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfFunctionalArchitectureModel_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "FunctionalArchitectureModel class UndefinedPart".
 */
private pattern mustInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FunctionalArchitectureModel class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFunctionalArchitectureModel_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FunctionalArchitectureModel class UndefinedPart");
}

/**
 * An element may be an instance of type "FunctionalArchitectureModel class UndefinedPart".
 */
private pattern mayInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalArchitectureModel_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find scopeDisallowsNewFunctionalArchitectureModel_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem,interpretation,element); }

//////////
// 1.2 Relation Declaration Indexers
//////////
/**
 * Matcher for detecting tuples t where []interface reference FunctionalElement(source,target)
 */
private pattern mustInRelationinterface_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"interface reference FunctionalElement");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>interface reference FunctionalElement(source,target)
 */
private pattern mayInRelationinterface_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalElement_class(problem,interpretation,source);
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationinterface_reference_FunctionalElement(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationelement_reference_FunctionalInterface(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationinterface_reference_FunctionalElement(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []model reference FunctionalElement(source,target)
 */
private pattern mustInRelationmodel_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"model reference FunctionalElement");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>model reference FunctionalElement(source,target)
 */
private pattern mayInRelationmodel_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalElement_class(problem,interpretation,source);
	find mayInstanceOfFunctionalArchitectureModel_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationmodel_reference_FunctionalElement(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationmodel_reference_FunctionalElement(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []parent reference FunctionalElement(source,target)
 */
private pattern mustInRelationparent_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"parent reference FunctionalElement");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>parent reference FunctionalElement(source,target)
 */
private pattern mayInRelationparent_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalElement_class(problem,interpretation,source);
	find mayInstanceOfFunction_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationparent_reference_FunctionalElement(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationparent_reference_FunctionalElement(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []rootElements reference FunctionalArchitectureModel(source,target)
 */
private pattern mustInRelationrootElements_reference_FunctionalArchitectureModel(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"rootElements reference FunctionalArchitectureModel");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>rootElements reference FunctionalArchitectureModel(source,target)
 */
private pattern mayInRelationrootElements_reference_FunctionalArchitectureModel(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalArchitectureModel_class(problem,interpretation,source);
	find mayInstanceOfFunctionalElement_class(problem,interpretation,target);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationrootElements_reference_FunctionalArchitectureModel(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []subElements reference Function(source,target)
 */
private pattern mustInRelationsubElements_reference_Function(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"subElements reference Function");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>subElements reference Function(source,target)
 */
private pattern mayInRelationsubElements_reference_Function(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunction_class(problem,interpretation,source);
	find mayInstanceOfFunctionalElement_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationparent_reference_FunctionalElement(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationsubElements_reference_Function(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []data reference FAMTerminator(source,target)
 */
private pattern mustInRelationdata_reference_FAMTerminator(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"data reference FAMTerminator");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>data reference FAMTerminator(source,target)
 */
private pattern mayInRelationdata_reference_FAMTerminator(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFAMTerminator_class(problem,interpretation,source);
	find mayInstanceOfFunctionalData_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationdata_reference_FAMTerminator(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationterminator_reference_FunctionalData(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationdata_reference_FAMTerminator(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []from reference InformationLink(source,target)
 */
private pattern mustInRelationfrom_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"from reference InformationLink");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>from reference InformationLink(source,target)
 */
private pattern mayInRelationfrom_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfInformationLink_class(problem,interpretation,source);
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationfrom_reference_InformationLink(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationfrom_reference_InformationLink(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []to reference InformationLink(source,target)
 */
private pattern mustInRelationto_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"to reference InformationLink");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>to reference InformationLink(source,target)
 */
private pattern mayInRelationto_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfInformationLink_class(problem,interpretation,source);
	find mayInstanceOfFunctionalInput_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationto_reference_InformationLink(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationto_reference_InformationLink(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []data reference FunctionalInterface(source,target)
 */
private pattern mustInRelationdata_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"data reference FunctionalInterface");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>data reference FunctionalInterface(source,target)
 */
private pattern mayInRelationdata_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,source);
	find mayInstanceOfFunctionalData_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationinterface_reference_FunctionalData(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationdata_reference_FunctionalInterface(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []element reference FunctionalInterface(source,target)
 */
private pattern mustInRelationelement_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"element reference FunctionalInterface");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>element reference FunctionalInterface(source,target)
 */
private pattern mayInRelationelement_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,source);
	find mayInstanceOfFunctionalElement_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationelement_reference_FunctionalInterface(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationinterface_reference_FunctionalElement(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationelement_reference_FunctionalInterface(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []IncomingLinks reference FunctionalInput(source,target)
 */
private pattern mustInRelationIncomingLinks_reference_FunctionalInput(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"IncomingLinks reference FunctionalInput");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>IncomingLinks reference FunctionalInput(source,target)
 */
private pattern mayInRelationIncomingLinks_reference_FunctionalInput(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalInput_class(problem,interpretation,source);
	find mayInstanceOfInformationLink_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationto_reference_InformationLink(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
} or {
	find mustInRelationIncomingLinks_reference_FunctionalInput(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []outgoingLinks reference FunctionalOutput(source,target)
 */
private pattern mustInRelationoutgoingLinks_reference_FunctionalOutput(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"outgoingLinks reference FunctionalOutput");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>outgoingLinks reference FunctionalOutput(source,target)
 */
private pattern mayInRelationoutgoingLinks_reference_FunctionalOutput(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,source);
	find mayInstanceOfInformationLink_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationfrom_reference_InformationLink(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationoutgoingLinks_reference_FunctionalOutput(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []terminator reference FunctionalData(source,target)
 */
private pattern mustInRelationterminator_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"terminator reference FunctionalData");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>terminator reference FunctionalData(source,target)
 */
private pattern mayInRelationterminator_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalData_class(problem,interpretation,source);
	find mayInstanceOfFAMTerminator_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationterminator_reference_FunctionalData(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationdata_reference_FAMTerminator(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationterminator_reference_FunctionalData(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []interface reference FunctionalData(source,target)
 */
private pattern mustInRelationinterface_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"interface reference FunctionalData");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>interface reference FunctionalData(source,target)
 */
private pattern mayInRelationinterface_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunctionalData_class(problem,interpretation,source);
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationinterface_reference_FunctionalData(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationinterface_reference_FunctionalData(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []type attribute Function(source,target)
 */
private pattern mustInRelationtype_attribute_Function(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"type attribute Function");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>type attribute Function(source,target)
 */
private pattern mayInRelationtype_attribute_Function(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFunction_class(problem,interpretation,source);
	find mayInstanceOfFunctionType_enum(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationtype_attribute_Function(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationtype_attribute_Function(problem,interpretation,source,target);
}

//////////
// 1.3 Relation Definition Indexers
//////////

//////////
// 1.4 Containment Indexer
//////////
private pattern mustContains2(source: DefinedElement, target: DefinedElement) {
	find mustContains4(_,_,source,target);
}
	
private pattern mustContains4(problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target: DefinedElement)
	{ find mustInRelationinterface_reference_FunctionalElement(problem,interpretation,source,target); }or
	
	{ find mustInRelationrootElements_reference_FunctionalArchitectureModel(problem,interpretation,source,target); }or
	
	{ find mustInRelationsubElements_reference_Function(problem,interpretation,source,target); }or
	
	{ find mustInRelationdata_reference_FunctionalInterface(problem,interpretation,source,target); }or
	
	{ find mustInRelationoutgoingLinks_reference_FunctionalOutput(problem,interpretation,source,target); }or
	
	{ find mustInRelationterminator_reference_FunctionalData(problem,interpretation,source,target); }

private pattern mustTransitiveContains(source,target) {
	find mustContains2+(source,target);
}

//////////
// 2. Invalidation Indexers
//////////
// 2.1 Invalidated by WF Queries
//////////

//////////
// 3. Unfinishedness Indexers
//////////
// 3.1 Unfinishedness Measured by Multiplicity
//////////
pattern unfinishedLowerMultiplicity_model_reference_FunctionalElement(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"model reference FunctionalElement");
	find mustInstanceOfFunctionalElement_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationmodel_reference_FunctionalElement(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_to_reference_InformationLink(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"to reference InformationLink");
	find mustInstanceOfInformationLink_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationto_reference_InformationLink(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_type_attribute_Function(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"type attribute Function");
	find mustInstanceOfFunction_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationtype_attribute_Function(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}

//////////
// 3.2 Unfinishedness Measured by WF Queries
//////////

//////////
// 4. Refinement Indexers
//////////
// 4.1 Object constructors
//////////
private pattern hasElementInContainment(problem:LogicProblem, interpretation:PartialInterpretation)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalData_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunction_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFAMTerminator_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfInformationLink_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalInterface_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalElement_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalInput_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalOutput_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalArchitectureModel_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}
pattern createObject_FunctionalOutput_class_by_data_reference_FunctionalInterface_with_interface_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalOutput class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"data reference FunctionalInterface");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"interface reference FunctionalData");
	find mustInstanceOfFunctionalInterface_class(problem,interpretation,container);
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,newObject);
	find mayInRelationdata_reference_FunctionalInterface(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalOutput_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalOutput class");
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FAMTerminator_class_by_terminator_reference_FunctionalData_with_data_reference_FAMTerminator(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FAMTerminator class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"terminator reference FunctionalData");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"data reference FAMTerminator");
	find mustInstanceOfFunctionalData_class(problem,interpretation,container);
	find mayInstanceOfFAMTerminator_class(problem,interpretation,newObject);
	find mayInRelationterminator_reference_FunctionalData(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FAMTerminator_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FAMTerminator class");
	find mayInstanceOfFAMTerminator_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalInterface_class_by_interface_reference_FunctionalElement_with_element_reference_FunctionalInterface(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalInterface class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"interface reference FunctionalElement");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"element reference FunctionalInterface");
	find mustInstanceOfFunctionalElement_class(problem,interpretation,container);
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,newObject);
	find mayInRelationinterface_reference_FunctionalElement(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalInterface_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalInterface class");
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalArchitectureModel_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalArchitectureModel class UndefinedPart");
	find mayInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Function_class_by_rootElements_reference_FunctionalArchitectureModel(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Function class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"rootElements reference FunctionalArchitectureModel");
	find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,container);
	find mayInstanceOfFunction_class(problem,interpretation,newObject);
	find mayInRelationrootElements_reference_FunctionalArchitectureModel(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Function_class_by_subElements_reference_Function_with_parent_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Function class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"subElements reference Function");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"parent reference FunctionalElement");
	find mustInstanceOfFunction_class(problem,interpretation,container);
	find mayInstanceOfFunction_class(problem,interpretation,newObject);
	find mayInRelationsubElements_reference_Function(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Function_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Function class");
	find mayInstanceOfFunction_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_InformationLink_class_by_outgoingLinks_reference_FunctionalOutput_with_from_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"InformationLink class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"outgoingLinks reference FunctionalOutput");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"from reference InformationLink");
	find mustInstanceOfFunctionalOutput_class(problem,interpretation,container);
	find mayInstanceOfInformationLink_class(problem,interpretation,newObject);
	find mayInRelationoutgoingLinks_reference_FunctionalOutput(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_InformationLink_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"InformationLink class");
	find mayInstanceOfInformationLink_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalInput_class_by_data_reference_FunctionalInterface_with_interface_reference_FunctionalData(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalInput class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"data reference FunctionalInterface");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"interface reference FunctionalData");
	find mustInstanceOfFunctionalInterface_class(problem,interpretation,container);
	find mayInstanceOfFunctionalInput_class(problem,interpretation,newObject);
	find mayInRelationdata_reference_FunctionalInterface(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FunctionalInput_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FunctionalInput class");
	find mayInstanceOfFunctionalInput_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}

//////////
// 4.2 Type refinement
//////////
pattern refineTypeTo_FunctionalOutput_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
}
pattern refineTypeTo_FAMTerminator_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
}
pattern refineTypeTo_FunctionalInterface_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
}
pattern refineTypeTo_FunctionalArchitectureModel_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
}
pattern refineTypeTo_Function_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunction_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfFunction_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
}
pattern refineTypeTo_InformationLink_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalData_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
}
pattern refineTypeTo_FunctionalInput_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFunctionalInput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalOutput_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInterface_class(problem,interpretation,element);
	neg find mustInstanceOfFAMTerminator_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalElement_class(problem,interpretation,element);
	neg find mustInstanceOfInformationLink_class(problem,interpretation,element);
	neg find mustInstanceOfFunctionalInput_class(problem,interpretation,element);
}

//////////
// 4.3 Relation refinement
//////////
pattern refineRelation_model_reference_FunctionalElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"model reference FunctionalElement");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFunctionalElement_class(problem,interpretation,from);
	find mustInstanceOfFunctionalArchitectureModel_class(problem,interpretation,to);
	find mayInRelationmodel_reference_FunctionalElement(problem,interpretation,from,to);
	neg find mustInRelationmodel_reference_FunctionalElement(problem,interpretation,from,to);
}
pattern refineRelation_IncomingLinks_reference_FunctionalInput_and_to_reference_InformationLink(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation, oppositeInterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"IncomingLinks reference FunctionalInput");
	PartialInterpretation.partialrelationinterpretation(interpretation,oppositeInterpretation);
	PartialRelationInterpretation.interpretationOf.name(oppositeInterpretation,"to reference InformationLink");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFunctionalInput_class(problem,interpretation,from);
	find mustInstanceOfInformationLink_class(problem,interpretation,to);
	find mayInRelationIncomingLinks_reference_FunctionalInput(problem,interpretation,from,to);
	neg find mustInRelationIncomingLinks_reference_FunctionalInput(problem,interpretation,from,to);
}
pattern refineRelation_type_attribute_Function(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"type attribute Function");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFunction_class(problem,interpretation,from);
	find mustInstanceOfFunctionType_enum(problem,interpretation,to);
	find mayInRelationtype_attribute_Function(problem,interpretation,from,to);
	neg find mustInRelationtype_attribute_Function(problem,interpretation,from,to);
}
import epackage "http://www.bme.hu/mit/inf/dslreasoner/viatrasolver/partialinterpretationlanguage"
import epackage "http://www.bme.hu/mit/inf/dslreasoner/logic/model/problem"
import epackage "http://www.bme.hu/mit/inf/dslreasoner/logic/model/language"

//////////
// 0. Util
//////////
private pattern interpretation(problem:LogicProblem, interpretation:PartialInterpretation) {
	PartialInterpretation.problem(interpretation,problem);
}
	
/////////////////////////
// 0.1 Existence
/////////////////////////
private pattern mustExist(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	find interpretation(problem,interpretation);
	LogicProblem.elements(problem,element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
}

private pattern mayExist(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
    find mustExist(problem,interpretation,element);
} or {
    find interpretation(problem,interpretation);
    neg find elementCloseWorld(element);
    PartialInterpretation.openWorldElements(interpretation,element);
}

private pattern elementCloseWorld(element:DefinedElement) {
	PartialInterpretation.openWorldElements(i,element);
    PartialInterpretation.maxNewElements(i,0);
} or {
	Scope.targetTypeInterpretation(scope,interpretation);
	PartialTypeInterpratation.elements(interpretation,element);
	Scope.maxNewElements(scope,0);
}

////////////////////////
// 0.2 Equivalence
////////////////////////
pattern mayEquivalent(problem:LogicProblem, interpretation:PartialInterpretation, a: DefinedElement, b: DefinedElement) {
	find mayExist(problem,interpretation,a);
	find mayExist(problem,interpretation,b);
	a == b;
}

////////////////////////
// 0.3 Required Patterns by TypeIndexer
////////////////////////
private pattern typeInterpretation(problem:LogicProblem, interpretation:PartialInterpretation, type:TypeDeclaration, typeInterpretation:PartialComplexTypeInterpretation) {
	find interpretation(problem,interpretation);
	LogicProblem.types(problem,type);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
}

private pattern directInstanceOf(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement, type:Type) {
	find interpretation(problem,interpretation);
	LogicProblem.types(problem,type);
	TypeDefinition.elements(type,element);
} or {
	find interpretation(problem,interpretation);
	find typeInterpretation(problem,interpretation,type,typeInterpretation);
	PartialComplexTypeInterpretation.elements(typeInterpretation,element);
}

private pattern isPrimitive(element: PrimitiveElement) {
	PrimitiveElement(element);
}

//////////
// 1. Problem-Specific Base Indexers
//////////
// 1.1 Type Indexers
//////////
// 1.1.1 primitive Type Indexers
//////////

//////////
// 1.1.2 domain-specific Type Indexers
//////////
/**
 * An element must be an instance of type "EAttribute class".
 */
private pattern mustInstanceOfEAttribute_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"EAttribute class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewEAttribute_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"EAttribute class");
}

/**
 * An element may be an instance of type "EAttribute class".
 */
private pattern mayInstanceOfEAttribute_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEReference_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfEEnumLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfETypeParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEClassifier_class(problem,interpretation,element);
	neg find mustInstanceOfEPackage_class(problem,interpretation,element);
	neg find mustInstanceOfEOperation_class(problem,interpretation,element);
	neg find scopeDisallowsNewEAttribute_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEReference_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfEEnumLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfETypeParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEClassifier_class(problem,interpretation,element);
	neg find mustInstanceOfEPackage_class(problem,interpretation,element);
	neg find mustInstanceOfEOperation_class(problem,interpretation,element);
	neg find scopeDisallowsNewEAttribute_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfEAttribute_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "EAnnotation class".
 */
private pattern mustInstanceOfEAnnotation_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"EAnnotation class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewEAnnotation_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"EAnnotation class");
}

/**
 * An element may be an instance of type "EAnnotation class".
 */
private pattern mayInstanceOfEAnnotation_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfENamedElement_class(problem,interpretation,element);
	neg find scopeDisallowsNewEAnnotation_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfENamedElement_class(problem,interpretation,element);
	neg find scopeDisallowsNewEAnnotation_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfEAnnotation_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "EClass class".
 */
private pattern mustInstanceOfEClass_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"EClass class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewEClass_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"EClass class");
}

/**
 * An element may be an instance of type "EClass class".
 */
private pattern mayInstanceOfEClass_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfEDataType_class(problem,interpretation,element);
	neg find mustInstanceOfEEnumLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfETypeParameter_class(problem,interpretation,element);
	neg find mustInstanceOfETypedElement_class(problem,interpretation,element);
	neg find mustInstanceOfEPackage_class(problem,interpretation,element);
	neg find scopeDisallowsNewEClass_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfEDataType_class(problem,interpretation,element);
	neg find mustInstanceOfEEnumLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfETypeParameter_class(problem,interpretation,element);
	neg find mustInstanceOfETypedElement_class(problem,interpretation,element);
	neg find mustInstanceOfEPackage_class(problem,interpretation,element);
	neg find scopeDisallowsNewEClass_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfEClass_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "EClassifier class".
 */
private pattern mustInstanceOfEClassifier_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"EClassifier class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewEClassifier_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"EClassifier class");
}

/**
 * An element may be an instance of type "EClassifier class".
 */
private pattern mayInstanceOfEClassifier_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfEDataType_class(problem,interpretation,element);
	neg find mustInstanceOfEEnumLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfETypeParameter_class(problem,interpretation,element);
	neg find mustInstanceOfETypedElement_class(problem,interpretation,element);
	neg find mustInstanceOfEClass_class(problem,interpretation,element);
	neg find mustInstanceOfEPackage_class(problem,interpretation,element);
	neg find scopeDisallowsNewEClassifier_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfEDataType_class(problem,interpretation,element);
	neg find mustInstanceOfEEnumLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfETypeParameter_class(problem,interpretation,element);
	neg find mustInstanceOfETypedElement_class(problem,interpretation,element);
	neg find mustInstanceOfEClass_class(problem,interpretation,element);
	neg find mustInstanceOfEPackage_class(problem,interpretation,element);
	neg find scopeDisallowsNewEClassifier_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfEClassifier_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "EDataType class".
 */
private pattern mustInstanceOfEDataType_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"EDataType class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewEDataType_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"EDataType class");
}

/**
 * An element may be an instance of type "EDataType class".
 */
private pattern mayInstanceOfEDataType_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEEnum_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfEEnumLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfETypeParameter_class(problem,interpretation,element);
	neg find mustInstanceOfETypedElement_class(problem,interpretation,element);
	neg find mustInstanceOfEClass_class(problem,interpretation,element);
	neg find mustInstanceOfEPackage_class(problem,interpretation,element);
	neg find scopeDisallowsNewEDataType_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEEnum_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfEEnumLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfETypeParameter_class(problem,interpretation,element);
	neg find mustInstanceOfETypedElement_class(problem,interpretation,element);
	neg find mustInstanceOfEClass_class(problem,interpretation,element);
	neg find mustInstanceOfEPackage_class(problem,interpretation,element);
	neg find scopeDisallowsNewEDataType_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfEDataType_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "EEnum class".
 */
private pattern mustInstanceOfEEnum_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"EEnum class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewEEnum_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"EEnum class");
}

/**
 * An element may be an instance of type "EEnum class".
 */
private pattern mayInstanceOfEEnum_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfEEnumLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfETypeParameter_class(problem,interpretation,element);
	neg find mustInstanceOfETypedElement_class(problem,interpretation,element);
	neg find mustInstanceOfEClass_class(problem,interpretation,element);
	neg find mustInstanceOfEPackage_class(problem,interpretation,element);
	neg find scopeDisallowsNewEEnum_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfEEnumLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfETypeParameter_class(problem,interpretation,element);
	neg find mustInstanceOfETypedElement_class(problem,interpretation,element);
	neg find mustInstanceOfEClass_class(problem,interpretation,element);
	neg find mustInstanceOfEPackage_class(problem,interpretation,element);
	neg find scopeDisallowsNewEEnum_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfEEnum_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "EEnumLiteral class".
 */
private pattern mustInstanceOfEEnumLiteral_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"EEnumLiteral class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewEEnumLiteral_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"EEnumLiteral class");
}

/**
 * An element may be an instance of type "EEnumLiteral class".
 */
private pattern mayInstanceOfEEnumLiteral_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfETypeParameter_class(problem,interpretation,element);
	neg find mustInstanceOfETypedElement_class(problem,interpretation,element);
	neg find mustInstanceOfEClassifier_class(problem,interpretation,element);
	neg find mustInstanceOfEPackage_class(problem,interpretation,element);
	neg find scopeDisallowsNewEEnumLiteral_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfETypeParameter_class(problem,interpretation,element);
	neg find mustInstanceOfETypedElement_class(problem,interpretation,element);
	neg find mustInstanceOfEClassifier_class(problem,interpretation,element);
	neg find mustInstanceOfEPackage_class(problem,interpretation,element);
	neg find scopeDisallowsNewEEnumLiteral_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfEEnumLiteral_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "EModelElement class".
 */
private pattern mustInstanceOfEModelElement_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"EModelElement class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewEModelElement_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"EModelElement class");
}

/**
 * An element may be an instance of type "EModelElement class".
 */
private pattern mayInstanceOfEModelElement_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfENamedElement_class(problem,interpretation,element);
	neg find mustInstanceOfEModelElement_class_UndefinedPart(problem,interpretation,element);
	neg find scopeDisallowsNewEModelElement_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfENamedElement_class(problem,interpretation,element);
	neg find mustInstanceOfEModelElement_class_UndefinedPart(problem,interpretation,element);
	neg find scopeDisallowsNewEModelElement_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfEModelElement_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "ENamedElement class".
 */
private pattern mustInstanceOfENamedElement_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"ENamedElement class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewENamedElement_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"ENamedElement class");
}

/**
 * An element may be an instance of type "ENamedElement class".
 */
private pattern mayInstanceOfENamedElement_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfEPackage_class(problem,interpretation,element);
	neg find mustInstanceOfEModelElement_class_UndefinedPart(problem,interpretation,element);
	neg find scopeDisallowsNewENamedElement_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfEPackage_class(problem,interpretation,element);
	neg find mustInstanceOfEModelElement_class_UndefinedPart(problem,interpretation,element);
	neg find scopeDisallowsNewENamedElement_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfENamedElement_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "EObject class".
 */
private pattern mustInstanceOfEObject_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"EObject class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewEObject_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"EObject class");
}

/**
 * An element may be an instance of type "EObject class".
 */
private pattern mayInstanceOfEObject_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEModelElement_class(problem,interpretation,element);
	neg find scopeDisallowsNewEObject_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEModelElement_class(problem,interpretation,element);
	neg find scopeDisallowsNewEObject_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfEObject_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "EOperation class".
 */
private pattern mustInstanceOfEOperation_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"EOperation class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewEOperation_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"EOperation class");
}

/**
 * An element may be an instance of type "EOperation class".
 */
private pattern mayInstanceOfEOperation_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfEEnumLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfETypeParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEStructuralFeature_class(problem,interpretation,element);
	neg find mustInstanceOfEClassifier_class(problem,interpretation,element);
	neg find mustInstanceOfEPackage_class(problem,interpretation,element);
	neg find scopeDisallowsNewEOperation_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfEEnumLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfETypeParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEStructuralFeature_class(problem,interpretation,element);
	neg find mustInstanceOfEClassifier_class(problem,interpretation,element);
	neg find mustInstanceOfEPackage_class(problem,interpretation,element);
	neg find scopeDisallowsNewEOperation_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfEOperation_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "EPackage class".
 */
private pattern mustInstanceOfEPackage_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"EPackage class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewEPackage_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"EPackage class");
}

/**
 * An element may be an instance of type "EPackage class".
 */
private pattern mayInstanceOfEPackage_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfEModelElement_class_UndefinedPart(problem,interpretation,element);
	neg find scopeDisallowsNewEPackage_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfEModelElement_class_UndefinedPart(problem,interpretation,element);
	neg find scopeDisallowsNewEPackage_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfEPackage_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "EParameter class".
 */
private pattern mustInstanceOfEParameter_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"EParameter class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewEParameter_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"EParameter class");
}

/**
 * An element may be an instance of type "EParameter class".
 */
private pattern mayInstanceOfEParameter_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfEEnumLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfETypeParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEStructuralFeature_class(problem,interpretation,element);
	neg find mustInstanceOfEClassifier_class(problem,interpretation,element);
	neg find mustInstanceOfEPackage_class(problem,interpretation,element);
	neg find mustInstanceOfEOperation_class(problem,interpretation,element);
	neg find scopeDisallowsNewEParameter_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfEEnumLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfETypeParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEStructuralFeature_class(problem,interpretation,element);
	neg find mustInstanceOfEClassifier_class(problem,interpretation,element);
	neg find mustInstanceOfEPackage_class(problem,interpretation,element);
	neg find mustInstanceOfEOperation_class(problem,interpretation,element);
	neg find scopeDisallowsNewEParameter_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfEParameter_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "EReference class".
 */
private pattern mustInstanceOfEReference_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"EReference class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewEReference_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"EReference class");
}

/**
 * An element may be an instance of type "EReference class".
 */
private pattern mayInstanceOfEReference_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfEEnumLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfETypeParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEClassifier_class(problem,interpretation,element);
	neg find mustInstanceOfEPackage_class(problem,interpretation,element);
	neg find mustInstanceOfEOperation_class(problem,interpretation,element);
	neg find mustInstanceOfEAttribute_class(problem,interpretation,element);
	neg find scopeDisallowsNewEReference_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfEEnumLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfETypeParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEClassifier_class(problem,interpretation,element);
	neg find mustInstanceOfEPackage_class(problem,interpretation,element);
	neg find mustInstanceOfEOperation_class(problem,interpretation,element);
	neg find mustInstanceOfEAttribute_class(problem,interpretation,element);
	neg find scopeDisallowsNewEReference_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfEReference_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "EStructuralFeature class".
 */
private pattern mustInstanceOfEStructuralFeature_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"EStructuralFeature class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewEStructuralFeature_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"EStructuralFeature class");
}

/**
 * An element may be an instance of type "EStructuralFeature class".
 */
private pattern mayInstanceOfEStructuralFeature_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEReference_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfEEnumLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfETypeParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEClassifier_class(problem,interpretation,element);
	neg find mustInstanceOfEPackage_class(problem,interpretation,element);
	neg find mustInstanceOfEOperation_class(problem,interpretation,element);
	neg find mustInstanceOfEAttribute_class(problem,interpretation,element);
	neg find scopeDisallowsNewEStructuralFeature_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEReference_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfEEnumLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfETypeParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEClassifier_class(problem,interpretation,element);
	neg find mustInstanceOfEPackage_class(problem,interpretation,element);
	neg find mustInstanceOfEOperation_class(problem,interpretation,element);
	neg find mustInstanceOfEAttribute_class(problem,interpretation,element);
	neg find scopeDisallowsNewEStructuralFeature_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfEStructuralFeature_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "ETypedElement class".
 */
private pattern mustInstanceOfETypedElement_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"ETypedElement class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewETypedElement_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"ETypedElement class");
}

/**
 * An element may be an instance of type "ETypedElement class".
 */
private pattern mayInstanceOfETypedElement_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfEEnumLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfETypeParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEStructuralFeature_class(problem,interpretation,element);
	neg find mustInstanceOfEClassifier_class(problem,interpretation,element);
	neg find mustInstanceOfEPackage_class(problem,interpretation,element);
	neg find mustInstanceOfEOperation_class(problem,interpretation,element);
	neg find scopeDisallowsNewETypedElement_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfEEnumLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfETypeParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEStructuralFeature_class(problem,interpretation,element);
	neg find mustInstanceOfEClassifier_class(problem,interpretation,element);
	neg find mustInstanceOfEPackage_class(problem,interpretation,element);
	neg find mustInstanceOfEOperation_class(problem,interpretation,element);
	neg find scopeDisallowsNewETypedElement_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfETypedElement_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "EStringToStringMapEntry class".
 */
private pattern mustInstanceOfEStringToStringMapEntry_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"EStringToStringMapEntry class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewEStringToStringMapEntry_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"EStringToStringMapEntry class");
}

/**
 * An element may be an instance of type "EStringToStringMapEntry class".
 */
private pattern mayInstanceOfEStringToStringMapEntry_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfEModelElement_class(problem,interpretation,element);
	neg find scopeDisallowsNewEStringToStringMapEntry_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfEModelElement_class(problem,interpretation,element);
	neg find scopeDisallowsNewEStringToStringMapEntry_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "EGenericType class".
 */
private pattern mustInstanceOfEGenericType_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"EGenericType class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewEGenericType_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"EGenericType class");
}

/**
 * An element may be an instance of type "EGenericType class".
 */
private pattern mayInstanceOfEGenericType_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfEModelElement_class(problem,interpretation,element);
	neg find scopeDisallowsNewEGenericType_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfEModelElement_class(problem,interpretation,element);
	neg find scopeDisallowsNewEGenericType_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfEGenericType_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "ETypeParameter class".
 */
private pattern mustInstanceOfETypeParameter_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"ETypeParameter class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewETypeParameter_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"ETypeParameter class");
}

/**
 * An element may be an instance of type "ETypeParameter class".
 */
private pattern mayInstanceOfETypeParameter_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfEEnumLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfETypedElement_class(problem,interpretation,element);
	neg find mustInstanceOfEClassifier_class(problem,interpretation,element);
	neg find mustInstanceOfEPackage_class(problem,interpretation,element);
	neg find scopeDisallowsNewETypeParameter_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfEEnumLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfETypedElement_class(problem,interpretation,element);
	neg find mustInstanceOfEClassifier_class(problem,interpretation,element);
	neg find mustInstanceOfEPackage_class(problem,interpretation,element);
	neg find scopeDisallowsNewETypeParameter_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfETypeParameter_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "EModelElement class DefinedPart".
 */
private pattern mustInstanceOfEModelElement_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"EModelElement class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewEModelElement_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"EModelElement class DefinedPart");
}

/**
 * An element may be an instance of type "EModelElement class DefinedPart".
 */
private pattern mayInstanceOfEModelElement_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfEModelElement_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "EModelElement class UndefinedPart".
 */
private pattern mustInstanceOfEModelElement_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"EModelElement class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewEModelElement_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"EModelElement class UndefinedPart");
}

/**
 * An element may be an instance of type "EModelElement class UndefinedPart".
 */
private pattern mayInstanceOfEModelElement_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfENamedElement_class(problem,interpretation,element);
	neg find scopeDisallowsNewEModelElement_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfENamedElement_class(problem,interpretation,element);
	neg find scopeDisallowsNewEModelElement_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfEModelElement_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "ENamedElement class DefinedPart".
 */
private pattern mustInstanceOfENamedElement_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"ENamedElement class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewENamedElement_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"ENamedElement class DefinedPart");
}

/**
 * An element may be an instance of type "ENamedElement class DefinedPart".
 */
private pattern mayInstanceOfENamedElement_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfENamedElement_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "ENamedElement class UndefinedPart".
 */
private pattern mustInstanceOfENamedElement_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"ENamedElement class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewENamedElement_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"ENamedElement class UndefinedPart");
}

/**
 * An element may be an instance of type "ENamedElement class UndefinedPart".
 */
private pattern mayInstanceOfENamedElement_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfEEnumLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfETypeParameter_class(problem,interpretation,element);
	neg find mustInstanceOfETypedElement_class(problem,interpretation,element);
	neg find mustInstanceOfEClassifier_class(problem,interpretation,element);
	neg find mustInstanceOfEPackage_class(problem,interpretation,element);
	neg find scopeDisallowsNewENamedElement_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfEEnumLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfETypeParameter_class(problem,interpretation,element);
	neg find mustInstanceOfETypedElement_class(problem,interpretation,element);
	neg find mustInstanceOfEClassifier_class(problem,interpretation,element);
	neg find mustInstanceOfEPackage_class(problem,interpretation,element);
	neg find scopeDisallowsNewENamedElement_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfENamedElement_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "EPackage class DefinedPart".
 */
private pattern mustInstanceOfEPackage_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"EPackage class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewEPackage_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"EPackage class DefinedPart");
}

/**
 * An element may be an instance of type "EPackage class DefinedPart".
 */
private pattern mayInstanceOfEPackage_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfEPackage_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "EPackage class UndefinedPart".
 */
private pattern mustInstanceOfEPackage_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"EPackage class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewEPackage_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"EPackage class UndefinedPart");
}

/**
 * An element may be an instance of type "EPackage class UndefinedPart".
 */
private pattern mayInstanceOfEPackage_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfEEnumLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfETypeParameter_class(problem,interpretation,element);
	neg find mustInstanceOfETypedElement_class(problem,interpretation,element);
	neg find mustInstanceOfEClassifier_class(problem,interpretation,element);
	neg find scopeDisallowsNewEPackage_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfEEnumLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfETypeParameter_class(problem,interpretation,element);
	neg find mustInstanceOfETypedElement_class(problem,interpretation,element);
	neg find mustInstanceOfEClassifier_class(problem,interpretation,element);
	neg find scopeDisallowsNewEPackage_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfEPackage_class_UndefinedPart(problem,interpretation,element); }

//////////
// 1.2 Relation Declaration Indexers
//////////
/**
 * Matcher for detecting tuples t where []eAttributeType reference EAttribute(source,target)
 */
private pattern mustInRelationeAttributeType_reference_EAttribute(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eAttributeType reference EAttribute");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eAttributeType reference EAttribute(source,target)
 */
private pattern mayInRelationeAttributeType_reference_EAttribute(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEAttribute_class(problem,interpretation,source);
	find mayInstanceOfEDataType_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationeAttributeType_reference_EAttribute(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationeAttributeType_reference_EAttribute(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []details reference EAnnotation(source,target)
 */
private pattern mustInRelationdetails_reference_EAnnotation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"details reference EAnnotation");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>details reference EAnnotation(source,target)
 */
private pattern mayInRelationdetails_reference_EAnnotation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEAnnotation_class(problem,interpretation,source);
	find mayInstanceOfEStringToStringMapEntry_class(problem,interpretation,target);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationdetails_reference_EAnnotation(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eModelElement reference EAnnotation(source,target)
 */
private pattern mustInRelationeModelElement_reference_EAnnotation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eModelElement reference EAnnotation");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eModelElement reference EAnnotation(source,target)
 */
private pattern mayInRelationeModelElement_reference_EAnnotation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEAnnotation_class(problem,interpretation,source);
	find mayInstanceOfEModelElement_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationeModelElement_reference_EAnnotation(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationeModelElement_reference_EAnnotation(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []contents reference EAnnotation(source,target)
 */
private pattern mustInRelationcontents_reference_EAnnotation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"contents reference EAnnotation");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>contents reference EAnnotation(source,target)
 */
private pattern mayInRelationcontents_reference_EAnnotation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEAnnotation_class(problem,interpretation,source);
	find mayInstanceOfEObject_class(problem,interpretation,target);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationcontents_reference_EAnnotation(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []references reference EAnnotation(source,target)
 */
private pattern mustInRelationreferences_reference_EAnnotation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"references reference EAnnotation");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>references reference EAnnotation(source,target)
 */
private pattern mayInRelationreferences_reference_EAnnotation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEAnnotation_class(problem,interpretation,source);
	find mayInstanceOfEObject_class(problem,interpretation,target);
} or {
	find mustInRelationreferences_reference_EAnnotation(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eSuperTypes reference EClass(source,target)
 */
private pattern mustInRelationeSuperTypes_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eSuperTypes reference EClass");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eSuperTypes reference EClass(source,target)
 */
private pattern mayInRelationeSuperTypes_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEClass_class(problem,interpretation,source);
	find mayInstanceOfEClass_class(problem,interpretation,target);
} or {
	find mustInRelationeSuperTypes_reference_EClass(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eOperations reference EClass(source,target)
 */
private pattern mustInRelationeOperations_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eOperations reference EClass");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eOperations reference EClass(source,target)
 */
private pattern mayInRelationeOperations_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEClass_class(problem,interpretation,source);
	find mayInstanceOfEOperation_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationeContainingClass_reference_EOperation(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationeOperations_reference_EClass(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eAllAttributes reference EClass(source,target)
 */
private pattern mustInRelationeAllAttributes_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eAllAttributes reference EClass");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eAllAttributes reference EClass(source,target)
 */
private pattern mayInRelationeAllAttributes_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEClass_class(problem,interpretation,source);
	find mayInstanceOfEAttribute_class(problem,interpretation,target);
} or {
	find mustInRelationeAllAttributes_reference_EClass(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eAllReferences reference EClass(source,target)
 */
private pattern mustInRelationeAllReferences_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eAllReferences reference EClass");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eAllReferences reference EClass(source,target)
 */
private pattern mayInRelationeAllReferences_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEClass_class(problem,interpretation,source);
	find mayInstanceOfEReference_class(problem,interpretation,target);
} or {
	find mustInRelationeAllReferences_reference_EClass(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eReferences reference EClass(source,target)
 */
private pattern mustInRelationeReferences_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eReferences reference EClass");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eReferences reference EClass(source,target)
 */
private pattern mayInRelationeReferences_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEClass_class(problem,interpretation,source);
	find mayInstanceOfEReference_class(problem,interpretation,target);
} or {
	find mustInRelationeReferences_reference_EClass(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eAttributes reference EClass(source,target)
 */
private pattern mustInRelationeAttributes_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eAttributes reference EClass");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eAttributes reference EClass(source,target)
 */
private pattern mayInRelationeAttributes_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEClass_class(problem,interpretation,source);
	find mayInstanceOfEAttribute_class(problem,interpretation,target);
} or {
	find mustInRelationeAttributes_reference_EClass(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eAllContainments reference EClass(source,target)
 */
private pattern mustInRelationeAllContainments_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eAllContainments reference EClass");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eAllContainments reference EClass(source,target)
 */
private pattern mayInRelationeAllContainments_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEClass_class(problem,interpretation,source);
	find mayInstanceOfEReference_class(problem,interpretation,target);
} or {
	find mustInRelationeAllContainments_reference_EClass(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eAllOperations reference EClass(source,target)
 */
private pattern mustInRelationeAllOperations_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eAllOperations reference EClass");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eAllOperations reference EClass(source,target)
 */
private pattern mayInRelationeAllOperations_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEClass_class(problem,interpretation,source);
	find mayInstanceOfEOperation_class(problem,interpretation,target);
} or {
	find mustInRelationeAllOperations_reference_EClass(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eAllStructuralFeatures reference EClass(source,target)
 */
private pattern mustInRelationeAllStructuralFeatures_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eAllStructuralFeatures reference EClass");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eAllStructuralFeatures reference EClass(source,target)
 */
private pattern mayInRelationeAllStructuralFeatures_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEClass_class(problem,interpretation,source);
	find mayInstanceOfEStructuralFeature_class(problem,interpretation,target);
} or {
	find mustInRelationeAllStructuralFeatures_reference_EClass(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eAllSuperTypes reference EClass(source,target)
 */
private pattern mustInRelationeAllSuperTypes_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eAllSuperTypes reference EClass");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eAllSuperTypes reference EClass(source,target)
 */
private pattern mayInRelationeAllSuperTypes_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEClass_class(problem,interpretation,source);
	find mayInstanceOfEClass_class(problem,interpretation,target);
} or {
	find mustInRelationeAllSuperTypes_reference_EClass(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eIDAttribute reference EClass(source,target)
 */
private pattern mustInRelationeIDAttribute_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eIDAttribute reference EClass");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eIDAttribute reference EClass(source,target)
 */
private pattern mayInRelationeIDAttribute_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEClass_class(problem,interpretation,source);
	find mayInstanceOfEAttribute_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationeIDAttribute_reference_EClass(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationeIDAttribute_reference_EClass(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eStructuralFeatures reference EClass(source,target)
 */
private pattern mustInRelationeStructuralFeatures_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eStructuralFeatures reference EClass");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eStructuralFeatures reference EClass(source,target)
 */
private pattern mayInRelationeStructuralFeatures_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEClass_class(problem,interpretation,source);
	find mayInstanceOfEStructuralFeature_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationeContainingClass_reference_EStructuralFeature(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationeStructuralFeatures_reference_EClass(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eGenericSuperTypes reference EClass(source,target)
 */
private pattern mustInRelationeGenericSuperTypes_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eGenericSuperTypes reference EClass");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eGenericSuperTypes reference EClass(source,target)
 */
private pattern mayInRelationeGenericSuperTypes_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEClass_class(problem,interpretation,source);
	find mayInstanceOfEGenericType_class(problem,interpretation,target);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationeGenericSuperTypes_reference_EClass(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eAllGenericSuperTypes reference EClass(source,target)
 */
private pattern mustInRelationeAllGenericSuperTypes_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eAllGenericSuperTypes reference EClass");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eAllGenericSuperTypes reference EClass(source,target)
 */
private pattern mayInRelationeAllGenericSuperTypes_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEClass_class(problem,interpretation,source);
	find mayInstanceOfEGenericType_class(problem,interpretation,target);
} or {
	find mustInRelationeAllGenericSuperTypes_reference_EClass(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []ePackage reference EClassifier(source,target)
 */
private pattern mustInRelationePackage_reference_EClassifier(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"ePackage reference EClassifier");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>ePackage reference EClassifier(source,target)
 */
private pattern mayInRelationePackage_reference_EClassifier(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEClassifier_class(problem,interpretation,source);
	find mayInstanceOfEPackage_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationePackage_reference_EClassifier(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationePackage_reference_EClassifier(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eTypeParameters reference EClassifier(source,target)
 */
private pattern mustInRelationeTypeParameters_reference_EClassifier(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eTypeParameters reference EClassifier");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eTypeParameters reference EClassifier(source,target)
 */
private pattern mayInRelationeTypeParameters_reference_EClassifier(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEClassifier_class(problem,interpretation,source);
	find mayInstanceOfETypeParameter_class(problem,interpretation,target);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationeTypeParameters_reference_EClassifier(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eLiterals reference EEnum(source,target)
 */
private pattern mustInRelationeLiterals_reference_EEnum(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eLiterals reference EEnum");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eLiterals reference EEnum(source,target)
 */
private pattern mayInRelationeLiterals_reference_EEnum(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEEnum_class(problem,interpretation,source);
	find mayInstanceOfEEnumLiteral_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationeEnum_reference_EEnumLiteral(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationeLiterals_reference_EEnum(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eEnum reference EEnumLiteral(source,target)
 */
private pattern mustInRelationeEnum_reference_EEnumLiteral(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eEnum reference EEnumLiteral");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eEnum reference EEnumLiteral(source,target)
 */
private pattern mayInRelationeEnum_reference_EEnumLiteral(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEEnumLiteral_class(problem,interpretation,source);
	find mayInstanceOfEEnum_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationeEnum_reference_EEnumLiteral(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationeEnum_reference_EEnumLiteral(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eAnnotations reference EModelElement(source,target)
 */
private pattern mustInRelationeAnnotations_reference_EModelElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eAnnotations reference EModelElement");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eAnnotations reference EModelElement(source,target)
 */
private pattern mayInRelationeAnnotations_reference_EModelElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEModelElement_class(problem,interpretation,source);
	find mayInstanceOfEAnnotation_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationeModelElement_reference_EAnnotation(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationeAnnotations_reference_EModelElement(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eContainingClass reference EOperation(source,target)
 */
private pattern mustInRelationeContainingClass_reference_EOperation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eContainingClass reference EOperation");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eContainingClass reference EOperation(source,target)
 */
private pattern mayInRelationeContainingClass_reference_EOperation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEOperation_class(problem,interpretation,source);
	find mayInstanceOfEClass_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationeContainingClass_reference_EOperation(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationeContainingClass_reference_EOperation(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eTypeParameters reference EOperation(source,target)
 */
private pattern mustInRelationeTypeParameters_reference_EOperation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eTypeParameters reference EOperation");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eTypeParameters reference EOperation(source,target)
 */
private pattern mayInRelationeTypeParameters_reference_EOperation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEOperation_class(problem,interpretation,source);
	find mayInstanceOfETypeParameter_class(problem,interpretation,target);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationeTypeParameters_reference_EOperation(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eParameters reference EOperation(source,target)
 */
private pattern mustInRelationeParameters_reference_EOperation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eParameters reference EOperation");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eParameters reference EOperation(source,target)
 */
private pattern mayInRelationeParameters_reference_EOperation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEOperation_class(problem,interpretation,source);
	find mayInstanceOfEParameter_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationeOperation_reference_EParameter(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationeParameters_reference_EOperation(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eExceptions reference EOperation(source,target)
 */
private pattern mustInRelationeExceptions_reference_EOperation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eExceptions reference EOperation");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eExceptions reference EOperation(source,target)
 */
private pattern mayInRelationeExceptions_reference_EOperation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEOperation_class(problem,interpretation,source);
	find mayInstanceOfEClassifier_class(problem,interpretation,target);
} or {
	find mustInRelationeExceptions_reference_EOperation(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eGenericExceptions reference EOperation(source,target)
 */
private pattern mustInRelationeGenericExceptions_reference_EOperation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eGenericExceptions reference EOperation");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eGenericExceptions reference EOperation(source,target)
 */
private pattern mayInRelationeGenericExceptions_reference_EOperation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEOperation_class(problem,interpretation,source);
	find mayInstanceOfEGenericType_class(problem,interpretation,target);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationeGenericExceptions_reference_EOperation(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eClassifiers reference EPackage(source,target)
 */
private pattern mustInRelationeClassifiers_reference_EPackage(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eClassifiers reference EPackage");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eClassifiers reference EPackage(source,target)
 */
private pattern mayInRelationeClassifiers_reference_EPackage(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEPackage_class(problem,interpretation,source);
	find mayInstanceOfEClassifier_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationePackage_reference_EClassifier(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationeClassifiers_reference_EPackage(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eSubpackages reference EPackage(source,target)
 */
private pattern mustInRelationeSubpackages_reference_EPackage(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eSubpackages reference EPackage");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eSubpackages reference EPackage(source,target)
 */
private pattern mayInRelationeSubpackages_reference_EPackage(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEPackage_class(problem,interpretation,source);
	find mayInstanceOfEPackage_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationeSuperPackage_reference_EPackage(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationeSubpackages_reference_EPackage(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eSuperPackage reference EPackage(source,target)
 */
private pattern mustInRelationeSuperPackage_reference_EPackage(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eSuperPackage reference EPackage");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eSuperPackage reference EPackage(source,target)
 */
private pattern mayInRelationeSuperPackage_reference_EPackage(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEPackage_class(problem,interpretation,source);
	find mayInstanceOfEPackage_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationeSuperPackage_reference_EPackage(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationeSuperPackage_reference_EPackage(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eOperation reference EParameter(source,target)
 */
private pattern mustInRelationeOperation_reference_EParameter(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eOperation reference EParameter");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eOperation reference EParameter(source,target)
 */
private pattern mayInRelationeOperation_reference_EParameter(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEParameter_class(problem,interpretation,source);
	find mayInstanceOfEOperation_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationeOperation_reference_EParameter(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationeOperation_reference_EParameter(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eOpposite reference EReference(source,target)
 */
private pattern mustInRelationeOpposite_reference_EReference(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eOpposite reference EReference");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eOpposite reference EReference(source,target)
 */
private pattern mayInRelationeOpposite_reference_EReference(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEReference_class(problem,interpretation,source);
	find mayInstanceOfEReference_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationeOpposite_reference_EReference(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationeOpposite_reference_EReference(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eReferenceType reference EReference(source,target)
 */
private pattern mustInRelationeReferenceType_reference_EReference(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eReferenceType reference EReference");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eReferenceType reference EReference(source,target)
 */
private pattern mayInRelationeReferenceType_reference_EReference(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEReference_class(problem,interpretation,source);
	find mayInstanceOfEClass_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationeReferenceType_reference_EReference(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationeReferenceType_reference_EReference(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eKeys reference EReference(source,target)
 */
private pattern mustInRelationeKeys_reference_EReference(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eKeys reference EReference");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eKeys reference EReference(source,target)
 */
private pattern mayInRelationeKeys_reference_EReference(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEReference_class(problem,interpretation,source);
	find mayInstanceOfEAttribute_class(problem,interpretation,target);
} or {
	find mustInRelationeKeys_reference_EReference(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eContainingClass reference EStructuralFeature(source,target)
 */
private pattern mustInRelationeContainingClass_reference_EStructuralFeature(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eContainingClass reference EStructuralFeature");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eContainingClass reference EStructuralFeature(source,target)
 */
private pattern mayInRelationeContainingClass_reference_EStructuralFeature(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEStructuralFeature_class(problem,interpretation,source);
	find mayInstanceOfEClass_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationeContainingClass_reference_EStructuralFeature(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationeContainingClass_reference_EStructuralFeature(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eType reference ETypedElement(source,target)
 */
private pattern mustInRelationeType_reference_ETypedElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eType reference ETypedElement");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eType reference ETypedElement(source,target)
 */
private pattern mayInRelationeType_reference_ETypedElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfETypedElement_class(problem,interpretation,source);
	find mayInstanceOfEClassifier_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationeType_reference_ETypedElement(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationeType_reference_ETypedElement(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eGenericType reference ETypedElement(source,target)
 */
private pattern mustInRelationeGenericType_reference_ETypedElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eGenericType reference ETypedElement");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eGenericType reference ETypedElement(source,target)
 */
private pattern mayInRelationeGenericType_reference_ETypedElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfETypedElement_class(problem,interpretation,source);
	find mayInstanceOfEGenericType_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationeGenericType_reference_ETypedElement(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationeGenericType_reference_ETypedElement(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eUpperBound reference EGenericType(source,target)
 */
private pattern mustInRelationeUpperBound_reference_EGenericType(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eUpperBound reference EGenericType");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eUpperBound reference EGenericType(source,target)
 */
private pattern mayInRelationeUpperBound_reference_EGenericType(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEGenericType_class(problem,interpretation,source);
	find mayInstanceOfEGenericType_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationeUpperBound_reference_EGenericType(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationeUpperBound_reference_EGenericType(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eTypeArguments reference EGenericType(source,target)
 */
private pattern mustInRelationeTypeArguments_reference_EGenericType(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eTypeArguments reference EGenericType");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eTypeArguments reference EGenericType(source,target)
 */
private pattern mayInRelationeTypeArguments_reference_EGenericType(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEGenericType_class(problem,interpretation,source);
	find mayInstanceOfEGenericType_class(problem,interpretation,target);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationeTypeArguments_reference_EGenericType(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eRawType reference EGenericType(source,target)
 */
private pattern mustInRelationeRawType_reference_EGenericType(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eRawType reference EGenericType");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eRawType reference EGenericType(source,target)
 */
private pattern mayInRelationeRawType_reference_EGenericType(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEGenericType_class(problem,interpretation,source);
	find mayInstanceOfEClassifier_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationeRawType_reference_EGenericType(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationeRawType_reference_EGenericType(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eLowerBound reference EGenericType(source,target)
 */
private pattern mustInRelationeLowerBound_reference_EGenericType(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eLowerBound reference EGenericType");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eLowerBound reference EGenericType(source,target)
 */
private pattern mayInRelationeLowerBound_reference_EGenericType(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEGenericType_class(problem,interpretation,source);
	find mayInstanceOfEGenericType_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationeLowerBound_reference_EGenericType(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationeLowerBound_reference_EGenericType(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eTypeParameter reference EGenericType(source,target)
 */
private pattern mustInRelationeTypeParameter_reference_EGenericType(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eTypeParameter reference EGenericType");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eTypeParameter reference EGenericType(source,target)
 */
private pattern mayInRelationeTypeParameter_reference_EGenericType(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEGenericType_class(problem,interpretation,source);
	find mayInstanceOfETypeParameter_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationeTypeParameter_reference_EGenericType(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationeTypeParameter_reference_EGenericType(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eClassifier reference EGenericType(source,target)
 */
private pattern mustInRelationeClassifier_reference_EGenericType(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eClassifier reference EGenericType");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eClassifier reference EGenericType(source,target)
 */
private pattern mayInRelationeClassifier_reference_EGenericType(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEGenericType_class(problem,interpretation,source);
	find mayInstanceOfEClassifier_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationeClassifier_reference_EGenericType(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationeClassifier_reference_EGenericType(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []eBounds reference ETypeParameter(source,target)
 */
private pattern mustInRelationeBounds_reference_ETypeParameter(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eBounds reference ETypeParameter");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>eBounds reference ETypeParameter(source,target)
 */
private pattern mayInRelationeBounds_reference_ETypeParameter(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfETypeParameter_class(problem,interpretation,source);
	find mayInstanceOfEGenericType_class(problem,interpretation,target);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationeBounds_reference_ETypeParameter(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []iD attribute EAttribute(source,target)
 */
private pattern mustInRelationiD_attribute_EAttribute(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"iD attribute EAttribute");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>iD attribute EAttribute(source,target)
 */
private pattern mayInRelationiD_attribute_EAttribute(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEAttribute_class(problem,interpretation,source);
	BooleanElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationiD_attribute_EAttribute(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationiD_attribute_EAttribute(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []source attribute EAnnotation(source,target)
 */
private pattern mustInRelationsource_attribute_EAnnotation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"source attribute EAnnotation");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>source attribute EAnnotation(source,target)
 */
private pattern mayInRelationsource_attribute_EAnnotation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEAnnotation_class(problem,interpretation,source);
	StringElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationsource_attribute_EAnnotation(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationsource_attribute_EAnnotation(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []abstract attribute EClass(source,target)
 */
private pattern mustInRelationabstract_attribute_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"abstract attribute EClass");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>abstract attribute EClass(source,target)
 */
private pattern mayInRelationabstract_attribute_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEClass_class(problem,interpretation,source);
	BooleanElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationabstract_attribute_EClass(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationabstract_attribute_EClass(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []interface attribute EClass(source,target)
 */
private pattern mustInRelationinterface_attribute_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"interface attribute EClass");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>interface attribute EClass(source,target)
 */
private pattern mayInRelationinterface_attribute_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEClass_class(problem,interpretation,source);
	BooleanElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationinterface_attribute_EClass(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationinterface_attribute_EClass(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []instanceClassName attribute EClassifier(source,target)
 */
private pattern mustInRelationinstanceClassName_attribute_EClassifier(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"instanceClassName attribute EClassifier");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>instanceClassName attribute EClassifier(source,target)
 */
private pattern mayInRelationinstanceClassName_attribute_EClassifier(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEClassifier_class(problem,interpretation,source);
	StringElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationinstanceClassName_attribute_EClassifier(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationinstanceClassName_attribute_EClassifier(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []instanceTypeName attribute EClassifier(source,target)
 */
private pattern mustInRelationinstanceTypeName_attribute_EClassifier(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"instanceTypeName attribute EClassifier");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>instanceTypeName attribute EClassifier(source,target)
 */
private pattern mayInRelationinstanceTypeName_attribute_EClassifier(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEClassifier_class(problem,interpretation,source);
	StringElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationinstanceTypeName_attribute_EClassifier(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationinstanceTypeName_attribute_EClassifier(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []serializable attribute EDataType(source,target)
 */
private pattern mustInRelationserializable_attribute_EDataType(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"serializable attribute EDataType");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>serializable attribute EDataType(source,target)
 */
private pattern mayInRelationserializable_attribute_EDataType(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEDataType_class(problem,interpretation,source);
	BooleanElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationserializable_attribute_EDataType(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationserializable_attribute_EDataType(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []value attribute EEnumLiteral(source,target)
 */
private pattern mustInRelationvalue_attribute_EEnumLiteral(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"value attribute EEnumLiteral");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>value attribute EEnumLiteral(source,target)
 */
private pattern mayInRelationvalue_attribute_EEnumLiteral(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEEnumLiteral_class(problem,interpretation,source);
	IntegerElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationvalue_attribute_EEnumLiteral(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationvalue_attribute_EEnumLiteral(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []literal attribute EEnumLiteral(source,target)
 */
private pattern mustInRelationliteral_attribute_EEnumLiteral(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"literal attribute EEnumLiteral");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>literal attribute EEnumLiteral(source,target)
 */
private pattern mayInRelationliteral_attribute_EEnumLiteral(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEEnumLiteral_class(problem,interpretation,source);
	StringElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationliteral_attribute_EEnumLiteral(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationliteral_attribute_EEnumLiteral(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []name attribute ENamedElement(source,target)
 */
private pattern mustInRelationname_attribute_ENamedElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"name attribute ENamedElement");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>name attribute ENamedElement(source,target)
 */
private pattern mayInRelationname_attribute_ENamedElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfENamedElement_class(problem,interpretation,source);
	StringElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationname_attribute_ENamedElement(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationname_attribute_ENamedElement(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []nsURI attribute EPackage(source,target)
 */
private pattern mustInRelationnsURI_attribute_EPackage(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"nsURI attribute EPackage");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>nsURI attribute EPackage(source,target)
 */
private pattern mayInRelationnsURI_attribute_EPackage(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEPackage_class(problem,interpretation,source);
	StringElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationnsURI_attribute_EPackage(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationnsURI_attribute_EPackage(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []nsPrefix attribute EPackage(source,target)
 */
private pattern mustInRelationnsPrefix_attribute_EPackage(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"nsPrefix attribute EPackage");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>nsPrefix attribute EPackage(source,target)
 */
private pattern mayInRelationnsPrefix_attribute_EPackage(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEPackage_class(problem,interpretation,source);
	StringElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationnsPrefix_attribute_EPackage(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationnsPrefix_attribute_EPackage(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []containment attribute EReference(source,target)
 */
private pattern mustInRelationcontainment_attribute_EReference(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"containment attribute EReference");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>containment attribute EReference(source,target)
 */
private pattern mayInRelationcontainment_attribute_EReference(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEReference_class(problem,interpretation,source);
	BooleanElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationcontainment_attribute_EReference(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationcontainment_attribute_EReference(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []container attribute EReference(source,target)
 */
private pattern mustInRelationcontainer_attribute_EReference(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"container attribute EReference");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>container attribute EReference(source,target)
 */
private pattern mayInRelationcontainer_attribute_EReference(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEReference_class(problem,interpretation,source);
	BooleanElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationcontainer_attribute_EReference(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationcontainer_attribute_EReference(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []resolveProxies attribute EReference(source,target)
 */
private pattern mustInRelationresolveProxies_attribute_EReference(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"resolveProxies attribute EReference");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>resolveProxies attribute EReference(source,target)
 */
private pattern mayInRelationresolveProxies_attribute_EReference(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEReference_class(problem,interpretation,source);
	BooleanElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationresolveProxies_attribute_EReference(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationresolveProxies_attribute_EReference(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []changeable attribute EStructuralFeature(source,target)
 */
private pattern mustInRelationchangeable_attribute_EStructuralFeature(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"changeable attribute EStructuralFeature");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>changeable attribute EStructuralFeature(source,target)
 */
private pattern mayInRelationchangeable_attribute_EStructuralFeature(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEStructuralFeature_class(problem,interpretation,source);
	BooleanElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationchangeable_attribute_EStructuralFeature(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationchangeable_attribute_EStructuralFeature(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []volatile attribute EStructuralFeature(source,target)
 */
private pattern mustInRelationvolatile_attribute_EStructuralFeature(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"volatile attribute EStructuralFeature");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>volatile attribute EStructuralFeature(source,target)
 */
private pattern mayInRelationvolatile_attribute_EStructuralFeature(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEStructuralFeature_class(problem,interpretation,source);
	BooleanElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationvolatile_attribute_EStructuralFeature(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationvolatile_attribute_EStructuralFeature(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []transient attribute EStructuralFeature(source,target)
 */
private pattern mustInRelationtransient_attribute_EStructuralFeature(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"transient attribute EStructuralFeature");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>transient attribute EStructuralFeature(source,target)
 */
private pattern mayInRelationtransient_attribute_EStructuralFeature(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEStructuralFeature_class(problem,interpretation,source);
	BooleanElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationtransient_attribute_EStructuralFeature(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationtransient_attribute_EStructuralFeature(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []defaultValueLiteral attribute EStructuralFeature(source,target)
 */
private pattern mustInRelationdefaultValueLiteral_attribute_EStructuralFeature(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"defaultValueLiteral attribute EStructuralFeature");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>defaultValueLiteral attribute EStructuralFeature(source,target)
 */
private pattern mayInRelationdefaultValueLiteral_attribute_EStructuralFeature(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEStructuralFeature_class(problem,interpretation,source);
	StringElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationdefaultValueLiteral_attribute_EStructuralFeature(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationdefaultValueLiteral_attribute_EStructuralFeature(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []unsettable attribute EStructuralFeature(source,target)
 */
private pattern mustInRelationunsettable_attribute_EStructuralFeature(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"unsettable attribute EStructuralFeature");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>unsettable attribute EStructuralFeature(source,target)
 */
private pattern mayInRelationunsettable_attribute_EStructuralFeature(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEStructuralFeature_class(problem,interpretation,source);
	BooleanElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationunsettable_attribute_EStructuralFeature(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationunsettable_attribute_EStructuralFeature(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []derived attribute EStructuralFeature(source,target)
 */
private pattern mustInRelationderived_attribute_EStructuralFeature(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"derived attribute EStructuralFeature");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>derived attribute EStructuralFeature(source,target)
 */
private pattern mayInRelationderived_attribute_EStructuralFeature(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEStructuralFeature_class(problem,interpretation,source);
	BooleanElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationderived_attribute_EStructuralFeature(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationderived_attribute_EStructuralFeature(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []ordered attribute ETypedElement(source,target)
 */
private pattern mustInRelationordered_attribute_ETypedElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"ordered attribute ETypedElement");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>ordered attribute ETypedElement(source,target)
 */
private pattern mayInRelationordered_attribute_ETypedElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfETypedElement_class(problem,interpretation,source);
	BooleanElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationordered_attribute_ETypedElement(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationordered_attribute_ETypedElement(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []unique attribute ETypedElement(source,target)
 */
private pattern mustInRelationunique_attribute_ETypedElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"unique attribute ETypedElement");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>unique attribute ETypedElement(source,target)
 */
private pattern mayInRelationunique_attribute_ETypedElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfETypedElement_class(problem,interpretation,source);
	BooleanElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationunique_attribute_ETypedElement(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationunique_attribute_ETypedElement(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []lowerBound attribute ETypedElement(source,target)
 */
private pattern mustInRelationlowerBound_attribute_ETypedElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"lowerBound attribute ETypedElement");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>lowerBound attribute ETypedElement(source,target)
 */
private pattern mayInRelationlowerBound_attribute_ETypedElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfETypedElement_class(problem,interpretation,source);
	IntegerElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationlowerBound_attribute_ETypedElement(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationlowerBound_attribute_ETypedElement(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []upperBound attribute ETypedElement(source,target)
 */
private pattern mustInRelationupperBound_attribute_ETypedElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"upperBound attribute ETypedElement");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>upperBound attribute ETypedElement(source,target)
 */
private pattern mayInRelationupperBound_attribute_ETypedElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfETypedElement_class(problem,interpretation,source);
	IntegerElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationupperBound_attribute_ETypedElement(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationupperBound_attribute_ETypedElement(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []many attribute ETypedElement(source,target)
 */
private pattern mustInRelationmany_attribute_ETypedElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"many attribute ETypedElement");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>many attribute ETypedElement(source,target)
 */
private pattern mayInRelationmany_attribute_ETypedElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfETypedElement_class(problem,interpretation,source);
	BooleanElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationmany_attribute_ETypedElement(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationmany_attribute_ETypedElement(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []required attribute ETypedElement(source,target)
 */
private pattern mustInRelationrequired_attribute_ETypedElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"required attribute ETypedElement");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>required attribute ETypedElement(source,target)
 */
private pattern mayInRelationrequired_attribute_ETypedElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfETypedElement_class(problem,interpretation,source);
	BooleanElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationrequired_attribute_ETypedElement(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationrequired_attribute_ETypedElement(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []key attribute EStringToStringMapEntry(source,target)
 */
private pattern mustInRelationkey_attribute_EStringToStringMapEntry(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"key attribute EStringToStringMapEntry");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>key attribute EStringToStringMapEntry(source,target)
 */
private pattern mayInRelationkey_attribute_EStringToStringMapEntry(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEStringToStringMapEntry_class(problem,interpretation,source);
	StringElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationkey_attribute_EStringToStringMapEntry(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationkey_attribute_EStringToStringMapEntry(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []value attribute EStringToStringMapEntry(source,target)
 */
private pattern mustInRelationvalue_attribute_EStringToStringMapEntry(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"value attribute EStringToStringMapEntry");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>value attribute EStringToStringMapEntry(source,target)
 */
private pattern mayInRelationvalue_attribute_EStringToStringMapEntry(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfEStringToStringMapEntry_class(problem,interpretation,source);
	StringElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationvalue_attribute_EStringToStringMapEntry(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationvalue_attribute_EStringToStringMapEntry(problem,interpretation,source,target);
}

//////////
// 1.3 Relation Definition Indexers
//////////

//////////
// 1.4 Containment Indexer
//////////
private pattern mustContains2(source: DefinedElement, target: DefinedElement) {
	find mustContains4(_,_,source,target);
}
	
private pattern mustContains4(problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target: DefinedElement)
	{ find mustInRelationdetails_reference_EAnnotation(problem,interpretation,source,target); }or
	
	{ find mustInRelationcontents_reference_EAnnotation(problem,interpretation,source,target); }or
	
	{ find mustInRelationeOperations_reference_EClass(problem,interpretation,source,target); }or
	
	{ find mustInRelationeStructuralFeatures_reference_EClass(problem,interpretation,source,target); }or
	
	{ find mustInRelationeGenericSuperTypes_reference_EClass(problem,interpretation,source,target); }or
	
	{ find mustInRelationeTypeParameters_reference_EClassifier(problem,interpretation,source,target); }or
	
	{ find mustInRelationeLiterals_reference_EEnum(problem,interpretation,source,target); }or
	
	{ find mustInRelationeAnnotations_reference_EModelElement(problem,interpretation,source,target); }or
	
	{ find mustInRelationeTypeParameters_reference_EOperation(problem,interpretation,source,target); }or
	
	{ find mustInRelationeParameters_reference_EOperation(problem,interpretation,source,target); }or
	
	{ find mustInRelationeGenericExceptions_reference_EOperation(problem,interpretation,source,target); }or
	
	{ find mustInRelationeClassifiers_reference_EPackage(problem,interpretation,source,target); }or
	
	{ find mustInRelationeSubpackages_reference_EPackage(problem,interpretation,source,target); }or
	
	{ find mustInRelationeGenericType_reference_ETypedElement(problem,interpretation,source,target); }or
	
	{ find mustInRelationeUpperBound_reference_EGenericType(problem,interpretation,source,target); }or
	
	{ find mustInRelationeTypeArguments_reference_EGenericType(problem,interpretation,source,target); }or
	
	{ find mustInRelationeLowerBound_reference_EGenericType(problem,interpretation,source,target); }or
	
	{ find mustInRelationeBounds_reference_ETypeParameter(problem,interpretation,source,target); }

private pattern mustTransitiveContains(source,target) {
	find mustContains2+(source,target);
}

//////////
// 2. Invalidation Indexers
//////////
// 2.1 Invalidated by WF Queries
//////////

//////////
// 3. Unfinishedness Indexers
//////////
// 3.1 Unfinishedness Measured by Multiplicity
//////////
pattern unfinishedLowerMultiplicity_eAttributeType_reference_EAttribute(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eAttributeType reference EAttribute");
	find mustInstanceOfEAttribute_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationeAttributeType_reference_EAttribute(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_eReferenceType_reference_EReference(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eReferenceType reference EReference");
	find mustInstanceOfEReference_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationeReferenceType_reference_EReference(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_eRawType_reference_EGenericType(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eRawType reference EGenericType");
	find mustInstanceOfEGenericType_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationeRawType_reference_EGenericType(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}

//////////
// 3.2 Unfinishedness Measured by WF Queries
//////////

//////////
// 4. Refinement Indexers
//////////
// 4.1 Object constructors
//////////
private pattern hasElementInContainment(problem:LogicProblem, interpretation:PartialInterpretation)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfEOperation_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfENamedElement_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfEEnumLiteral_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfEGenericType_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfEObject_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfEAttribute_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfEPackage_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfEParameter_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfEDataType_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfEClassifier_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfEStructuralFeature_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfEModelElement_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfEAnnotation_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfETypeParameter_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfEReference_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfEEnum_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfETypedElement_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfEClass_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfEModelElement_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfEModelElement_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfENamedElement_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfENamedElement_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfEPackage_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfEPackage_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}
pattern createObject_EStringToStringMapEntry_class_by_details_reference_EAnnotation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"EStringToStringMapEntry class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"details reference EAnnotation");
	find mustInstanceOfEAnnotation_class(problem,interpretation,container);
	find mayInstanceOfEStringToStringMapEntry_class(problem,interpretation,newObject);
	find mayInRelationdetails_reference_EAnnotation(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_EStringToStringMapEntry_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"EStringToStringMapEntry class");
	find mayInstanceOfEStringToStringMapEntry_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_EEnum_class_by_eClassifiers_reference_EPackage_with_ePackage_reference_EClassifier(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"EEnum class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"eClassifiers reference EPackage");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"ePackage reference EClassifier");
	find mustInstanceOfEPackage_class(problem,interpretation,container);
	find mayInstanceOfEEnum_class(problem,interpretation,newObject);
	find mayInRelationeClassifiers_reference_EPackage(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_EEnum_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"EEnum class");
	find mayInstanceOfEEnum_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_EParameter_class_by_eParameters_reference_EOperation_with_eOperation_reference_EParameter(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"EParameter class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"eParameters reference EOperation");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"eOperation reference EParameter");
	find mustInstanceOfEOperation_class(problem,interpretation,container);
	find mayInstanceOfEParameter_class(problem,interpretation,newObject);
	find mayInRelationeParameters_reference_EOperation(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_EParameter_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"EParameter class");
	find mayInstanceOfEParameter_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_EGenericType_class_by_eGenericSuperTypes_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"EGenericType class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"eGenericSuperTypes reference EClass");
	find mustInstanceOfEClass_class(problem,interpretation,container);
	find mayInstanceOfEGenericType_class(problem,interpretation,newObject);
	find mayInRelationeGenericSuperTypes_reference_EClass(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_EGenericType_class_by_eGenericExceptions_reference_EOperation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"EGenericType class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"eGenericExceptions reference EOperation");
	find mustInstanceOfEOperation_class(problem,interpretation,container);
	find mayInstanceOfEGenericType_class(problem,interpretation,newObject);
	find mayInRelationeGenericExceptions_reference_EOperation(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_EGenericType_class_by_eGenericType_reference_ETypedElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"EGenericType class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"eGenericType reference ETypedElement");
	find mustInstanceOfETypedElement_class(problem,interpretation,container);
	find mayInstanceOfEGenericType_class(problem,interpretation,newObject);
	find mayInRelationeGenericType_reference_ETypedElement(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_EGenericType_class_by_eUpperBound_reference_EGenericType(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"EGenericType class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"eUpperBound reference EGenericType");
	find mustInstanceOfEGenericType_class(problem,interpretation,container);
	find mayInstanceOfEGenericType_class(problem,interpretation,newObject);
	find mayInRelationeUpperBound_reference_EGenericType(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_EGenericType_class_by_eTypeArguments_reference_EGenericType(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"EGenericType class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"eTypeArguments reference EGenericType");
	find mustInstanceOfEGenericType_class(problem,interpretation,container);
	find mayInstanceOfEGenericType_class(problem,interpretation,newObject);
	find mayInRelationeTypeArguments_reference_EGenericType(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_EGenericType_class_by_eLowerBound_reference_EGenericType(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"EGenericType class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"eLowerBound reference EGenericType");
	find mustInstanceOfEGenericType_class(problem,interpretation,container);
	find mayInstanceOfEGenericType_class(problem,interpretation,newObject);
	find mayInRelationeLowerBound_reference_EGenericType(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_EGenericType_class_by_eBounds_reference_ETypeParameter(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"EGenericType class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"eBounds reference ETypeParameter");
	find mustInstanceOfETypeParameter_class(problem,interpretation,container);
	find mayInstanceOfEGenericType_class(problem,interpretation,newObject);
	find mayInRelationeBounds_reference_ETypeParameter(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_EGenericType_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"EGenericType class");
	find mayInstanceOfEGenericType_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_EPackage_class_UndefinedPart_by_eSubpackages_reference_EPackage_with_eSuperPackage_reference_EPackage(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"EPackage class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"eSubpackages reference EPackage");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"eSuperPackage reference EPackage");
	find mustInstanceOfEPackage_class(problem,interpretation,container);
	find mayInstanceOfEPackage_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationeSubpackages_reference_EPackage(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_EPackage_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"EPackage class UndefinedPart");
	find mayInstanceOfEPackage_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_EObject_class_by_contents_reference_EAnnotation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"EObject class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"contents reference EAnnotation");
	find mustInstanceOfEAnnotation_class(problem,interpretation,container);
	find mayInstanceOfEObject_class(problem,interpretation,newObject);
	find mayInRelationcontents_reference_EAnnotation(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_EObject_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"EObject class");
	find mayInstanceOfEObject_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_EEnumLiteral_class_by_eLiterals_reference_EEnum_with_eEnum_reference_EEnumLiteral(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"EEnumLiteral class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"eLiterals reference EEnum");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"eEnum reference EEnumLiteral");
	find mustInstanceOfEEnum_class(problem,interpretation,container);
	find mayInstanceOfEEnumLiteral_class(problem,interpretation,newObject);
	find mayInRelationeLiterals_reference_EEnum(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_EEnumLiteral_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"EEnumLiteral class");
	find mayInstanceOfEEnumLiteral_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_ETypeParameter_class_by_eTypeParameters_reference_EClassifier(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"ETypeParameter class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"eTypeParameters reference EClassifier");
	find mustInstanceOfEClassifier_class(problem,interpretation,container);
	find mayInstanceOfETypeParameter_class(problem,interpretation,newObject);
	find mayInRelationeTypeParameters_reference_EClassifier(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_ETypeParameter_class_by_eTypeParameters_reference_EOperation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"ETypeParameter class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"eTypeParameters reference EOperation");
	find mustInstanceOfEOperation_class(problem,interpretation,container);
	find mayInstanceOfETypeParameter_class(problem,interpretation,newObject);
	find mayInRelationeTypeParameters_reference_EOperation(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_ETypeParameter_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"ETypeParameter class");
	find mayInstanceOfETypeParameter_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_EAttribute_class_by_eStructuralFeatures_reference_EClass_with_eContainingClass_reference_EStructuralFeature(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"EAttribute class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"eStructuralFeatures reference EClass");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"eContainingClass reference EStructuralFeature");
	find mustInstanceOfEClass_class(problem,interpretation,container);
	find mayInstanceOfEAttribute_class(problem,interpretation,newObject);
	find mayInRelationeStructuralFeatures_reference_EClass(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_EAttribute_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"EAttribute class");
	find mayInstanceOfEAttribute_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_EOperation_class_by_eOperations_reference_EClass_with_eContainingClass_reference_EOperation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"EOperation class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"eOperations reference EClass");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"eContainingClass reference EOperation");
	find mustInstanceOfEClass_class(problem,interpretation,container);
	find mayInstanceOfEOperation_class(problem,interpretation,newObject);
	find mayInRelationeOperations_reference_EClass(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_EOperation_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"EOperation class");
	find mayInstanceOfEOperation_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_EAnnotation_class_by_eAnnotations_reference_EModelElement_with_eModelElement_reference_EAnnotation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"EAnnotation class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"eAnnotations reference EModelElement");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"eModelElement reference EAnnotation");
	find mustInstanceOfEModelElement_class(problem,interpretation,container);
	find mayInstanceOfEAnnotation_class(problem,interpretation,newObject);
	find mayInRelationeAnnotations_reference_EModelElement(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_EAnnotation_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"EAnnotation class");
	find mayInstanceOfEAnnotation_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_EReference_class_by_eStructuralFeatures_reference_EClass_with_eContainingClass_reference_EStructuralFeature(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"EReference class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"eStructuralFeatures reference EClass");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"eContainingClass reference EStructuralFeature");
	find mustInstanceOfEClass_class(problem,interpretation,container);
	find mayInstanceOfEReference_class(problem,interpretation,newObject);
	find mayInRelationeStructuralFeatures_reference_EClass(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_EReference_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"EReference class");
	find mayInstanceOfEReference_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_EDataType_class_by_eClassifiers_reference_EPackage_with_ePackage_reference_EClassifier(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"EDataType class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"eClassifiers reference EPackage");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"ePackage reference EClassifier");
	find mustInstanceOfEPackage_class(problem,interpretation,container);
	find mayInstanceOfEDataType_class(problem,interpretation,newObject);
	find mayInRelationeClassifiers_reference_EPackage(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_EDataType_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"EDataType class");
	find mayInstanceOfEDataType_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_EClass_class_by_eClassifiers_reference_EPackage_with_ePackage_reference_EClassifier(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"EClass class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"eClassifiers reference EPackage");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"ePackage reference EClassifier");
	find mustInstanceOfEPackage_class(problem,interpretation,container);
	find mayInstanceOfEClass_class(problem,interpretation,newObject);
	find mayInRelationeClassifiers_reference_EPackage(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_EClass_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"EClass class");
	find mayInstanceOfEClass_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}

//////////
// 4.2 Type refinement
//////////
pattern refineTypeTo_EStringToStringMapEntry_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfEModelElement_class(problem,interpretation,element);
}
pattern refineTypeTo_EEnum_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfEEnum_class(problem,interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEEnum_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfEEnumLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfETypeParameter_class(problem,interpretation,element);
	neg find mustInstanceOfETypedElement_class(problem,interpretation,element);
	neg find mustInstanceOfEClass_class(problem,interpretation,element);
	neg find mustInstanceOfEPackage_class(problem,interpretation,element);
}
pattern refineTypeTo_EParameter_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfEParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfEEnumLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfETypeParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEStructuralFeature_class(problem,interpretation,element);
	neg find mustInstanceOfEClassifier_class(problem,interpretation,element);
	neg find mustInstanceOfEPackage_class(problem,interpretation,element);
	neg find mustInstanceOfEOperation_class(problem,interpretation,element);
}
pattern refineTypeTo_EGenericType_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfEModelElement_class(problem,interpretation,element);
}
pattern refineTypeTo_EPackage_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfEPackage_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfEPackage_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfEEnumLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfETypeParameter_class(problem,interpretation,element);
	neg find mustInstanceOfETypedElement_class(problem,interpretation,element);
	neg find mustInstanceOfEClassifier_class(problem,interpretation,element);
}
pattern refineTypeTo_EObject_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfEModelElement_class(problem,interpretation,element);
}
pattern refineTypeTo_EEnumLiteral_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfEEnumLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfEEnumLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfETypeParameter_class(problem,interpretation,element);
	neg find mustInstanceOfETypedElement_class(problem,interpretation,element);
	neg find mustInstanceOfEClassifier_class(problem,interpretation,element);
	neg find mustInstanceOfEPackage_class(problem,interpretation,element);
}
pattern refineTypeTo_ETypeParameter_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfETypeParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfEEnumLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfETypeParameter_class(problem,interpretation,element);
	neg find mustInstanceOfETypedElement_class(problem,interpretation,element);
	neg find mustInstanceOfEClassifier_class(problem,interpretation,element);
	neg find mustInstanceOfEPackage_class(problem,interpretation,element);
}
pattern refineTypeTo_EAttribute_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfEAttribute_class(problem,interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEReference_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfEEnumLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfETypeParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEClassifier_class(problem,interpretation,element);
	neg find mustInstanceOfEPackage_class(problem,interpretation,element);
	neg find mustInstanceOfEAttribute_class(problem,interpretation,element);
	neg find mustInstanceOfEOperation_class(problem,interpretation,element);
}
pattern refineTypeTo_EOperation_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfEOperation_class(problem,interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfEEnumLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfETypeParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEStructuralFeature_class(problem,interpretation,element);
	neg find mustInstanceOfEClassifier_class(problem,interpretation,element);
	neg find mustInstanceOfEPackage_class(problem,interpretation,element);
	neg find mustInstanceOfEOperation_class(problem,interpretation,element);
}
pattern refineTypeTo_EAnnotation_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfENamedElement_class(problem,interpretation,element);
}
pattern refineTypeTo_EReference_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfEReference_class(problem,interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEReference_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfEEnumLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfETypeParameter_class(problem,interpretation,element);
	neg find mustInstanceOfEClassifier_class(problem,interpretation,element);
	neg find mustInstanceOfEPackage_class(problem,interpretation,element);
	neg find mustInstanceOfEOperation_class(problem,interpretation,element);
	neg find mustInstanceOfEAttribute_class(problem,interpretation,element);
}
pattern refineTypeTo_EDataType_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfEDataType_class(problem,interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEEnum_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfEEnumLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfEDataType_class(problem,interpretation,element);
	neg find mustInstanceOfETypeParameter_class(problem,interpretation,element);
	neg find mustInstanceOfETypedElement_class(problem,interpretation,element);
	neg find mustInstanceOfEClass_class(problem,interpretation,element);
	neg find mustInstanceOfEPackage_class(problem,interpretation,element);
}
pattern refineTypeTo_EClass_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfEClass_class(problem,interpretation,element);
	neg find mustInstanceOfEAnnotation_class(problem,interpretation,element);
	neg find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,element);
	neg find mustInstanceOfEGenericType_class(problem,interpretation,element);
	neg find mustInstanceOfEObject_class(problem,interpretation,element);
	neg find mustInstanceOfEDataType_class(problem,interpretation,element);
	neg find mustInstanceOfEEnumLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfETypeParameter_class(problem,interpretation,element);
	neg find mustInstanceOfETypedElement_class(problem,interpretation,element);
	neg find mustInstanceOfEClass_class(problem,interpretation,element);
	neg find mustInstanceOfEPackage_class(problem,interpretation,element);
}

//////////
// 4.3 Relation refinement
//////////
pattern refineRelation_eAttributeType_reference_EAttribute(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eAttributeType reference EAttribute");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEAttribute_class(problem,interpretation,from);
	find mustInstanceOfEDataType_class(problem,interpretation,to);
	find mayInRelationeAttributeType_reference_EAttribute(problem,interpretation,from,to);
	neg find mustInRelationeAttributeType_reference_EAttribute(problem,interpretation,from,to);
}
pattern refineRelation_references_reference_EAnnotation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"references reference EAnnotation");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEAnnotation_class(problem,interpretation,from);
	find mustInstanceOfEObject_class(problem,interpretation,to);
	find mayInRelationreferences_reference_EAnnotation(problem,interpretation,from,to);
	neg find mustInRelationreferences_reference_EAnnotation(problem,interpretation,from,to);
}
pattern refineRelation_eSuperTypes_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eSuperTypes reference EClass");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEClass_class(problem,interpretation,from);
	find mustInstanceOfEClass_class(problem,interpretation,to);
	find mayInRelationeSuperTypes_reference_EClass(problem,interpretation,from,to);
	neg find mustInRelationeSuperTypes_reference_EClass(problem,interpretation,from,to);
}
pattern refineRelation_eAllAttributes_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eAllAttributes reference EClass");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEClass_class(problem,interpretation,from);
	find mustInstanceOfEAttribute_class(problem,interpretation,to);
	find mayInRelationeAllAttributes_reference_EClass(problem,interpretation,from,to);
	neg find mustInRelationeAllAttributes_reference_EClass(problem,interpretation,from,to);
}
pattern refineRelation_eAllReferences_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eAllReferences reference EClass");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEClass_class(problem,interpretation,from);
	find mustInstanceOfEReference_class(problem,interpretation,to);
	find mayInRelationeAllReferences_reference_EClass(problem,interpretation,from,to);
	neg find mustInRelationeAllReferences_reference_EClass(problem,interpretation,from,to);
}
pattern refineRelation_eReferences_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eReferences reference EClass");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEClass_class(problem,interpretation,from);
	find mustInstanceOfEReference_class(problem,interpretation,to);
	find mayInRelationeReferences_reference_EClass(problem,interpretation,from,to);
	neg find mustInRelationeReferences_reference_EClass(problem,interpretation,from,to);
}
pattern refineRelation_eAttributes_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eAttributes reference EClass");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEClass_class(problem,interpretation,from);
	find mustInstanceOfEAttribute_class(problem,interpretation,to);
	find mayInRelationeAttributes_reference_EClass(problem,interpretation,from,to);
	neg find mustInRelationeAttributes_reference_EClass(problem,interpretation,from,to);
}
pattern refineRelation_eAllContainments_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eAllContainments reference EClass");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEClass_class(problem,interpretation,from);
	find mustInstanceOfEReference_class(problem,interpretation,to);
	find mayInRelationeAllContainments_reference_EClass(problem,interpretation,from,to);
	neg find mustInRelationeAllContainments_reference_EClass(problem,interpretation,from,to);
}
pattern refineRelation_eAllOperations_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eAllOperations reference EClass");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEClass_class(problem,interpretation,from);
	find mustInstanceOfEOperation_class(problem,interpretation,to);
	find mayInRelationeAllOperations_reference_EClass(problem,interpretation,from,to);
	neg find mustInRelationeAllOperations_reference_EClass(problem,interpretation,from,to);
}
pattern refineRelation_eAllStructuralFeatures_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eAllStructuralFeatures reference EClass");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEClass_class(problem,interpretation,from);
	find mustInstanceOfEStructuralFeature_class(problem,interpretation,to);
	find mayInRelationeAllStructuralFeatures_reference_EClass(problem,interpretation,from,to);
	neg find mustInRelationeAllStructuralFeatures_reference_EClass(problem,interpretation,from,to);
}
pattern refineRelation_eAllSuperTypes_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eAllSuperTypes reference EClass");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEClass_class(problem,interpretation,from);
	find mustInstanceOfEClass_class(problem,interpretation,to);
	find mayInRelationeAllSuperTypes_reference_EClass(problem,interpretation,from,to);
	neg find mustInRelationeAllSuperTypes_reference_EClass(problem,interpretation,from,to);
}
pattern refineRelation_eIDAttribute_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eIDAttribute reference EClass");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEClass_class(problem,interpretation,from);
	find mustInstanceOfEAttribute_class(problem,interpretation,to);
	find mayInRelationeIDAttribute_reference_EClass(problem,interpretation,from,to);
	neg find mustInRelationeIDAttribute_reference_EClass(problem,interpretation,from,to);
}
pattern refineRelation_eAllGenericSuperTypes_reference_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eAllGenericSuperTypes reference EClass");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEClass_class(problem,interpretation,from);
	find mustInstanceOfEGenericType_class(problem,interpretation,to);
	find mayInRelationeAllGenericSuperTypes_reference_EClass(problem,interpretation,from,to);
	neg find mustInRelationeAllGenericSuperTypes_reference_EClass(problem,interpretation,from,to);
}
pattern refineRelation_eExceptions_reference_EOperation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eExceptions reference EOperation");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEOperation_class(problem,interpretation,from);
	find mustInstanceOfEClassifier_class(problem,interpretation,to);
	find mayInRelationeExceptions_reference_EOperation(problem,interpretation,from,to);
	neg find mustInRelationeExceptions_reference_EOperation(problem,interpretation,from,to);
}
pattern refineRelation_eOpposite_reference_EReference(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eOpposite reference EReference");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEReference_class(problem,interpretation,from);
	find mustInstanceOfEReference_class(problem,interpretation,to);
	find mayInRelationeOpposite_reference_EReference(problem,interpretation,from,to);
	neg find mustInRelationeOpposite_reference_EReference(problem,interpretation,from,to);
}
pattern refineRelation_eReferenceType_reference_EReference(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eReferenceType reference EReference");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEReference_class(problem,interpretation,from);
	find mustInstanceOfEClass_class(problem,interpretation,to);
	find mayInRelationeReferenceType_reference_EReference(problem,interpretation,from,to);
	neg find mustInRelationeReferenceType_reference_EReference(problem,interpretation,from,to);
}
pattern refineRelation_eKeys_reference_EReference(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eKeys reference EReference");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEReference_class(problem,interpretation,from);
	find mustInstanceOfEAttribute_class(problem,interpretation,to);
	find mayInRelationeKeys_reference_EReference(problem,interpretation,from,to);
	neg find mustInRelationeKeys_reference_EReference(problem,interpretation,from,to);
}
pattern refineRelation_eType_reference_ETypedElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eType reference ETypedElement");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfETypedElement_class(problem,interpretation,from);
	find mustInstanceOfEClassifier_class(problem,interpretation,to);
	find mayInRelationeType_reference_ETypedElement(problem,interpretation,from,to);
	neg find mustInRelationeType_reference_ETypedElement(problem,interpretation,from,to);
}
pattern refineRelation_eRawType_reference_EGenericType(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eRawType reference EGenericType");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEGenericType_class(problem,interpretation,from);
	find mustInstanceOfEClassifier_class(problem,interpretation,to);
	find mayInRelationeRawType_reference_EGenericType(problem,interpretation,from,to);
	neg find mustInRelationeRawType_reference_EGenericType(problem,interpretation,from,to);
}
pattern refineRelation_eTypeParameter_reference_EGenericType(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eTypeParameter reference EGenericType");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEGenericType_class(problem,interpretation,from);
	find mustInstanceOfETypeParameter_class(problem,interpretation,to);
	find mayInRelationeTypeParameter_reference_EGenericType(problem,interpretation,from,to);
	neg find mustInRelationeTypeParameter_reference_EGenericType(problem,interpretation,from,to);
}
pattern refineRelation_eClassifier_reference_EGenericType(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"eClassifier reference EGenericType");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEGenericType_class(problem,interpretation,from);
	find mustInstanceOfEClassifier_class(problem,interpretation,to);
	find mayInRelationeClassifier_reference_EGenericType(problem,interpretation,from,to);
	neg find mustInRelationeClassifier_reference_EGenericType(problem,interpretation,from,to);
}
pattern refineRelation_iD_attribute_EAttribute(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"iD attribute EAttribute");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEAttribute_class(problem,interpretation,from);
	BooleanElement(to);
	find mayInRelationiD_attribute_EAttribute(problem,interpretation,from,to);
	neg find mustInRelationiD_attribute_EAttribute(problem,interpretation,from,to);
}
pattern refineRelation_source_attribute_EAnnotation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"source attribute EAnnotation");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEAnnotation_class(problem,interpretation,from);
	StringElement(to);
	find mayInRelationsource_attribute_EAnnotation(problem,interpretation,from,to);
	neg find mustInRelationsource_attribute_EAnnotation(problem,interpretation,from,to);
}
pattern refineRelation_abstract_attribute_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"abstract attribute EClass");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEClass_class(problem,interpretation,from);
	BooleanElement(to);
	find mayInRelationabstract_attribute_EClass(problem,interpretation,from,to);
	neg find mustInRelationabstract_attribute_EClass(problem,interpretation,from,to);
}
pattern refineRelation_interface_attribute_EClass(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"interface attribute EClass");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEClass_class(problem,interpretation,from);
	BooleanElement(to);
	find mayInRelationinterface_attribute_EClass(problem,interpretation,from,to);
	neg find mustInRelationinterface_attribute_EClass(problem,interpretation,from,to);
}
pattern refineRelation_instanceClassName_attribute_EClassifier(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"instanceClassName attribute EClassifier");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEClassifier_class(problem,interpretation,from);
	StringElement(to);
	find mayInRelationinstanceClassName_attribute_EClassifier(problem,interpretation,from,to);
	neg find mustInRelationinstanceClassName_attribute_EClassifier(problem,interpretation,from,to);
}
pattern refineRelation_instanceTypeName_attribute_EClassifier(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"instanceTypeName attribute EClassifier");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEClassifier_class(problem,interpretation,from);
	StringElement(to);
	find mayInRelationinstanceTypeName_attribute_EClassifier(problem,interpretation,from,to);
	neg find mustInRelationinstanceTypeName_attribute_EClassifier(problem,interpretation,from,to);
}
pattern refineRelation_serializable_attribute_EDataType(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"serializable attribute EDataType");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEDataType_class(problem,interpretation,from);
	BooleanElement(to);
	find mayInRelationserializable_attribute_EDataType(problem,interpretation,from,to);
	neg find mustInRelationserializable_attribute_EDataType(problem,interpretation,from,to);
}
pattern refineRelation_value_attribute_EEnumLiteral(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"value attribute EEnumLiteral");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEEnumLiteral_class(problem,interpretation,from);
	IntegerElement(to);
	find mayInRelationvalue_attribute_EEnumLiteral(problem,interpretation,from,to);
	neg find mustInRelationvalue_attribute_EEnumLiteral(problem,interpretation,from,to);
}
pattern refineRelation_literal_attribute_EEnumLiteral(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"literal attribute EEnumLiteral");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEEnumLiteral_class(problem,interpretation,from);
	StringElement(to);
	find mayInRelationliteral_attribute_EEnumLiteral(problem,interpretation,from,to);
	neg find mustInRelationliteral_attribute_EEnumLiteral(problem,interpretation,from,to);
}
pattern refineRelation_name_attribute_ENamedElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"name attribute ENamedElement");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfENamedElement_class(problem,interpretation,from);
	StringElement(to);
	find mayInRelationname_attribute_ENamedElement(problem,interpretation,from,to);
	neg find mustInRelationname_attribute_ENamedElement(problem,interpretation,from,to);
}
pattern refineRelation_nsURI_attribute_EPackage(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"nsURI attribute EPackage");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEPackage_class(problem,interpretation,from);
	StringElement(to);
	find mayInRelationnsURI_attribute_EPackage(problem,interpretation,from,to);
	neg find mustInRelationnsURI_attribute_EPackage(problem,interpretation,from,to);
}
pattern refineRelation_nsPrefix_attribute_EPackage(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"nsPrefix attribute EPackage");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEPackage_class(problem,interpretation,from);
	StringElement(to);
	find mayInRelationnsPrefix_attribute_EPackage(problem,interpretation,from,to);
	neg find mustInRelationnsPrefix_attribute_EPackage(problem,interpretation,from,to);
}
pattern refineRelation_containment_attribute_EReference(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"containment attribute EReference");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEReference_class(problem,interpretation,from);
	BooleanElement(to);
	find mayInRelationcontainment_attribute_EReference(problem,interpretation,from,to);
	neg find mustInRelationcontainment_attribute_EReference(problem,interpretation,from,to);
}
pattern refineRelation_container_attribute_EReference(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"container attribute EReference");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEReference_class(problem,interpretation,from);
	BooleanElement(to);
	find mayInRelationcontainer_attribute_EReference(problem,interpretation,from,to);
	neg find mustInRelationcontainer_attribute_EReference(problem,interpretation,from,to);
}
pattern refineRelation_resolveProxies_attribute_EReference(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"resolveProxies attribute EReference");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEReference_class(problem,interpretation,from);
	BooleanElement(to);
	find mayInRelationresolveProxies_attribute_EReference(problem,interpretation,from,to);
	neg find mustInRelationresolveProxies_attribute_EReference(problem,interpretation,from,to);
}
pattern refineRelation_changeable_attribute_EStructuralFeature(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"changeable attribute EStructuralFeature");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEStructuralFeature_class(problem,interpretation,from);
	BooleanElement(to);
	find mayInRelationchangeable_attribute_EStructuralFeature(problem,interpretation,from,to);
	neg find mustInRelationchangeable_attribute_EStructuralFeature(problem,interpretation,from,to);
}
pattern refineRelation_volatile_attribute_EStructuralFeature(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"volatile attribute EStructuralFeature");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEStructuralFeature_class(problem,interpretation,from);
	BooleanElement(to);
	find mayInRelationvolatile_attribute_EStructuralFeature(problem,interpretation,from,to);
	neg find mustInRelationvolatile_attribute_EStructuralFeature(problem,interpretation,from,to);
}
pattern refineRelation_transient_attribute_EStructuralFeature(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"transient attribute EStructuralFeature");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEStructuralFeature_class(problem,interpretation,from);
	BooleanElement(to);
	find mayInRelationtransient_attribute_EStructuralFeature(problem,interpretation,from,to);
	neg find mustInRelationtransient_attribute_EStructuralFeature(problem,interpretation,from,to);
}
pattern refineRelation_defaultValueLiteral_attribute_EStructuralFeature(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"defaultValueLiteral attribute EStructuralFeature");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEStructuralFeature_class(problem,interpretation,from);
	StringElement(to);
	find mayInRelationdefaultValueLiteral_attribute_EStructuralFeature(problem,interpretation,from,to);
	neg find mustInRelationdefaultValueLiteral_attribute_EStructuralFeature(problem,interpretation,from,to);
}
pattern refineRelation_unsettable_attribute_EStructuralFeature(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"unsettable attribute EStructuralFeature");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEStructuralFeature_class(problem,interpretation,from);
	BooleanElement(to);
	find mayInRelationunsettable_attribute_EStructuralFeature(problem,interpretation,from,to);
	neg find mustInRelationunsettable_attribute_EStructuralFeature(problem,interpretation,from,to);
}
pattern refineRelation_derived_attribute_EStructuralFeature(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"derived attribute EStructuralFeature");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEStructuralFeature_class(problem,interpretation,from);
	BooleanElement(to);
	find mayInRelationderived_attribute_EStructuralFeature(problem,interpretation,from,to);
	neg find mustInRelationderived_attribute_EStructuralFeature(problem,interpretation,from,to);
}
pattern refineRelation_ordered_attribute_ETypedElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"ordered attribute ETypedElement");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfETypedElement_class(problem,interpretation,from);
	BooleanElement(to);
	find mayInRelationordered_attribute_ETypedElement(problem,interpretation,from,to);
	neg find mustInRelationordered_attribute_ETypedElement(problem,interpretation,from,to);
}
pattern refineRelation_unique_attribute_ETypedElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"unique attribute ETypedElement");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfETypedElement_class(problem,interpretation,from);
	BooleanElement(to);
	find mayInRelationunique_attribute_ETypedElement(problem,interpretation,from,to);
	neg find mustInRelationunique_attribute_ETypedElement(problem,interpretation,from,to);
}
pattern refineRelation_lowerBound_attribute_ETypedElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"lowerBound attribute ETypedElement");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfETypedElement_class(problem,interpretation,from);
	IntegerElement(to);
	find mayInRelationlowerBound_attribute_ETypedElement(problem,interpretation,from,to);
	neg find mustInRelationlowerBound_attribute_ETypedElement(problem,interpretation,from,to);
}
pattern refineRelation_upperBound_attribute_ETypedElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"upperBound attribute ETypedElement");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfETypedElement_class(problem,interpretation,from);
	IntegerElement(to);
	find mayInRelationupperBound_attribute_ETypedElement(problem,interpretation,from,to);
	neg find mustInRelationupperBound_attribute_ETypedElement(problem,interpretation,from,to);
}
pattern refineRelation_many_attribute_ETypedElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"many attribute ETypedElement");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfETypedElement_class(problem,interpretation,from);
	BooleanElement(to);
	find mayInRelationmany_attribute_ETypedElement(problem,interpretation,from,to);
	neg find mustInRelationmany_attribute_ETypedElement(problem,interpretation,from,to);
}
pattern refineRelation_required_attribute_ETypedElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"required attribute ETypedElement");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfETypedElement_class(problem,interpretation,from);
	BooleanElement(to);
	find mayInRelationrequired_attribute_ETypedElement(problem,interpretation,from,to);
	neg find mustInRelationrequired_attribute_ETypedElement(problem,interpretation,from,to);
}
pattern refineRelation_key_attribute_EStringToStringMapEntry(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"key attribute EStringToStringMapEntry");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,from);
	StringElement(to);
	find mayInRelationkey_attribute_EStringToStringMapEntry(problem,interpretation,from,to);
	neg find mustInRelationkey_attribute_EStringToStringMapEntry(problem,interpretation,from,to);
}
pattern refineRelation_value_attribute_EStringToStringMapEntry(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"value attribute EStringToStringMapEntry");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfEStringToStringMapEntry_class(problem,interpretation,from);
	StringElement(to);
	find mayInRelationvalue_attribute_EStringToStringMapEntry(problem,interpretation,from,to);
	neg find mustInRelationvalue_attribute_EStringToStringMapEntry(problem,interpretation,from,to);
}
