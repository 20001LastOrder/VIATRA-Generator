import epackage "http://www.bme.hu/mit/inf/dslreasoner/viatrasolver/partialinterpretationlanguage"
import epackage "http://www.bme.hu/mit/inf/dslreasoner/logic/model/problem"
import epackage "http://www.bme.hu/mit/inf/dslreasoner/logic/model/language"

//////////
// 0. Util
//////////
private pattern interpretation(problem:LogicProblem, interpretation:PartialInterpretation) {
	PartialInterpretation.problem(interpretation,problem);
}
	
/////////////////////////
// 0.1 Existence
/////////////////////////
/** [[exist(element)]]=1 */
private pattern mustExist(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	find interpretation(problem,interpretation);
	LogicProblem.elements(problem,element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
}

/** [[exist(element)]]>=1/2 */
private pattern mayExist(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
    find mustExist(problem,interpretation,element);
} or {
    find interpretation(problem,interpretation);
    neg find elementCloseWorld(element);
    PartialInterpretation.openWorldElements(interpretation,element);
}

private pattern elementCloseWorld(element:DefinedElement) {
	PartialInterpretation.openWorldElements(i,element);
    PartialInterpretation.maxNewElements(i,0);
} or {
	Scope.targetTypeInterpretation(scope,interpretation);
	PartialTypeInterpratation.elements(interpretation,element);
	Scope.maxNewElements(scope,0);
}

////////////////////////
// 0.2 Equivalence
////////////////////////
pattern mayEquivalent(problem:LogicProblem, interpretation:PartialInterpretation, a: DefinedElement, b: DefinedElement)
// For non-primitive type. Boolean types always must equivalent or cannot equivalent
{
	find mayExist(problem,interpretation,a);
	find mayExist(problem,interpretation,b);
	a == b;
} or {
	find mayExist(problem,interpretation,a);
	find mayExist(problem,interpretation,b);
	IntegerElement(a);
	IntegerElement(b);
	PrimitiveElement.valueSet(a,false);
} or {
	find mayExist(problem,interpretation,a);
	find mayExist(problem,interpretation,b);
	IntegerElement(a);
	IntegerElement(b);
	PrimitiveElement.valueSet(b,false);
} or {
	find mayExist(problem,interpretation,a);
	find mayExist(problem,interpretation,b);
	RealElement(a);
	RealElement(b);
	PrimitiveElement.valueSet(a,false);
} or {
	find mayExist(problem,interpretation,a);
	find mayExist(problem,interpretation,b);
	RealElement(a);
	RealElement(b);
	PrimitiveElement.valueSet(b,false);
} or {
	find mayExist(problem,interpretation,a);
	find mayExist(problem,interpretation,b);
	RealElement(a);
	IntegerElement(b);
	PrimitiveElement.valueSet(a,false);
} or {
	find mayExist(problem,interpretation,a);
	find mayExist(problem,interpretation,b);
	RealElement(a);
	IntegerElement(b);
	PrimitiveElement.valueSet(b,false);
} or {
	find mayExist(problem,interpretation,a);
	find mayExist(problem,interpretation,b);
	IntegerElement(a);
	RealElement(b);
	PrimitiveElement.valueSet(a,false);
} or {
	find mayExist(problem,interpretation,a);
	find mayExist(problem,interpretation,b);
	IntegerElement(a);
	RealElement(b);
	PrimitiveElement.valueSet(b,false);
} or {
	find mayExist(problem,interpretation,a);
	find mayExist(problem,interpretation,b);
	StringElement(a);
	StringElement(b);
	PrimitiveElement.valueSet(a,false);
} or {
	find mayExist(problem,interpretation,a);
	find mayExist(problem,interpretation,b);
	StringElement(a);
	StringElement(b);
	PrimitiveElement.valueSet(b,false);
}

pattern mustEquivalent(problem:LogicProblem, interpretation:PartialInterpretation, a: DefinedElement, b: DefinedElement) {
// For non-primitive and Boolean primitive type
	find mustExist(problem,interpretation,a);
	find mustExist(problem,interpretation,b);
	a == b;
} or {
	find mustExist(problem,interpretation,a);
	find mustExist(problem,interpretation,b);
	PrimitiveElement.valueSet(a,true);
	PrimitiveElement.valueSet(b,true);
	IntegerElement.value(a,value);
	IntegerElement.value(b,value);
} or {
	find mustExist(problem,interpretation,a);
	find mustExist(problem,interpretation,b);
	PrimitiveElement.valueSet(a,true);
	PrimitiveElement.valueSet(b,true);
	RealElement.value(a,value);
	RealElement.value(b,value);
} or {
	find mustExist(problem,interpretation,a);
	find mustExist(problem,interpretation,b);
	PrimitiveElement.valueSet(a,true);
	PrimitiveElement.valueSet(b,true);
	RealElement.value(a,value);
	IntegerElement.value(b,value);
} or {
	find mustExist(problem,interpretation,a);
	find mustExist(problem,interpretation,b);
	PrimitiveElement.valueSet(a,true);
	PrimitiveElement.valueSet(b,true);
	IntegerElement.value(a,value);
	RealElement.value(b,value);
} or {
	find mustExist(problem,interpretation,a);
	find mustExist(problem,interpretation,b);
	PrimitiveElement.valueSet(a,true);
	PrimitiveElement.valueSet(b,true);
	StringElement.value(a,value);
	StringElement.value(b,value);
}

//////////
// 1. Problem-Specific Base Indexers
//////////
// 1.1 Type Indexers
//////////
// 1.1.1 Required Patterns by TypeIndexer
//////////
private pattern typeInterpretation(problem:LogicProblem, interpretation:PartialInterpretation, type:TypeDeclaration, typeInterpretation:PartialComplexTypeInterpretation) {
	find interpretation(problem,interpretation);
	LogicProblem.types(problem,type);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
}

private pattern directInstanceOf(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement, type:Type) {
	find interpretation(problem,interpretation);
	LogicProblem.types(problem,type);
	TypeDefinition.elements(type,element);
} or {
	find interpretation(problem,interpretation);
	find typeInterpretation(problem,interpretation,type,typeInterpretation);
	PartialComplexTypeInterpretation.elements(typeInterpretation,element);
}

private pattern isPrimitive(element: PrimitiveElement) {
	PrimitiveElement(element);
}
//////////
// 1.1.2 primitive Type Indexers
//////////
// Currently unused. Refer primitive types as:
// > PrimitiveElement(element)
// specific types are referred as:
// > BooleanElement(variableName)
// > IntegerElement(variableName)
// > RealElement(variableName)
// > StringElement(variableName)
// And their value as
// > BooleanElement.value(variableName,value)
// > IntegerElement.value(variableName,value)
// > RealElement.value(variableName,value)
// > StringElement.value(variableName,value)
// Whether a value is set is defined by:
// > PrimitiveElement.valueSet(variableName,isFilled);
//////////
// 1.1.3 domain-specific Type Indexers
//////////
/**
 * An element must be an instance of type "Constants class".
 */
private pattern mustInstanceOfConstants_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Constants class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewConstants_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Constants class");
}

/**
 * An element may be an instance of type "Constants class".
 */
private pattern mayInstanceOfConstants_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFromAgent_class(problem,interpretation,element);
	neg find mustInstanceOfFromLaw_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Case_class(problem,interpretation,element);
	neg find mustInstanceOfExpense_class(problem,interpretation,element);
	neg find mustInstanceOfAddress_class(problem,interpretation,element);
	neg find mustInstanceOfDS_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Type_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_class(problem,interpretation,element);
	neg find mustInstanceOfPhysical_Person_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Property_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_class(problem,interpretation,element);
	neg find mustInstanceOfProfessional_Expenses_Deduction_class(problem,interpretation,element);
	neg find mustInstanceOfExternal_Allowance_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Detail_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_Credit_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Card_class(problem,interpretation,element);
	neg find mustInstanceOfLegal_Union_Record_class(problem,interpretation,element);
	neg find scopeDisallowsNewConstants_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFromAgent_class(problem,interpretation,element);
	neg find mustInstanceOfFromLaw_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Case_class(problem,interpretation,element);
	neg find mustInstanceOfExpense_class(problem,interpretation,element);
	neg find mustInstanceOfAddress_class(problem,interpretation,element);
	neg find mustInstanceOfDS_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Type_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_class(problem,interpretation,element);
	neg find mustInstanceOfPhysical_Person_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Property_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_class(problem,interpretation,element);
	neg find mustInstanceOfProfessional_Expenses_Deduction_class(problem,interpretation,element);
	neg find mustInstanceOfExternal_Allowance_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Detail_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_Credit_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Card_class(problem,interpretation,element);
	neg find mustInstanceOfLegal_Union_Record_class(problem,interpretation,element);
	neg find scopeDisallowsNewConstants_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfConstants_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Income_Tax class".
 */
private pattern mustInstanceOfIncome_Tax_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Income_Tax class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewIncome_Tax_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Income_Tax class");
}

/**
 * An element may be an instance of type "Income_Tax class".
 */
private pattern mayInstanceOfIncome_Tax_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFromAgent_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Case_class(problem,interpretation,element);
	neg find mustInstanceOfFromLaw_class(problem,interpretation,element);
	neg find mustInstanceOfConstants_class(problem,interpretation,element);
	neg find mustInstanceOfExpense_class(problem,interpretation,element);
	neg find mustInstanceOfAddress_class(problem,interpretation,element);
	neg find mustInstanceOfDS_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Type_class(problem,interpretation,element);
	neg find mustInstanceOfPhysical_Person_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Property_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_class(problem,interpretation,element);
	neg find mustInstanceOfProfessional_Expenses_Deduction_class(problem,interpretation,element);
	neg find mustInstanceOfExternal_Allowance_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_Credit_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Detail_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Card_class(problem,interpretation,element);
	neg find mustInstanceOfLegal_Union_Record_class(problem,interpretation,element);
	neg find scopeDisallowsNewIncome_Tax_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFromAgent_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Case_class(problem,interpretation,element);
	neg find mustInstanceOfFromLaw_class(problem,interpretation,element);
	neg find mustInstanceOfConstants_class(problem,interpretation,element);
	neg find mustInstanceOfExpense_class(problem,interpretation,element);
	neg find mustInstanceOfAddress_class(problem,interpretation,element);
	neg find mustInstanceOfDS_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Type_class(problem,interpretation,element);
	neg find mustInstanceOfPhysical_Person_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Property_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_class(problem,interpretation,element);
	neg find mustInstanceOfProfessional_Expenses_Deduction_class(problem,interpretation,element);
	neg find mustInstanceOfExternal_Allowance_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_Credit_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Detail_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Card_class(problem,interpretation,element);
	neg find mustInstanceOfLegal_Union_Record_class(problem,interpretation,element);
	neg find scopeDisallowsNewIncome_Tax_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfIncome_Tax_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Tax_Payer class".
 */
private pattern mustInstanceOfTax_Payer_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Tax_Payer class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewTax_Payer_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Tax_Payer class");
}

/**
 * An element may be an instance of type "Tax_Payer class".
 */
private pattern mayInstanceOfTax_Payer_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFromAgent_class(problem,interpretation,element);
	neg find mustInstanceOfFromLaw_class(problem,interpretation,element);
	neg find mustInstanceOfExpense_class(problem,interpretation,element);
	neg find mustInstanceOfConstants_class(problem,interpretation,element);
	neg find mustInstanceOfAddress_class(problem,interpretation,element);
	neg find mustInstanceOfDS_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Type_class(problem,interpretation,element);
	neg find mustInstanceOfResident_Tax_Payer_class(problem,interpretation,element);
	neg find mustInstanceOfNon_Resident_Tax_Payer_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Property_class(problem,interpretation,element);
	neg find mustInstanceOfDependent_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_class(problem,interpretation,element);
	neg find mustInstanceOfProfessional_Expenses_Deduction_class(problem,interpretation,element);
	neg find mustInstanceOfExternal_Allowance_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Detail_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_Credit_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Card_class(problem,interpretation,element);
	neg find mustInstanceOfHousehold_class(problem,interpretation,element);
	neg find mustInstanceOfLegal_Union_Record_class(problem,interpretation,element);
	neg find scopeDisallowsNewTax_Payer_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFromAgent_class(problem,interpretation,element);
	neg find mustInstanceOfFromLaw_class(problem,interpretation,element);
	neg find mustInstanceOfExpense_class(problem,interpretation,element);
	neg find mustInstanceOfConstants_class(problem,interpretation,element);
	neg find mustInstanceOfAddress_class(problem,interpretation,element);
	neg find mustInstanceOfDS_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Type_class(problem,interpretation,element);
	neg find mustInstanceOfResident_Tax_Payer_class(problem,interpretation,element);
	neg find mustInstanceOfNon_Resident_Tax_Payer_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Property_class(problem,interpretation,element);
	neg find mustInstanceOfDependent_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_class(problem,interpretation,element);
	neg find mustInstanceOfProfessional_Expenses_Deduction_class(problem,interpretation,element);
	neg find mustInstanceOfExternal_Allowance_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Detail_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_Credit_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Card_class(problem,interpretation,element);
	neg find mustInstanceOfHousehold_class(problem,interpretation,element);
	neg find mustInstanceOfLegal_Union_Record_class(problem,interpretation,element);
	neg find scopeDisallowsNewTax_Payer_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfTax_Payer_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Physical_Person class".
 */
private pattern mustInstanceOfPhysical_Person_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Physical_Person class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewPhysical_Person_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Physical_Person class");
}

/**
 * An element may be an instance of type "Physical_Person class".
 */
private pattern mayInstanceOfPhysical_Person_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFromAgent_class(problem,interpretation,element);
	neg find mustInstanceOfFromLaw_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Case_class(problem,interpretation,element);
	neg find mustInstanceOfExpense_class(problem,interpretation,element);
	neg find mustInstanceOfConstants_class(problem,interpretation,element);
	neg find mustInstanceOfAddress_class(problem,interpretation,element);
	neg find mustInstanceOfDS_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Type_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Property_class(problem,interpretation,element);
	neg find mustInstanceOfDependent_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_class(problem,interpretation,element);
	neg find mustInstanceOfProfessional_Expenses_Deduction_class(problem,interpretation,element);
	neg find mustInstanceOfExternal_Allowance_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_Credit_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Detail_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Card_class(problem,interpretation,element);
	neg find mustInstanceOfLegal_Union_Record_class(problem,interpretation,element);
	neg find scopeDisallowsNewPhysical_Person_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFromAgent_class(problem,interpretation,element);
	neg find mustInstanceOfFromLaw_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Case_class(problem,interpretation,element);
	neg find mustInstanceOfExpense_class(problem,interpretation,element);
	neg find mustInstanceOfConstants_class(problem,interpretation,element);
	neg find mustInstanceOfAddress_class(problem,interpretation,element);
	neg find mustInstanceOfDS_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Type_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Property_class(problem,interpretation,element);
	neg find mustInstanceOfDependent_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_class(problem,interpretation,element);
	neg find mustInstanceOfProfessional_Expenses_Deduction_class(problem,interpretation,element);
	neg find mustInstanceOfExternal_Allowance_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_Credit_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Detail_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Card_class(problem,interpretation,element);
	neg find mustInstanceOfLegal_Union_Record_class(problem,interpretation,element);
	neg find scopeDisallowsNewPhysical_Person_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfPhysical_Person_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Address class".
 */
private pattern mustInstanceOfAddress_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Address class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewAddress_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Address class");
}

/**
 * An element may be an instance of type "Address class".
 */
private pattern mayInstanceOfAddress_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFromAgent_class(problem,interpretation,element);
	neg find mustInstanceOfFromLaw_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Case_class(problem,interpretation,element);
	neg find mustInstanceOfExpense_class(problem,interpretation,element);
	neg find mustInstanceOfConstants_class(problem,interpretation,element);
	neg find mustInstanceOfDS_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Type_class(problem,interpretation,element);
	neg find mustInstanceOfPhysical_Person_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_class(problem,interpretation,element);
	neg find mustInstanceOfFiscal_Address_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Property_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_class(problem,interpretation,element);
	neg find mustInstanceOfProfessional_Expenses_Deduction_class(problem,interpretation,element);
	neg find mustInstanceOfExternal_Allowance_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Detail_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_Credit_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Card_class(problem,interpretation,element);
	neg find mustInstanceOfLegal_Union_Record_class(problem,interpretation,element);
	neg find mustInstanceOfHabitual_Address_class(problem,interpretation,element);
	neg find scopeDisallowsNewAddress_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFromAgent_class(problem,interpretation,element);
	neg find mustInstanceOfFromLaw_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Case_class(problem,interpretation,element);
	neg find mustInstanceOfExpense_class(problem,interpretation,element);
	neg find mustInstanceOfConstants_class(problem,interpretation,element);
	neg find mustInstanceOfDS_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Type_class(problem,interpretation,element);
	neg find mustInstanceOfPhysical_Person_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_class(problem,interpretation,element);
	neg find mustInstanceOfFiscal_Address_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Property_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_class(problem,interpretation,element);
	neg find mustInstanceOfProfessional_Expenses_Deduction_class(problem,interpretation,element);
	neg find mustInstanceOfExternal_Allowance_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Detail_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_Credit_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Card_class(problem,interpretation,element);
	neg find mustInstanceOfLegal_Union_Record_class(problem,interpretation,element);
	neg find mustInstanceOfHabitual_Address_class(problem,interpretation,element);
	neg find scopeDisallowsNewAddress_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfAddress_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Expense class".
 */
private pattern mustInstanceOfExpense_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Expense class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewExpense_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Expense class");
}

/**
 * An element may be an instance of type "Expense class".
 */
private pattern mayInstanceOfExpense_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFromAgent_class(problem,interpretation,element);
	neg find mustInstanceOfFromLaw_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Case_class(problem,interpretation,element);
	neg find mustInstanceOfProfessional_Expense_class(problem,interpretation,element);
	neg find mustInstanceOfConstants_class(problem,interpretation,element);
	neg find mustInstanceOfAddress_class(problem,interpretation,element);
	neg find mustInstanceOfDS_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Type_class(problem,interpretation,element);
	neg find mustInstanceOfSpecial_Expense_DS_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_class(problem,interpretation,element);
	neg find mustInstanceOfPhysical_Person_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Property_class(problem,interpretation,element);
	neg find mustInstanceOfSpousal_Expense_AC_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_class(problem,interpretation,element);
	neg find mustInstanceOfProfessional_Expenses_Deduction_class(problem,interpretation,element);
	neg find mustInstanceOfExtraordinary_Expense_CE_class(problem,interpretation,element);
	neg find mustInstanceOfExternal_Allowance_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_Credit_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Detail_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Card_class(problem,interpretation,element);
	neg find mustInstanceOfLegal_Union_Record_class(problem,interpretation,element);
	neg find scopeDisallowsNewExpense_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFromAgent_class(problem,interpretation,element);
	neg find mustInstanceOfFromLaw_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Case_class(problem,interpretation,element);
	neg find mustInstanceOfProfessional_Expense_class(problem,interpretation,element);
	neg find mustInstanceOfConstants_class(problem,interpretation,element);
	neg find mustInstanceOfAddress_class(problem,interpretation,element);
	neg find mustInstanceOfDS_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Type_class(problem,interpretation,element);
	neg find mustInstanceOfSpecial_Expense_DS_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_class(problem,interpretation,element);
	neg find mustInstanceOfPhysical_Person_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Property_class(problem,interpretation,element);
	neg find mustInstanceOfSpousal_Expense_AC_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_class(problem,interpretation,element);
	neg find mustInstanceOfProfessional_Expenses_Deduction_class(problem,interpretation,element);
	neg find mustInstanceOfExtraordinary_Expense_CE_class(problem,interpretation,element);
	neg find mustInstanceOfExternal_Allowance_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_Credit_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Detail_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Card_class(problem,interpretation,element);
	neg find mustInstanceOfLegal_Union_Record_class(problem,interpretation,element);
	neg find scopeDisallowsNewExpense_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfExpense_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Dependent class".
 */
private pattern mustInstanceOfDependent_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Dependent class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewDependent_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Dependent class");
}

/**
 * An element may be an instance of type "Dependent class".
 */
private pattern mayInstanceOfDependent_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFromAgent_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Case_class(problem,interpretation,element);
	neg find mustInstanceOfFromLaw_class(problem,interpretation,element);
	neg find mustInstanceOfExpense_class(problem,interpretation,element);
	neg find mustInstanceOfConstants_class(problem,interpretation,element);
	neg find mustInstanceOfAddress_class(problem,interpretation,element);
	neg find mustInstanceOfDS_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Type_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Property_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_class(problem,interpretation,element);
	neg find mustInstanceOfProfessional_Expenses_Deduction_class(problem,interpretation,element);
	neg find mustInstanceOfExternal_Allowance_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_Credit_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Detail_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Card_class(problem,interpretation,element);
	neg find mustInstanceOfLegal_Union_Record_class(problem,interpretation,element);
	neg find scopeDisallowsNewDependent_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFromAgent_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Case_class(problem,interpretation,element);
	neg find mustInstanceOfFromLaw_class(problem,interpretation,element);
	neg find mustInstanceOfExpense_class(problem,interpretation,element);
	neg find mustInstanceOfConstants_class(problem,interpretation,element);
	neg find mustInstanceOfAddress_class(problem,interpretation,element);
	neg find mustInstanceOfDS_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Type_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Property_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_class(problem,interpretation,element);
	neg find mustInstanceOfProfessional_Expenses_Deduction_class(problem,interpretation,element);
	neg find mustInstanceOfExternal_Allowance_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_Credit_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Detail_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Card_class(problem,interpretation,element);
	neg find mustInstanceOfLegal_Union_Record_class(problem,interpretation,element);
	neg find scopeDisallowsNewDependent_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfDependent_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "External_Allowance class".
 */
private pattern mustInstanceOfExternal_Allowance_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"External_Allowance class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewExternal_Allowance_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"External_Allowance class");
}

/**
 * An element may be an instance of type "External_Allowance class".
 */
private pattern mayInstanceOfExternal_Allowance_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFromAgent_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Case_class(problem,interpretation,element);
	neg find mustInstanceOfFromLaw_class(problem,interpretation,element);
	neg find mustInstanceOfConstants_class(problem,interpretation,element);
	neg find mustInstanceOfExpense_class(problem,interpretation,element);
	neg find mustInstanceOfAddress_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Type_class(problem,interpretation,element);
	neg find mustInstanceOfDS_class(problem,interpretation,element);
	neg find mustInstanceOfPhysical_Person_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Property_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_class(problem,interpretation,element);
	neg find mustInstanceOfProfessional_Expenses_Deduction_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_Credit_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Detail_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Card_class(problem,interpretation,element);
	neg find mustInstanceOfLegal_Union_Record_class(problem,interpretation,element);
	neg find scopeDisallowsNewExternal_Allowance_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFromAgent_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Case_class(problem,interpretation,element);
	neg find mustInstanceOfFromLaw_class(problem,interpretation,element);
	neg find mustInstanceOfConstants_class(problem,interpretation,element);
	neg find mustInstanceOfExpense_class(problem,interpretation,element);
	neg find mustInstanceOfAddress_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Type_class(problem,interpretation,element);
	neg find mustInstanceOfDS_class(problem,interpretation,element);
	neg find mustInstanceOfPhysical_Person_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Property_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_class(problem,interpretation,element);
	neg find mustInstanceOfProfessional_Expenses_Deduction_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_Credit_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Detail_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Card_class(problem,interpretation,element);
	neg find mustInstanceOfLegal_Union_Record_class(problem,interpretation,element);
	neg find scopeDisallowsNewExternal_Allowance_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfExternal_Allowance_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Household class".
 */
private pattern mustInstanceOfHousehold_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Household class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewHousehold_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Household class");
}

/**
 * An element may be an instance of type "Household class".
 */
private pattern mayInstanceOfHousehold_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFromAgent_class(problem,interpretation,element);
	neg find mustInstanceOfFromLaw_class(problem,interpretation,element);
	neg find mustInstanceOfExpense_class(problem,interpretation,element);
	neg find mustInstanceOfConstants_class(problem,interpretation,element);
	neg find mustInstanceOfAddress_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Type_class(problem,interpretation,element);
	neg find mustInstanceOfDS_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_class(problem,interpretation,element);
	neg find mustInstanceOfPhysical_Person_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Property_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_class(problem,interpretation,element);
	neg find mustInstanceOfProfessional_Expenses_Deduction_class(problem,interpretation,element);
	neg find mustInstanceOfExternal_Allowance_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Detail_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_Credit_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Card_class(problem,interpretation,element);
	neg find mustInstanceOfLegal_Union_Record_class(problem,interpretation,element);
	neg find scopeDisallowsNewHousehold_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFromAgent_class(problem,interpretation,element);
	neg find mustInstanceOfFromLaw_class(problem,interpretation,element);
	neg find mustInstanceOfExpense_class(problem,interpretation,element);
	neg find mustInstanceOfConstants_class(problem,interpretation,element);
	neg find mustInstanceOfAddress_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Type_class(problem,interpretation,element);
	neg find mustInstanceOfDS_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_class(problem,interpretation,element);
	neg find mustInstanceOfPhysical_Person_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Property_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_class(problem,interpretation,element);
	neg find mustInstanceOfProfessional_Expenses_Deduction_class(problem,interpretation,element);
	neg find mustInstanceOfExternal_Allowance_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Detail_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_Credit_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Card_class(problem,interpretation,element);
	neg find mustInstanceOfLegal_Union_Record_class(problem,interpretation,element);
	neg find scopeDisallowsNewHousehold_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfHousehold_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Legal_Union_Record class".
 */
private pattern mustInstanceOfLegal_Union_Record_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Legal_Union_Record class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewLegal_Union_Record_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Legal_Union_Record class");
}

/**
 * An element may be an instance of type "Legal_Union_Record class".
 */
private pattern mayInstanceOfLegal_Union_Record_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFromAgent_class(problem,interpretation,element);
	neg find mustInstanceOfFromLaw_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Case_class(problem,interpretation,element);
	neg find mustInstanceOfConstants_class(problem,interpretation,element);
	neg find mustInstanceOfExpense_class(problem,interpretation,element);
	neg find mustInstanceOfAddress_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Type_class(problem,interpretation,element);
	neg find mustInstanceOfDS_class(problem,interpretation,element);
	neg find mustInstanceOfMarriage_Record_class(problem,interpretation,element);
	neg find mustInstanceOfPhysical_Person_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Property_class(problem,interpretation,element);
	neg find mustInstanceOfPartnership_Record_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_class(problem,interpretation,element);
	neg find mustInstanceOfProfessional_Expenses_Deduction_class(problem,interpretation,element);
	neg find mustInstanceOfExternal_Allowance_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Detail_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_Credit_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Card_class(problem,interpretation,element);
	neg find scopeDisallowsNewLegal_Union_Record_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFromAgent_class(problem,interpretation,element);
	neg find mustInstanceOfFromLaw_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Case_class(problem,interpretation,element);
	neg find mustInstanceOfConstants_class(problem,interpretation,element);
	neg find mustInstanceOfExpense_class(problem,interpretation,element);
	neg find mustInstanceOfAddress_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Type_class(problem,interpretation,element);
	neg find mustInstanceOfDS_class(problem,interpretation,element);
	neg find mustInstanceOfMarriage_Record_class(problem,interpretation,element);
	neg find mustInstanceOfPhysical_Person_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Property_class(problem,interpretation,element);
	neg find mustInstanceOfPartnership_Record_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_class(problem,interpretation,element);
	neg find mustInstanceOfProfessional_Expenses_Deduction_class(problem,interpretation,element);
	neg find mustInstanceOfExternal_Allowance_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Detail_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_Credit_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Card_class(problem,interpretation,element);
	neg find scopeDisallowsNewLegal_Union_Record_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfLegal_Union_Record_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Tax_Property class".
 */
private pattern mustInstanceOfTax_Property_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Tax_Property class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewTax_Property_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Tax_Property class");
}

/**
 * An element may be an instance of type "Tax_Property class".
 */
private pattern mayInstanceOfTax_Property_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFromAgent_class(problem,interpretation,element);
	neg find mustInstanceOfFromLaw_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Case_class(problem,interpretation,element);
	neg find mustInstanceOfExpense_class(problem,interpretation,element);
	neg find mustInstanceOfConstants_class(problem,interpretation,element);
	neg find mustInstanceOfAddress_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Type_class(problem,interpretation,element);
	neg find mustInstanceOfDS_class(problem,interpretation,element);
	neg find mustInstanceOfPhysical_Person_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_class(problem,interpretation,element);
	neg find mustInstanceOfProfessional_Expenses_Deduction_class(problem,interpretation,element);
	neg find mustInstanceOfExternal_Allowance_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Detail_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_Credit_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Card_class(problem,interpretation,element);
	neg find mustInstanceOfLegal_Union_Record_class(problem,interpretation,element);
	neg find scopeDisallowsNewTax_Property_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFromAgent_class(problem,interpretation,element);
	neg find mustInstanceOfFromLaw_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Case_class(problem,interpretation,element);
	neg find mustInstanceOfExpense_class(problem,interpretation,element);
	neg find mustInstanceOfConstants_class(problem,interpretation,element);
	neg find mustInstanceOfAddress_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Type_class(problem,interpretation,element);
	neg find mustInstanceOfDS_class(problem,interpretation,element);
	neg find mustInstanceOfPhysical_Person_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_class(problem,interpretation,element);
	neg find mustInstanceOfProfessional_Expenses_Deduction_class(problem,interpretation,element);
	neg find mustInstanceOfExternal_Allowance_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Detail_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_Credit_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Card_class(problem,interpretation,element);
	neg find mustInstanceOfLegal_Union_Record_class(problem,interpretation,element);
	neg find scopeDisallowsNewTax_Property_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfTax_Property_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Tax_Case class".
 */
private pattern mustInstanceOfTax_Case_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Tax_Case class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewTax_Case_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Tax_Case class");
}

/**
 * An element may be an instance of type "Tax_Case class".
 */
private pattern mayInstanceOfTax_Case_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFromAgent_class(problem,interpretation,element);
	neg find mustInstanceOfFromLaw_class(problem,interpretation,element);
	neg find mustInstanceOfConstants_class(problem,interpretation,element);
	neg find mustInstanceOfExpense_class(problem,interpretation,element);
	neg find mustInstanceOfAddress_class(problem,interpretation,element);
	neg find mustInstanceOfDS_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Type_class(problem,interpretation,element);
	neg find mustInstanceOfPhysical_Person_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Property_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_class(problem,interpretation,element);
	neg find mustInstanceOfProfessional_Expenses_Deduction_class(problem,interpretation,element);
	neg find mustInstanceOfExternal_Allowance_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Detail_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_Credit_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Card_class(problem,interpretation,element);
	neg find mustInstanceOfHousehold_class(problem,interpretation,element);
	neg find mustInstanceOfLegal_Union_Record_class(problem,interpretation,element);
	neg find scopeDisallowsNewTax_Case_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFromAgent_class(problem,interpretation,element);
	neg find mustInstanceOfFromLaw_class(problem,interpretation,element);
	neg find mustInstanceOfConstants_class(problem,interpretation,element);
	neg find mustInstanceOfExpense_class(problem,interpretation,element);
	neg find mustInstanceOfAddress_class(problem,interpretation,element);
	neg find mustInstanceOfDS_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Type_class(problem,interpretation,element);
	neg find mustInstanceOfPhysical_Person_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Property_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_class(problem,interpretation,element);
	neg find mustInstanceOfProfessional_Expenses_Deduction_class(problem,interpretation,element);
	neg find mustInstanceOfExternal_Allowance_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Detail_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_Credit_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Card_class(problem,interpretation,element);
	neg find mustInstanceOfHousehold_class(problem,interpretation,element);
	neg find mustInstanceOfLegal_Union_Record_class(problem,interpretation,element);
	neg find scopeDisallowsNewTax_Case_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfTax_Case_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FromAgent class".
 */
private pattern mustInstanceOfFromAgent_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FromAgent class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFromAgent_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FromAgent class");
}

/**
 * An element may be an instance of type "FromAgent class".
 */
private pattern mayInstanceOfFromAgent_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfTax_Case_class(problem,interpretation,element);
	neg find mustInstanceOfFromLaw_class(problem,interpretation,element);
	neg find mustInstanceOfExpense_class(problem,interpretation,element);
	neg find mustInstanceOfConstants_class(problem,interpretation,element);
	neg find mustInstanceOfAddress_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Type_class(problem,interpretation,element);
	neg find mustInstanceOfDS_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_class(problem,interpretation,element);
	neg find mustInstanceOfPhysical_Person_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Property_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_class(problem,interpretation,element);
	neg find mustInstanceOfProfessional_Expenses_Deduction_class(problem,interpretation,element);
	neg find mustInstanceOfExternal_Allowance_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Detail_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_Credit_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Card_class(problem,interpretation,element);
	neg find mustInstanceOfLegal_Union_Record_class(problem,interpretation,element);
	neg find scopeDisallowsNewFromAgent_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfTax_Case_class(problem,interpretation,element);
	neg find mustInstanceOfFromLaw_class(problem,interpretation,element);
	neg find mustInstanceOfExpense_class(problem,interpretation,element);
	neg find mustInstanceOfConstants_class(problem,interpretation,element);
	neg find mustInstanceOfAddress_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Type_class(problem,interpretation,element);
	neg find mustInstanceOfDS_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_class(problem,interpretation,element);
	neg find mustInstanceOfPhysical_Person_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Property_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_class(problem,interpretation,element);
	neg find mustInstanceOfProfessional_Expenses_Deduction_class(problem,interpretation,element);
	neg find mustInstanceOfExternal_Allowance_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Detail_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_Credit_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Card_class(problem,interpretation,element);
	neg find mustInstanceOfLegal_Union_Record_class(problem,interpretation,element);
	neg find scopeDisallowsNewFromAgent_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFromAgent_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Income class".
 */
private pattern mustInstanceOfIncome_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Income class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewIncome_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Income class");
}

/**
 * An element may be an instance of type "Income class".
 */
private pattern mayInstanceOfIncome_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFromAgent_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Case_class(problem,interpretation,element);
	neg find mustInstanceOfFromLaw_class(problem,interpretation,element);
	neg find mustInstanceOfConstants_class(problem,interpretation,element);
	neg find mustInstanceOfExpense_class(problem,interpretation,element);
	neg find mustInstanceOfAddress_class(problem,interpretation,element);
	neg find mustInstanceOfForeign_Income_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Type_class(problem,interpretation,element);
	neg find mustInstanceOfDS_class(problem,interpretation,element);
	neg find mustInstanceOfPhysical_Person_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Property_class(problem,interpretation,element);
	neg find mustInstanceOfLocal_Income_class(problem,interpretation,element);
	neg find mustInstanceOfProfessional_Expenses_Deduction_class(problem,interpretation,element);
	neg find mustInstanceOfExternal_Allowance_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Detail_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_Credit_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Card_class(problem,interpretation,element);
	neg find mustInstanceOfLegal_Union_Record_class(problem,interpretation,element);
	neg find scopeDisallowsNewIncome_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFromAgent_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Case_class(problem,interpretation,element);
	neg find mustInstanceOfFromLaw_class(problem,interpretation,element);
	neg find mustInstanceOfConstants_class(problem,interpretation,element);
	neg find mustInstanceOfExpense_class(problem,interpretation,element);
	neg find mustInstanceOfAddress_class(problem,interpretation,element);
	neg find mustInstanceOfForeign_Income_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Type_class(problem,interpretation,element);
	neg find mustInstanceOfDS_class(problem,interpretation,element);
	neg find mustInstanceOfPhysical_Person_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Property_class(problem,interpretation,element);
	neg find mustInstanceOfLocal_Income_class(problem,interpretation,element);
	neg find mustInstanceOfProfessional_Expenses_Deduction_class(problem,interpretation,element);
	neg find mustInstanceOfExternal_Allowance_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Detail_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_Credit_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Card_class(problem,interpretation,element);
	neg find mustInstanceOfLegal_Union_Record_class(problem,interpretation,element);
	neg find scopeDisallowsNewIncome_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfIncome_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Income_Type class".
 */
private pattern mustInstanceOfIncome_Type_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Income_Type class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewIncome_Type_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Income_Type class");
}

/**
 * An element may be an instance of type "Income_Type class".
 */
private pattern mayInstanceOfIncome_Type_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFromAgent_class(problem,interpretation,element);
	neg find mustInstanceOfFromLaw_class(problem,interpretation,element);
	neg find mustInstanceOfCapital_and_Investments_Income_class(problem,interpretation,element);
	neg find mustInstanceOfRentals_and_Leases_Income_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Case_class(problem,interpretation,element);
	neg find mustInstanceOfConstants_class(problem,interpretation,element);
	neg find mustInstanceOfExpense_class(problem,interpretation,element);
	neg find mustInstanceOfAddress_class(problem,interpretation,element);
	neg find mustInstanceOfDS_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_class(problem,interpretation,element);
	neg find mustInstanceOfPhysical_Person_class(problem,interpretation,element);
	neg find mustInstanceOfPensions_and_Annuities_Income_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Property_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_class(problem,interpretation,element);
	neg find mustInstanceOfProfessional_Expenses_Deduction_class(problem,interpretation,element);
	neg find mustInstanceOfEmployment_Income_class(problem,interpretation,element);
	neg find mustInstanceOfExternal_Allowance_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_Credit_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Detail_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Card_class(problem,interpretation,element);
	neg find mustInstanceOfAgriculture_and_Forestry_Income_class(problem,interpretation,element);
	neg find mustInstanceOfLegal_Union_Record_class(problem,interpretation,element);
	neg find mustInstanceOfTrade_and_Business_Income_class(problem,interpretation,element);
	neg find scopeDisallowsNewIncome_Type_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFromAgent_class(problem,interpretation,element);
	neg find mustInstanceOfFromLaw_class(problem,interpretation,element);
	neg find mustInstanceOfCapital_and_Investments_Income_class(problem,interpretation,element);
	neg find mustInstanceOfRentals_and_Leases_Income_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Case_class(problem,interpretation,element);
	neg find mustInstanceOfConstants_class(problem,interpretation,element);
	neg find mustInstanceOfExpense_class(problem,interpretation,element);
	neg find mustInstanceOfAddress_class(problem,interpretation,element);
	neg find mustInstanceOfDS_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_class(problem,interpretation,element);
	neg find mustInstanceOfPhysical_Person_class(problem,interpretation,element);
	neg find mustInstanceOfPensions_and_Annuities_Income_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Property_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_class(problem,interpretation,element);
	neg find mustInstanceOfProfessional_Expenses_Deduction_class(problem,interpretation,element);
	neg find mustInstanceOfEmployment_Income_class(problem,interpretation,element);
	neg find mustInstanceOfExternal_Allowance_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_Credit_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Detail_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Card_class(problem,interpretation,element);
	neg find mustInstanceOfAgriculture_and_Forestry_Income_class(problem,interpretation,element);
	neg find mustInstanceOfLegal_Union_Record_class(problem,interpretation,element);
	neg find mustInstanceOfTrade_and_Business_Income_class(problem,interpretation,element);
	neg find scopeDisallowsNewIncome_Type_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfIncome_Type_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Tax_Card class".
 */
private pattern mustInstanceOfTax_Card_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Tax_Card class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewTax_Card_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Tax_Card class");
}

/**
 * An element may be an instance of type "Tax_Card class".
 */
private pattern mayInstanceOfTax_Card_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFromAgent_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Case_class(problem,interpretation,element);
	neg find mustInstanceOfFromLaw_class(problem,interpretation,element);
	neg find mustInstanceOfConstants_class(problem,interpretation,element);
	neg find mustInstanceOfExpense_class(problem,interpretation,element);
	neg find mustInstanceOfAddress_class(problem,interpretation,element);
	neg find mustInstanceOfDS_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Type_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_class(problem,interpretation,element);
	neg find mustInstanceOfPhysical_Person_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Property_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_class(problem,interpretation,element);
	neg find mustInstanceOfProfessional_Expenses_Deduction_class(problem,interpretation,element);
	neg find mustInstanceOfExternal_Allowance_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Detail_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_Credit_class(problem,interpretation,element);
	neg find mustInstanceOfLegal_Union_Record_class(problem,interpretation,element);
	neg find scopeDisallowsNewTax_Card_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFromAgent_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Case_class(problem,interpretation,element);
	neg find mustInstanceOfFromLaw_class(problem,interpretation,element);
	neg find mustInstanceOfConstants_class(problem,interpretation,element);
	neg find mustInstanceOfExpense_class(problem,interpretation,element);
	neg find mustInstanceOfAddress_class(problem,interpretation,element);
	neg find mustInstanceOfDS_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Type_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_class(problem,interpretation,element);
	neg find mustInstanceOfPhysical_Person_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Property_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_class(problem,interpretation,element);
	neg find mustInstanceOfProfessional_Expenses_Deduction_class(problem,interpretation,element);
	neg find mustInstanceOfExternal_Allowance_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Detail_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_Credit_class(problem,interpretation,element);
	neg find mustInstanceOfLegal_Union_Record_class(problem,interpretation,element);
	neg find scopeDisallowsNewTax_Card_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfTax_Card_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Income_Tax_Credit class".
 */
private pattern mustInstanceOfIncome_Tax_Credit_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Income_Tax_Credit class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewIncome_Tax_Credit_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Income_Tax_Credit class");
}

/**
 * An element may be an instance of type "Income_Tax_Credit class".
 */
private pattern mayInstanceOfIncome_Tax_Credit_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFromAgent_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Case_class(problem,interpretation,element);
	neg find mustInstanceOfFromLaw_class(problem,interpretation,element);
	neg find mustInstanceOfExpense_class(problem,interpretation,element);
	neg find mustInstanceOfConstants_class(problem,interpretation,element);
	neg find mustInstanceOfAddress_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Type_class(problem,interpretation,element);
	neg find mustInstanceOfDS_class(problem,interpretation,element);
	neg find mustInstanceOfCIS_class(problem,interpretation,element);
	neg find mustInstanceOfCIP_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_class(problem,interpretation,element);
	neg find mustInstanceOfPhysical_Person_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Property_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_class(problem,interpretation,element);
	neg find mustInstanceOfProfessional_Expenses_Deduction_class(problem,interpretation,element);
	neg find mustInstanceOfExternal_Allowance_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Detail_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Card_class(problem,interpretation,element);
	neg find mustInstanceOfCIM_class(problem,interpretation,element);
	neg find mustInstanceOfLegal_Union_Record_class(problem,interpretation,element);
	neg find scopeDisallowsNewIncome_Tax_Credit_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFromAgent_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Case_class(problem,interpretation,element);
	neg find mustInstanceOfFromLaw_class(problem,interpretation,element);
	neg find mustInstanceOfExpense_class(problem,interpretation,element);
	neg find mustInstanceOfConstants_class(problem,interpretation,element);
	neg find mustInstanceOfAddress_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Type_class(problem,interpretation,element);
	neg find mustInstanceOfDS_class(problem,interpretation,element);
	neg find mustInstanceOfCIS_class(problem,interpretation,element);
	neg find mustInstanceOfCIP_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_class(problem,interpretation,element);
	neg find mustInstanceOfPhysical_Person_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Property_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_class(problem,interpretation,element);
	neg find mustInstanceOfProfessional_Expenses_Deduction_class(problem,interpretation,element);
	neg find mustInstanceOfExternal_Allowance_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Detail_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Card_class(problem,interpretation,element);
	neg find mustInstanceOfCIM_class(problem,interpretation,element);
	neg find mustInstanceOfLegal_Union_Record_class(problem,interpretation,element);
	neg find scopeDisallowsNewIncome_Tax_Credit_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfIncome_Tax_Credit_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Income_Detail class".
 */
private pattern mustInstanceOfIncome_Detail_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Income_Detail class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewIncome_Detail_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Income_Detail class");
}

/**
 * An element may be an instance of type "Income_Detail class".
 */
private pattern mayInstanceOfIncome_Detail_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFromAgent_class(problem,interpretation,element);
	neg find mustInstanceOfFromLaw_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Case_class(problem,interpretation,element);
	neg find mustInstanceOfConstants_class(problem,interpretation,element);
	neg find mustInstanceOfExpense_class(problem,interpretation,element);
	neg find mustInstanceOfAddress_class(problem,interpretation,element);
	neg find mustInstanceOfDS_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Type_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_class(problem,interpretation,element);
	neg find mustInstanceOfPhysical_Person_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Property_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_class(problem,interpretation,element);
	neg find mustInstanceOfProfessional_Expenses_Deduction_class(problem,interpretation,element);
	neg find mustInstanceOfExternal_Allowance_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_Credit_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Card_class(problem,interpretation,element);
	neg find mustInstanceOfLegal_Union_Record_class(problem,interpretation,element);
	neg find scopeDisallowsNewIncome_Detail_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFromAgent_class(problem,interpretation,element);
	neg find mustInstanceOfFromLaw_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Case_class(problem,interpretation,element);
	neg find mustInstanceOfConstants_class(problem,interpretation,element);
	neg find mustInstanceOfExpense_class(problem,interpretation,element);
	neg find mustInstanceOfAddress_class(problem,interpretation,element);
	neg find mustInstanceOfDS_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Type_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_class(problem,interpretation,element);
	neg find mustInstanceOfPhysical_Person_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Property_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_class(problem,interpretation,element);
	neg find mustInstanceOfProfessional_Expenses_Deduction_class(problem,interpretation,element);
	neg find mustInstanceOfExternal_Allowance_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_Credit_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Card_class(problem,interpretation,element);
	neg find mustInstanceOfLegal_Union_Record_class(problem,interpretation,element);
	neg find scopeDisallowsNewIncome_Detail_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfIncome_Detail_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FromLaw class".
 */
private pattern mustInstanceOfFromLaw_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FromLaw class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFromLaw_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FromLaw class");
}

/**
 * An element may be an instance of type "FromLaw class".
 */
private pattern mayInstanceOfFromLaw_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFromAgent_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Case_class(problem,interpretation,element);
	neg find mustInstanceOfConstants_class(problem,interpretation,element);
	neg find mustInstanceOfExpense_class(problem,interpretation,element);
	neg find mustInstanceOfAddress_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Type_class(problem,interpretation,element);
	neg find mustInstanceOfDS_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_class(problem,interpretation,element);
	neg find mustInstanceOfPhysical_Person_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Property_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_class(problem,interpretation,element);
	neg find mustInstanceOfProfessional_Expenses_Deduction_class(problem,interpretation,element);
	neg find mustInstanceOfExternal_Allowance_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Detail_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_Credit_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Card_class(problem,interpretation,element);
	neg find mustInstanceOfLegal_Union_Record_class(problem,interpretation,element);
	neg find scopeDisallowsNewFromLaw_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFromAgent_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Case_class(problem,interpretation,element);
	neg find mustInstanceOfConstants_class(problem,interpretation,element);
	neg find mustInstanceOfExpense_class(problem,interpretation,element);
	neg find mustInstanceOfAddress_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Type_class(problem,interpretation,element);
	neg find mustInstanceOfDS_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_class(problem,interpretation,element);
	neg find mustInstanceOfPhysical_Person_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Property_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_class(problem,interpretation,element);
	neg find mustInstanceOfProfessional_Expenses_Deduction_class(problem,interpretation,element);
	neg find mustInstanceOfExternal_Allowance_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Detail_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_Credit_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Card_class(problem,interpretation,element);
	neg find mustInstanceOfLegal_Union_Record_class(problem,interpretation,element);
	neg find scopeDisallowsNewFromLaw_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFromLaw_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Fiscal_Address class".
 */
private pattern mustInstanceOfFiscal_Address_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Fiscal_Address class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFiscal_Address_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Fiscal_Address class");
}

/**
 * An element may be an instance of type "Fiscal_Address class".
 */
private pattern mayInstanceOfFiscal_Address_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFromAgent_class(problem,interpretation,element);
	neg find mustInstanceOfFromLaw_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Case_class(problem,interpretation,element);
	neg find mustInstanceOfConstants_class(problem,interpretation,element);
	neg find mustInstanceOfExpense_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Type_class(problem,interpretation,element);
	neg find mustInstanceOfDS_class(problem,interpretation,element);
	neg find mustInstanceOfPhysical_Person_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Property_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_class(problem,interpretation,element);
	neg find mustInstanceOfProfessional_Expenses_Deduction_class(problem,interpretation,element);
	neg find mustInstanceOfExternal_Allowance_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_Credit_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Detail_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Card_class(problem,interpretation,element);
	neg find mustInstanceOfLegal_Union_Record_class(problem,interpretation,element);
	neg find mustInstanceOfHabitual_Address_class(problem,interpretation,element);
	neg find scopeDisallowsNewFiscal_Address_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFromAgent_class(problem,interpretation,element);
	neg find mustInstanceOfFromLaw_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Case_class(problem,interpretation,element);
	neg find mustInstanceOfConstants_class(problem,interpretation,element);
	neg find mustInstanceOfExpense_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Type_class(problem,interpretation,element);
	neg find mustInstanceOfDS_class(problem,interpretation,element);
	neg find mustInstanceOfPhysical_Person_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Property_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_class(problem,interpretation,element);
	neg find mustInstanceOfProfessional_Expenses_Deduction_class(problem,interpretation,element);
	neg find mustInstanceOfExternal_Allowance_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_Credit_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Detail_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Card_class(problem,interpretation,element);
	neg find mustInstanceOfLegal_Union_Record_class(problem,interpretation,element);
	neg find mustInstanceOfHabitual_Address_class(problem,interpretation,element);
	neg find scopeDisallowsNewFiscal_Address_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFiscal_Address_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Habitual_Address class".
 */
private pattern mustInstanceOfHabitual_Address_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Habitual_Address class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewHabitual_Address_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Habitual_Address class");
}

/**
 * An element may be an instance of type "Habitual_Address class".
 */
private pattern mayInstanceOfHabitual_Address_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFromAgent_class(problem,interpretation,element);
	neg find mustInstanceOfFromLaw_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Case_class(problem,interpretation,element);
	neg find mustInstanceOfExpense_class(problem,interpretation,element);
	neg find mustInstanceOfConstants_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Type_class(problem,interpretation,element);
	neg find mustInstanceOfDS_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_class(problem,interpretation,element);
	neg find mustInstanceOfPhysical_Person_class(problem,interpretation,element);
	neg find mustInstanceOfFiscal_Address_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Property_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_class(problem,interpretation,element);
	neg find mustInstanceOfProfessional_Expenses_Deduction_class(problem,interpretation,element);
	neg find mustInstanceOfExternal_Allowance_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_Credit_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Detail_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Card_class(problem,interpretation,element);
	neg find mustInstanceOfLegal_Union_Record_class(problem,interpretation,element);
	neg find scopeDisallowsNewHabitual_Address_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFromAgent_class(problem,interpretation,element);
	neg find mustInstanceOfFromLaw_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Case_class(problem,interpretation,element);
	neg find mustInstanceOfExpense_class(problem,interpretation,element);
	neg find mustInstanceOfConstants_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Type_class(problem,interpretation,element);
	neg find mustInstanceOfDS_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_class(problem,interpretation,element);
	neg find mustInstanceOfPhysical_Person_class(problem,interpretation,element);
	neg find mustInstanceOfFiscal_Address_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Property_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_class(problem,interpretation,element);
	neg find mustInstanceOfProfessional_Expenses_Deduction_class(problem,interpretation,element);
	neg find mustInstanceOfExternal_Allowance_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_Credit_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Detail_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Card_class(problem,interpretation,element);
	neg find mustInstanceOfLegal_Union_Record_class(problem,interpretation,element);
	neg find scopeDisallowsNewHabitual_Address_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfHabitual_Address_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Marriage_Record class".
 */
private pattern mustInstanceOfMarriage_Record_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Marriage_Record class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewMarriage_Record_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Marriage_Record class");
}

/**
 * An element may be an instance of type "Marriage_Record class".
 */
private pattern mayInstanceOfMarriage_Record_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFromAgent_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Case_class(problem,interpretation,element);
	neg find mustInstanceOfFromLaw_class(problem,interpretation,element);
	neg find mustInstanceOfExpense_class(problem,interpretation,element);
	neg find mustInstanceOfConstants_class(problem,interpretation,element);
	neg find mustInstanceOfAddress_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Type_class(problem,interpretation,element);
	neg find mustInstanceOfDS_class(problem,interpretation,element);
	neg find mustInstanceOfPhysical_Person_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Property_class(problem,interpretation,element);
	neg find mustInstanceOfPartnership_Record_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_class(problem,interpretation,element);
	neg find mustInstanceOfProfessional_Expenses_Deduction_class(problem,interpretation,element);
	neg find mustInstanceOfExternal_Allowance_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Detail_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_Credit_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Card_class(problem,interpretation,element);
	neg find scopeDisallowsNewMarriage_Record_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFromAgent_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Case_class(problem,interpretation,element);
	neg find mustInstanceOfFromLaw_class(problem,interpretation,element);
	neg find mustInstanceOfExpense_class(problem,interpretation,element);
	neg find mustInstanceOfConstants_class(problem,interpretation,element);
	neg find mustInstanceOfAddress_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Type_class(problem,interpretation,element);
	neg find mustInstanceOfDS_class(problem,interpretation,element);
	neg find mustInstanceOfPhysical_Person_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Property_class(problem,interpretation,element);
	neg find mustInstanceOfPartnership_Record_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_class(problem,interpretation,element);
	neg find mustInstanceOfProfessional_Expenses_Deduction_class(problem,interpretation,element);
	neg find mustInstanceOfExternal_Allowance_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Detail_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_Credit_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Card_class(problem,interpretation,element);
	neg find scopeDisallowsNewMarriage_Record_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfMarriage_Record_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Non_Resident_Tax_Payer class".
 */
private pattern mustInstanceOfNon_Resident_Tax_Payer_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Non_Resident_Tax_Payer class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewNon_Resident_Tax_Payer_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Non_Resident_Tax_Payer class");
}

/**
 * An element may be an instance of type "Non_Resident_Tax_Payer class".
 */
private pattern mayInstanceOfNon_Resident_Tax_Payer_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFromAgent_class(problem,interpretation,element);
	neg find mustInstanceOfFromLaw_class(problem,interpretation,element);
	neg find mustInstanceOfExpense_class(problem,interpretation,element);
	neg find mustInstanceOfConstants_class(problem,interpretation,element);
	neg find mustInstanceOfAddress_class(problem,interpretation,element);
	neg find mustInstanceOfDS_class(problem,interpretation,element);
	neg find mustInstanceOfResident_Tax_Payer_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Type_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Property_class(problem,interpretation,element);
	neg find mustInstanceOfDependent_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_class(problem,interpretation,element);
	neg find mustInstanceOfProfessional_Expenses_Deduction_class(problem,interpretation,element);
	neg find mustInstanceOfExternal_Allowance_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Detail_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_Credit_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Card_class(problem,interpretation,element);
	neg find mustInstanceOfHousehold_class(problem,interpretation,element);
	neg find mustInstanceOfLegal_Union_Record_class(problem,interpretation,element);
	neg find scopeDisallowsNewNon_Resident_Tax_Payer_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFromAgent_class(problem,interpretation,element);
	neg find mustInstanceOfFromLaw_class(problem,interpretation,element);
	neg find mustInstanceOfExpense_class(problem,interpretation,element);
	neg find mustInstanceOfConstants_class(problem,interpretation,element);
	neg find mustInstanceOfAddress_class(problem,interpretation,element);
	neg find mustInstanceOfDS_class(problem,interpretation,element);
	neg find mustInstanceOfResident_Tax_Payer_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Type_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Property_class(problem,interpretation,element);
	neg find mustInstanceOfDependent_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_class(problem,interpretation,element);
	neg find mustInstanceOfProfessional_Expenses_Deduction_class(problem,interpretation,element);
	neg find mustInstanceOfExternal_Allowance_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Detail_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_Credit_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Card_class(problem,interpretation,element);
	neg find mustInstanceOfHousehold_class(problem,interpretation,element);
	neg find mustInstanceOfLegal_Union_Record_class(problem,interpretation,element);
	neg find scopeDisallowsNewNon_Resident_Tax_Payer_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfNon_Resident_Tax_Payer_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Partnership_Record class".
 */
private pattern mustInstanceOfPartnership_Record_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Partnership_Record class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewPartnership_Record_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Partnership_Record class");
}

/**
 * An element may be an instance of type "Partnership_Record class".
 */
private pattern mayInstanceOfPartnership_Record_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFromAgent_class(problem,interpretation,element);
	neg find mustInstanceOfFromLaw_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Case_class(problem,interpretation,element);
	neg find mustInstanceOfExpense_class(problem,interpretation,element);
	neg find mustInstanceOfConstants_class(problem,interpretation,element);
	neg find mustInstanceOfAddress_class(problem,interpretation,element);
	neg find mustInstanceOfDS_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Type_class(problem,interpretation,element);
	neg find mustInstanceOfMarriage_Record_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_class(problem,interpretation,element);
	neg find mustInstanceOfPhysical_Person_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Property_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_class(problem,interpretation,element);
	neg find mustInstanceOfProfessional_Expenses_Deduction_class(problem,interpretation,element);
	neg find mustInstanceOfExternal_Allowance_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Detail_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_Credit_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Card_class(problem,interpretation,element);
	neg find scopeDisallowsNewPartnership_Record_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFromAgent_class(problem,interpretation,element);
	neg find mustInstanceOfFromLaw_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Case_class(problem,interpretation,element);
	neg find mustInstanceOfExpense_class(problem,interpretation,element);
	neg find mustInstanceOfConstants_class(problem,interpretation,element);
	neg find mustInstanceOfAddress_class(problem,interpretation,element);
	neg find mustInstanceOfDS_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Type_class(problem,interpretation,element);
	neg find mustInstanceOfMarriage_Record_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_class(problem,interpretation,element);
	neg find mustInstanceOfPhysical_Person_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Property_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_class(problem,interpretation,element);
	neg find mustInstanceOfProfessional_Expenses_Deduction_class(problem,interpretation,element);
	neg find mustInstanceOfExternal_Allowance_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Detail_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_Credit_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Card_class(problem,interpretation,element);
	neg find scopeDisallowsNewPartnership_Record_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfPartnership_Record_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Resident_Tax_Payer class".
 */
private pattern mustInstanceOfResident_Tax_Payer_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Resident_Tax_Payer class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewResident_Tax_Payer_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Resident_Tax_Payer class");
}

/**
 * An element may be an instance of type "Resident_Tax_Payer class".
 */
private pattern mayInstanceOfResident_Tax_Payer_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFromAgent_class(problem,interpretation,element);
	neg find mustInstanceOfFromLaw_class(problem,interpretation,element);
	neg find mustInstanceOfExpense_class(problem,interpretation,element);
	neg find mustInstanceOfConstants_class(problem,interpretation,element);
	neg find mustInstanceOfAddress_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Type_class(problem,interpretation,element);
	neg find mustInstanceOfDS_class(problem,interpretation,element);
	neg find mustInstanceOfNon_Resident_Tax_Payer_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Property_class(problem,interpretation,element);
	neg find mustInstanceOfDependent_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_class(problem,interpretation,element);
	neg find mustInstanceOfProfessional_Expenses_Deduction_class(problem,interpretation,element);
	neg find mustInstanceOfExternal_Allowance_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_Credit_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Detail_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Card_class(problem,interpretation,element);
	neg find mustInstanceOfHousehold_class(problem,interpretation,element);
	neg find mustInstanceOfLegal_Union_Record_class(problem,interpretation,element);
	neg find scopeDisallowsNewResident_Tax_Payer_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFromAgent_class(problem,interpretation,element);
	neg find mustInstanceOfFromLaw_class(problem,interpretation,element);
	neg find mustInstanceOfExpense_class(problem,interpretation,element);
	neg find mustInstanceOfConstants_class(problem,interpretation,element);
	neg find mustInstanceOfAddress_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Type_class(problem,interpretation,element);
	neg find mustInstanceOfDS_class(problem,interpretation,element);
	neg find mustInstanceOfNon_Resident_Tax_Payer_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Property_class(problem,interpretation,element);
	neg find mustInstanceOfDependent_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_class(problem,interpretation,element);
	neg find mustInstanceOfProfessional_Expenses_Deduction_class(problem,interpretation,element);
	neg find mustInstanceOfExternal_Allowance_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_Credit_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Detail_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Card_class(problem,interpretation,element);
	neg find mustInstanceOfHousehold_class(problem,interpretation,element);
	neg find mustInstanceOfLegal_Union_Record_class(problem,interpretation,element);
	neg find scopeDisallowsNewResident_Tax_Payer_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfResident_Tax_Payer_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Trade_and_Business_Income class".
 */
private pattern mustInstanceOfTrade_and_Business_Income_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Trade_and_Business_Income class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewTrade_and_Business_Income_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Trade_and_Business_Income class");
}

/**
 * An element may be an instance of type "Trade_and_Business_Income class".
 */
private pattern mayInstanceOfTrade_and_Business_Income_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFromAgent_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Case_class(problem,interpretation,element);
	neg find mustInstanceOfFromLaw_class(problem,interpretation,element);
	neg find mustInstanceOfCapital_and_Investments_Income_class(problem,interpretation,element);
	neg find mustInstanceOfRentals_and_Leases_Income_class(problem,interpretation,element);
	neg find mustInstanceOfExpense_class(problem,interpretation,element);
	neg find mustInstanceOfConstants_class(problem,interpretation,element);
	neg find mustInstanceOfAddress_class(problem,interpretation,element);
	neg find mustInstanceOfDS_class(problem,interpretation,element);
	neg find mustInstanceOfPhysical_Person_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_class(problem,interpretation,element);
	neg find mustInstanceOfPensions_and_Annuities_Income_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Property_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_class(problem,interpretation,element);
	neg find mustInstanceOfProfessional_Expenses_Deduction_class(problem,interpretation,element);
	neg find mustInstanceOfEmployment_Income_class(problem,interpretation,element);
	neg find mustInstanceOfExternal_Allowance_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Detail_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_Credit_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Card_class(problem,interpretation,element);
	neg find mustInstanceOfAgriculture_and_Forestry_Income_class(problem,interpretation,element);
	neg find mustInstanceOfLegal_Union_Record_class(problem,interpretation,element);
	neg find scopeDisallowsNewTrade_and_Business_Income_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFromAgent_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Case_class(problem,interpretation,element);
	neg find mustInstanceOfFromLaw_class(problem,interpretation,element);
	neg find mustInstanceOfCapital_and_Investments_Income_class(problem,interpretation,element);
	neg find mustInstanceOfRentals_and_Leases_Income_class(problem,interpretation,element);
	neg find mustInstanceOfExpense_class(problem,interpretation,element);
	neg find mustInstanceOfConstants_class(problem,interpretation,element);
	neg find mustInstanceOfAddress_class(problem,interpretation,element);
	neg find mustInstanceOfDS_class(problem,interpretation,element);
	neg find mustInstanceOfPhysical_Person_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_class(problem,interpretation,element);
	neg find mustInstanceOfPensions_and_Annuities_Income_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Property_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_class(problem,interpretation,element);
	neg find mustInstanceOfProfessional_Expenses_Deduction_class(problem,interpretation,element);
	neg find mustInstanceOfEmployment_Income_class(problem,interpretation,element);
	neg find mustInstanceOfExternal_Allowance_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Detail_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_Credit_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Card_class(problem,interpretation,element);
	neg find mustInstanceOfAgriculture_and_Forestry_Income_class(problem,interpretation,element);
	neg find mustInstanceOfLegal_Union_Record_class(problem,interpretation,element);
	neg find scopeDisallowsNewTrade_and_Business_Income_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfTrade_and_Business_Income_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Agriculture_and_Forestry_Income class".
 */
private pattern mustInstanceOfAgriculture_and_Forestry_Income_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Agriculture_and_Forestry_Income class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewAgriculture_and_Forestry_Income_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Agriculture_and_Forestry_Income class");
}

/**
 * An element may be an instance of type "Agriculture_and_Forestry_Income class".
 */
private pattern mayInstanceOfAgriculture_and_Forestry_Income_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFromAgent_class(problem,interpretation,element);
	neg find mustInstanceOfRentals_and_Leases_Income_class(problem,interpretation,element);
	neg find mustInstanceOfCapital_and_Investments_Income_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Case_class(problem,interpretation,element);
	neg find mustInstanceOfFromLaw_class(problem,interpretation,element);
	neg find mustInstanceOfConstants_class(problem,interpretation,element);
	neg find mustInstanceOfExpense_class(problem,interpretation,element);
	neg find mustInstanceOfAddress_class(problem,interpretation,element);
	neg find mustInstanceOfDS_class(problem,interpretation,element);
	neg find mustInstanceOfPhysical_Person_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_class(problem,interpretation,element);
	neg find mustInstanceOfPensions_and_Annuities_Income_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Property_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_class(problem,interpretation,element);
	neg find mustInstanceOfProfessional_Expenses_Deduction_class(problem,interpretation,element);
	neg find mustInstanceOfEmployment_Income_class(problem,interpretation,element);
	neg find mustInstanceOfExternal_Allowance_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_Credit_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Detail_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Card_class(problem,interpretation,element);
	neg find mustInstanceOfLegal_Union_Record_class(problem,interpretation,element);
	neg find mustInstanceOfTrade_and_Business_Income_class(problem,interpretation,element);
	neg find scopeDisallowsNewAgriculture_and_Forestry_Income_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFromAgent_class(problem,interpretation,element);
	neg find mustInstanceOfRentals_and_Leases_Income_class(problem,interpretation,element);
	neg find mustInstanceOfCapital_and_Investments_Income_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Case_class(problem,interpretation,element);
	neg find mustInstanceOfFromLaw_class(problem,interpretation,element);
	neg find mustInstanceOfConstants_class(problem,interpretation,element);
	neg find mustInstanceOfExpense_class(problem,interpretation,element);
	neg find mustInstanceOfAddress_class(problem,interpretation,element);
	neg find mustInstanceOfDS_class(problem,interpretation,element);
	neg find mustInstanceOfPhysical_Person_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_class(problem,interpretation,element);
	neg find mustInstanceOfPensions_and_Annuities_Income_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Property_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_class(problem,interpretation,element);
	neg find mustInstanceOfProfessional_Expenses_Deduction_class(problem,interpretation,element);
	neg find mustInstanceOfEmployment_Income_class(problem,interpretation,element);
	neg find mustInstanceOfExternal_Allowance_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_Credit_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Detail_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Card_class(problem,interpretation,element);
	neg find mustInstanceOfLegal_Union_Record_class(problem,interpretation,element);
	neg find mustInstanceOfTrade_and_Business_Income_class(problem,interpretation,element);
	neg find scopeDisallowsNewAgriculture_and_Forestry_Income_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfAgriculture_and_Forestry_Income_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Pensions_and_Annuities_Income class".
 */
private pattern mustInstanceOfPensions_and_Annuities_Income_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Pensions_and_Annuities_Income class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewPensions_and_Annuities_Income_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Pensions_and_Annuities_Income class");
}

/**
 * An element may be an instance of type "Pensions_and_Annuities_Income class".
 */
private pattern mayInstanceOfPensions_and_Annuities_Income_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFromAgent_class(problem,interpretation,element);
	neg find mustInstanceOfFromLaw_class(problem,interpretation,element);
	neg find mustInstanceOfRentals_and_Leases_Income_class(problem,interpretation,element);
	neg find mustInstanceOfCapital_and_Investments_Income_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Case_class(problem,interpretation,element);
	neg find mustInstanceOfExpense_class(problem,interpretation,element);
	neg find mustInstanceOfConstants_class(problem,interpretation,element);
	neg find mustInstanceOfAddress_class(problem,interpretation,element);
	neg find mustInstanceOfDS_class(problem,interpretation,element);
	neg find mustInstanceOfPhysical_Person_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Property_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_class(problem,interpretation,element);
	neg find mustInstanceOfProfessional_Expenses_Deduction_class(problem,interpretation,element);
	neg find mustInstanceOfExternal_Allowance_class(problem,interpretation,element);
	neg find mustInstanceOfEmployment_Income_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Detail_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_Credit_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Card_class(problem,interpretation,element);
	neg find mustInstanceOfLegal_Union_Record_class(problem,interpretation,element);
	neg find mustInstanceOfAgriculture_and_Forestry_Income_class(problem,interpretation,element);
	neg find mustInstanceOfTrade_and_Business_Income_class(problem,interpretation,element);
	neg find scopeDisallowsNewPensions_and_Annuities_Income_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFromAgent_class(problem,interpretation,element);
	neg find mustInstanceOfFromLaw_class(problem,interpretation,element);
	neg find mustInstanceOfRentals_and_Leases_Income_class(problem,interpretation,element);
	neg find mustInstanceOfCapital_and_Investments_Income_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Case_class(problem,interpretation,element);
	neg find mustInstanceOfExpense_class(problem,interpretation,element);
	neg find mustInstanceOfConstants_class(problem,interpretation,element);
	neg find mustInstanceOfAddress_class(problem,interpretation,element);
	neg find mustInstanceOfDS_class(problem,interpretation,element);
	neg find mustInstanceOfPhysical_Person_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Property_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_class(problem,interpretation,element);
	neg find mustInstanceOfProfessional_Expenses_Deduction_class(problem,interpretation,element);
	neg find mustInstanceOfExternal_Allowance_class(problem,interpretation,element);
	neg find mustInstanceOfEmployment_Income_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Detail_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_Credit_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Card_class(problem,interpretation,element);
	neg find mustInstanceOfLegal_Union_Record_class(problem,interpretation,element);
	neg find mustInstanceOfAgriculture_and_Forestry_Income_class(problem,interpretation,element);
	neg find mustInstanceOfTrade_and_Business_Income_class(problem,interpretation,element);
	neg find scopeDisallowsNewPensions_and_Annuities_Income_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfPensions_and_Annuities_Income_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Capital_and_Investments_Income class".
 */
private pattern mustInstanceOfCapital_and_Investments_Income_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Capital_and_Investments_Income class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewCapital_and_Investments_Income_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Capital_and_Investments_Income class");
}

/**
 * An element may be an instance of type "Capital_and_Investments_Income class".
 */
private pattern mayInstanceOfCapital_and_Investments_Income_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFromAgent_class(problem,interpretation,element);
	neg find mustInstanceOfFromLaw_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Case_class(problem,interpretation,element);
	neg find mustInstanceOfRentals_and_Leases_Income_class(problem,interpretation,element);
	neg find mustInstanceOfExpense_class(problem,interpretation,element);
	neg find mustInstanceOfConstants_class(problem,interpretation,element);
	neg find mustInstanceOfAddress_class(problem,interpretation,element);
	neg find mustInstanceOfDS_class(problem,interpretation,element);
	neg find mustInstanceOfPhysical_Person_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_class(problem,interpretation,element);
	neg find mustInstanceOfPensions_and_Annuities_Income_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Property_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_class(problem,interpretation,element);
	neg find mustInstanceOfProfessional_Expenses_Deduction_class(problem,interpretation,element);
	neg find mustInstanceOfEmployment_Income_class(problem,interpretation,element);
	neg find mustInstanceOfExternal_Allowance_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_Credit_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Detail_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Card_class(problem,interpretation,element);
	neg find mustInstanceOfLegal_Union_Record_class(problem,interpretation,element);
	neg find mustInstanceOfAgriculture_and_Forestry_Income_class(problem,interpretation,element);
	neg find mustInstanceOfTrade_and_Business_Income_class(problem,interpretation,element);
	neg find scopeDisallowsNewCapital_and_Investments_Income_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFromAgent_class(problem,interpretation,element);
	neg find mustInstanceOfFromLaw_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Case_class(problem,interpretation,element);
	neg find mustInstanceOfRentals_and_Leases_Income_class(problem,interpretation,element);
	neg find mustInstanceOfExpense_class(problem,interpretation,element);
	neg find mustInstanceOfConstants_class(problem,interpretation,element);
	neg find mustInstanceOfAddress_class(problem,interpretation,element);
	neg find mustInstanceOfDS_class(problem,interpretation,element);
	neg find mustInstanceOfPhysical_Person_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_class(problem,interpretation,element);
	neg find mustInstanceOfPensions_and_Annuities_Income_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Property_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_class(problem,interpretation,element);
	neg find mustInstanceOfProfessional_Expenses_Deduction_class(problem,interpretation,element);
	neg find mustInstanceOfEmployment_Income_class(problem,interpretation,element);
	neg find mustInstanceOfExternal_Allowance_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_Credit_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Detail_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Card_class(problem,interpretation,element);
	neg find mustInstanceOfLegal_Union_Record_class(problem,interpretation,element);
	neg find mustInstanceOfAgriculture_and_Forestry_Income_class(problem,interpretation,element);
	neg find mustInstanceOfTrade_and_Business_Income_class(problem,interpretation,element);
	neg find scopeDisallowsNewCapital_and_Investments_Income_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfCapital_and_Investments_Income_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Employment_Income class".
 */
private pattern mustInstanceOfEmployment_Income_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Employment_Income class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewEmployment_Income_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Employment_Income class");
}

/**
 * An element may be an instance of type "Employment_Income class".
 */
private pattern mayInstanceOfEmployment_Income_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFromAgent_class(problem,interpretation,element);
	neg find mustInstanceOfFromLaw_class(problem,interpretation,element);
	neg find mustInstanceOfRentals_and_Leases_Income_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Case_class(problem,interpretation,element);
	neg find mustInstanceOfCapital_and_Investments_Income_class(problem,interpretation,element);
	neg find mustInstanceOfExpense_class(problem,interpretation,element);
	neg find mustInstanceOfConstants_class(problem,interpretation,element);
	neg find mustInstanceOfAddress_class(problem,interpretation,element);
	neg find mustInstanceOfDS_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_class(problem,interpretation,element);
	neg find mustInstanceOfPhysical_Person_class(problem,interpretation,element);
	neg find mustInstanceOfPensions_and_Annuities_Income_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Property_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_class(problem,interpretation,element);
	neg find mustInstanceOfProfessional_Expenses_Deduction_class(problem,interpretation,element);
	neg find mustInstanceOfExternal_Allowance_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Detail_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_Credit_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Card_class(problem,interpretation,element);
	neg find mustInstanceOfAgriculture_and_Forestry_Income_class(problem,interpretation,element);
	neg find mustInstanceOfLegal_Union_Record_class(problem,interpretation,element);
	neg find mustInstanceOfTrade_and_Business_Income_class(problem,interpretation,element);
	neg find scopeDisallowsNewEmployment_Income_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFromAgent_class(problem,interpretation,element);
	neg find mustInstanceOfFromLaw_class(problem,interpretation,element);
	neg find mustInstanceOfRentals_and_Leases_Income_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Case_class(problem,interpretation,element);
	neg find mustInstanceOfCapital_and_Investments_Income_class(problem,interpretation,element);
	neg find mustInstanceOfExpense_class(problem,interpretation,element);
	neg find mustInstanceOfConstants_class(problem,interpretation,element);
	neg find mustInstanceOfAddress_class(problem,interpretation,element);
	neg find mustInstanceOfDS_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_class(problem,interpretation,element);
	neg find mustInstanceOfPhysical_Person_class(problem,interpretation,element);
	neg find mustInstanceOfPensions_and_Annuities_Income_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Property_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_class(problem,interpretation,element);
	neg find mustInstanceOfProfessional_Expenses_Deduction_class(problem,interpretation,element);
	neg find mustInstanceOfExternal_Allowance_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Detail_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_Credit_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Card_class(problem,interpretation,element);
	neg find mustInstanceOfAgriculture_and_Forestry_Income_class(problem,interpretation,element);
	neg find mustInstanceOfLegal_Union_Record_class(problem,interpretation,element);
	neg find mustInstanceOfTrade_and_Business_Income_class(problem,interpretation,element);
	neg find scopeDisallowsNewEmployment_Income_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfEmployment_Income_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Rentals_and_Leases_Income class".
 */
private pattern mustInstanceOfRentals_and_Leases_Income_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Rentals_and_Leases_Income class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewRentals_and_Leases_Income_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Rentals_and_Leases_Income class");
}

/**
 * An element may be an instance of type "Rentals_and_Leases_Income class".
 */
private pattern mayInstanceOfRentals_and_Leases_Income_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFromAgent_class(problem,interpretation,element);
	neg find mustInstanceOfFromLaw_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Case_class(problem,interpretation,element);
	neg find mustInstanceOfCapital_and_Investments_Income_class(problem,interpretation,element);
	neg find mustInstanceOfConstants_class(problem,interpretation,element);
	neg find mustInstanceOfExpense_class(problem,interpretation,element);
	neg find mustInstanceOfAddress_class(problem,interpretation,element);
	neg find mustInstanceOfDS_class(problem,interpretation,element);
	neg find mustInstanceOfPhysical_Person_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Property_class(problem,interpretation,element);
	neg find mustInstanceOfPensions_and_Annuities_Income_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_class(problem,interpretation,element);
	neg find mustInstanceOfProfessional_Expenses_Deduction_class(problem,interpretation,element);
	neg find mustInstanceOfExternal_Allowance_class(problem,interpretation,element);
	neg find mustInstanceOfEmployment_Income_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Detail_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_Credit_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Card_class(problem,interpretation,element);
	neg find mustInstanceOfAgriculture_and_Forestry_Income_class(problem,interpretation,element);
	neg find mustInstanceOfLegal_Union_Record_class(problem,interpretation,element);
	neg find mustInstanceOfTrade_and_Business_Income_class(problem,interpretation,element);
	neg find scopeDisallowsNewRentals_and_Leases_Income_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFromAgent_class(problem,interpretation,element);
	neg find mustInstanceOfFromLaw_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Case_class(problem,interpretation,element);
	neg find mustInstanceOfCapital_and_Investments_Income_class(problem,interpretation,element);
	neg find mustInstanceOfConstants_class(problem,interpretation,element);
	neg find mustInstanceOfExpense_class(problem,interpretation,element);
	neg find mustInstanceOfAddress_class(problem,interpretation,element);
	neg find mustInstanceOfDS_class(problem,interpretation,element);
	neg find mustInstanceOfPhysical_Person_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Property_class(problem,interpretation,element);
	neg find mustInstanceOfPensions_and_Annuities_Income_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_class(problem,interpretation,element);
	neg find mustInstanceOfProfessional_Expenses_Deduction_class(problem,interpretation,element);
	neg find mustInstanceOfExternal_Allowance_class(problem,interpretation,element);
	neg find mustInstanceOfEmployment_Income_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Detail_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_Credit_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Card_class(problem,interpretation,element);
	neg find mustInstanceOfAgriculture_and_Forestry_Income_class(problem,interpretation,element);
	neg find mustInstanceOfLegal_Union_Record_class(problem,interpretation,element);
	neg find mustInstanceOfTrade_and_Business_Income_class(problem,interpretation,element);
	neg find scopeDisallowsNewRentals_and_Leases_Income_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfRentals_and_Leases_Income_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Foreign_Income class".
 */
private pattern mustInstanceOfForeign_Income_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Foreign_Income class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewForeign_Income_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Foreign_Income class");
}

/**
 * An element may be an instance of type "Foreign_Income class".
 */
private pattern mayInstanceOfForeign_Income_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFromAgent_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Case_class(problem,interpretation,element);
	neg find mustInstanceOfFromLaw_class(problem,interpretation,element);
	neg find mustInstanceOfExpense_class(problem,interpretation,element);
	neg find mustInstanceOfConstants_class(problem,interpretation,element);
	neg find mustInstanceOfAddress_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Type_class(problem,interpretation,element);
	neg find mustInstanceOfDS_class(problem,interpretation,element);
	neg find mustInstanceOfPhysical_Person_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Property_class(problem,interpretation,element);
	neg find mustInstanceOfLocal_Income_class(problem,interpretation,element);
	neg find mustInstanceOfProfessional_Expenses_Deduction_class(problem,interpretation,element);
	neg find mustInstanceOfExternal_Allowance_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Detail_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_Credit_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Card_class(problem,interpretation,element);
	neg find mustInstanceOfLegal_Union_Record_class(problem,interpretation,element);
	neg find scopeDisallowsNewForeign_Income_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFromAgent_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Case_class(problem,interpretation,element);
	neg find mustInstanceOfFromLaw_class(problem,interpretation,element);
	neg find mustInstanceOfExpense_class(problem,interpretation,element);
	neg find mustInstanceOfConstants_class(problem,interpretation,element);
	neg find mustInstanceOfAddress_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Type_class(problem,interpretation,element);
	neg find mustInstanceOfDS_class(problem,interpretation,element);
	neg find mustInstanceOfPhysical_Person_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Property_class(problem,interpretation,element);
	neg find mustInstanceOfLocal_Income_class(problem,interpretation,element);
	neg find mustInstanceOfProfessional_Expenses_Deduction_class(problem,interpretation,element);
	neg find mustInstanceOfExternal_Allowance_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Detail_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_Credit_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Card_class(problem,interpretation,element);
	neg find mustInstanceOfLegal_Union_Record_class(problem,interpretation,element);
	neg find scopeDisallowsNewForeign_Income_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfForeign_Income_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Local_Income class".
 */
private pattern mustInstanceOfLocal_Income_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Local_Income class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewLocal_Income_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Local_Income class");
}

/**
 * An element may be an instance of type "Local_Income class".
 */
private pattern mayInstanceOfLocal_Income_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFromAgent_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Case_class(problem,interpretation,element);
	neg find mustInstanceOfFromLaw_class(problem,interpretation,element);
	neg find mustInstanceOfConstants_class(problem,interpretation,element);
	neg find mustInstanceOfExpense_class(problem,interpretation,element);
	neg find mustInstanceOfAddress_class(problem,interpretation,element);
	neg find mustInstanceOfForeign_Income_class(problem,interpretation,element);
	neg find mustInstanceOfDS_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Type_class(problem,interpretation,element);
	neg find mustInstanceOfPhysical_Person_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Property_class(problem,interpretation,element);
	neg find mustInstanceOfProfessional_Expenses_Deduction_class(problem,interpretation,element);
	neg find mustInstanceOfExternal_Allowance_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Detail_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_Credit_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Card_class(problem,interpretation,element);
	neg find mustInstanceOfLegal_Union_Record_class(problem,interpretation,element);
	neg find scopeDisallowsNewLocal_Income_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFromAgent_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Case_class(problem,interpretation,element);
	neg find mustInstanceOfFromLaw_class(problem,interpretation,element);
	neg find mustInstanceOfConstants_class(problem,interpretation,element);
	neg find mustInstanceOfExpense_class(problem,interpretation,element);
	neg find mustInstanceOfAddress_class(problem,interpretation,element);
	neg find mustInstanceOfForeign_Income_class(problem,interpretation,element);
	neg find mustInstanceOfDS_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Type_class(problem,interpretation,element);
	neg find mustInstanceOfPhysical_Person_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Property_class(problem,interpretation,element);
	neg find mustInstanceOfProfessional_Expenses_Deduction_class(problem,interpretation,element);
	neg find mustInstanceOfExternal_Allowance_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Detail_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_Credit_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Card_class(problem,interpretation,element);
	neg find mustInstanceOfLegal_Union_Record_class(problem,interpretation,element);
	neg find scopeDisallowsNewLocal_Income_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfLocal_Income_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "CIM class".
 */
private pattern mustInstanceOfCIM_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"CIM class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewCIM_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"CIM class");
}

/**
 * An element may be an instance of type "CIM class".
 */
private pattern mayInstanceOfCIM_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFromAgent_class(problem,interpretation,element);
	neg find mustInstanceOfFromLaw_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Case_class(problem,interpretation,element);
	neg find mustInstanceOfConstants_class(problem,interpretation,element);
	neg find mustInstanceOfExpense_class(problem,interpretation,element);
	neg find mustInstanceOfAddress_class(problem,interpretation,element);
	neg find mustInstanceOfDS_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Type_class(problem,interpretation,element);
	neg find mustInstanceOfCIS_class(problem,interpretation,element);
	neg find mustInstanceOfCIP_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_class(problem,interpretation,element);
	neg find mustInstanceOfPhysical_Person_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Property_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_class(problem,interpretation,element);
	neg find mustInstanceOfProfessional_Expenses_Deduction_class(problem,interpretation,element);
	neg find mustInstanceOfExternal_Allowance_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Detail_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Card_class(problem,interpretation,element);
	neg find mustInstanceOfLegal_Union_Record_class(problem,interpretation,element);
	neg find scopeDisallowsNewCIM_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFromAgent_class(problem,interpretation,element);
	neg find mustInstanceOfFromLaw_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Case_class(problem,interpretation,element);
	neg find mustInstanceOfConstants_class(problem,interpretation,element);
	neg find mustInstanceOfExpense_class(problem,interpretation,element);
	neg find mustInstanceOfAddress_class(problem,interpretation,element);
	neg find mustInstanceOfDS_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Type_class(problem,interpretation,element);
	neg find mustInstanceOfCIS_class(problem,interpretation,element);
	neg find mustInstanceOfCIP_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_class(problem,interpretation,element);
	neg find mustInstanceOfPhysical_Person_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Property_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_class(problem,interpretation,element);
	neg find mustInstanceOfProfessional_Expenses_Deduction_class(problem,interpretation,element);
	neg find mustInstanceOfExternal_Allowance_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Detail_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Card_class(problem,interpretation,element);
	neg find mustInstanceOfLegal_Union_Record_class(problem,interpretation,element);
	neg find scopeDisallowsNewCIM_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfCIM_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "CIP class".
 */
private pattern mustInstanceOfCIP_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"CIP class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewCIP_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"CIP class");
}

/**
 * An element may be an instance of type "CIP class".
 */
private pattern mayInstanceOfCIP_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFromAgent_class(problem,interpretation,element);
	neg find mustInstanceOfFromLaw_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Case_class(problem,interpretation,element);
	neg find mustInstanceOfConstants_class(problem,interpretation,element);
	neg find mustInstanceOfExpense_class(problem,interpretation,element);
	neg find mustInstanceOfAddress_class(problem,interpretation,element);
	neg find mustInstanceOfDS_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Type_class(problem,interpretation,element);
	neg find mustInstanceOfCIS_class(problem,interpretation,element);
	neg find mustInstanceOfPhysical_Person_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Property_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_class(problem,interpretation,element);
	neg find mustInstanceOfProfessional_Expenses_Deduction_class(problem,interpretation,element);
	neg find mustInstanceOfExternal_Allowance_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Detail_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Card_class(problem,interpretation,element);
	neg find mustInstanceOfCIM_class(problem,interpretation,element);
	neg find mustInstanceOfLegal_Union_Record_class(problem,interpretation,element);
	neg find scopeDisallowsNewCIP_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFromAgent_class(problem,interpretation,element);
	neg find mustInstanceOfFromLaw_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Case_class(problem,interpretation,element);
	neg find mustInstanceOfConstants_class(problem,interpretation,element);
	neg find mustInstanceOfExpense_class(problem,interpretation,element);
	neg find mustInstanceOfAddress_class(problem,interpretation,element);
	neg find mustInstanceOfDS_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Type_class(problem,interpretation,element);
	neg find mustInstanceOfCIS_class(problem,interpretation,element);
	neg find mustInstanceOfPhysical_Person_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Property_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_class(problem,interpretation,element);
	neg find mustInstanceOfProfessional_Expenses_Deduction_class(problem,interpretation,element);
	neg find mustInstanceOfExternal_Allowance_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Detail_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Card_class(problem,interpretation,element);
	neg find mustInstanceOfCIM_class(problem,interpretation,element);
	neg find mustInstanceOfLegal_Union_Record_class(problem,interpretation,element);
	neg find scopeDisallowsNewCIP_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfCIP_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "CIS class".
 */
private pattern mustInstanceOfCIS_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"CIS class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewCIS_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"CIS class");
}

/**
 * An element may be an instance of type "CIS class".
 */
private pattern mayInstanceOfCIS_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFromAgent_class(problem,interpretation,element);
	neg find mustInstanceOfFromLaw_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Case_class(problem,interpretation,element);
	neg find mustInstanceOfConstants_class(problem,interpretation,element);
	neg find mustInstanceOfExpense_class(problem,interpretation,element);
	neg find mustInstanceOfAddress_class(problem,interpretation,element);
	neg find mustInstanceOfDS_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Type_class(problem,interpretation,element);
	neg find mustInstanceOfCIP_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_class(problem,interpretation,element);
	neg find mustInstanceOfPhysical_Person_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Property_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_class(problem,interpretation,element);
	neg find mustInstanceOfProfessional_Expenses_Deduction_class(problem,interpretation,element);
	neg find mustInstanceOfExternal_Allowance_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Detail_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Card_class(problem,interpretation,element);
	neg find mustInstanceOfCIM_class(problem,interpretation,element);
	neg find mustInstanceOfLegal_Union_Record_class(problem,interpretation,element);
	neg find scopeDisallowsNewCIS_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFromAgent_class(problem,interpretation,element);
	neg find mustInstanceOfFromLaw_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Case_class(problem,interpretation,element);
	neg find mustInstanceOfConstants_class(problem,interpretation,element);
	neg find mustInstanceOfExpense_class(problem,interpretation,element);
	neg find mustInstanceOfAddress_class(problem,interpretation,element);
	neg find mustInstanceOfDS_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Type_class(problem,interpretation,element);
	neg find mustInstanceOfCIP_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_class(problem,interpretation,element);
	neg find mustInstanceOfPhysical_Person_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Property_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_class(problem,interpretation,element);
	neg find mustInstanceOfProfessional_Expenses_Deduction_class(problem,interpretation,element);
	neg find mustInstanceOfExternal_Allowance_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Detail_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Card_class(problem,interpretation,element);
	neg find mustInstanceOfCIM_class(problem,interpretation,element);
	neg find mustInstanceOfLegal_Union_Record_class(problem,interpretation,element);
	neg find scopeDisallowsNewCIS_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfCIS_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FD class".
 */
private pattern mustInstanceOfFD_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FD class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFD_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FD class");
}

/**
 * An element may be an instance of type "FD class".
 */
private pattern mayInstanceOfFD_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFromAgent_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Case_class(problem,interpretation,element);
	neg find mustInstanceOfFromLaw_class(problem,interpretation,element);
	neg find mustInstanceOfExpense_class(problem,interpretation,element);
	neg find mustInstanceOfConstants_class(problem,interpretation,element);
	neg find mustInstanceOfAddress_class(problem,interpretation,element);
	neg find mustInstanceOfDS_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Type_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_class(problem,interpretation,element);
	neg find mustInstanceOfPhysical_Person_class(problem,interpretation,element);
	neg find mustInstanceOfFO_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Property_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_class(problem,interpretation,element);
	neg find mustInstanceOfExternal_Allowance_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_Credit_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Detail_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Card_class(problem,interpretation,element);
	neg find mustInstanceOfLegal_Union_Record_class(problem,interpretation,element);
	neg find scopeDisallowsNewFD_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFromAgent_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Case_class(problem,interpretation,element);
	neg find mustInstanceOfFromLaw_class(problem,interpretation,element);
	neg find mustInstanceOfExpense_class(problem,interpretation,element);
	neg find mustInstanceOfConstants_class(problem,interpretation,element);
	neg find mustInstanceOfAddress_class(problem,interpretation,element);
	neg find mustInstanceOfDS_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Type_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_class(problem,interpretation,element);
	neg find mustInstanceOfPhysical_Person_class(problem,interpretation,element);
	neg find mustInstanceOfFO_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Property_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_class(problem,interpretation,element);
	neg find mustInstanceOfExternal_Allowance_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_Credit_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Detail_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Card_class(problem,interpretation,element);
	neg find mustInstanceOfLegal_Union_Record_class(problem,interpretation,element);
	neg find scopeDisallowsNewFD_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFD_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Professional_Expenses_Deduction class".
 */
private pattern mustInstanceOfProfessional_Expenses_Deduction_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Professional_Expenses_Deduction class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewProfessional_Expenses_Deduction_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Professional_Expenses_Deduction class");
}

/**
 * An element may be an instance of type "Professional_Expenses_Deduction class".
 */
private pattern mayInstanceOfProfessional_Expenses_Deduction_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFromAgent_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Case_class(problem,interpretation,element);
	neg find mustInstanceOfFromLaw_class(problem,interpretation,element);
	neg find mustInstanceOfExpense_class(problem,interpretation,element);
	neg find mustInstanceOfConstants_class(problem,interpretation,element);
	neg find mustInstanceOfFD_class(problem,interpretation,element);
	neg find mustInstanceOfAddress_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Type_class(problem,interpretation,element);
	neg find mustInstanceOfDS_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_class(problem,interpretation,element);
	neg find mustInstanceOfPhysical_Person_class(problem,interpretation,element);
	neg find mustInstanceOfFO_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Property_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_class(problem,interpretation,element);
	neg find mustInstanceOfExternal_Allowance_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_Credit_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Detail_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Card_class(problem,interpretation,element);
	neg find mustInstanceOfLegal_Union_Record_class(problem,interpretation,element);
	neg find scopeDisallowsNewProfessional_Expenses_Deduction_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFromAgent_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Case_class(problem,interpretation,element);
	neg find mustInstanceOfFromLaw_class(problem,interpretation,element);
	neg find mustInstanceOfExpense_class(problem,interpretation,element);
	neg find mustInstanceOfConstants_class(problem,interpretation,element);
	neg find mustInstanceOfFD_class(problem,interpretation,element);
	neg find mustInstanceOfAddress_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Type_class(problem,interpretation,element);
	neg find mustInstanceOfDS_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_class(problem,interpretation,element);
	neg find mustInstanceOfPhysical_Person_class(problem,interpretation,element);
	neg find mustInstanceOfFO_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Property_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_class(problem,interpretation,element);
	neg find mustInstanceOfExternal_Allowance_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_Credit_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Detail_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Card_class(problem,interpretation,element);
	neg find mustInstanceOfLegal_Union_Record_class(problem,interpretation,element);
	neg find scopeDisallowsNewProfessional_Expenses_Deduction_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfProfessional_Expenses_Deduction_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FO class".
 */
private pattern mustInstanceOfFO_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FO class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFO_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FO class");
}

/**
 * An element may be an instance of type "FO class".
 */
private pattern mayInstanceOfFO_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFromAgent_class(problem,interpretation,element);
	neg find mustInstanceOfFromLaw_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Case_class(problem,interpretation,element);
	neg find mustInstanceOfConstants_class(problem,interpretation,element);
	neg find mustInstanceOfExpense_class(problem,interpretation,element);
	neg find mustInstanceOfFD_class(problem,interpretation,element);
	neg find mustInstanceOfAddress_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Type_class(problem,interpretation,element);
	neg find mustInstanceOfDS_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_class(problem,interpretation,element);
	neg find mustInstanceOfPhysical_Person_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Property_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_class(problem,interpretation,element);
	neg find mustInstanceOfExternal_Allowance_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Detail_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_Credit_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Card_class(problem,interpretation,element);
	neg find mustInstanceOfLegal_Union_Record_class(problem,interpretation,element);
	neg find scopeDisallowsNewFO_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFromAgent_class(problem,interpretation,element);
	neg find mustInstanceOfFromLaw_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Case_class(problem,interpretation,element);
	neg find mustInstanceOfConstants_class(problem,interpretation,element);
	neg find mustInstanceOfExpense_class(problem,interpretation,element);
	neg find mustInstanceOfFD_class(problem,interpretation,element);
	neg find mustInstanceOfAddress_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Type_class(problem,interpretation,element);
	neg find mustInstanceOfDS_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_class(problem,interpretation,element);
	neg find mustInstanceOfPhysical_Person_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Property_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_class(problem,interpretation,element);
	neg find mustInstanceOfExternal_Allowance_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Detail_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_Credit_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Card_class(problem,interpretation,element);
	neg find mustInstanceOfLegal_Union_Record_class(problem,interpretation,element);
	neg find scopeDisallowsNewFO_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFO_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "DS_for_Permanent_Expense class".
 */
private pattern mustInstanceOfDS_for_Permanent_Expense_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"DS_for_Permanent_Expense class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewDS_for_Permanent_Expense_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"DS_for_Permanent_Expense class");
}

/**
 * An element may be an instance of type "DS_for_Permanent_Expense class".
 */
private pattern mayInstanceOfDS_for_Permanent_Expense_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFromAgent_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Case_class(problem,interpretation,element);
	neg find mustInstanceOfFromLaw_class(problem,interpretation,element);
	neg find mustInstanceOfExpense_class(problem,interpretation,element);
	neg find mustInstanceOfConstants_class(problem,interpretation,element);
	neg find mustInstanceOfAddress_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Type_class(problem,interpretation,element);
	neg find mustInstanceOfPhysical_Person_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Property_class(problem,interpretation,element);
	neg find mustInstanceOfDS_for_Loss_Carryforward_class(problem,interpretation,element);
	neg find mustInstanceOfDS_for_Donation_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_class(problem,interpretation,element);
	neg find mustInstanceOfProfessional_Expenses_Deduction_class(problem,interpretation,element);
	neg find mustInstanceOfExternal_Allowance_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Detail_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_Credit_class(problem,interpretation,element);
	neg find mustInstanceOfDS_for_Interest_Expense_class(problem,interpretation,element);
	neg find mustInstanceOfDS_for_Health_and_Pension_Insurance_class(problem,interpretation,element);
	neg find mustInstanceOfDS_for_Private_Insurance_and_Plan_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Card_class(problem,interpretation,element);
	neg find mustInstanceOfLegal_Union_Record_class(problem,interpretation,element);
	neg find scopeDisallowsNewDS_for_Permanent_Expense_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFromAgent_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Case_class(problem,interpretation,element);
	neg find mustInstanceOfFromLaw_class(problem,interpretation,element);
	neg find mustInstanceOfExpense_class(problem,interpretation,element);
	neg find mustInstanceOfConstants_class(problem,interpretation,element);
	neg find mustInstanceOfAddress_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Type_class(problem,interpretation,element);
	neg find mustInstanceOfPhysical_Person_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Property_class(problem,interpretation,element);
	neg find mustInstanceOfDS_for_Loss_Carryforward_class(problem,interpretation,element);
	neg find mustInstanceOfDS_for_Donation_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_class(problem,interpretation,element);
	neg find mustInstanceOfProfessional_Expenses_Deduction_class(problem,interpretation,element);
	neg find mustInstanceOfExternal_Allowance_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Detail_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_Credit_class(problem,interpretation,element);
	neg find mustInstanceOfDS_for_Interest_Expense_class(problem,interpretation,element);
	neg find mustInstanceOfDS_for_Health_and_Pension_Insurance_class(problem,interpretation,element);
	neg find mustInstanceOfDS_for_Private_Insurance_and_Plan_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Card_class(problem,interpretation,element);
	neg find mustInstanceOfLegal_Union_Record_class(problem,interpretation,element);
	neg find scopeDisallowsNewDS_for_Permanent_Expense_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfDS_for_Permanent_Expense_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "DS class".
 */
private pattern mustInstanceOfDS_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"DS class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewDS_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"DS class");
}

/**
 * An element may be an instance of type "DS class".
 */
private pattern mayInstanceOfDS_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFromAgent_class(problem,interpretation,element);
	neg find mustInstanceOfDS_for_Permanent_Expense_class(problem,interpretation,element);
	neg find mustInstanceOfFromLaw_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Case_class(problem,interpretation,element);
	neg find mustInstanceOfConstants_class(problem,interpretation,element);
	neg find mustInstanceOfExpense_class(problem,interpretation,element);
	neg find mustInstanceOfAddress_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Type_class(problem,interpretation,element);
	neg find mustInstanceOfPhysical_Person_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Property_class(problem,interpretation,element);
	neg find mustInstanceOfDS_for_Loss_Carryforward_class(problem,interpretation,element);
	neg find mustInstanceOfDS_for_Donation_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_class(problem,interpretation,element);
	neg find mustInstanceOfProfessional_Expenses_Deduction_class(problem,interpretation,element);
	neg find mustInstanceOfExternal_Allowance_class(problem,interpretation,element);
	neg find mustInstanceOfDS_for_Interest_Expense_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_Credit_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Detail_class(problem,interpretation,element);
	neg find mustInstanceOfDS_for_Health_and_Pension_Insurance_class(problem,interpretation,element);
	neg find mustInstanceOfDS_for_Private_Insurance_and_Plan_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Card_class(problem,interpretation,element);
	neg find mustInstanceOfLegal_Union_Record_class(problem,interpretation,element);
	neg find scopeDisallowsNewDS_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFromAgent_class(problem,interpretation,element);
	neg find mustInstanceOfDS_for_Permanent_Expense_class(problem,interpretation,element);
	neg find mustInstanceOfFromLaw_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Case_class(problem,interpretation,element);
	neg find mustInstanceOfConstants_class(problem,interpretation,element);
	neg find mustInstanceOfExpense_class(problem,interpretation,element);
	neg find mustInstanceOfAddress_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Type_class(problem,interpretation,element);
	neg find mustInstanceOfPhysical_Person_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Property_class(problem,interpretation,element);
	neg find mustInstanceOfDS_for_Loss_Carryforward_class(problem,interpretation,element);
	neg find mustInstanceOfDS_for_Donation_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_class(problem,interpretation,element);
	neg find mustInstanceOfProfessional_Expenses_Deduction_class(problem,interpretation,element);
	neg find mustInstanceOfExternal_Allowance_class(problem,interpretation,element);
	neg find mustInstanceOfDS_for_Interest_Expense_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_Credit_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Detail_class(problem,interpretation,element);
	neg find mustInstanceOfDS_for_Health_and_Pension_Insurance_class(problem,interpretation,element);
	neg find mustInstanceOfDS_for_Private_Insurance_and_Plan_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Card_class(problem,interpretation,element);
	neg find mustInstanceOfLegal_Union_Record_class(problem,interpretation,element);
	neg find scopeDisallowsNewDS_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfDS_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "DS_for_Interest_Expense class".
 */
private pattern mustInstanceOfDS_for_Interest_Expense_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"DS_for_Interest_Expense class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewDS_for_Interest_Expense_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"DS_for_Interest_Expense class");
}

/**
 * An element may be an instance of type "DS_for_Interest_Expense class".
 */
private pattern mayInstanceOfDS_for_Interest_Expense_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFromAgent_class(problem,interpretation,element);
	neg find mustInstanceOfDS_for_Permanent_Expense_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Case_class(problem,interpretation,element);
	neg find mustInstanceOfFromLaw_class(problem,interpretation,element);
	neg find mustInstanceOfExpense_class(problem,interpretation,element);
	neg find mustInstanceOfConstants_class(problem,interpretation,element);
	neg find mustInstanceOfAddress_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Type_class(problem,interpretation,element);
	neg find mustInstanceOfPhysical_Person_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Property_class(problem,interpretation,element);
	neg find mustInstanceOfDS_for_Loss_Carryforward_class(problem,interpretation,element);
	neg find mustInstanceOfDS_for_Donation_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_class(problem,interpretation,element);
	neg find mustInstanceOfProfessional_Expenses_Deduction_class(problem,interpretation,element);
	neg find mustInstanceOfExternal_Allowance_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_Credit_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Detail_class(problem,interpretation,element);
	neg find mustInstanceOfDS_for_Health_and_Pension_Insurance_class(problem,interpretation,element);
	neg find mustInstanceOfDS_for_Private_Insurance_and_Plan_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Card_class(problem,interpretation,element);
	neg find mustInstanceOfLegal_Union_Record_class(problem,interpretation,element);
	neg find scopeDisallowsNewDS_for_Interest_Expense_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFromAgent_class(problem,interpretation,element);
	neg find mustInstanceOfDS_for_Permanent_Expense_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Case_class(problem,interpretation,element);
	neg find mustInstanceOfFromLaw_class(problem,interpretation,element);
	neg find mustInstanceOfExpense_class(problem,interpretation,element);
	neg find mustInstanceOfConstants_class(problem,interpretation,element);
	neg find mustInstanceOfAddress_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Type_class(problem,interpretation,element);
	neg find mustInstanceOfPhysical_Person_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Property_class(problem,interpretation,element);
	neg find mustInstanceOfDS_for_Loss_Carryforward_class(problem,interpretation,element);
	neg find mustInstanceOfDS_for_Donation_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_class(problem,interpretation,element);
	neg find mustInstanceOfProfessional_Expenses_Deduction_class(problem,interpretation,element);
	neg find mustInstanceOfExternal_Allowance_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_Credit_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Detail_class(problem,interpretation,element);
	neg find mustInstanceOfDS_for_Health_and_Pension_Insurance_class(problem,interpretation,element);
	neg find mustInstanceOfDS_for_Private_Insurance_and_Plan_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Card_class(problem,interpretation,element);
	neg find mustInstanceOfLegal_Union_Record_class(problem,interpretation,element);
	neg find scopeDisallowsNewDS_for_Interest_Expense_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfDS_for_Interest_Expense_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "DS_for_Health_and_Pension_Insurance class".
 */
private pattern mustInstanceOfDS_for_Health_and_Pension_Insurance_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"DS_for_Health_and_Pension_Insurance class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewDS_for_Health_and_Pension_Insurance_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"DS_for_Health_and_Pension_Insurance class");
}

/**
 * An element may be an instance of type "DS_for_Health_and_Pension_Insurance class".
 */
private pattern mayInstanceOfDS_for_Health_and_Pension_Insurance_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFromAgent_class(problem,interpretation,element);
	neg find mustInstanceOfDS_for_Permanent_Expense_class(problem,interpretation,element);
	neg find mustInstanceOfFromLaw_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Case_class(problem,interpretation,element);
	neg find mustInstanceOfExpense_class(problem,interpretation,element);
	neg find mustInstanceOfConstants_class(problem,interpretation,element);
	neg find mustInstanceOfAddress_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Type_class(problem,interpretation,element);
	neg find mustInstanceOfPhysical_Person_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Property_class(problem,interpretation,element);
	neg find mustInstanceOfDS_for_Loss_Carryforward_class(problem,interpretation,element);
	neg find mustInstanceOfDS_for_Donation_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_class(problem,interpretation,element);
	neg find mustInstanceOfProfessional_Expenses_Deduction_class(problem,interpretation,element);
	neg find mustInstanceOfExternal_Allowance_class(problem,interpretation,element);
	neg find mustInstanceOfDS_for_Interest_Expense_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Detail_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_Credit_class(problem,interpretation,element);
	neg find mustInstanceOfDS_for_Private_Insurance_and_Plan_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Card_class(problem,interpretation,element);
	neg find mustInstanceOfLegal_Union_Record_class(problem,interpretation,element);
	neg find scopeDisallowsNewDS_for_Health_and_Pension_Insurance_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFromAgent_class(problem,interpretation,element);
	neg find mustInstanceOfDS_for_Permanent_Expense_class(problem,interpretation,element);
	neg find mustInstanceOfFromLaw_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Case_class(problem,interpretation,element);
	neg find mustInstanceOfExpense_class(problem,interpretation,element);
	neg find mustInstanceOfConstants_class(problem,interpretation,element);
	neg find mustInstanceOfAddress_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Type_class(problem,interpretation,element);
	neg find mustInstanceOfPhysical_Person_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Property_class(problem,interpretation,element);
	neg find mustInstanceOfDS_for_Loss_Carryforward_class(problem,interpretation,element);
	neg find mustInstanceOfDS_for_Donation_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_class(problem,interpretation,element);
	neg find mustInstanceOfProfessional_Expenses_Deduction_class(problem,interpretation,element);
	neg find mustInstanceOfExternal_Allowance_class(problem,interpretation,element);
	neg find mustInstanceOfDS_for_Interest_Expense_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Detail_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_Credit_class(problem,interpretation,element);
	neg find mustInstanceOfDS_for_Private_Insurance_and_Plan_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Card_class(problem,interpretation,element);
	neg find mustInstanceOfLegal_Union_Record_class(problem,interpretation,element);
	neg find scopeDisallowsNewDS_for_Health_and_Pension_Insurance_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfDS_for_Health_and_Pension_Insurance_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "DS_for_Private_Insurance_and_Plan class".
 */
private pattern mustInstanceOfDS_for_Private_Insurance_and_Plan_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"DS_for_Private_Insurance_and_Plan class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewDS_for_Private_Insurance_and_Plan_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"DS_for_Private_Insurance_and_Plan class");
}

/**
 * An element may be an instance of type "DS_for_Private_Insurance_and_Plan class".
 */
private pattern mayInstanceOfDS_for_Private_Insurance_and_Plan_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFromAgent_class(problem,interpretation,element);
	neg find mustInstanceOfDS_for_Permanent_Expense_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Case_class(problem,interpretation,element);
	neg find mustInstanceOfFromLaw_class(problem,interpretation,element);
	neg find mustInstanceOfExpense_class(problem,interpretation,element);
	neg find mustInstanceOfConstants_class(problem,interpretation,element);
	neg find mustInstanceOfAddress_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Type_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_class(problem,interpretation,element);
	neg find mustInstanceOfPhysical_Person_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Property_class(problem,interpretation,element);
	neg find mustInstanceOfDS_for_Loss_Carryforward_class(problem,interpretation,element);
	neg find mustInstanceOfDS_for_Donation_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_class(problem,interpretation,element);
	neg find mustInstanceOfProfessional_Expenses_Deduction_class(problem,interpretation,element);
	neg find mustInstanceOfExternal_Allowance_class(problem,interpretation,element);
	neg find mustInstanceOfDS_for_Interest_Expense_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Detail_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_Credit_class(problem,interpretation,element);
	neg find mustInstanceOfDS_for_Health_and_Pension_Insurance_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Card_class(problem,interpretation,element);
	neg find mustInstanceOfLegal_Union_Record_class(problem,interpretation,element);
	neg find scopeDisallowsNewDS_for_Private_Insurance_and_Plan_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFromAgent_class(problem,interpretation,element);
	neg find mustInstanceOfDS_for_Permanent_Expense_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Case_class(problem,interpretation,element);
	neg find mustInstanceOfFromLaw_class(problem,interpretation,element);
	neg find mustInstanceOfExpense_class(problem,interpretation,element);
	neg find mustInstanceOfConstants_class(problem,interpretation,element);
	neg find mustInstanceOfAddress_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Type_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_class(problem,interpretation,element);
	neg find mustInstanceOfPhysical_Person_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Property_class(problem,interpretation,element);
	neg find mustInstanceOfDS_for_Loss_Carryforward_class(problem,interpretation,element);
	neg find mustInstanceOfDS_for_Donation_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_class(problem,interpretation,element);
	neg find mustInstanceOfProfessional_Expenses_Deduction_class(problem,interpretation,element);
	neg find mustInstanceOfExternal_Allowance_class(problem,interpretation,element);
	neg find mustInstanceOfDS_for_Interest_Expense_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Detail_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_Credit_class(problem,interpretation,element);
	neg find mustInstanceOfDS_for_Health_and_Pension_Insurance_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Card_class(problem,interpretation,element);
	neg find mustInstanceOfLegal_Union_Record_class(problem,interpretation,element);
	neg find scopeDisallowsNewDS_for_Private_Insurance_and_Plan_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfDS_for_Private_Insurance_and_Plan_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "DS_for_Loss_Carryforward class".
 */
private pattern mustInstanceOfDS_for_Loss_Carryforward_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"DS_for_Loss_Carryforward class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewDS_for_Loss_Carryforward_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"DS_for_Loss_Carryforward class");
}

/**
 * An element may be an instance of type "DS_for_Loss_Carryforward class".
 */
private pattern mayInstanceOfDS_for_Loss_Carryforward_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFromAgent_class(problem,interpretation,element);
	neg find mustInstanceOfDS_for_Permanent_Expense_class(problem,interpretation,element);
	neg find mustInstanceOfFromLaw_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Case_class(problem,interpretation,element);
	neg find mustInstanceOfConstants_class(problem,interpretation,element);
	neg find mustInstanceOfExpense_class(problem,interpretation,element);
	neg find mustInstanceOfAddress_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Type_class(problem,interpretation,element);
	neg find mustInstanceOfPhysical_Person_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Property_class(problem,interpretation,element);
	neg find mustInstanceOfDS_for_Donation_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_class(problem,interpretation,element);
	neg find mustInstanceOfProfessional_Expenses_Deduction_class(problem,interpretation,element);
	neg find mustInstanceOfExternal_Allowance_class(problem,interpretation,element);
	neg find mustInstanceOfDS_for_Interest_Expense_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_Credit_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Detail_class(problem,interpretation,element);
	neg find mustInstanceOfDS_for_Health_and_Pension_Insurance_class(problem,interpretation,element);
	neg find mustInstanceOfDS_for_Private_Insurance_and_Plan_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Card_class(problem,interpretation,element);
	neg find mustInstanceOfLegal_Union_Record_class(problem,interpretation,element);
	neg find scopeDisallowsNewDS_for_Loss_Carryforward_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFromAgent_class(problem,interpretation,element);
	neg find mustInstanceOfDS_for_Permanent_Expense_class(problem,interpretation,element);
	neg find mustInstanceOfFromLaw_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Case_class(problem,interpretation,element);
	neg find mustInstanceOfConstants_class(problem,interpretation,element);
	neg find mustInstanceOfExpense_class(problem,interpretation,element);
	neg find mustInstanceOfAddress_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Type_class(problem,interpretation,element);
	neg find mustInstanceOfPhysical_Person_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Property_class(problem,interpretation,element);
	neg find mustInstanceOfDS_for_Donation_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_class(problem,interpretation,element);
	neg find mustInstanceOfProfessional_Expenses_Deduction_class(problem,interpretation,element);
	neg find mustInstanceOfExternal_Allowance_class(problem,interpretation,element);
	neg find mustInstanceOfDS_for_Interest_Expense_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_Credit_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Detail_class(problem,interpretation,element);
	neg find mustInstanceOfDS_for_Health_and_Pension_Insurance_class(problem,interpretation,element);
	neg find mustInstanceOfDS_for_Private_Insurance_and_Plan_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Card_class(problem,interpretation,element);
	neg find mustInstanceOfLegal_Union_Record_class(problem,interpretation,element);
	neg find scopeDisallowsNewDS_for_Loss_Carryforward_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfDS_for_Loss_Carryforward_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "DS_for_Donation class".
 */
private pattern mustInstanceOfDS_for_Donation_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"DS_for_Donation class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewDS_for_Donation_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"DS_for_Donation class");
}

/**
 * An element may be an instance of type "DS_for_Donation class".
 */
private pattern mayInstanceOfDS_for_Donation_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFromAgent_class(problem,interpretation,element);
	neg find mustInstanceOfDS_for_Permanent_Expense_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Case_class(problem,interpretation,element);
	neg find mustInstanceOfFromLaw_class(problem,interpretation,element);
	neg find mustInstanceOfConstants_class(problem,interpretation,element);
	neg find mustInstanceOfExpense_class(problem,interpretation,element);
	neg find mustInstanceOfAddress_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Type_class(problem,interpretation,element);
	neg find mustInstanceOfPhysical_Person_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Property_class(problem,interpretation,element);
	neg find mustInstanceOfDS_for_Loss_Carryforward_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_class(problem,interpretation,element);
	neg find mustInstanceOfProfessional_Expenses_Deduction_class(problem,interpretation,element);
	neg find mustInstanceOfExternal_Allowance_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_Credit_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Detail_class(problem,interpretation,element);
	neg find mustInstanceOfDS_for_Interest_Expense_class(problem,interpretation,element);
	neg find mustInstanceOfDS_for_Health_and_Pension_Insurance_class(problem,interpretation,element);
	neg find mustInstanceOfDS_for_Private_Insurance_and_Plan_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Card_class(problem,interpretation,element);
	neg find mustInstanceOfLegal_Union_Record_class(problem,interpretation,element);
	neg find scopeDisallowsNewDS_for_Donation_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFromAgent_class(problem,interpretation,element);
	neg find mustInstanceOfDS_for_Permanent_Expense_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Case_class(problem,interpretation,element);
	neg find mustInstanceOfFromLaw_class(problem,interpretation,element);
	neg find mustInstanceOfConstants_class(problem,interpretation,element);
	neg find mustInstanceOfExpense_class(problem,interpretation,element);
	neg find mustInstanceOfAddress_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Type_class(problem,interpretation,element);
	neg find mustInstanceOfPhysical_Person_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Property_class(problem,interpretation,element);
	neg find mustInstanceOfDS_for_Loss_Carryforward_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_class(problem,interpretation,element);
	neg find mustInstanceOfProfessional_Expenses_Deduction_class(problem,interpretation,element);
	neg find mustInstanceOfExternal_Allowance_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_Credit_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Detail_class(problem,interpretation,element);
	neg find mustInstanceOfDS_for_Interest_Expense_class(problem,interpretation,element);
	neg find mustInstanceOfDS_for_Health_and_Pension_Insurance_class(problem,interpretation,element);
	neg find mustInstanceOfDS_for_Private_Insurance_and_Plan_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Card_class(problem,interpretation,element);
	neg find mustInstanceOfLegal_Union_Record_class(problem,interpretation,element);
	neg find scopeDisallowsNewDS_for_Donation_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfDS_for_Donation_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Permanent_Expense class".
 */
private pattern mustInstanceOfPermanent_Expense_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Permanent_Expense class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewPermanent_Expense_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Permanent_Expense class");
}

/**
 * An element may be an instance of type "Permanent_Expense class".
 */
private pattern mayInstanceOfPermanent_Expense_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfTax_Case_class(problem,interpretation,element);
	neg find mustInstanceOfProfessional_Expense_class(problem,interpretation,element);
	neg find mustInstanceOfAddress_class(problem,interpretation,element);
	neg find mustInstanceOfDS_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Type_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_class(problem,interpretation,element);
	neg find mustInstanceOfPhysical_Person_class(problem,interpretation,element);
	neg find mustInstanceOfSpousal_Expense_AC_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_class(problem,interpretation,element);
	neg find mustInstanceOfProfessional_Expenses_Deduction_class(problem,interpretation,element);
	neg find mustInstanceOfInterest_Expense_class(problem,interpretation,element);
	neg find mustInstanceOfExtraordinary_Expense_CE_class(problem,interpretation,element);
	neg find mustInstanceOfPrivate_Insurance_and_Plan_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Card_class(problem,interpretation,element);
	neg find mustInstanceOfHealth_and_Pension_Insurance_class(problem,interpretation,element);
	neg find mustInstanceOfDonation_class(problem,interpretation,element);
	neg find mustInstanceOfFromAgent_class(problem,interpretation,element);
	neg find mustInstanceOfFromLaw_class(problem,interpretation,element);
	neg find mustInstanceOfConstants_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Property_class(problem,interpretation,element);
	neg find mustInstanceOfLoss_Carryforward_class(problem,interpretation,element);
	neg find mustInstanceOfExternal_Allowance_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Detail_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_Credit_class(problem,interpretation,element);
	neg find mustInstanceOfLegal_Union_Record_class(problem,interpretation,element);
	neg find scopeDisallowsNewPermanent_Expense_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfTax_Case_class(problem,interpretation,element);
	neg find mustInstanceOfProfessional_Expense_class(problem,interpretation,element);
	neg find mustInstanceOfAddress_class(problem,interpretation,element);
	neg find mustInstanceOfDS_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Type_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_class(problem,interpretation,element);
	neg find mustInstanceOfPhysical_Person_class(problem,interpretation,element);
	neg find mustInstanceOfSpousal_Expense_AC_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_class(problem,interpretation,element);
	neg find mustInstanceOfProfessional_Expenses_Deduction_class(problem,interpretation,element);
	neg find mustInstanceOfInterest_Expense_class(problem,interpretation,element);
	neg find mustInstanceOfExtraordinary_Expense_CE_class(problem,interpretation,element);
	neg find mustInstanceOfPrivate_Insurance_and_Plan_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Card_class(problem,interpretation,element);
	neg find mustInstanceOfHealth_and_Pension_Insurance_class(problem,interpretation,element);
	neg find mustInstanceOfDonation_class(problem,interpretation,element);
	neg find mustInstanceOfFromAgent_class(problem,interpretation,element);
	neg find mustInstanceOfFromLaw_class(problem,interpretation,element);
	neg find mustInstanceOfConstants_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Property_class(problem,interpretation,element);
	neg find mustInstanceOfLoss_Carryforward_class(problem,interpretation,element);
	neg find mustInstanceOfExternal_Allowance_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Detail_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_Credit_class(problem,interpretation,element);
	neg find mustInstanceOfLegal_Union_Record_class(problem,interpretation,element);
	neg find scopeDisallowsNewPermanent_Expense_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfPermanent_Expense_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Special_Expense_DS class".
 */
private pattern mustInstanceOfSpecial_Expense_DS_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Special_Expense_DS class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewSpecial_Expense_DS_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Special_Expense_DS class");
}

/**
 * An element may be an instance of type "Special_Expense_DS class".
 */
private pattern mayInstanceOfSpecial_Expense_DS_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfTax_Case_class(problem,interpretation,element);
	neg find mustInstanceOfProfessional_Expense_class(problem,interpretation,element);
	neg find mustInstanceOfAddress_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Type_class(problem,interpretation,element);
	neg find mustInstanceOfDS_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_class(problem,interpretation,element);
	neg find mustInstanceOfPhysical_Person_class(problem,interpretation,element);
	neg find mustInstanceOfSpousal_Expense_AC_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_class(problem,interpretation,element);
	neg find mustInstanceOfProfessional_Expenses_Deduction_class(problem,interpretation,element);
	neg find mustInstanceOfInterest_Expense_class(problem,interpretation,element);
	neg find mustInstanceOfExtraordinary_Expense_CE_class(problem,interpretation,element);
	neg find mustInstanceOfPrivate_Insurance_and_Plan_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Card_class(problem,interpretation,element);
	neg find mustInstanceOfHealth_and_Pension_Insurance_class(problem,interpretation,element);
	neg find mustInstanceOfDonation_class(problem,interpretation,element);
	neg find mustInstanceOfFromAgent_class(problem,interpretation,element);
	neg find mustInstanceOfFromLaw_class(problem,interpretation,element);
	neg find mustInstanceOfConstants_class(problem,interpretation,element);
	neg find mustInstanceOfPermanent_Expense_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Property_class(problem,interpretation,element);
	neg find mustInstanceOfLoss_Carryforward_class(problem,interpretation,element);
	neg find mustInstanceOfExternal_Allowance_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_Credit_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Detail_class(problem,interpretation,element);
	neg find mustInstanceOfLegal_Union_Record_class(problem,interpretation,element);
	neg find scopeDisallowsNewSpecial_Expense_DS_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfTax_Case_class(problem,interpretation,element);
	neg find mustInstanceOfProfessional_Expense_class(problem,interpretation,element);
	neg find mustInstanceOfAddress_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Type_class(problem,interpretation,element);
	neg find mustInstanceOfDS_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_class(problem,interpretation,element);
	neg find mustInstanceOfPhysical_Person_class(problem,interpretation,element);
	neg find mustInstanceOfSpousal_Expense_AC_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_class(problem,interpretation,element);
	neg find mustInstanceOfProfessional_Expenses_Deduction_class(problem,interpretation,element);
	neg find mustInstanceOfInterest_Expense_class(problem,interpretation,element);
	neg find mustInstanceOfExtraordinary_Expense_CE_class(problem,interpretation,element);
	neg find mustInstanceOfPrivate_Insurance_and_Plan_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Card_class(problem,interpretation,element);
	neg find mustInstanceOfHealth_and_Pension_Insurance_class(problem,interpretation,element);
	neg find mustInstanceOfDonation_class(problem,interpretation,element);
	neg find mustInstanceOfFromAgent_class(problem,interpretation,element);
	neg find mustInstanceOfFromLaw_class(problem,interpretation,element);
	neg find mustInstanceOfConstants_class(problem,interpretation,element);
	neg find mustInstanceOfPermanent_Expense_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Property_class(problem,interpretation,element);
	neg find mustInstanceOfLoss_Carryforward_class(problem,interpretation,element);
	neg find mustInstanceOfExternal_Allowance_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_Credit_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Detail_class(problem,interpretation,element);
	neg find mustInstanceOfLegal_Union_Record_class(problem,interpretation,element);
	neg find scopeDisallowsNewSpecial_Expense_DS_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfSpecial_Expense_DS_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Interest_Expense class".
 */
private pattern mustInstanceOfInterest_Expense_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Interest_Expense class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewInterest_Expense_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Interest_Expense class");
}

/**
 * An element may be an instance of type "Interest_Expense class".
 */
private pattern mayInstanceOfInterest_Expense_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfTax_Case_class(problem,interpretation,element);
	neg find mustInstanceOfProfessional_Expense_class(problem,interpretation,element);
	neg find mustInstanceOfAddress_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Type_class(problem,interpretation,element);
	neg find mustInstanceOfDS_class(problem,interpretation,element);
	neg find mustInstanceOfPhysical_Person_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_class(problem,interpretation,element);
	neg find mustInstanceOfSpousal_Expense_AC_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_class(problem,interpretation,element);
	neg find mustInstanceOfProfessional_Expenses_Deduction_class(problem,interpretation,element);
	neg find mustInstanceOfExtraordinary_Expense_CE_class(problem,interpretation,element);
	neg find mustInstanceOfPrivate_Insurance_and_Plan_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Card_class(problem,interpretation,element);
	neg find mustInstanceOfDonation_class(problem,interpretation,element);
	neg find mustInstanceOfHealth_and_Pension_Insurance_class(problem,interpretation,element);
	neg find mustInstanceOfFromAgent_class(problem,interpretation,element);
	neg find mustInstanceOfFromLaw_class(problem,interpretation,element);
	neg find mustInstanceOfConstants_class(problem,interpretation,element);
	neg find mustInstanceOfPermanent_Expense_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Property_class(problem,interpretation,element);
	neg find mustInstanceOfLoss_Carryforward_class(problem,interpretation,element);
	neg find mustInstanceOfExternal_Allowance_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Detail_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_Credit_class(problem,interpretation,element);
	neg find mustInstanceOfLegal_Union_Record_class(problem,interpretation,element);
	neg find scopeDisallowsNewInterest_Expense_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfTax_Case_class(problem,interpretation,element);
	neg find mustInstanceOfProfessional_Expense_class(problem,interpretation,element);
	neg find mustInstanceOfAddress_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Type_class(problem,interpretation,element);
	neg find mustInstanceOfDS_class(problem,interpretation,element);
	neg find mustInstanceOfPhysical_Person_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_class(problem,interpretation,element);
	neg find mustInstanceOfSpousal_Expense_AC_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_class(problem,interpretation,element);
	neg find mustInstanceOfProfessional_Expenses_Deduction_class(problem,interpretation,element);
	neg find mustInstanceOfExtraordinary_Expense_CE_class(problem,interpretation,element);
	neg find mustInstanceOfPrivate_Insurance_and_Plan_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Card_class(problem,interpretation,element);
	neg find mustInstanceOfDonation_class(problem,interpretation,element);
	neg find mustInstanceOfHealth_and_Pension_Insurance_class(problem,interpretation,element);
	neg find mustInstanceOfFromAgent_class(problem,interpretation,element);
	neg find mustInstanceOfFromLaw_class(problem,interpretation,element);
	neg find mustInstanceOfConstants_class(problem,interpretation,element);
	neg find mustInstanceOfPermanent_Expense_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Property_class(problem,interpretation,element);
	neg find mustInstanceOfLoss_Carryforward_class(problem,interpretation,element);
	neg find mustInstanceOfExternal_Allowance_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Detail_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_Credit_class(problem,interpretation,element);
	neg find mustInstanceOfLegal_Union_Record_class(problem,interpretation,element);
	neg find scopeDisallowsNewInterest_Expense_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfInterest_Expense_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Private_Insurance_and_Plan class".
 */
private pattern mustInstanceOfPrivate_Insurance_and_Plan_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Private_Insurance_and_Plan class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewPrivate_Insurance_and_Plan_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Private_Insurance_and_Plan class");
}

/**
 * An element may be an instance of type "Private_Insurance_and_Plan class".
 */
private pattern mayInstanceOfPrivate_Insurance_and_Plan_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfTax_Case_class(problem,interpretation,element);
	neg find mustInstanceOfProfessional_Expense_class(problem,interpretation,element);
	neg find mustInstanceOfAddress_class(problem,interpretation,element);
	neg find mustInstanceOfDS_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Type_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_class(problem,interpretation,element);
	neg find mustInstanceOfPhysical_Person_class(problem,interpretation,element);
	neg find mustInstanceOfSpousal_Expense_AC_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_class(problem,interpretation,element);
	neg find mustInstanceOfProfessional_Expenses_Deduction_class(problem,interpretation,element);
	neg find mustInstanceOfInterest_Expense_class(problem,interpretation,element);
	neg find mustInstanceOfExtraordinary_Expense_CE_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Card_class(problem,interpretation,element);
	neg find mustInstanceOfDonation_class(problem,interpretation,element);
	neg find mustInstanceOfHealth_and_Pension_Insurance_class(problem,interpretation,element);
	neg find mustInstanceOfFromAgent_class(problem,interpretation,element);
	neg find mustInstanceOfFromLaw_class(problem,interpretation,element);
	neg find mustInstanceOfConstants_class(problem,interpretation,element);
	neg find mustInstanceOfPermanent_Expense_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Property_class(problem,interpretation,element);
	neg find mustInstanceOfLoss_Carryforward_class(problem,interpretation,element);
	neg find mustInstanceOfExternal_Allowance_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_Credit_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Detail_class(problem,interpretation,element);
	neg find mustInstanceOfLegal_Union_Record_class(problem,interpretation,element);
	neg find scopeDisallowsNewPrivate_Insurance_and_Plan_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfTax_Case_class(problem,interpretation,element);
	neg find mustInstanceOfProfessional_Expense_class(problem,interpretation,element);
	neg find mustInstanceOfAddress_class(problem,interpretation,element);
	neg find mustInstanceOfDS_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Type_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_class(problem,interpretation,element);
	neg find mustInstanceOfPhysical_Person_class(problem,interpretation,element);
	neg find mustInstanceOfSpousal_Expense_AC_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_class(problem,interpretation,element);
	neg find mustInstanceOfProfessional_Expenses_Deduction_class(problem,interpretation,element);
	neg find mustInstanceOfInterest_Expense_class(problem,interpretation,element);
	neg find mustInstanceOfExtraordinary_Expense_CE_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Card_class(problem,interpretation,element);
	neg find mustInstanceOfDonation_class(problem,interpretation,element);
	neg find mustInstanceOfHealth_and_Pension_Insurance_class(problem,interpretation,element);
	neg find mustInstanceOfFromAgent_class(problem,interpretation,element);
	neg find mustInstanceOfFromLaw_class(problem,interpretation,element);
	neg find mustInstanceOfConstants_class(problem,interpretation,element);
	neg find mustInstanceOfPermanent_Expense_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Property_class(problem,interpretation,element);
	neg find mustInstanceOfLoss_Carryforward_class(problem,interpretation,element);
	neg find mustInstanceOfExternal_Allowance_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_Credit_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Detail_class(problem,interpretation,element);
	neg find mustInstanceOfLegal_Union_Record_class(problem,interpretation,element);
	neg find scopeDisallowsNewPrivate_Insurance_and_Plan_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfPrivate_Insurance_and_Plan_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Health_and_Pension_Insurance class".
 */
private pattern mustInstanceOfHealth_and_Pension_Insurance_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Health_and_Pension_Insurance class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewHealth_and_Pension_Insurance_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Health_and_Pension_Insurance class");
}

/**
 * An element may be an instance of type "Health_and_Pension_Insurance class".
 */
private pattern mayInstanceOfHealth_and_Pension_Insurance_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfTax_Case_class(problem,interpretation,element);
	neg find mustInstanceOfProfessional_Expense_class(problem,interpretation,element);
	neg find mustInstanceOfAddress_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Type_class(problem,interpretation,element);
	neg find mustInstanceOfDS_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_class(problem,interpretation,element);
	neg find mustInstanceOfPhysical_Person_class(problem,interpretation,element);
	neg find mustInstanceOfSpousal_Expense_AC_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_class(problem,interpretation,element);
	neg find mustInstanceOfProfessional_Expenses_Deduction_class(problem,interpretation,element);
	neg find mustInstanceOfInterest_Expense_class(problem,interpretation,element);
	neg find mustInstanceOfExtraordinary_Expense_CE_class(problem,interpretation,element);
	neg find mustInstanceOfPrivate_Insurance_and_Plan_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Card_class(problem,interpretation,element);
	neg find mustInstanceOfDonation_class(problem,interpretation,element);
	neg find mustInstanceOfFromAgent_class(problem,interpretation,element);
	neg find mustInstanceOfFromLaw_class(problem,interpretation,element);
	neg find mustInstanceOfConstants_class(problem,interpretation,element);
	neg find mustInstanceOfPermanent_Expense_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Property_class(problem,interpretation,element);
	neg find mustInstanceOfLoss_Carryforward_class(problem,interpretation,element);
	neg find mustInstanceOfExternal_Allowance_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Detail_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_Credit_class(problem,interpretation,element);
	neg find mustInstanceOfLegal_Union_Record_class(problem,interpretation,element);
	neg find scopeDisallowsNewHealth_and_Pension_Insurance_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfTax_Case_class(problem,interpretation,element);
	neg find mustInstanceOfProfessional_Expense_class(problem,interpretation,element);
	neg find mustInstanceOfAddress_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Type_class(problem,interpretation,element);
	neg find mustInstanceOfDS_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_class(problem,interpretation,element);
	neg find mustInstanceOfPhysical_Person_class(problem,interpretation,element);
	neg find mustInstanceOfSpousal_Expense_AC_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_class(problem,interpretation,element);
	neg find mustInstanceOfProfessional_Expenses_Deduction_class(problem,interpretation,element);
	neg find mustInstanceOfInterest_Expense_class(problem,interpretation,element);
	neg find mustInstanceOfExtraordinary_Expense_CE_class(problem,interpretation,element);
	neg find mustInstanceOfPrivate_Insurance_and_Plan_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Card_class(problem,interpretation,element);
	neg find mustInstanceOfDonation_class(problem,interpretation,element);
	neg find mustInstanceOfFromAgent_class(problem,interpretation,element);
	neg find mustInstanceOfFromLaw_class(problem,interpretation,element);
	neg find mustInstanceOfConstants_class(problem,interpretation,element);
	neg find mustInstanceOfPermanent_Expense_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Property_class(problem,interpretation,element);
	neg find mustInstanceOfLoss_Carryforward_class(problem,interpretation,element);
	neg find mustInstanceOfExternal_Allowance_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Detail_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_Credit_class(problem,interpretation,element);
	neg find mustInstanceOfLegal_Union_Record_class(problem,interpretation,element);
	neg find scopeDisallowsNewHealth_and_Pension_Insurance_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfHealth_and_Pension_Insurance_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Donation class".
 */
private pattern mustInstanceOfDonation_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Donation class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewDonation_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Donation class");
}

/**
 * An element may be an instance of type "Donation class".
 */
private pattern mayInstanceOfDonation_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfTax_Case_class(problem,interpretation,element);
	neg find mustInstanceOfProfessional_Expense_class(problem,interpretation,element);
	neg find mustInstanceOfAddress_class(problem,interpretation,element);
	neg find mustInstanceOfDS_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Type_class(problem,interpretation,element);
	neg find mustInstanceOfPhysical_Person_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_class(problem,interpretation,element);
	neg find mustInstanceOfSpousal_Expense_AC_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_class(problem,interpretation,element);
	neg find mustInstanceOfProfessional_Expenses_Deduction_class(problem,interpretation,element);
	neg find mustInstanceOfInterest_Expense_class(problem,interpretation,element);
	neg find mustInstanceOfExtraordinary_Expense_CE_class(problem,interpretation,element);
	neg find mustInstanceOfPrivate_Insurance_and_Plan_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Card_class(problem,interpretation,element);
	neg find mustInstanceOfHealth_and_Pension_Insurance_class(problem,interpretation,element);
	neg find mustInstanceOfFromAgent_class(problem,interpretation,element);
	neg find mustInstanceOfFromLaw_class(problem,interpretation,element);
	neg find mustInstanceOfConstants_class(problem,interpretation,element);
	neg find mustInstanceOfPermanent_Expense_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Property_class(problem,interpretation,element);
	neg find mustInstanceOfLoss_Carryforward_class(problem,interpretation,element);
	neg find mustInstanceOfExternal_Allowance_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Detail_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_Credit_class(problem,interpretation,element);
	neg find mustInstanceOfLegal_Union_Record_class(problem,interpretation,element);
	neg find scopeDisallowsNewDonation_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfTax_Case_class(problem,interpretation,element);
	neg find mustInstanceOfProfessional_Expense_class(problem,interpretation,element);
	neg find mustInstanceOfAddress_class(problem,interpretation,element);
	neg find mustInstanceOfDS_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Type_class(problem,interpretation,element);
	neg find mustInstanceOfPhysical_Person_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_class(problem,interpretation,element);
	neg find mustInstanceOfSpousal_Expense_AC_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_class(problem,interpretation,element);
	neg find mustInstanceOfProfessional_Expenses_Deduction_class(problem,interpretation,element);
	neg find mustInstanceOfInterest_Expense_class(problem,interpretation,element);
	neg find mustInstanceOfExtraordinary_Expense_CE_class(problem,interpretation,element);
	neg find mustInstanceOfPrivate_Insurance_and_Plan_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Card_class(problem,interpretation,element);
	neg find mustInstanceOfHealth_and_Pension_Insurance_class(problem,interpretation,element);
	neg find mustInstanceOfFromAgent_class(problem,interpretation,element);
	neg find mustInstanceOfFromLaw_class(problem,interpretation,element);
	neg find mustInstanceOfConstants_class(problem,interpretation,element);
	neg find mustInstanceOfPermanent_Expense_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Property_class(problem,interpretation,element);
	neg find mustInstanceOfLoss_Carryforward_class(problem,interpretation,element);
	neg find mustInstanceOfExternal_Allowance_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Detail_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_Credit_class(problem,interpretation,element);
	neg find mustInstanceOfLegal_Union_Record_class(problem,interpretation,element);
	neg find scopeDisallowsNewDonation_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfDonation_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Loss_Carryforward class".
 */
private pattern mustInstanceOfLoss_Carryforward_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Loss_Carryforward class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewLoss_Carryforward_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Loss_Carryforward class");
}

/**
 * An element may be an instance of type "Loss_Carryforward class".
 */
private pattern mayInstanceOfLoss_Carryforward_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfTax_Case_class(problem,interpretation,element);
	neg find mustInstanceOfProfessional_Expense_class(problem,interpretation,element);
	neg find mustInstanceOfAddress_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Type_class(problem,interpretation,element);
	neg find mustInstanceOfDS_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_class(problem,interpretation,element);
	neg find mustInstanceOfPhysical_Person_class(problem,interpretation,element);
	neg find mustInstanceOfSpousal_Expense_AC_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_class(problem,interpretation,element);
	neg find mustInstanceOfProfessional_Expenses_Deduction_class(problem,interpretation,element);
	neg find mustInstanceOfInterest_Expense_class(problem,interpretation,element);
	neg find mustInstanceOfExtraordinary_Expense_CE_class(problem,interpretation,element);
	neg find mustInstanceOfPrivate_Insurance_and_Plan_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Card_class(problem,interpretation,element);
	neg find mustInstanceOfHealth_and_Pension_Insurance_class(problem,interpretation,element);
	neg find mustInstanceOfDonation_class(problem,interpretation,element);
	neg find mustInstanceOfFromAgent_class(problem,interpretation,element);
	neg find mustInstanceOfFromLaw_class(problem,interpretation,element);
	neg find mustInstanceOfConstants_class(problem,interpretation,element);
	neg find mustInstanceOfPermanent_Expense_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Property_class(problem,interpretation,element);
	neg find mustInstanceOfExternal_Allowance_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_Credit_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Detail_class(problem,interpretation,element);
	neg find mustInstanceOfLegal_Union_Record_class(problem,interpretation,element);
	neg find scopeDisallowsNewLoss_Carryforward_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfTax_Case_class(problem,interpretation,element);
	neg find mustInstanceOfProfessional_Expense_class(problem,interpretation,element);
	neg find mustInstanceOfAddress_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Type_class(problem,interpretation,element);
	neg find mustInstanceOfDS_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_class(problem,interpretation,element);
	neg find mustInstanceOfPhysical_Person_class(problem,interpretation,element);
	neg find mustInstanceOfSpousal_Expense_AC_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_class(problem,interpretation,element);
	neg find mustInstanceOfProfessional_Expenses_Deduction_class(problem,interpretation,element);
	neg find mustInstanceOfInterest_Expense_class(problem,interpretation,element);
	neg find mustInstanceOfExtraordinary_Expense_CE_class(problem,interpretation,element);
	neg find mustInstanceOfPrivate_Insurance_and_Plan_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Card_class(problem,interpretation,element);
	neg find mustInstanceOfHealth_and_Pension_Insurance_class(problem,interpretation,element);
	neg find mustInstanceOfDonation_class(problem,interpretation,element);
	neg find mustInstanceOfFromAgent_class(problem,interpretation,element);
	neg find mustInstanceOfFromLaw_class(problem,interpretation,element);
	neg find mustInstanceOfConstants_class(problem,interpretation,element);
	neg find mustInstanceOfPermanent_Expense_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Property_class(problem,interpretation,element);
	neg find mustInstanceOfExternal_Allowance_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_Credit_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Detail_class(problem,interpretation,element);
	neg find mustInstanceOfLegal_Union_Record_class(problem,interpretation,element);
	neg find scopeDisallowsNewLoss_Carryforward_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfLoss_Carryforward_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Spousal_Expense_AC class".
 */
private pattern mustInstanceOfSpousal_Expense_AC_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Spousal_Expense_AC class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewSpousal_Expense_AC_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Spousal_Expense_AC class");
}

/**
 * An element may be an instance of type "Spousal_Expense_AC class".
 */
private pattern mayInstanceOfSpousal_Expense_AC_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFromAgent_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Case_class(problem,interpretation,element);
	neg find mustInstanceOfFromLaw_class(problem,interpretation,element);
	neg find mustInstanceOfProfessional_Expense_class(problem,interpretation,element);
	neg find mustInstanceOfConstants_class(problem,interpretation,element);
	neg find mustInstanceOfAddress_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Type_class(problem,interpretation,element);
	neg find mustInstanceOfDS_class(problem,interpretation,element);
	neg find mustInstanceOfSpecial_Expense_DS_class(problem,interpretation,element);
	neg find mustInstanceOfPhysical_Person_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Property_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_class(problem,interpretation,element);
	neg find mustInstanceOfProfessional_Expenses_Deduction_class(problem,interpretation,element);
	neg find mustInstanceOfExtraordinary_Expense_CE_class(problem,interpretation,element);
	neg find mustInstanceOfExternal_Allowance_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Detail_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_Credit_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Card_class(problem,interpretation,element);
	neg find mustInstanceOfLegal_Union_Record_class(problem,interpretation,element);
	neg find scopeDisallowsNewSpousal_Expense_AC_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFromAgent_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Case_class(problem,interpretation,element);
	neg find mustInstanceOfFromLaw_class(problem,interpretation,element);
	neg find mustInstanceOfProfessional_Expense_class(problem,interpretation,element);
	neg find mustInstanceOfConstants_class(problem,interpretation,element);
	neg find mustInstanceOfAddress_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Type_class(problem,interpretation,element);
	neg find mustInstanceOfDS_class(problem,interpretation,element);
	neg find mustInstanceOfSpecial_Expense_DS_class(problem,interpretation,element);
	neg find mustInstanceOfPhysical_Person_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Property_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_class(problem,interpretation,element);
	neg find mustInstanceOfProfessional_Expenses_Deduction_class(problem,interpretation,element);
	neg find mustInstanceOfExtraordinary_Expense_CE_class(problem,interpretation,element);
	neg find mustInstanceOfExternal_Allowance_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Detail_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_Credit_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Card_class(problem,interpretation,element);
	neg find mustInstanceOfLegal_Union_Record_class(problem,interpretation,element);
	neg find scopeDisallowsNewSpousal_Expense_AC_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfSpousal_Expense_AC_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Extraordinary_Expense_CE class".
 */
private pattern mustInstanceOfExtraordinary_Expense_CE_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Extraordinary_Expense_CE class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewExtraordinary_Expense_CE_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Extraordinary_Expense_CE class");
}

/**
 * An element may be an instance of type "Extraordinary_Expense_CE class".
 */
private pattern mayInstanceOfExtraordinary_Expense_CE_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFromAgent_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Case_class(problem,interpretation,element);
	neg find mustInstanceOfFromLaw_class(problem,interpretation,element);
	neg find mustInstanceOfConstants_class(problem,interpretation,element);
	neg find mustInstanceOfProfessional_Expense_class(problem,interpretation,element);
	neg find mustInstanceOfAddress_class(problem,interpretation,element);
	neg find mustInstanceOfDS_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Type_class(problem,interpretation,element);
	neg find mustInstanceOfSpecial_Expense_DS_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_class(problem,interpretation,element);
	neg find mustInstanceOfPhysical_Person_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Property_class(problem,interpretation,element);
	neg find mustInstanceOfSpousal_Expense_AC_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_class(problem,interpretation,element);
	neg find mustInstanceOfProfessional_Expenses_Deduction_class(problem,interpretation,element);
	neg find mustInstanceOfExternal_Allowance_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_Credit_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Detail_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Card_class(problem,interpretation,element);
	neg find mustInstanceOfLegal_Union_Record_class(problem,interpretation,element);
	neg find scopeDisallowsNewExtraordinary_Expense_CE_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFromAgent_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Case_class(problem,interpretation,element);
	neg find mustInstanceOfFromLaw_class(problem,interpretation,element);
	neg find mustInstanceOfConstants_class(problem,interpretation,element);
	neg find mustInstanceOfProfessional_Expense_class(problem,interpretation,element);
	neg find mustInstanceOfAddress_class(problem,interpretation,element);
	neg find mustInstanceOfDS_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Type_class(problem,interpretation,element);
	neg find mustInstanceOfSpecial_Expense_DS_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_class(problem,interpretation,element);
	neg find mustInstanceOfPhysical_Person_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Property_class(problem,interpretation,element);
	neg find mustInstanceOfSpousal_Expense_AC_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_class(problem,interpretation,element);
	neg find mustInstanceOfProfessional_Expenses_Deduction_class(problem,interpretation,element);
	neg find mustInstanceOfExternal_Allowance_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_Credit_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Detail_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Card_class(problem,interpretation,element);
	neg find mustInstanceOfLegal_Union_Record_class(problem,interpretation,element);
	neg find scopeDisallowsNewExtraordinary_Expense_CE_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfExtraordinary_Expense_CE_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Travel_Expense_FD class".
 */
private pattern mustInstanceOfTravel_Expense_FD_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Travel_Expense_FD class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewTravel_Expense_FD_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Travel_Expense_FD class");
}

/**
 * An element may be an instance of type "Travel_Expense_FD class".
 */
private pattern mayInstanceOfTravel_Expense_FD_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFromAgent_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Case_class(problem,interpretation,element);
	neg find mustInstanceOfFromLaw_class(problem,interpretation,element);
	neg find mustInstanceOfConstants_class(problem,interpretation,element);
	neg find mustInstanceOfAddress_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Type_class(problem,interpretation,element);
	neg find mustInstanceOfDS_class(problem,interpretation,element);
	neg find mustInstanceOfSpecial_Expense_DS_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_class(problem,interpretation,element);
	neg find mustInstanceOfPhysical_Person_class(problem,interpretation,element);
	neg find mustInstanceOfMiscellaneous_Expense_FO_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Property_class(problem,interpretation,element);
	neg find mustInstanceOfSpousal_Expense_AC_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_class(problem,interpretation,element);
	neg find mustInstanceOfProfessional_Expenses_Deduction_class(problem,interpretation,element);
	neg find mustInstanceOfExtraordinary_Expense_CE_class(problem,interpretation,element);
	neg find mustInstanceOfExternal_Allowance_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_Credit_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Detail_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Card_class(problem,interpretation,element);
	neg find mustInstanceOfLegal_Union_Record_class(problem,interpretation,element);
	neg find scopeDisallowsNewTravel_Expense_FD_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFromAgent_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Case_class(problem,interpretation,element);
	neg find mustInstanceOfFromLaw_class(problem,interpretation,element);
	neg find mustInstanceOfConstants_class(problem,interpretation,element);
	neg find mustInstanceOfAddress_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Type_class(problem,interpretation,element);
	neg find mustInstanceOfDS_class(problem,interpretation,element);
	neg find mustInstanceOfSpecial_Expense_DS_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_class(problem,interpretation,element);
	neg find mustInstanceOfPhysical_Person_class(problem,interpretation,element);
	neg find mustInstanceOfMiscellaneous_Expense_FO_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Property_class(problem,interpretation,element);
	neg find mustInstanceOfSpousal_Expense_AC_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_class(problem,interpretation,element);
	neg find mustInstanceOfProfessional_Expenses_Deduction_class(problem,interpretation,element);
	neg find mustInstanceOfExtraordinary_Expense_CE_class(problem,interpretation,element);
	neg find mustInstanceOfExternal_Allowance_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_Credit_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Detail_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Card_class(problem,interpretation,element);
	neg find mustInstanceOfLegal_Union_Record_class(problem,interpretation,element);
	neg find scopeDisallowsNewTravel_Expense_FD_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfTravel_Expense_FD_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Professional_Expense class".
 */
private pattern mustInstanceOfProfessional_Expense_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Professional_Expense class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewProfessional_Expense_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Professional_Expense class");
}

/**
 * An element may be an instance of type "Professional_Expense class".
 */
private pattern mayInstanceOfProfessional_Expense_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFromAgent_class(problem,interpretation,element);
	neg find mustInstanceOfFromLaw_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Case_class(problem,interpretation,element);
	neg find mustInstanceOfConstants_class(problem,interpretation,element);
	neg find mustInstanceOfAddress_class(problem,interpretation,element);
	neg find mustInstanceOfDS_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Type_class(problem,interpretation,element);
	neg find mustInstanceOfSpecial_Expense_DS_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_class(problem,interpretation,element);
	neg find mustInstanceOfPhysical_Person_class(problem,interpretation,element);
	neg find mustInstanceOfMiscellaneous_Expense_FO_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Property_class(problem,interpretation,element);
	neg find mustInstanceOfSpousal_Expense_AC_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_class(problem,interpretation,element);
	neg find mustInstanceOfProfessional_Expenses_Deduction_class(problem,interpretation,element);
	neg find mustInstanceOfExternal_Allowance_class(problem,interpretation,element);
	neg find mustInstanceOfExtraordinary_Expense_CE_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_Credit_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Detail_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Card_class(problem,interpretation,element);
	neg find mustInstanceOfTravel_Expense_FD_class(problem,interpretation,element);
	neg find mustInstanceOfLegal_Union_Record_class(problem,interpretation,element);
	neg find scopeDisallowsNewProfessional_Expense_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFromAgent_class(problem,interpretation,element);
	neg find mustInstanceOfFromLaw_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Case_class(problem,interpretation,element);
	neg find mustInstanceOfConstants_class(problem,interpretation,element);
	neg find mustInstanceOfAddress_class(problem,interpretation,element);
	neg find mustInstanceOfDS_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Type_class(problem,interpretation,element);
	neg find mustInstanceOfSpecial_Expense_DS_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_class(problem,interpretation,element);
	neg find mustInstanceOfPhysical_Person_class(problem,interpretation,element);
	neg find mustInstanceOfMiscellaneous_Expense_FO_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Property_class(problem,interpretation,element);
	neg find mustInstanceOfSpousal_Expense_AC_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_class(problem,interpretation,element);
	neg find mustInstanceOfProfessional_Expenses_Deduction_class(problem,interpretation,element);
	neg find mustInstanceOfExternal_Allowance_class(problem,interpretation,element);
	neg find mustInstanceOfExtraordinary_Expense_CE_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_Credit_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Detail_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Card_class(problem,interpretation,element);
	neg find mustInstanceOfTravel_Expense_FD_class(problem,interpretation,element);
	neg find mustInstanceOfLegal_Union_Record_class(problem,interpretation,element);
	neg find scopeDisallowsNewProfessional_Expense_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfProfessional_Expense_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Miscellaneous_Expense_FO class".
 */
private pattern mustInstanceOfMiscellaneous_Expense_FO_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Miscellaneous_Expense_FO class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewMiscellaneous_Expense_FO_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Miscellaneous_Expense_FO class");
}

/**
 * An element may be an instance of type "Miscellaneous_Expense_FO class".
 */
private pattern mayInstanceOfMiscellaneous_Expense_FO_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFromAgent_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Case_class(problem,interpretation,element);
	neg find mustInstanceOfFromLaw_class(problem,interpretation,element);
	neg find mustInstanceOfConstants_class(problem,interpretation,element);
	neg find mustInstanceOfAddress_class(problem,interpretation,element);
	neg find mustInstanceOfDS_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Type_class(problem,interpretation,element);
	neg find mustInstanceOfSpecial_Expense_DS_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_class(problem,interpretation,element);
	neg find mustInstanceOfPhysical_Person_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Property_class(problem,interpretation,element);
	neg find mustInstanceOfSpousal_Expense_AC_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_class(problem,interpretation,element);
	neg find mustInstanceOfProfessional_Expenses_Deduction_class(problem,interpretation,element);
	neg find mustInstanceOfExternal_Allowance_class(problem,interpretation,element);
	neg find mustInstanceOfExtraordinary_Expense_CE_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_Credit_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Detail_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Card_class(problem,interpretation,element);
	neg find mustInstanceOfTravel_Expense_FD_class(problem,interpretation,element);
	neg find mustInstanceOfLegal_Union_Record_class(problem,interpretation,element);
	neg find scopeDisallowsNewMiscellaneous_Expense_FO_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFromAgent_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Case_class(problem,interpretation,element);
	neg find mustInstanceOfFromLaw_class(problem,interpretation,element);
	neg find mustInstanceOfConstants_class(problem,interpretation,element);
	neg find mustInstanceOfAddress_class(problem,interpretation,element);
	neg find mustInstanceOfDS_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Type_class(problem,interpretation,element);
	neg find mustInstanceOfSpecial_Expense_DS_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_class(problem,interpretation,element);
	neg find mustInstanceOfPhysical_Person_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Property_class(problem,interpretation,element);
	neg find mustInstanceOfSpousal_Expense_AC_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_class(problem,interpretation,element);
	neg find mustInstanceOfProfessional_Expenses_Deduction_class(problem,interpretation,element);
	neg find mustInstanceOfExternal_Allowance_class(problem,interpretation,element);
	neg find mustInstanceOfExtraordinary_Expense_CE_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_Credit_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Detail_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Card_class(problem,interpretation,element);
	neg find mustInstanceOfTravel_Expense_FD_class(problem,interpretation,element);
	neg find mustInstanceOfLegal_Union_Record_class(problem,interpretation,element);
	neg find scopeDisallowsNewMiscellaneous_Expense_FO_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfMiscellaneous_Expense_FO_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Grantor enum".
 */
private pattern mustInstanceOfGrantor_enum(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Grantor enum");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewGrantor_enum(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Grantor enum");
}

/**
 * An element may be an instance of type "Grantor enum".
 */
private pattern mayInstanceOfGrantor_enum(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfGrantor_enum(problem,interpretation,element); }
/**
 * An element must be an instance of type "Disability_Types enum".
 */
private pattern mustInstanceOfDisability_Types_enum(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Disability_Types enum");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewDisability_Types_enum(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Disability_Types enum");
}

/**
 * An element may be an instance of type "Disability_Types enum".
 */
private pattern mayInstanceOfDisability_Types_enum(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfDisability_Types_enum(problem,interpretation,element); }
/**
 * An element must be an instance of type "Country enum".
 */
private pattern mustInstanceOfCountry_enum(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Country enum");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewCountry_enum(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Country enum");
}

/**
 * An element may be an instance of type "Country enum".
 */
private pattern mayInstanceOfCountry_enum(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfCountry_enum(problem,interpretation,element); }
/**
 * An element must be an instance of type "Tax_Card_Type enum".
 */
private pattern mustInstanceOfTax_Card_Type_enum(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Tax_Card_Type enum");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewTax_Card_Type_enum(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Tax_Card_Type enum");
}

/**
 * An element may be an instance of type "Tax_Card_Type enum".
 */
private pattern mayInstanceOfTax_Card_Type_enum(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfTax_Card_Type_enum(problem,interpretation,element); }
/**
 * An element must be an instance of type "Tax_Office enum".
 */
private pattern mustInstanceOfTax_Office_enum(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Tax_Office enum");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewTax_Office_enum(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Tax_Office enum");
}

/**
 * An element may be an instance of type "Tax_Office enum".
 */
private pattern mayInstanceOfTax_Office_enum(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfTax_Office_enum(problem,interpretation,element); }
/**
 * An element must be an instance of type "Tax_Class_Category enum".
 */
private pattern mustInstanceOfTax_Class_Category_enum(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Tax_Class_Category enum");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewTax_Class_Category_enum(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Tax_Class_Category enum");
}

/**
 * An element may be an instance of type "Tax_Class_Category enum".
 */
private pattern mayInstanceOfTax_Class_Category_enum(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfTax_Class_Category_enum(problem,interpretation,element); }
/**
 * An element must be an instance of type "Job_Activity enum".
 */
private pattern mustInstanceOfJob_Activity_enum(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Job_Activity enum");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewJob_Activity_enum(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Job_Activity enum");
}

/**
 * An element may be an instance of type "Job_Activity enum".
 */
private pattern mayInstanceOfJob_Activity_enum(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfJob_Activity_enum(problem,interpretation,element); }
/**
 * An element must be an instance of type "Town enum".
 */
private pattern mustInstanceOfTown_enum(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Town enum");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewTown_enum(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Town enum");
}

/**
 * An element may be an instance of type "Town enum".
 */
private pattern mayInstanceOfTown_enum(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfTown_enum(problem,interpretation,element); }
/**
 * An element must be an instance of type "Type_of_Rate enum".
 */
private pattern mustInstanceOfType_of_Rate_enum(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Type_of_Rate enum");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewType_of_Rate_enum(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Type_of_Rate enum");
}

/**
 * An element may be an instance of type "Type_of_Rate enum".
 */
private pattern mayInstanceOfType_of_Rate_enum(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfType_of_Rate_enum(problem,interpretation,element); }
/**
 * An element must be an instance of type "CE_Type enum".
 */
private pattern mustInstanceOfCE_Type_enum(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"CE_Type enum");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewCE_Type_enum(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"CE_Type enum");
}

/**
 * An element may be an instance of type "CE_Type enum".
 */
private pattern mayInstanceOfCE_Type_enum(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfCE_Type_enum(problem,interpretation,element); }
/**
 * An element must be an instance of type "Expense_Purpose enum".
 */
private pattern mustInstanceOfExpense_Purpose_enum(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Expense_Purpose enum");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewExpense_Purpose_enum(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Expense_Purpose enum");
}

/**
 * An element may be an instance of type "Expense_Purpose enum".
 */
private pattern mayInstanceOfExpense_Purpose_enum(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfExpense_Purpose_enum(problem,interpretation,element); }
/**
 * An element must be an instance of type "Dependent_Type enum".
 */
private pattern mustInstanceOfDependent_Type_enum(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Dependent_Type enum");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewDependent_Type_enum(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Dependent_Type enum");
}

/**
 * An element may be an instance of type "Dependent_Type enum".
 */
private pattern mayInstanceOfDependent_Type_enum(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfDependent_Type_enum(problem,interpretation,element); }
/**
 * An element must be an instance of type "Separation_Causes enum".
 */
private pattern mustInstanceOfSeparation_Causes_enum(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Separation_Causes enum");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewSeparation_Causes_enum(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Separation_Causes enum");
}

/**
 * An element may be an instance of type "Separation_Causes enum".
 */
private pattern mayInstanceOfSeparation_Causes_enum(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfSeparation_Causes_enum(problem,interpretation,element); }
/**
 * An element must be an instance of type "Category_of_Permanent_Expense enum".
 */
private pattern mustInstanceOfCategory_of_Permanent_Expense_enum(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Category_of_Permanent_Expense enum");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewCategory_of_Permanent_Expense_enum(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Category_of_Permanent_Expense enum");
}

/**
 * An element may be an instance of type "Category_of_Permanent_Expense enum".
 */
private pattern mayInstanceOfCategory_of_Permanent_Expense_enum(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfCategory_of_Permanent_Expense_enum(problem,interpretation,element); }
/**
 * An element must be an instance of type "Category_of_Health_and_Pension_Insurances enum".
 */
private pattern mustInstanceOfCategory_of_Health_and_Pension_Insurances_enum(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Category_of_Health_and_Pension_Insurances enum");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewCategory_of_Health_and_Pension_Insurances_enum(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Category_of_Health_and_Pension_Insurances enum");
}

/**
 * An element may be an instance of type "Category_of_Health_and_Pension_Insurances enum".
 */
private pattern mayInstanceOfCategory_of_Health_and_Pension_Insurances_enum(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfCategory_of_Health_and_Pension_Insurances_enum(problem,interpretation,element); }
/**
 * An element must be an instance of type "Category_of_Private_Insurance_and_Plan enum".
 */
private pattern mustInstanceOfCategory_of_Private_Insurance_and_Plan_enum(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Category_of_Private_Insurance_and_Plan enum");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewCategory_of_Private_Insurance_and_Plan_enum(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Category_of_Private_Insurance_and_Plan enum");
}

/**
 * An element may be an instance of type "Category_of_Private_Insurance_and_Plan enum".
 */
private pattern mayInstanceOfCategory_of_Private_Insurance_and_Plan_enum(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfCategory_of_Private_Insurance_and_Plan_enum(problem,interpretation,element); }
/**
 * An element must be an instance of type "Legal_Union_Types enum".
 */
private pattern mustInstanceOfLegal_Union_Types_enum(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Legal_Union_Types enum");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewLegal_Union_Types_enum(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Legal_Union_Types enum");
}

/**
 * An element may be an instance of type "Legal_Union_Types enum".
 */
private pattern mayInstanceOfLegal_Union_Types_enum(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfLegal_Union_Types_enum(problem,interpretation,element); }

//////////
// 1.2 Relation Declaration Indexers
//////////
/**
 * Matcher for detecting tuples t where []taxPayer reference Income_Tax(source,target)
 */
private pattern mustInRelationtaxPayer_reference_Income_Tax(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"taxPayer reference Income_Tax");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>taxPayer reference Income_Tax(source,target)
 */
private pattern mayInRelationtaxPayer_reference_Income_Tax(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfIncome_Tax_class(problem,interpretation,source);
	find mayInstanceOfTax_Payer_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationtaxPayer_reference_Income_Tax(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationtaxPayer_reference_Income_Tax(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []dependents reference Tax_Payer(source,target)
 */
private pattern mustInRelationdependents_reference_Tax_Payer(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"dependents reference Tax_Payer");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>dependents reference Tax_Payer(source,target)
 */
private pattern mayInRelationdependents_reference_Tax_Payer(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfTax_Payer_class(problem,interpretation,source);
	find mayInstanceOfDependent_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationdependents_reference_Tax_Payer(problem,interpretation,source,_);
	check(numberOfExistingReferences < 6);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationresponsible_person_reference_Dependent(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationdependents_reference_Tax_Payer(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []from_agent reference Tax_Payer(source,target)
 */
private pattern mustInRelationfrom_agent_reference_Tax_Payer(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"from_agent reference Tax_Payer");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>from_agent reference Tax_Payer(source,target)
 */
private pattern mayInRelationfrom_agent_reference_Tax_Payer(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfTax_Payer_class(problem,interpretation,source);
	find mayInstanceOfFromAgent_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationfrom_agent_reference_Tax_Payer(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationtaxPayer_reference_FromAgent(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationfrom_agent_reference_Tax_Payer(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []incomes reference Tax_Payer(source,target)
 */
private pattern mustInRelationincomes_reference_Tax_Payer(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"incomes reference Tax_Payer");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>incomes reference Tax_Payer(source,target)
 */
private pattern mayInRelationincomes_reference_Tax_Payer(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfTax_Payer_class(problem,interpretation,source);
	find mayInstanceOfIncome_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationtaxPayer_reference_Income(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationincomes_reference_Tax_Payer(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []from_law reference Tax_Payer(source,target)
 */
private pattern mustInRelationfrom_law_reference_Tax_Payer(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"from_law reference Tax_Payer");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>from_law reference Tax_Payer(source,target)
 */
private pattern mayInRelationfrom_law_reference_Tax_Payer(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfTax_Payer_class(problem,interpretation,source);
	find mayInstanceOfFromLaw_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationfrom_law_reference_Tax_Payer(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationtaxPayer_reference_FromLaw(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationfrom_law_reference_Tax_Payer(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []addresses reference Physical_Person(source,target)
 */
private pattern mustInRelationaddresses_reference_Physical_Person(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"addresses reference Physical_Person");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>addresses reference Physical_Person(source,target)
 */
private pattern mayInRelationaddresses_reference_Physical_Person(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfPhysical_Person_class(problem,interpretation,source);
	find mayInstanceOfAddress_class(problem,interpretation,target);
} or {
	find mustInRelationaddresses_reference_Physical_Person(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []expenses reference Physical_Person(source,target)
 */
private pattern mustInRelationexpenses_reference_Physical_Person(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"expenses reference Physical_Person");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>expenses reference Physical_Person(source,target)
 */
private pattern mayInRelationexpenses_reference_Physical_Person(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfPhysical_Person_class(problem,interpretation,source);
	find mayInstanceOfExpense_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationbeneficiary_reference_Expense(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
} or {
	find mustInRelationexpenses_reference_Physical_Person(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []taxPayer reference Address(source,target)
 */
private pattern mustInRelationtaxPayer_reference_Address(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"taxPayer reference Address");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>taxPayer reference Address(source,target)
 */
private pattern mayInRelationtaxPayer_reference_Address(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfAddress_class(problem,interpretation,source);
	find mayInstanceOfPhysical_Person_class(problem,interpretation,target);
} or {
	find mustInRelationtaxPayer_reference_Address(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []dependent reference Expense(source,target)
 */
private pattern mustInRelationdependent_reference_Expense(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"dependent reference Expense");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>dependent reference Expense(source,target)
 */
private pattern mayInRelationdependent_reference_Expense(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfExpense_class(problem,interpretation,source);
	find mayInstanceOfDependent_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationdependent_reference_Expense(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationdependent_reference_Expense(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []from_agent reference Expense(source,target)
 */
private pattern mustInRelationfrom_agent_reference_Expense(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"from_agent reference Expense");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>from_agent reference Expense(source,target)
 */
private pattern mayInRelationfrom_agent_reference_Expense(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfExpense_class(problem,interpretation,source);
	find mayInstanceOfFromAgent_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationfrom_agent_reference_Expense(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationexpense_reference_FromAgent(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
} or {
	find mustInRelationfrom_agent_reference_Expense(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []income reference Expense(source,target)
 */
private pattern mustInRelationincome_reference_Expense(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"income reference Expense");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>income reference Expense(source,target)
 */
private pattern mayInRelationincome_reference_Expense(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfExpense_class(problem,interpretation,source);
	find mayInstanceOfIncome_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationincome_reference_Expense(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationincome_reference_Expense(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []beneficiary reference Expense(source,target)
 */
private pattern mustInRelationbeneficiary_reference_Expense(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"beneficiary reference Expense");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>beneficiary reference Expense(source,target)
 */
private pattern mayInRelationbeneficiary_reference_Expense(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfExpense_class(problem,interpretation,source);
	find mayInstanceOfPhysical_Person_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationbeneficiary_reference_Expense(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationbeneficiary_reference_Expense(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []responsible_person reference Dependent(source,target)
 */
private pattern mustInRelationresponsible_person_reference_Dependent(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"responsible_person reference Dependent");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>responsible_person reference Dependent(source,target)
 */
private pattern mayInRelationresponsible_person_reference_Dependent(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfDependent_class(problem,interpretation,source);
	find mayInstanceOfTax_Payer_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationresponsible_person_reference_Dependent(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationdependents_reference_Tax_Payer(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 6);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationresponsible_person_reference_Dependent(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []allowances reference Dependent(source,target)
 */
private pattern mustInRelationallowances_reference_Dependent(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"allowances reference Dependent");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>allowances reference Dependent(source,target)
 */
private pattern mayInRelationallowances_reference_Dependent(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfDependent_class(problem,interpretation,source);
	find mayInstanceOfExternal_Allowance_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationallowances_reference_Dependent(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationperson_reference_External_Allowance(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationallowances_reference_Dependent(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []household reference Dependent(source,target)
 */
private pattern mustInRelationhousehold_reference_Dependent(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"household reference Dependent");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>household reference Dependent(source,target)
 */
private pattern mayInRelationhousehold_reference_Dependent(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfDependent_class(problem,interpretation,source);
	find mayInstanceOfHousehold_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationhousehold_reference_Dependent(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationhousehold_reference_Dependent(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []from_agent reference Dependent(source,target)
 */
private pattern mustInRelationfrom_agent_reference_Dependent(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"from_agent reference Dependent");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>from_agent reference Dependent(source,target)
 */
private pattern mayInRelationfrom_agent_reference_Dependent(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfDependent_class(problem,interpretation,source);
	find mayInstanceOfFromAgent_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationfrom_agent_reference_Dependent(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationdependent_reference_FromAgent(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
} or {
	find mustInRelationfrom_agent_reference_Dependent(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []expense reference Dependent(source,target)
 */
private pattern mustInRelationexpense_reference_Dependent(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"expense reference Dependent");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>expense reference Dependent(source,target)
 */
private pattern mayInRelationexpense_reference_Dependent(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfDependent_class(problem,interpretation,source);
	find mayInstanceOfExpense_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationdependent_reference_Expense(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
} or {
	find mustInRelationexpense_reference_Dependent(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []reciver reference External_Allowance(source,target)
 */
private pattern mustInRelationreciver_reference_External_Allowance(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"reciver reference External_Allowance");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>reciver reference External_Allowance(source,target)
 */
private pattern mayInRelationreciver_reference_External_Allowance(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfExternal_Allowance_class(problem,interpretation,source);
	find mayInstanceOfPhysical_Person_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationreciver_reference_External_Allowance(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationreciver_reference_External_Allowance(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []person reference External_Allowance(source,target)
 */
private pattern mustInRelationperson_reference_External_Allowance(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"person reference External_Allowance");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>person reference External_Allowance(source,target)
 */
private pattern mayInRelationperson_reference_External_Allowance(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfExternal_Allowance_class(problem,interpretation,source);
	find mayInstanceOfDependent_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationperson_reference_External_Allowance(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationallowances_reference_Dependent(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationperson_reference_External_Allowance(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []parents reference Household(source,target)
 */
private pattern mustInRelationparents_reference_Household(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"parents reference Household");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>parents reference Household(source,target)
 */
private pattern mayInRelationparents_reference_Household(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfHousehold_class(problem,interpretation,source);
	find mayInstanceOfLegal_Union_Record_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationparents_reference_Household(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationhousehold_reference_Legal_Union_Record(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationparents_reference_Household(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []children reference Household(source,target)
 */
private pattern mustInRelationchildren_reference_Household(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"children reference Household");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>children reference Household(source,target)
 */
private pattern mayInRelationchildren_reference_Household(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfHousehold_class(problem,interpretation,source);
	find mayInstanceOfDependent_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationhousehold_reference_Dependent(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationchildren_reference_Household(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []individual_A reference Legal_Union_Record(source,target)
 */
private pattern mustInRelationindividual_A_reference_Legal_Union_Record(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"individual_A reference Legal_Union_Record");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>individual_A reference Legal_Union_Record(source,target)
 */
private pattern mayInRelationindividual_A_reference_Legal_Union_Record(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfLegal_Union_Record_class(problem,interpretation,source);
	find mayInstanceOfPhysical_Person_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationindividual_A_reference_Legal_Union_Record(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationindividual_A_reference_Legal_Union_Record(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []individual_B reference Legal_Union_Record(source,target)
 */
private pattern mustInRelationindividual_B_reference_Legal_Union_Record(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"individual_B reference Legal_Union_Record");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>individual_B reference Legal_Union_Record(source,target)
 */
private pattern mayInRelationindividual_B_reference_Legal_Union_Record(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfLegal_Union_Record_class(problem,interpretation,source);
	find mayInstanceOfPhysical_Person_class(problem,interpretation,target);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationindividual_B_reference_Legal_Union_Record(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []properties reference Legal_Union_Record(source,target)
 */
private pattern mustInRelationproperties_reference_Legal_Union_Record(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"properties reference Legal_Union_Record");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>properties reference Legal_Union_Record(source,target)
 */
private pattern mayInRelationproperties_reference_Legal_Union_Record(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfLegal_Union_Record_class(problem,interpretation,source);
	find mayInstanceOfTax_Property_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationunion_record_reference_Tax_Property(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationproperties_reference_Legal_Union_Record(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []household reference Legal_Union_Record(source,target)
 */
private pattern mustInRelationhousehold_reference_Legal_Union_Record(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"household reference Legal_Union_Record");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>household reference Legal_Union_Record(source,target)
 */
private pattern mayInRelationhousehold_reference_Legal_Union_Record(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfLegal_Union_Record_class(problem,interpretation,source);
	find mayInstanceOfHousehold_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationhousehold_reference_Legal_Union_Record(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationparents_reference_Household(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationhousehold_reference_Legal_Union_Record(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []union_record reference Tax_Property(source,target)
 */
private pattern mustInRelationunion_record_reference_Tax_Property(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"union_record reference Tax_Property");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>union_record reference Tax_Property(source,target)
 */
private pattern mayInRelationunion_record_reference_Tax_Property(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfTax_Property_class(problem,interpretation,source);
	find mayInstanceOfLegal_Union_Record_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationunion_record_reference_Tax_Property(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationunion_record_reference_Tax_Property(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []taxPayer reference FromAgent(source,target)
 */
private pattern mustInRelationtaxPayer_reference_FromAgent(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"taxPayer reference FromAgent");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>taxPayer reference FromAgent(source,target)
 */
private pattern mayInRelationtaxPayer_reference_FromAgent(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFromAgent_class(problem,interpretation,source);
	find mayInstanceOfTax_Payer_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationtaxPayer_reference_FromAgent(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationfrom_agent_reference_Tax_Payer(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationtaxPayer_reference_FromAgent(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []expense reference FromAgent(source,target)
 */
private pattern mustInRelationexpense_reference_FromAgent(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"expense reference FromAgent");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>expense reference FromAgent(source,target)
 */
private pattern mayInRelationexpense_reference_FromAgent(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFromAgent_class(problem,interpretation,source);
	find mayInstanceOfExpense_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationexpense_reference_FromAgent(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationfrom_agent_reference_Expense(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
} or {
	find mustInRelationexpense_reference_FromAgent(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []dependent reference FromAgent(source,target)
 */
private pattern mustInRelationdependent_reference_FromAgent(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"dependent reference FromAgent");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>dependent reference FromAgent(source,target)
 */
private pattern mayInRelationdependent_reference_FromAgent(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFromAgent_class(problem,interpretation,source);
	find mayInstanceOfDependent_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationdependent_reference_FromAgent(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationfrom_agent_reference_Dependent(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
} or {
	find mustInRelationdependent_reference_FromAgent(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []income_type reference Income(source,target)
 */
private pattern mustInRelationincome_type_reference_Income(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"income_type reference Income");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>income_type reference Income(source,target)
 */
private pattern mayInRelationincome_type_reference_Income(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfIncome_class(problem,interpretation,source);
	find mayInstanceOfIncome_Type_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationincome_type_reference_Income(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationincome_reference_Income_Type(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationincome_type_reference_Income(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []tax_card reference Income(source,target)
 */
private pattern mustInRelationtax_card_reference_Income(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"tax_card reference Income");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>tax_card reference Income(source,target)
 */
private pattern mayInRelationtax_card_reference_Income(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfIncome_class(problem,interpretation,source);
	find mayInstanceOfTax_Card_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationtax_card_reference_Income(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationincome_reference_Tax_Card(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationtax_card_reference_Income(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []taxPayer reference Income(source,target)
 */
private pattern mustInRelationtaxPayer_reference_Income(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"taxPayer reference Income");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>taxPayer reference Income(source,target)
 */
private pattern mayInRelationtaxPayer_reference_Income(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfIncome_class(problem,interpretation,source);
	find mayInstanceOfTax_Payer_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationtaxPayer_reference_Income(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationtaxPayer_reference_Income(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []details reference Income(source,target)
 */
private pattern mustInRelationdetails_reference_Income(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"details reference Income");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>details reference Income(source,target)
 */
private pattern mayInRelationdetails_reference_Income(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfIncome_class(problem,interpretation,source);
	find mayInstanceOfIncome_Detail_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationdetails_reference_Income(problem,interpretation,source,_);
	check(numberOfExistingReferences < 12);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationincome_reference_Income_Detail(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationdetails_reference_Income(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []expenses reference Income(source,target)
 */
private pattern mustInRelationexpenses_reference_Income(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"expenses reference Income");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>expenses reference Income(source,target)
 */
private pattern mayInRelationexpenses_reference_Income(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfIncome_class(problem,interpretation,source);
	find mayInstanceOfExpense_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationincome_reference_Expense(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationexpenses_reference_Income(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []income reference Income_Type(source,target)
 */
private pattern mustInRelationincome_reference_Income_Type(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"income reference Income_Type");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>income reference Income_Type(source,target)
 */
private pattern mayInRelationincome_reference_Income_Type(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfIncome_Type_class(problem,interpretation,source);
	find mayInstanceOfIncome_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationincome_reference_Income_Type(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationincome_type_reference_Income(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationincome_reference_Income_Type(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []tax_payers_address reference Tax_Card(source,target)
 */
private pattern mustInRelationtax_payers_address_reference_Tax_Card(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"tax_payers_address reference Tax_Card");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>tax_payers_address reference Tax_Card(source,target)
 */
private pattern mayInRelationtax_payers_address_reference_Tax_Card(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfTax_Card_class(problem,interpretation,source);
	find mayInstanceOfAddress_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationtax_payers_address_reference_Tax_Card(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationtax_payers_address_reference_Tax_Card(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []income_Tax_Credit reference Tax_Card(source,target)
 */
private pattern mustInRelationincome_Tax_Credit_reference_Tax_Card(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"income_Tax_Credit reference Tax_Card");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>income_Tax_Credit reference Tax_Card(source,target)
 */
private pattern mayInRelationincome_Tax_Credit_reference_Tax_Card(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfTax_Card_class(problem,interpretation,source);
	find mayInstanceOfIncome_Tax_Credit_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationtaxation_Frame_reference_Income_Tax_Credit(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
} or {
	find mustInRelationincome_Tax_Credit_reference_Tax_Card(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []previous reference Tax_Card(source,target)
 */
private pattern mustInRelationprevious_reference_Tax_Card(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"previous reference Tax_Card");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>previous reference Tax_Card(source,target)
 */
private pattern mayInRelationprevious_reference_Tax_Card(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfTax_Card_class(problem,interpretation,source);
	find mayInstanceOfTax_Card_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationprevious_reference_Tax_Card(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationcurrent_tax_card_reference_Tax_Card(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
} or {
	find mustInRelationprevious_reference_Tax_Card(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []current_tax_card reference Tax_Card(source,target)
 */
private pattern mustInRelationcurrent_tax_card_reference_Tax_Card(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"current_tax_card reference Tax_Card");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>current_tax_card reference Tax_Card(source,target)
 */
private pattern mayInRelationcurrent_tax_card_reference_Tax_Card(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfTax_Card_class(problem,interpretation,source);
	find mayInstanceOfTax_Card_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationcurrent_tax_card_reference_Tax_Card(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationprevious_reference_Tax_Card(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
} or {
	find mustInRelationcurrent_tax_card_reference_Tax_Card(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []income reference Tax_Card(source,target)
 */
private pattern mustInRelationincome_reference_Tax_Card(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"income reference Tax_Card");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>income reference Tax_Card(source,target)
 */
private pattern mayInRelationincome_reference_Tax_Card(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfTax_Card_class(problem,interpretation,source);
	find mayInstanceOfIncome_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationincome_reference_Tax_Card(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationtax_card_reference_Income(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationincome_reference_Tax_Card(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []taxPayer reference Income_Tax_Credit(source,target)
 */
private pattern mustInRelationtaxPayer_reference_Income_Tax_Credit(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"taxPayer reference Income_Tax_Credit");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>taxPayer reference Income_Tax_Credit(source,target)
 */
private pattern mayInRelationtaxPayer_reference_Income_Tax_Credit(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfIncome_Tax_Credit_class(problem,interpretation,source);
	find mayInstanceOfTax_Payer_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationtaxPayer_reference_Income_Tax_Credit(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationtaxPayer_reference_Income_Tax_Credit(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []taxation_Frame reference Income_Tax_Credit(source,target)
 */
private pattern mustInRelationtaxation_Frame_reference_Income_Tax_Credit(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"taxation_Frame reference Income_Tax_Credit");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>taxation_Frame reference Income_Tax_Credit(source,target)
 */
private pattern mayInRelationtaxation_Frame_reference_Income_Tax_Credit(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfIncome_Tax_Credit_class(problem,interpretation,source);
	find mayInstanceOfTax_Card_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationtaxation_Frame_reference_Income_Tax_Credit(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationtaxation_Frame_reference_Income_Tax_Credit(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []income reference Income_Detail(source,target)
 */
private pattern mustInRelationincome_reference_Income_Detail(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"income reference Income_Detail");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>income reference Income_Detail(source,target)
 */
private pattern mayInRelationincome_reference_Income_Detail(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfIncome_Detail_class(problem,interpretation,source);
	find mayInstanceOfIncome_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationincome_reference_Income_Detail(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationdetails_reference_Income(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 12);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationincome_reference_Income_Detail(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []taxPayer reference FromLaw(source,target)
 */
private pattern mustInRelationtaxPayer_reference_FromLaw(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"taxPayer reference FromLaw");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>taxPayer reference FromLaw(source,target)
 */
private pattern mayInRelationtaxPayer_reference_FromLaw(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFromLaw_class(problem,interpretation,source);
	find mayInstanceOfTax_Payer_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationtaxPayer_reference_FromLaw(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationfrom_law_reference_Tax_Payer(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationtaxPayer_reference_FromLaw(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []MAXIMUM_CE_RATE_FOR_CHILD_NOT_BEING_PART_OF_HOUSEHOLD attribute Constants(source,target)
 */
private pattern mustInRelationMAXIMUM_CE_RATE_FOR_CHILD_NOT_BEING_PART_OF_HOUSEHOLD_attribute_Constants(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"MAXIMUM_CE_RATE_FOR_CHILD_NOT_BEING_PART_OF_HOUSEHOLD attribute Constants");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>MAXIMUM_CE_RATE_FOR_CHILD_NOT_BEING_PART_OF_HOUSEHOLD attribute Constants(source,target)
 */
private pattern mayInRelationMAXIMUM_CE_RATE_FOR_CHILD_NOT_BEING_PART_OF_HOUSEHOLD_attribute_Constants(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfConstants_class(problem,interpretation,source);
	RealElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationMAXIMUM_CE_RATE_FOR_CHILD_NOT_BEING_PART_OF_HOUSEHOLD_attribute_Constants(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationMAXIMUM_CE_RATE_FOR_CHILD_NOT_BEING_PART_OF_HOUSEHOLD_attribute_Constants(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []MAXIMUM_CE_RATE_FOR_HOUSE_CARE_AND_CHILD_PART_OF_THE_HOUSEHOLD_CARE attribute Constants(source,target)
 */
private pattern mustInRelationMAXIMUM_CE_RATE_FOR_HOUSE_CARE_AND_CHILD_PART_OF_THE_HOUSEHOLD_CARE_attribute_Constants(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"MAXIMUM_CE_RATE_FOR_HOUSE_CARE_AND_CHILD_PART_OF_THE_HOUSEHOLD_CARE attribute Constants");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>MAXIMUM_CE_RATE_FOR_HOUSE_CARE_AND_CHILD_PART_OF_THE_HOUSEHOLD_CARE attribute Constants(source,target)
 */
private pattern mayInRelationMAXIMUM_CE_RATE_FOR_HOUSE_CARE_AND_CHILD_PART_OF_THE_HOUSEHOLD_CARE_attribute_Constants(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfConstants_class(problem,interpretation,source);
	RealElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationMAXIMUM_CE_RATE_FOR_HOUSE_CARE_AND_CHILD_PART_OF_THE_HOUSEHOLD_CARE_attribute_Constants(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationMAXIMUM_CE_RATE_FOR_HOUSE_CARE_AND_CHILD_PART_OF_THE_HOUSEHOLD_CARE_attribute_Constants(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []MINIMUM_SALARY attribute Constants(source,target)
 */
private pattern mustInRelationMINIMUM_SALARY_attribute_Constants(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"MINIMUM_SALARY attribute Constants");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>MINIMUM_SALARY attribute Constants(source,target)
 */
private pattern mayInRelationMINIMUM_SALARY_attribute_Constants(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfConstants_class(problem,interpretation,source);
	RealElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationMINIMUM_SALARY_attribute_Constants(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationMINIMUM_SALARY_attribute_Constants(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []FLAT_RATE_FOR_EXTRA_PROFESSIONAL_DEDUCTION attribute Constants(source,target)
 */
private pattern mustInRelationFLAT_RATE_FOR_EXTRA_PROFESSIONAL_DEDUCTION_attribute_Constants(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"FLAT_RATE_FOR_EXTRA_PROFESSIONAL_DEDUCTION attribute Constants");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>FLAT_RATE_FOR_EXTRA_PROFESSIONAL_DEDUCTION attribute Constants(source,target)
 */
private pattern mayInRelationFLAT_RATE_FOR_EXTRA_PROFESSIONAL_DEDUCTION_attribute_Constants(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfConstants_class(problem,interpretation,source);
	RealElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationFLAT_RATE_FOR_EXTRA_PROFESSIONAL_DEDUCTION_attribute_Constants(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationFLAT_RATE_FOR_EXTRA_PROFESSIONAL_DEDUCTION_attribute_Constants(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []MAXIMUM_DEDUCTIBLE_PERCENTAGE_FOR_DONATIONS attribute Constants(source,target)
 */
private pattern mustInRelationMAXIMUM_DEDUCTIBLE_PERCENTAGE_FOR_DONATIONS_attribute_Constants(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"MAXIMUM_DEDUCTIBLE_PERCENTAGE_FOR_DONATIONS attribute Constants");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>MAXIMUM_DEDUCTIBLE_PERCENTAGE_FOR_DONATIONS attribute Constants(source,target)
 */
private pattern mayInRelationMAXIMUM_DEDUCTIBLE_PERCENTAGE_FOR_DONATIONS_attribute_Constants(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfConstants_class(problem,interpretation,source);
	RealElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationMAXIMUM_DEDUCTIBLE_PERCENTAGE_FOR_DONATIONS_attribute_Constants(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationMAXIMUM_DEDUCTIBLE_PERCENTAGE_FOR_DONATIONS_attribute_Constants(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []MINIMUM_DEDUCTIBLE_AMOUNT_FOR_DONATIONS attribute Constants(source,target)
 */
private pattern mustInRelationMINIMUM_DEDUCTIBLE_AMOUNT_FOR_DONATIONS_attribute_Constants(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"MINIMUM_DEDUCTIBLE_AMOUNT_FOR_DONATIONS attribute Constants");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>MINIMUM_DEDUCTIBLE_AMOUNT_FOR_DONATIONS attribute Constants(source,target)
 */
private pattern mayInRelationMINIMUM_DEDUCTIBLE_AMOUNT_FOR_DONATIONS_attribute_Constants(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfConstants_class(problem,interpretation,source);
	RealElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationMINIMUM_DEDUCTIBLE_AMOUNT_FOR_DONATIONS_attribute_Constants(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationMINIMUM_DEDUCTIBLE_AMOUNT_FOR_DONATIONS_attribute_Constants(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []MAXIMUM_DEDUCTIBLE_AMOUNT_FOR_ADDITIONAL_PENSION_AND_INSURANC attribute Constants(source,target)
 */
private pattern mustInRelationMAXIMUM_DEDUCTIBLE_AMOUNT_FOR_ADDITIONAL_PENSION_AND_INSURANC_attribute_Constants(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"MAXIMUM_DEDUCTIBLE_AMOUNT_FOR_ADDITIONAL_PENSION_AND_INSURANC attribute Constants");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>MAXIMUM_DEDUCTIBLE_AMOUNT_FOR_ADDITIONAL_PENSION_AND_INSURANC attribute Constants(source,target)
 */
private pattern mayInRelationMAXIMUM_DEDUCTIBLE_AMOUNT_FOR_ADDITIONAL_PENSION_AND_INSURANC_attribute_Constants(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfConstants_class(problem,interpretation,source);
	RealElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationMAXIMUM_DEDUCTIBLE_AMOUNT_FOR_ADDITIONAL_PENSION_AND_INSURANC_attribute_Constants(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationMAXIMUM_DEDUCTIBLE_AMOUNT_FOR_ADDITIONAL_PENSION_AND_INSURANC_attribute_Constants(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []MAXIMUM_DEDUCTIBLE_AMOUNT_FOR_ALIMONY_EXPENSE attribute Constants(source,target)
 */
private pattern mustInRelationMAXIMUM_DEDUCTIBLE_AMOUNT_FOR_ALIMONY_EXPENSE_attribute_Constants(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"MAXIMUM_DEDUCTIBLE_AMOUNT_FOR_ALIMONY_EXPENSE attribute Constants");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>MAXIMUM_DEDUCTIBLE_AMOUNT_FOR_ALIMONY_EXPENSE attribute Constants(source,target)
 */
private pattern mayInRelationMAXIMUM_DEDUCTIBLE_AMOUNT_FOR_ALIMONY_EXPENSE_attribute_Constants(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfConstants_class(problem,interpretation,source);
	RealElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationMAXIMUM_DEDUCTIBLE_AMOUNT_FOR_ALIMONY_EXPENSE_attribute_Constants(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationMAXIMUM_DEDUCTIBLE_AMOUNT_FOR_ALIMONY_EXPENSE_attribute_Constants(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []MAXIMAL_DISTANCE_FOR_TRAVEL_EXPENSE_DEDUCTION attribute Constants(source,target)
 */
private pattern mustInRelationMAXIMAL_DISTANCE_FOR_TRAVEL_EXPENSE_DEDUCTION_attribute_Constants(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"MAXIMAL_DISTANCE_FOR_TRAVEL_EXPENSE_DEDUCTION attribute Constants");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>MAXIMAL_DISTANCE_FOR_TRAVEL_EXPENSE_DEDUCTION attribute Constants(source,target)
 */
private pattern mayInRelationMAXIMAL_DISTANCE_FOR_TRAVEL_EXPENSE_DEDUCTION_attribute_Constants(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfConstants_class(problem,interpretation,source);
	RealElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationMAXIMAL_DISTANCE_FOR_TRAVEL_EXPENSE_DEDUCTION_attribute_Constants(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationMAXIMAL_DISTANCE_FOR_TRAVEL_EXPENSE_DEDUCTION_attribute_Constants(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []MAXIMAL_FLAT_DISTANCE_FOR_TRAVEL_EXPENSE_DEDUCTION attribute Constants(source,target)
 */
private pattern mustInRelationMAXIMAL_FLAT_DISTANCE_FOR_TRAVEL_EXPENSE_DEDUCTION_attribute_Constants(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"MAXIMAL_FLAT_DISTANCE_FOR_TRAVEL_EXPENSE_DEDUCTION attribute Constants");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>MAXIMAL_FLAT_DISTANCE_FOR_TRAVEL_EXPENSE_DEDUCTION attribute Constants(source,target)
 */
private pattern mayInRelationMAXIMAL_FLAT_DISTANCE_FOR_TRAVEL_EXPENSE_DEDUCTION_attribute_Constants(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfConstants_class(problem,interpretation,source);
	RealElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationMAXIMAL_FLAT_DISTANCE_FOR_TRAVEL_EXPENSE_DEDUCTION_attribute_Constants(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationMAXIMAL_FLAT_DISTANCE_FOR_TRAVEL_EXPENSE_DEDUCTION_attribute_Constants(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []MINIMAL_DISTANCE_FOR_TRAVEL_EXPENSE_DEDUCTION attribute Constants(source,target)
 */
private pattern mustInRelationMINIMAL_DISTANCE_FOR_TRAVEL_EXPENSE_DEDUCTION_attribute_Constants(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"MINIMAL_DISTANCE_FOR_TRAVEL_EXPENSE_DEDUCTION attribute Constants");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>MINIMAL_DISTANCE_FOR_TRAVEL_EXPENSE_DEDUCTION attribute Constants(source,target)
 */
private pattern mayInRelationMINIMAL_DISTANCE_FOR_TRAVEL_EXPENSE_DEDUCTION_attribute_Constants(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfConstants_class(problem,interpretation,source);
	RealElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationMINIMAL_DISTANCE_FOR_TRAVEL_EXPENSE_DEDUCTION_attribute_Constants(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationMINIMAL_DISTANCE_FOR_TRAVEL_EXPENSE_DEDUCTION_attribute_Constants(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []FLAT_RATE_CIM_DAILY attribute Constants(source,target)
 */
private pattern mustInRelationFLAT_RATE_CIM_DAILY_attribute_Constants(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"FLAT_RATE_CIM_DAILY attribute Constants");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>FLAT_RATE_CIM_DAILY attribute Constants(source,target)
 */
private pattern mayInRelationFLAT_RATE_CIM_DAILY_attribute_Constants(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfConstants_class(problem,interpretation,source);
	RealElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationFLAT_RATE_CIM_DAILY_attribute_Constants(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationFLAT_RATE_CIM_DAILY_attribute_Constants(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []FLAT_RATE_CIM_MONTHLY attribute Constants(source,target)
 */
private pattern mustInRelationFLAT_RATE_CIM_MONTHLY_attribute_Constants(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"FLAT_RATE_CIM_MONTHLY attribute Constants");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>FLAT_RATE_CIM_MONTHLY attribute Constants(source,target)
 */
private pattern mayInRelationFLAT_RATE_CIM_MONTHLY_attribute_Constants(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfConstants_class(problem,interpretation,source);
	RealElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationFLAT_RATE_CIM_MONTHLY_attribute_Constants(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationFLAT_RATE_CIM_MONTHLY_attribute_Constants(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []FLAT_RATE_CIM_YEARLY attribute Constants(source,target)
 */
private pattern mustInRelationFLAT_RATE_CIM_YEARLY_attribute_Constants(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"FLAT_RATE_CIM_YEARLY attribute Constants");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>FLAT_RATE_CIM_YEARLY attribute Constants(source,target)
 */
private pattern mayInRelationFLAT_RATE_CIM_YEARLY_attribute_Constants(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfConstants_class(problem,interpretation,source);
	RealElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationFLAT_RATE_CIM_YEARLY_attribute_Constants(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationFLAT_RATE_CIM_YEARLY_attribute_Constants(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []FLAT_RATE_CIP_DAILY attribute Constants(source,target)
 */
private pattern mustInRelationFLAT_RATE_CIP_DAILY_attribute_Constants(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"FLAT_RATE_CIP_DAILY attribute Constants");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>FLAT_RATE_CIP_DAILY attribute Constants(source,target)
 */
private pattern mayInRelationFLAT_RATE_CIP_DAILY_attribute_Constants(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfConstants_class(problem,interpretation,source);
	RealElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationFLAT_RATE_CIP_DAILY_attribute_Constants(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationFLAT_RATE_CIP_DAILY_attribute_Constants(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []FLAT_RATE_CIP_MONTHLY attribute Constants(source,target)
 */
private pattern mustInRelationFLAT_RATE_CIP_MONTHLY_attribute_Constants(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"FLAT_RATE_CIP_MONTHLY attribute Constants");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>FLAT_RATE_CIP_MONTHLY attribute Constants(source,target)
 */
private pattern mayInRelationFLAT_RATE_CIP_MONTHLY_attribute_Constants(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfConstants_class(problem,interpretation,source);
	RealElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationFLAT_RATE_CIP_MONTHLY_attribute_Constants(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationFLAT_RATE_CIP_MONTHLY_attribute_Constants(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []FLAT_RATE_CIP_YEARLY attribute Constants(source,target)
 */
private pattern mustInRelationFLAT_RATE_CIP_YEARLY_attribute_Constants(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"FLAT_RATE_CIP_YEARLY attribute Constants");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>FLAT_RATE_CIP_YEARLY attribute Constants(source,target)
 */
private pattern mayInRelationFLAT_RATE_CIP_YEARLY_attribute_Constants(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfConstants_class(problem,interpretation,source);
	RealElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationFLAT_RATE_CIP_YEARLY_attribute_Constants(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationFLAT_RATE_CIP_YEARLY_attribute_Constants(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []FLAT_RATE_CIS_DAILY attribute Constants(source,target)
 */
private pattern mustInRelationFLAT_RATE_CIS_DAILY_attribute_Constants(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"FLAT_RATE_CIS_DAILY attribute Constants");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>FLAT_RATE_CIS_DAILY attribute Constants(source,target)
 */
private pattern mayInRelationFLAT_RATE_CIS_DAILY_attribute_Constants(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfConstants_class(problem,interpretation,source);
	RealElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationFLAT_RATE_CIS_DAILY_attribute_Constants(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationFLAT_RATE_CIS_DAILY_attribute_Constants(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []FLAT_RATE_CIS_MONTHLY attribute Constants(source,target)
 */
private pattern mustInRelationFLAT_RATE_CIS_MONTHLY_attribute_Constants(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"FLAT_RATE_CIS_MONTHLY attribute Constants");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>FLAT_RATE_CIS_MONTHLY attribute Constants(source,target)
 */
private pattern mayInRelationFLAT_RATE_CIS_MONTHLY_attribute_Constants(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfConstants_class(problem,interpretation,source);
	RealElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationFLAT_RATE_CIS_MONTHLY_attribute_Constants(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationFLAT_RATE_CIS_MONTHLY_attribute_Constants(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []FLAT_RATE_CIS_YEARLY attribute Constants(source,target)
 */
private pattern mustInRelationFLAT_RATE_CIS_YEARLY_attribute_Constants(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"FLAT_RATE_CIS_YEARLY attribute Constants");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>FLAT_RATE_CIS_YEARLY attribute Constants(source,target)
 */
private pattern mayInRelationFLAT_RATE_CIS_YEARLY_attribute_Constants(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfConstants_class(problem,interpretation,source);
	RealElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationFLAT_RATE_CIS_YEARLY_attribute_Constants(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationFLAT_RATE_CIS_YEARLY_attribute_Constants(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []FLAT_RATE_FOR_TRAVEL_EXPENSE_PER_UNIT attribute Constants(source,target)
 */
private pattern mustInRelationFLAT_RATE_FOR_TRAVEL_EXPENSE_PER_UNIT_attribute_Constants(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"FLAT_RATE_FOR_TRAVEL_EXPENSE_PER_UNIT attribute Constants");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>FLAT_RATE_FOR_TRAVEL_EXPENSE_PER_UNIT attribute Constants(source,target)
 */
private pattern mayInRelationFLAT_RATE_FOR_TRAVEL_EXPENSE_PER_UNIT_attribute_Constants(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfConstants_class(problem,interpretation,source);
	RealElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationFLAT_RATE_FOR_TRAVEL_EXPENSE_PER_UNIT_attribute_Constants(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationFLAT_RATE_FOR_TRAVEL_EXPENSE_PER_UNIT_attribute_Constants(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []MAXIMUM_DEDUCTIBLE_AMOUNT_FOR_DS attribute Constants(source,target)
 */
private pattern mustInRelationMAXIMUM_DEDUCTIBLE_AMOUNT_FOR_DS_attribute_Constants(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"MAXIMUM_DEDUCTIBLE_AMOUNT_FOR_DS attribute Constants");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>MAXIMUM_DEDUCTIBLE_AMOUNT_FOR_DS attribute Constants(source,target)
 */
private pattern mayInRelationMAXIMUM_DEDUCTIBLE_AMOUNT_FOR_DS_attribute_Constants(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfConstants_class(problem,interpretation,source);
	RealElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationMAXIMUM_DEDUCTIBLE_AMOUNT_FOR_DS_attribute_Constants(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationMAXIMUM_DEDUCTIBLE_AMOUNT_FOR_DS_attribute_Constants(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []FLAT_RATE_FOR_MISCELLANEOUS_EXPENSE attribute Constants(source,target)
 */
private pattern mustInRelationFLAT_RATE_FOR_MISCELLANEOUS_EXPENSE_attribute_Constants(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"FLAT_RATE_FOR_MISCELLANEOUS_EXPENSE attribute Constants");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>FLAT_RATE_FOR_MISCELLANEOUS_EXPENSE attribute Constants(source,target)
 */
private pattern mayInRelationFLAT_RATE_FOR_MISCELLANEOUS_EXPENSE_attribute_Constants(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfConstants_class(problem,interpretation,source);
	RealElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationFLAT_RATE_FOR_MISCELLANEOUS_EXPENSE_attribute_Constants(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationFLAT_RATE_FOR_MISCELLANEOUS_EXPENSE_attribute_Constants(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []DISABILITY_FLAT_RATE_FOR_MISCELLANEOUS_EXPENSE attribute Constants(source,target)
 */
private pattern mustInRelationDISABILITY_FLAT_RATE_FOR_MISCELLANEOUS_EXPENSE_attribute_Constants(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"DISABILITY_FLAT_RATE_FOR_MISCELLANEOUS_EXPENSE attribute Constants");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>DISABILITY_FLAT_RATE_FOR_MISCELLANEOUS_EXPENSE attribute Constants(source,target)
 */
private pattern mayInRelationDISABILITY_FLAT_RATE_FOR_MISCELLANEOUS_EXPENSE_attribute_Constants(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfConstants_class(problem,interpretation,source);
	RealElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationDISABILITY_FLAT_RATE_FOR_MISCELLANEOUS_EXPENSE_attribute_Constants(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationDISABILITY_FLAT_RATE_FOR_MISCELLANEOUS_EXPENSE_attribute_Constants(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []MAXIMUM_DEDUCTIBLE_AMOUNT_FOR_ADDITIONAL_PENSION_AND_INSURANCE attribute Constants(source,target)
 */
private pattern mustInRelationMAXIMUM_DEDUCTIBLE_AMOUNT_FOR_ADDITIONAL_PENSION_AND_INSURANCE_attribute_Constants(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"MAXIMUM_DEDUCTIBLE_AMOUNT_FOR_ADDITIONAL_PENSION_AND_INSURANCE attribute Constants");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>MAXIMUM_DEDUCTIBLE_AMOUNT_FOR_ADDITIONAL_PENSION_AND_INSURANCE attribute Constants(source,target)
 */
private pattern mayInRelationMAXIMUM_DEDUCTIBLE_AMOUNT_FOR_ADDITIONAL_PENSION_AND_INSURANCE_attribute_Constants(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfConstants_class(problem,interpretation,source);
	RealElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationMAXIMUM_DEDUCTIBLE_AMOUNT_FOR_ADDITIONAL_PENSION_AND_INSURANCE_attribute_Constants(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationMAXIMUM_DEDUCTIBLE_AMOUNT_FOR_ADDITIONAL_PENSION_AND_INSURANCE_attribute_Constants(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []tax_amount attribute Income_Tax(source,target)
 */
private pattern mustInRelationtax_amount_attribute_Income_Tax(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"tax_amount attribute Income_Tax");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>tax_amount attribute Income_Tax(source,target)
 */
private pattern mayInRelationtax_amount_attribute_Income_Tax(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfIncome_Tax_class(problem,interpretation,source);
	RealElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationtax_amount_attribute_Income_Tax(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationtax_amount_attribute_Income_Tax(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []tax_year attribute Income_Tax(source,target)
 */
private pattern mustInRelationtax_year_attribute_Income_Tax(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"tax_year attribute Income_Tax");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>tax_year attribute Income_Tax(source,target)
 */
private pattern mayInRelationtax_year_attribute_Income_Tax(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfIncome_Tax_class(problem,interpretation,source);
	IntegerElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationtax_year_attribute_Income_Tax(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationtax_year_attribute_Income_Tax(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []id6 attribute Income_Tax(source,target)
 */
private pattern mustInRelationid6_attribute_Income_Tax(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"id6 attribute Income_Tax");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>id6 attribute Income_Tax(source,target)
 */
private pattern mayInRelationid6_attribute_Income_Tax(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfIncome_Tax_class(problem,interpretation,source);
	StringElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationid6_attribute_Income_Tax(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationid6_attribute_Income_Tax(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []taxesDue attribute Tax_Payer(source,target)
 */
private pattern mustInRelationtaxesDue_attribute_Tax_Payer(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"taxesDue attribute Tax_Payer");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>taxesDue attribute Tax_Payer(source,target)
 */
private pattern mayInRelationtaxesDue_attribute_Tax_Payer(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfTax_Payer_class(problem,interpretation,source);
	RealElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationtaxesDue_attribute_Tax_Payer(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationtaxesDue_attribute_Tax_Payer(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []is_assisting_spouse attribute Physical_Person(source,target)
 */
private pattern mustInRelationis_assisting_spouse_attribute_Physical_Person(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"is_assisting_spouse attribute Physical_Person");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>is_assisting_spouse attribute Physical_Person(source,target)
 */
private pattern mayInRelationis_assisting_spouse_attribute_Physical_Person(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfPhysical_Person_class(problem,interpretation,source);
	BooleanElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationis_assisting_spouse_attribute_Physical_Person(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationis_assisting_spouse_attribute_Physical_Person(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []SSNo attribute Physical_Person(source,target)
 */
private pattern mustInRelationSSNo_attribute_Physical_Person(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"SSNo attribute Physical_Person");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>SSNo attribute Physical_Person(source,target)
 */
private pattern mayInRelationSSNo_attribute_Physical_Person(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfPhysical_Person_class(problem,interpretation,source);
	StringElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationSSNo_attribute_Physical_Person(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationSSNo_attribute_Physical_Person(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []birth_year attribute Physical_Person(source,target)
 */
private pattern mustInRelationbirth_year_attribute_Physical_Person(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"birth_year attribute Physical_Person");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>birth_year attribute Physical_Person(source,target)
 */
private pattern mayInRelationbirth_year_attribute_Physical_Person(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfPhysical_Person_class(problem,interpretation,source);
	IntegerElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationbirth_year_attribute_Physical_Person(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationbirth_year_attribute_Physical_Person(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []disability_percentage attribute Physical_Person(source,target)
 */
private pattern mustInRelationdisability_percentage_attribute_Physical_Person(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"disability_percentage attribute Physical_Person");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>disability_percentage attribute Physical_Person(source,target)
 */
private pattern mayInRelationdisability_percentage_attribute_Physical_Person(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfPhysical_Person_class(problem,interpretation,source);
	RealElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationdisability_percentage_attribute_Physical_Person(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationdisability_percentage_attribute_Physical_Person(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []disability_type attribute Physical_Person(source,target)
 */
private pattern mustInRelationdisability_type_attribute_Physical_Person(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"disability_type attribute Physical_Person");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>disability_type attribute Physical_Person(source,target)
 */
private pattern mayInRelationdisability_type_attribute_Physical_Person(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfPhysical_Person_class(problem,interpretation,source);
	find mayInstanceOfDisability_Types_enum(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationdisability_type_attribute_Physical_Person(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationdisability_type_attribute_Physical_Person(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []is_affiliated_personnaly_to_social_security attribute Physical_Person(source,target)
 */
private pattern mustInRelationis_affiliated_personnaly_to_social_security_attribute_Physical_Person(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"is_affiliated_personnaly_to_social_security attribute Physical_Person");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>is_affiliated_personnaly_to_social_security attribute Physical_Person(source,target)
 */
private pattern mayInRelationis_affiliated_personnaly_to_social_security_attribute_Physical_Person(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfPhysical_Person_class(problem,interpretation,source);
	BooleanElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationis_affiliated_personnaly_to_social_security_attribute_Physical_Person(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationis_affiliated_personnaly_to_social_security_attribute_Physical_Person(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []birth_month attribute Physical_Person(source,target)
 */
private pattern mustInRelationbirth_month_attribute_Physical_Person(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"birth_month attribute Physical_Person");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>birth_month attribute Physical_Person(source,target)
 */
private pattern mayInRelationbirth_month_attribute_Physical_Person(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfPhysical_Person_class(problem,interpretation,source);
	IntegerElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationbirth_month_attribute_Physical_Person(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationbirth_month_attribute_Physical_Person(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []birth_day attribute Physical_Person(source,target)
 */
private pattern mustInRelationbirth_day_attribute_Physical_Person(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"birth_day attribute Physical_Person");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>birth_day attribute Physical_Person(source,target)
 */
private pattern mayInRelationbirth_day_attribute_Physical_Person(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfPhysical_Person_class(problem,interpretation,source);
	IntegerElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationbirth_day_attribute_Physical_Person(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationbirth_day_attribute_Physical_Person(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []is_widower attribute Physical_Person(source,target)
 */
private pattern mustInRelationis_widower_attribute_Physical_Person(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"is_widower attribute Physical_Person");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>is_widower attribute Physical_Person(source,target)
 */
private pattern mayInRelationis_widower_attribute_Physical_Person(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfPhysical_Person_class(problem,interpretation,source);
	BooleanElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationis_widower_attribute_Physical_Person(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationis_widower_attribute_Physical_Person(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []country attribute Address(source,target)
 */
private pattern mustInRelationcountry_attribute_Address(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"country attribute Address");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>country attribute Address(source,target)
 */
private pattern mayInRelationcountry_attribute_Address(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfAddress_class(problem,interpretation,source);
	find mayInstanceOfCountry_enum(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationcountry_attribute_Address(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationcountry_attribute_Address(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []street attribute Address(source,target)
 */
private pattern mustInRelationstreet_attribute_Address(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"street attribute Address");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>street attribute Address(source,target)
 */
private pattern mayInRelationstreet_attribute_Address(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfAddress_class(problem,interpretation,source);
	StringElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationstreet_attribute_Address(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationstreet_attribute_Address(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []zipCode attribute Address(source,target)
 */
private pattern mustInRelationzipCode_attribute_Address(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"zipCode attribute Address");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>zipCode attribute Address(source,target)
 */
private pattern mayInRelationzipCode_attribute_Address(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfAddress_class(problem,interpretation,source);
	StringElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationzipCode_attribute_Address(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationzipCode_attribute_Address(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []city attribute Address(source,target)
 */
private pattern mustInRelationcity_attribute_Address(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"city attribute Address");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>city attribute Address(source,target)
 */
private pattern mayInRelationcity_attribute_Address(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfAddress_class(problem,interpretation,source);
	StringElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationcity_attribute_Address(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationcity_attribute_Address(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []id2 attribute Address(source,target)
 */
private pattern mustInRelationid2_attribute_Address(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"id2 attribute Address");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>id2 attribute Address(source,target)
 */
private pattern mayInRelationid2_attribute_Address(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfAddress_class(problem,interpretation,source);
	StringElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationid2_attribute_Address(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationid2_attribute_Address(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []declared_amount attribute Expense(source,target)
 */
private pattern mustInRelationdeclared_amount_attribute_Expense(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"declared_amount attribute Expense");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>declared_amount attribute Expense(source,target)
 */
private pattern mayInRelationdeclared_amount_attribute_Expense(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfExpense_class(problem,interpretation,source);
	RealElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationdeclared_amount_attribute_Expense(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationdeclared_amount_attribute_Expense(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []expense_purpose attribute Expense(source,target)
 */
private pattern mustInRelationexpense_purpose_attribute_Expense(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"expense_purpose attribute Expense");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>expense_purpose attribute Expense(source,target)
 */
private pattern mayInRelationexpense_purpose_attribute_Expense(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfExpense_class(problem,interpretation,source);
	find mayInstanceOfExpense_Purpose_enum(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationexpense_purpose_attribute_Expense(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationexpense_purpose_attribute_Expense(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []id4 attribute Expense(source,target)
 */
private pattern mustInRelationid4_attribute_Expense(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"id4 attribute Expense");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>id4 attribute Expense(source,target)
 */
private pattern mayInRelationid4_attribute_Expense(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfExpense_class(problem,interpretation,source);
	StringElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationid4_attribute_Expense(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationid4_attribute_Expense(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []dependent_type attribute Dependent(source,target)
 */
private pattern mustInRelationdependent_type_attribute_Dependent(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"dependent_type attribute Dependent");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>dependent_type attribute Dependent(source,target)
 */
private pattern mayInRelationdependent_type_attribute_Dependent(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfDependent_class(problem,interpretation,source);
	find mayInstanceOfDependent_Type_enum(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationdependent_type_attribute_Dependent(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationdependent_type_attribute_Dependent(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []continued_studies attribute Dependent(source,target)
 */
private pattern mustInRelationcontinued_studies_attribute_Dependent(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"continued_studies attribute Dependent");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>continued_studies attribute Dependent(source,target)
 */
private pattern mayInRelationcontinued_studies_attribute_Dependent(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfDependent_class(problem,interpretation,source);
	BooleanElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationcontinued_studies_attribute_Dependent(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationcontinued_studies_attribute_Dependent(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []amount attribute External_Allowance(source,target)
 */
private pattern mustInRelationamount_attribute_External_Allowance(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"amount attribute External_Allowance");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>amount attribute External_Allowance(source,target)
 */
private pattern mayInRelationamount_attribute_External_Allowance(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfExternal_Allowance_class(problem,interpretation,source);
	RealElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationamount_attribute_External_Allowance(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationamount_attribute_External_Allowance(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []grantor attribute External_Allowance(source,target)
 */
private pattern mustInRelationgrantor_attribute_External_Allowance(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"grantor attribute External_Allowance");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>grantor attribute External_Allowance(source,target)
 */
private pattern mayInRelationgrantor_attribute_External_Allowance(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfExternal_Allowance_class(problem,interpretation,source);
	find mayInstanceOfGrantor_enum(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationgrantor_attribute_External_Allowance(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationgrantor_attribute_External_Allowance(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []starting_year attribute External_Allowance(source,target)
 */
private pattern mustInRelationstarting_year_attribute_External_Allowance(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"starting_year attribute External_Allowance");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>starting_year attribute External_Allowance(source,target)
 */
private pattern mayInRelationstarting_year_attribute_External_Allowance(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfExternal_Allowance_class(problem,interpretation,source);
	IntegerElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationstarting_year_attribute_External_Allowance(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationstarting_year_attribute_External_Allowance(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []ending_year attribute External_Allowance(source,target)
 */
private pattern mustInRelationending_year_attribute_External_Allowance(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"ending_year attribute External_Allowance");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>ending_year attribute External_Allowance(source,target)
 */
private pattern mayInRelationending_year_attribute_External_Allowance(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfExternal_Allowance_class(problem,interpretation,source);
	IntegerElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationending_year_attribute_External_Allowance(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationending_year_attribute_External_Allowance(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []id5 attribute External_Allowance(source,target)
 */
private pattern mustInRelationid5_attribute_External_Allowance(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"id5 attribute External_Allowance");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>id5 attribute External_Allowance(source,target)
 */
private pattern mayInRelationid5_attribute_External_Allowance(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfExternal_Allowance_class(problem,interpretation,source);
	StringElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationid5_attribute_External_Allowance(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationid5_attribute_External_Allowance(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []id1 attribute Household(source,target)
 */
private pattern mustInRelationid1_attribute_Household(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"id1 attribute Household");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>id1 attribute Household(source,target)
 */
private pattern mayInRelationid1_attribute_Household(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfHousehold_class(problem,interpretation,source);
	StringElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationid1_attribute_Household(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationid1_attribute_Household(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []start_year attribute Legal_Union_Record(source,target)
 */
private pattern mustInRelationstart_year_attribute_Legal_Union_Record(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"start_year attribute Legal_Union_Record");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>start_year attribute Legal_Union_Record(source,target)
 */
private pattern mayInRelationstart_year_attribute_Legal_Union_Record(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfLegal_Union_Record_class(problem,interpretation,source);
	IntegerElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationstart_year_attribute_Legal_Union_Record(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationstart_year_attribute_Legal_Union_Record(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []end_year attribute Legal_Union_Record(source,target)
 */
private pattern mustInRelationend_year_attribute_Legal_Union_Record(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"end_year attribute Legal_Union_Record");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>end_year attribute Legal_Union_Record(source,target)
 */
private pattern mayInRelationend_year_attribute_Legal_Union_Record(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfLegal_Union_Record_class(problem,interpretation,source);
	IntegerElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationend_year_attribute_Legal_Union_Record(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationend_year_attribute_Legal_Union_Record(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []separation_cause attribute Legal_Union_Record(source,target)
 */
private pattern mustInRelationseparation_cause_attribute_Legal_Union_Record(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"separation_cause attribute Legal_Union_Record");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>separation_cause attribute Legal_Union_Record(source,target)
 */
private pattern mayInRelationseparation_cause_attribute_Legal_Union_Record(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfLegal_Union_Record_class(problem,interpretation,source);
	find mayInstanceOfSeparation_Causes_enum(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationseparation_cause_attribute_Legal_Union_Record(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationseparation_cause_attribute_Legal_Union_Record(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []mutual_agreement attribute Legal_Union_Record(source,target)
 */
private pattern mustInRelationmutual_agreement_attribute_Legal_Union_Record(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"mutual_agreement attribute Legal_Union_Record");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>mutual_agreement attribute Legal_Union_Record(source,target)
 */
private pattern mayInRelationmutual_agreement_attribute_Legal_Union_Record(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfLegal_Union_Record_class(problem,interpretation,source);
	BooleanElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationmutual_agreement_attribute_Legal_Union_Record(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationmutual_agreement_attribute_Legal_Union_Record(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []id9 attribute Legal_Union_Record(source,target)
 */
private pattern mustInRelationid9_attribute_Legal_Union_Record(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"id9 attribute Legal_Union_Record");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>id9 attribute Legal_Union_Record(source,target)
 */
private pattern mayInRelationid9_attribute_Legal_Union_Record(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfLegal_Union_Record_class(problem,interpretation,source);
	StringElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationid9_attribute_Legal_Union_Record(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationid9_attribute_Legal_Union_Record(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []starting_year attribute Tax_Property(source,target)
 */
private pattern mustInRelationstarting_year_attribute_Tax_Property(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"starting_year attribute Tax_Property");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>starting_year attribute Tax_Property(source,target)
 */
private pattern mayInRelationstarting_year_attribute_Tax_Property(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfTax_Property_class(problem,interpretation,source);
	IntegerElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationstarting_year_attribute_Tax_Property(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationstarting_year_attribute_Tax_Property(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []id10 attribute Tax_Property(source,target)
 */
private pattern mustInRelationid10_attribute_Tax_Property(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"id10 attribute Tax_Property");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>id10 attribute Tax_Property(source,target)
 */
private pattern mayInRelationid10_attribute_Tax_Property(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfTax_Property_class(problem,interpretation,source);
	StringElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationid10_attribute_Tax_Property(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationid10_attribute_Tax_Property(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []is_dependent_eligible_for_CE_Not_In_Houshold_Children_Care attribute FromAgent(source,target)
 */
private pattern mustInRelationis_dependent_eligible_for_CE_Not_In_Houshold_Children_Care_attribute_FromAgent(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"is_dependent_eligible_for_CE_Not_In_Houshold_Children_Care attribute FromAgent");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>is_dependent_eligible_for_CE_Not_In_Houshold_Children_Care attribute FromAgent(source,target)
 */
private pattern mayInRelationis_dependent_eligible_for_CE_Not_In_Houshold_Children_Care_attribute_FromAgent(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFromAgent_class(problem,interpretation,source);
	BooleanElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationis_dependent_eligible_for_CE_Not_In_Houshold_Children_Care_attribute_FromAgent(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationis_dependent_eligible_for_CE_Not_In_Houshold_Children_Care_attribute_FromAgent(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []is_eligible_debt attribute FromAgent(source,target)
 */
private pattern mustInRelationis_eligible_debt_attribute_FromAgent(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"is_eligible_debt attribute FromAgent");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>is_eligible_debt attribute FromAgent(source,target)
 */
private pattern mayInRelationis_eligible_debt_attribute_FromAgent(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFromAgent_class(problem,interpretation,source);
	BooleanElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationis_eligible_debt_attribute_FromAgent(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationis_eligible_debt_attribute_FromAgent(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []income_amount attribute Income(source,target)
 */
private pattern mustInRelationincome_amount_attribute_Income(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"income_amount attribute Income");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>income_amount attribute Income(source,target)
 */
private pattern mayInRelationincome_amount_attribute_Income(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfIncome_class(problem,interpretation,source);
	RealElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationincome_amount_attribute_Income(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationincome_amount_attribute_Income(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []tax_liability attribute Income(source,target)
 */
private pattern mustInRelationtax_liability_attribute_Income(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"tax_liability attribute Income");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>tax_liability attribute Income(source,target)
 */
private pattern mayInRelationtax_liability_attribute_Income(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfIncome_class(problem,interpretation,source);
	RealElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationtax_liability_attribute_Income(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationtax_liability_attribute_Income(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []num attribute Income(source,target)
 */
private pattern mustInRelationnum_attribute_Income(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"num attribute Income");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>num attribute Income(source,target)
 */
private pattern mayInRelationnum_attribute_Income(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfIncome_class(problem,interpretation,source);
	IntegerElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationnum_attribute_Income(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationnum_attribute_Income(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []subjectToWithholdingTax attribute Income_Type(source,target)
 */
private pattern mustInRelationsubjectToWithholdingTax_attribute_Income_Type(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"subjectToWithholdingTax attribute Income_Type");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>subjectToWithholdingTax attribute Income_Type(source,target)
 */
private pattern mayInRelationsubjectToWithholdingTax_attribute_Income_Type(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfIncome_Type_class(problem,interpretation,source);
	BooleanElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationsubjectToWithholdingTax_attribute_Income_Type(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationsubjectToWithholdingTax_attribute_Income_Type(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []id8 attribute Income_Type(source,target)
 */
private pattern mustInRelationid8_attribute_Income_Type(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"id8 attribute Income_Type");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>id8 attribute Income_Type(source,target)
 */
private pattern mayInRelationid8_attribute_Income_Type(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfIncome_Type_class(problem,interpretation,source);
	StringElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationid8_attribute_Income_Type(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationid8_attribute_Income_Type(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []card_identifier attribute Tax_Card(source,target)
 */
private pattern mustInRelationcard_identifier_attribute_Tax_Card(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"card_identifier attribute Tax_Card");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>card_identifier attribute Tax_Card(source,target)
 */
private pattern mayInRelationcard_identifier_attribute_Tax_Card(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfTax_Card_class(problem,interpretation,source);
	StringElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationcard_identifier_attribute_Tax_Card(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationcard_identifier_attribute_Tax_Card(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []tax_card_type attribute Tax_Card(source,target)
 */
private pattern mustInRelationtax_card_type_attribute_Tax_Card(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"tax_card_type attribute Tax_Card");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>tax_card_type attribute Tax_Card(source,target)
 */
private pattern mayInRelationtax_card_type_attribute_Tax_Card(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfTax_Card_class(problem,interpretation,source);
	find mayInstanceOfTax_Card_Type_enum(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationtax_card_type_attribute_Tax_Card(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationtax_card_type_attribute_Tax_Card(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []tax_office attribute Tax_Card(source,target)
 */
private pattern mustInRelationtax_office_attribute_Tax_Card(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"tax_office attribute Tax_Card");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>tax_office attribute Tax_Card(source,target)
 */
private pattern mayInRelationtax_office_attribute_Tax_Card(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfTax_Card_class(problem,interpretation,source);
	find mayInstanceOfTax_Office_enum(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationtax_office_attribute_Tax_Card(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationtax_office_attribute_Tax_Card(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []percentage_of_witholding attribute Tax_Card(source,target)
 */
private pattern mustInRelationpercentage_of_witholding_attribute_Tax_Card(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"percentage_of_witholding attribute Tax_Card");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>percentage_of_witholding attribute Tax_Card(source,target)
 */
private pattern mayInRelationpercentage_of_witholding_attribute_Tax_Card(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfTax_Card_class(problem,interpretation,source);
	RealElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationpercentage_of_witholding_attribute_Tax_Card(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationpercentage_of_witholding_attribute_Tax_Card(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []tax_payers_name_surname attribute Tax_Card(source,target)
 */
private pattern mustInRelationtax_payers_name_surname_attribute_Tax_Card(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"tax_payers_name_surname attribute Tax_Card");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>tax_payers_name_surname attribute Tax_Card(source,target)
 */
private pattern mayInRelationtax_payers_name_surname_attribute_Tax_Card(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfTax_Card_class(problem,interpretation,source);
	StringElement(target);
} or {
	find mustInRelationtax_payers_name_surname_attribute_Tax_Card(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []tax_payers_partner_name_surname attribute Tax_Card(source,target)
 */
private pattern mustInRelationtax_payers_partner_name_surname_attribute_Tax_Card(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"tax_payers_partner_name_surname attribute Tax_Card");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>tax_payers_partner_name_surname attribute Tax_Card(source,target)
 */
private pattern mayInRelationtax_payers_partner_name_surname_attribute_Tax_Card(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfTax_Card_class(problem,interpretation,source);
	StringElement(target);
} or {
	find mustInRelationtax_payers_partner_name_surname_attribute_Tax_Card(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []jobs_Employer_SSNo attribute Tax_Card(source,target)
 */
private pattern mustInRelationjobs_Employer_SSNo_attribute_Tax_Card(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"jobs_Employer_SSNo attribute Tax_Card");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>jobs_Employer_SSNo attribute Tax_Card(source,target)
 */
private pattern mayInRelationjobs_Employer_SSNo_attribute_Tax_Card(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfTax_Card_class(problem,interpretation,source);
	StringElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationjobs_Employer_SSNo_attribute_Tax_Card(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationjobs_Employer_SSNo_attribute_Tax_Card(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []jobs_employers_name attribute Tax_Card(source,target)
 */
private pattern mustInRelationjobs_employers_name_attribute_Tax_Card(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"jobs_employers_name attribute Tax_Card");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>jobs_employers_name attribute Tax_Card(source,target)
 */
private pattern mayInRelationjobs_employers_name_attribute_Tax_Card(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfTax_Card_class(problem,interpretation,source);
	StringElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationjobs_employers_name_attribute_Tax_Card(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationjobs_employers_name_attribute_Tax_Card(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []jobs_activity_type attribute Tax_Card(source,target)
 */
private pattern mustInRelationjobs_activity_type_attribute_Tax_Card(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"jobs_activity_type attribute Tax_Card");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>jobs_activity_type attribute Tax_Card(source,target)
 */
private pattern mayInRelationjobs_activity_type_attribute_Tax_Card(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfTax_Card_class(problem,interpretation,source);
	find mayInstanceOfJob_Activity_enum(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationjobs_activity_type_attribute_Tax_Card(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationjobs_activity_type_attribute_Tax_Card(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []jobs_place_of_work attribute Tax_Card(source,target)
 */
private pattern mustInRelationjobs_place_of_work_attribute_Tax_Card(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"jobs_place_of_work attribute Tax_Card");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>jobs_place_of_work attribute Tax_Card(source,target)
 */
private pattern mayInRelationjobs_place_of_work_attribute_Tax_Card(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfTax_Card_class(problem,interpretation,source);
	find mayInstanceOfTown_enum(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationjobs_place_of_work_attribute_Tax_Card(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationjobs_place_of_work_attribute_Tax_Card(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []deduction_FD_daily attribute Tax_Card(source,target)
 */
private pattern mustInRelationdeduction_FD_daily_attribute_Tax_Card(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"deduction_FD_daily attribute Tax_Card");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>deduction_FD_daily attribute Tax_Card(source,target)
 */
private pattern mayInRelationdeduction_FD_daily_attribute_Tax_Card(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfTax_Card_class(problem,interpretation,source);
	RealElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationdeduction_FD_daily_attribute_Tax_Card(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationdeduction_FD_daily_attribute_Tax_Card(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []deduction_FD_monthly attribute Tax_Card(source,target)
 */
private pattern mustInRelationdeduction_FD_monthly_attribute_Tax_Card(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"deduction_FD_monthly attribute Tax_Card");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>deduction_FD_monthly attribute Tax_Card(source,target)
 */
private pattern mayInRelationdeduction_FD_monthly_attribute_Tax_Card(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfTax_Card_class(problem,interpretation,source);
	RealElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationdeduction_FD_monthly_attribute_Tax_Card(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationdeduction_FD_monthly_attribute_Tax_Card(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []deduction_AC_daily attribute Tax_Card(source,target)
 */
private pattern mustInRelationdeduction_AC_daily_attribute_Tax_Card(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"deduction_AC_daily attribute Tax_Card");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>deduction_AC_daily attribute Tax_Card(source,target)
 */
private pattern mayInRelationdeduction_AC_daily_attribute_Tax_Card(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfTax_Card_class(problem,interpretation,source);
	RealElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationdeduction_AC_daily_attribute_Tax_Card(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationdeduction_AC_daily_attribute_Tax_Card(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []deduction_AC_monthly attribute Tax_Card(source,target)
 */
private pattern mustInRelationdeduction_AC_monthly_attribute_Tax_Card(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"deduction_AC_monthly attribute Tax_Card");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>deduction_AC_monthly attribute Tax_Card(source,target)
 */
private pattern mayInRelationdeduction_AC_monthly_attribute_Tax_Card(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfTax_Card_class(problem,interpretation,source);
	RealElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationdeduction_AC_monthly_attribute_Tax_Card(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationdeduction_AC_monthly_attribute_Tax_Card(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []deduction_AC_yearly attribute Tax_Card(source,target)
 */
private pattern mustInRelationdeduction_AC_yearly_attribute_Tax_Card(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"deduction_AC_yearly attribute Tax_Card");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>deduction_AC_yearly attribute Tax_Card(source,target)
 */
private pattern mayInRelationdeduction_AC_yearly_attribute_Tax_Card(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfTax_Card_class(problem,interpretation,source);
	RealElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationdeduction_AC_yearly_attribute_Tax_Card(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationdeduction_AC_yearly_attribute_Tax_Card(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []deduction_CE_daily attribute Tax_Card(source,target)
 */
private pattern mustInRelationdeduction_CE_daily_attribute_Tax_Card(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"deduction_CE_daily attribute Tax_Card");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>deduction_CE_daily attribute Tax_Card(source,target)
 */
private pattern mayInRelationdeduction_CE_daily_attribute_Tax_Card(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfTax_Card_class(problem,interpretation,source);
	RealElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationdeduction_CE_daily_attribute_Tax_Card(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationdeduction_CE_daily_attribute_Tax_Card(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []deduction_CE_monthly attribute Tax_Card(source,target)
 */
private pattern mustInRelationdeduction_CE_monthly_attribute_Tax_Card(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"deduction_CE_monthly attribute Tax_Card");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>deduction_CE_monthly attribute Tax_Card(source,target)
 */
private pattern mayInRelationdeduction_CE_monthly_attribute_Tax_Card(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfTax_Card_class(problem,interpretation,source);
	RealElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationdeduction_CE_monthly_attribute_Tax_Card(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationdeduction_CE_monthly_attribute_Tax_Card(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []deduction_CE_yearly attribute Tax_Card(source,target)
 */
private pattern mustInRelationdeduction_CE_yearly_attribute_Tax_Card(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"deduction_CE_yearly attribute Tax_Card");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>deduction_CE_yearly attribute Tax_Card(source,target)
 */
private pattern mayInRelationdeduction_CE_yearly_attribute_Tax_Card(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfTax_Card_class(problem,interpretation,source);
	RealElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationdeduction_CE_yearly_attribute_Tax_Card(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationdeduction_CE_yearly_attribute_Tax_Card(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []deduction_DS_daily attribute Tax_Card(source,target)
 */
private pattern mustInRelationdeduction_DS_daily_attribute_Tax_Card(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"deduction_DS_daily attribute Tax_Card");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>deduction_DS_daily attribute Tax_Card(source,target)
 */
private pattern mayInRelationdeduction_DS_daily_attribute_Tax_Card(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfTax_Card_class(problem,interpretation,source);
	RealElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationdeduction_DS_daily_attribute_Tax_Card(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationdeduction_DS_daily_attribute_Tax_Card(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []deduction_DS_monthly attribute Tax_Card(source,target)
 */
private pattern mustInRelationdeduction_DS_monthly_attribute_Tax_Card(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"deduction_DS_monthly attribute Tax_Card");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>deduction_DS_monthly attribute Tax_Card(source,target)
 */
private pattern mayInRelationdeduction_DS_monthly_attribute_Tax_Card(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfTax_Card_class(problem,interpretation,source);
	RealElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationdeduction_DS_monthly_attribute_Tax_Card(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationdeduction_DS_monthly_attribute_Tax_Card(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []deduction_FO_daily attribute Tax_Card(source,target)
 */
private pattern mustInRelationdeduction_FO_daily_attribute_Tax_Card(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"deduction_FO_daily attribute Tax_Card");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>deduction_FO_daily attribute Tax_Card(source,target)
 */
private pattern mayInRelationdeduction_FO_daily_attribute_Tax_Card(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfTax_Card_class(problem,interpretation,source);
	RealElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationdeduction_FO_daily_attribute_Tax_Card(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationdeduction_FO_daily_attribute_Tax_Card(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []deduction_FO_monthly attribute Tax_Card(source,target)
 */
private pattern mustInRelationdeduction_FO_monthly_attribute_Tax_Card(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"deduction_FO_monthly attribute Tax_Card");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>deduction_FO_monthly attribute Tax_Card(source,target)
 */
private pattern mayInRelationdeduction_FO_monthly_attribute_Tax_Card(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfTax_Card_class(problem,interpretation,source);
	RealElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationdeduction_FO_monthly_attribute_Tax_Card(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationdeduction_FO_monthly_attribute_Tax_Card(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []deduction_FO_yearly attribute Tax_Card(source,target)
 */
private pattern mustInRelationdeduction_FO_yearly_attribute_Tax_Card(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"deduction_FO_yearly attribute Tax_Card");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>deduction_FO_yearly attribute Tax_Card(source,target)
 */
private pattern mayInRelationdeduction_FO_yearly_attribute_Tax_Card(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfTax_Card_class(problem,interpretation,source);
	RealElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationdeduction_FO_yearly_attribute_Tax_Card(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationdeduction_FO_yearly_attribute_Tax_Card(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []credit_CIS_daily attribute Tax_Card(source,target)
 */
private pattern mustInRelationcredit_CIS_daily_attribute_Tax_Card(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"credit_CIS_daily attribute Tax_Card");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>credit_CIS_daily attribute Tax_Card(source,target)
 */
private pattern mayInRelationcredit_CIS_daily_attribute_Tax_Card(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfTax_Card_class(problem,interpretation,source);
	RealElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationcredit_CIS_daily_attribute_Tax_Card(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationcredit_CIS_daily_attribute_Tax_Card(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []credit_CIS_monthly attribute Tax_Card(source,target)
 */
private pattern mustInRelationcredit_CIS_monthly_attribute_Tax_Card(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"credit_CIS_monthly attribute Tax_Card");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>credit_CIS_monthly attribute Tax_Card(source,target)
 */
private pattern mayInRelationcredit_CIS_monthly_attribute_Tax_Card(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfTax_Card_class(problem,interpretation,source);
	RealElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationcredit_CIS_monthly_attribute_Tax_Card(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationcredit_CIS_monthly_attribute_Tax_Card(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []credit_CIM_daily attribute Tax_Card(source,target)
 */
private pattern mustInRelationcredit_CIM_daily_attribute_Tax_Card(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"credit_CIM_daily attribute Tax_Card");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>credit_CIM_daily attribute Tax_Card(source,target)
 */
private pattern mayInRelationcredit_CIM_daily_attribute_Tax_Card(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfTax_Card_class(problem,interpretation,source);
	RealElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationcredit_CIM_daily_attribute_Tax_Card(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationcredit_CIM_daily_attribute_Tax_Card(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []validity attribute Tax_Card(source,target)
 */
private pattern mustInRelationvalidity_attribute_Tax_Card(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"validity attribute Tax_Card");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>validity attribute Tax_Card(source,target)
 */
private pattern mayInRelationvalidity_attribute_Tax_Card(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfTax_Card_class(problem,interpretation,source);
	BooleanElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationvalidity_attribute_Tax_Card(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationvalidity_attribute_Tax_Card(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []credit_CIM_yearly attribute Tax_Card(source,target)
 */
private pattern mustInRelationcredit_CIM_yearly_attribute_Tax_Card(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"credit_CIM_yearly attribute Tax_Card");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>credit_CIM_yearly attribute Tax_Card(source,target)
 */
private pattern mayInRelationcredit_CIM_yearly_attribute_Tax_Card(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfTax_Card_class(problem,interpretation,source);
	RealElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationcredit_CIM_yearly_attribute_Tax_Card(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationcredit_CIM_yearly_attribute_Tax_Card(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []deduction_DS_Alimony_yearly attribute Tax_Card(source,target)
 */
private pattern mustInRelationdeduction_DS_Alimony_yearly_attribute_Tax_Card(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"deduction_DS_Alimony_yearly attribute Tax_Card");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>deduction_DS_Alimony_yearly attribute Tax_Card(source,target)
 */
private pattern mayInRelationdeduction_DS_Alimony_yearly_attribute_Tax_Card(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfTax_Card_class(problem,interpretation,source);
	RealElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationdeduction_DS_Alimony_yearly_attribute_Tax_Card(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationdeduction_DS_Alimony_yearly_attribute_Tax_Card(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []deduction_DS_Debt_yearly attribute Tax_Card(source,target)
 */
private pattern mustInRelationdeduction_DS_Debt_yearly_attribute_Tax_Card(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"deduction_DS_Debt_yearly attribute Tax_Card");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>deduction_DS_Debt_yearly attribute Tax_Card(source,target)
 */
private pattern mayInRelationdeduction_DS_Debt_yearly_attribute_Tax_Card(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfTax_Card_class(problem,interpretation,source);
	RealElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationdeduction_DS_Debt_yearly_attribute_Tax_Card(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationdeduction_DS_Debt_yearly_attribute_Tax_Card(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []grantedBy attribute Income_Tax_Credit(source,target)
 */
private pattern mustInRelationgrantedBy_attribute_Income_Tax_Credit(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"grantedBy attribute Income_Tax_Credit");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>grantedBy attribute Income_Tax_Credit(source,target)
 */
private pattern mayInRelationgrantedBy_attribute_Income_Tax_Credit(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfIncome_Tax_Credit_class(problem,interpretation,source);
	find mayInstanceOfGrantor_enum(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationgrantedBy_attribute_Income_Tax_Credit(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationgrantedBy_attribute_Income_Tax_Credit(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []tax_year attribute Income_Tax_Credit(source,target)
 */
private pattern mustInRelationtax_year_attribute_Income_Tax_Credit(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"tax_year attribute Income_Tax_Credit");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>tax_year attribute Income_Tax_Credit(source,target)
 */
private pattern mayInRelationtax_year_attribute_Income_Tax_Credit(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfIncome_Tax_Credit_class(problem,interpretation,source);
	IntegerElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationtax_year_attribute_Income_Tax_Credit(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationtax_year_attribute_Income_Tax_Credit(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []yearly attribute Income_Tax_Credit(source,target)
 */
private pattern mustInRelationyearly_attribute_Income_Tax_Credit(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"yearly attribute Income_Tax_Credit");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>yearly attribute Income_Tax_Credit(source,target)
 */
private pattern mayInRelationyearly_attribute_Income_Tax_Credit(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfIncome_Tax_Credit_class(problem,interpretation,source);
	RealElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationyearly_attribute_Income_Tax_Credit(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationyearly_attribute_Income_Tax_Credit(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []monthly attribute Income_Tax_Credit(source,target)
 */
private pattern mustInRelationmonthly_attribute_Income_Tax_Credit(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"monthly attribute Income_Tax_Credit");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>monthly attribute Income_Tax_Credit(source,target)
 */
private pattern mayInRelationmonthly_attribute_Income_Tax_Credit(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfIncome_Tax_Credit_class(problem,interpretation,source);
	RealElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationmonthly_attribute_Income_Tax_Credit(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationmonthly_attribute_Income_Tax_Credit(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []daily attribute Income_Tax_Credit(source,target)
 */
private pattern mustInRelationdaily_attribute_Income_Tax_Credit(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"daily attribute Income_Tax_Credit");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>daily attribute Income_Tax_Credit(source,target)
 */
private pattern mayInRelationdaily_attribute_Income_Tax_Credit(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfIncome_Tax_Credit_class(problem,interpretation,source);
	RealElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationdaily_attribute_Income_Tax_Credit(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationdaily_attribute_Income_Tax_Credit(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []id7 attribute Income_Tax_Credit(source,target)
 */
private pattern mustInRelationid7_attribute_Income_Tax_Credit(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"id7 attribute Income_Tax_Credit");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>id7 attribute Income_Tax_Credit(source,target)
 */
private pattern mayInRelationid7_attribute_Income_Tax_Credit(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfIncome_Tax_Credit_class(problem,interpretation,source);
	StringElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationid7_attribute_Income_Tax_Credit(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationid7_attribute_Income_Tax_Credit(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []amount attribute Income_Detail(source,target)
 */
private pattern mustInRelationamount_attribute_Income_Detail(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"amount attribute Income_Detail");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>amount attribute Income_Detail(source,target)
 */
private pattern mayInRelationamount_attribute_Income_Detail(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfIncome_Detail_class(problem,interpretation,source);
	RealElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationamount_attribute_Income_Detail(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationamount_attribute_Income_Detail(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []is_worked attribute Income_Detail(source,target)
 */
private pattern mustInRelationis_worked_attribute_Income_Detail(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"is_worked attribute Income_Detail");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>is_worked attribute Income_Detail(source,target)
 */
private pattern mayInRelationis_worked_attribute_Income_Detail(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfIncome_Detail_class(problem,interpretation,source);
	BooleanElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationis_worked_attribute_Income_Detail(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationis_worked_attribute_Income_Detail(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []distance attribute Income_Detail(source,target)
 */
private pattern mustInRelationdistance_attribute_Income_Detail(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"distance attribute Income_Detail");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>distance attribute Income_Detail(source,target)
 */
private pattern mayInRelationdistance_attribute_Income_Detail(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfIncome_Detail_class(problem,interpretation,source);
	RealElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationdistance_attribute_Income_Detail(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationdistance_attribute_Income_Detail(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []worked_days attribute Income_Detail(source,target)
 */
private pattern mustInRelationworked_days_attribute_Income_Detail(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"worked_days attribute Income_Detail");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>worked_days attribute Income_Detail(source,target)
 */
private pattern mayInRelationworked_days_attribute_Income_Detail(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfIncome_Detail_class(problem,interpretation,source);
	IntegerElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationworked_days_attribute_Income_Detail(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationworked_days_attribute_Income_Detail(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []is_contributing_CNS attribute Income_Detail(source,target)
 */
private pattern mustInRelationis_contributing_CNS_attribute_Income_Detail(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"is_contributing_CNS attribute Income_Detail");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>is_contributing_CNS attribute Income_Detail(source,target)
 */
private pattern mayInRelationis_contributing_CNS_attribute_Income_Detail(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfIncome_Detail_class(problem,interpretation,source);
	BooleanElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationis_contributing_CNS_attribute_Income_Detail(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationis_contributing_CNS_attribute_Income_Detail(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []id5 attribute Income_Detail(source,target)
 */
private pattern mustInRelationid5_attribute_Income_Detail(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"id5 attribute Income_Detail");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>id5 attribute Income_Detail(source,target)
 */
private pattern mayInRelationid5_attribute_Income_Detail(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfIncome_Detail_class(problem,interpretation,source);
	StringElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationid5_attribute_Income_Detail(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationid5_attribute_Income_Detail(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []id attribute FromLaw(source,target)
 */
private pattern mustInRelationid_attribute_FromLaw(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"id attribute FromLaw");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>id attribute FromLaw(source,target)
 */
private pattern mayInRelationid_attribute_FromLaw(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFromLaw_class(problem,interpretation,source);
	StringElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationid_attribute_FromLaw(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationid_attribute_FromLaw(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []is_assimilated_to_resident attribute Non_Resident_Tax_Payer(source,target)
 */
private pattern mustInRelationis_assimilated_to_resident_attribute_Non_Resident_Tax_Payer(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"is_assimilated_to_resident attribute Non_Resident_Tax_Payer");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>is_assimilated_to_resident attribute Non_Resident_Tax_Payer(source,target)
 */
private pattern mayInRelationis_assimilated_to_resident_attribute_Non_Resident_Tax_Payer(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfNon_Resident_Tax_Payer_class(problem,interpretation,source);
	BooleanElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationis_assimilated_to_resident_attribute_Non_Resident_Tax_Payer(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationis_assimilated_to_resident_attribute_Non_Resident_Tax_Payer(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []occasional_payement attribute Pensions_and_Annuities_Income(source,target)
 */
private pattern mustInRelationoccasional_payement_attribute_Pensions_and_Annuities_Income(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"occasional_payement attribute Pensions_and_Annuities_Income");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>occasional_payement attribute Pensions_and_Annuities_Income(source,target)
 */
private pattern mayInRelationoccasional_payement_attribute_Pensions_and_Annuities_Income(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfPensions_and_Annuities_Income_class(problem,interpretation,source);
	BooleanElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationoccasional_payement_attribute_Pensions_and_Annuities_Income(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationoccasional_payement_attribute_Pensions_and_Annuities_Income(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []is_periodic attribute Rentals_and_Leases_Income(source,target)
 */
private pattern mustInRelationis_periodic_attribute_Rentals_and_Leases_Income(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"is_periodic attribute Rentals_and_Leases_Income");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>is_periodic attribute Rentals_and_Leases_Income(source,target)
 */
private pattern mayInRelationis_periodic_attribute_Rentals_and_Leases_Income(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfRentals_and_Leases_Income_class(problem,interpretation,source);
	BooleanElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationis_periodic_attribute_Rentals_and_Leases_Income(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationis_periodic_attribute_Rentals_and_Leases_Income(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []distance_declared_in_january attribute FD(source,target)
 */
private pattern mustInRelationdistance_declared_in_january_attribute_FD(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"distance_declared_in_january attribute FD");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>distance_declared_in_january attribute FD(source,target)
 */
private pattern mayInRelationdistance_declared_in_january_attribute_FD(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFD_class(problem,interpretation,source);
	RealElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationdistance_declared_in_january_attribute_FD(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationdistance_declared_in_january_attribute_FD(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []calculated_distance attribute FD(source,target)
 */
private pattern mustInRelationcalculated_distance_attribute_FD(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"calculated_distance attribute FD");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>calculated_distance attribute FD(source,target)
 */
private pattern mayInRelationcalculated_distance_attribute_FD(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFD_class(problem,interpretation,source);
	RealElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationcalculated_distance_attribute_FD(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationcalculated_distance_attribute_FD(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []rate_type_for_FO attribute FO(source,target)
 */
private pattern mustInRelationrate_type_for_FO_attribute_FO(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"rate_type_for_FO attribute FO");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>rate_type_for_FO attribute FO(source,target)
 */
private pattern mayInRelationrate_type_for_FO_attribute_FO(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfFO_class(problem,interpretation,source);
	find mayInstanceOfType_of_Rate_enum(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationrate_type_for_FO_attribute_FO(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationrate_type_for_FO_attribute_FO(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []permanent_expense_category attribute DS_for_Permanent_Expense(source,target)
 */
private pattern mustInRelationpermanent_expense_category_attribute_DS_for_Permanent_Expense(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"permanent_expense_category attribute DS_for_Permanent_Expense");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>permanent_expense_category attribute DS_for_Permanent_Expense(source,target)
 */
private pattern mayInRelationpermanent_expense_category_attribute_DS_for_Permanent_Expense(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfDS_for_Permanent_Expense_class(problem,interpretation,source);
	find mayInstanceOfCategory_of_Permanent_Expense_enum(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationpermanent_expense_category_attribute_DS_for_Permanent_Expense(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationpermanent_expense_category_attribute_DS_for_Permanent_Expense(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []maximum_deductible_amount attribute DS(source,target)
 */
private pattern mustInRelationmaximum_deductible_amount_attribute_DS(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"maximum_deductible_amount attribute DS");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>maximum_deductible_amount attribute DS(source,target)
 */
private pattern mayInRelationmaximum_deductible_amount_attribute_DS(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfDS_class(problem,interpretation,source);
	RealElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationmaximum_deductible_amount_attribute_DS(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationmaximum_deductible_amount_attribute_DS(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []id3 attribute DS(source,target)
 */
private pattern mustInRelationid3_attribute_DS(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"id3 attribute DS");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>id3 attribute DS(source,target)
 */
private pattern mayInRelationid3_attribute_DS(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfDS_class(problem,interpretation,source);
	StringElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationid3_attribute_DS(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationid3_attribute_DS(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []insurance_category attribute DS_for_Health_and_Pension_Insurance(source,target)
 */
private pattern mustInRelationinsurance_category_attribute_DS_for_Health_and_Pension_Insurance(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"insurance_category attribute DS_for_Health_and_Pension_Insurance");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>insurance_category attribute DS_for_Health_and_Pension_Insurance(source,target)
 */
private pattern mayInRelationinsurance_category_attribute_DS_for_Health_and_Pension_Insurance(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfDS_for_Health_and_Pension_Insurance_class(problem,interpretation,source);
	find mayInstanceOfCategory_of_Health_and_Pension_Insurances_enum(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationinsurance_category_attribute_DS_for_Health_and_Pension_Insurance(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationinsurance_category_attribute_DS_for_Health_and_Pension_Insurance(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []private_insurance_and_plan_category attribute DS_for_Private_Insurance_and_Plan(source,target)
 */
private pattern mustInRelationprivate_insurance_and_plan_category_attribute_DS_for_Private_Insurance_and_Plan(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"private_insurance_and_plan_category attribute DS_for_Private_Insurance_and_Plan");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>private_insurance_and_plan_category attribute DS_for_Private_Insurance_and_Plan(source,target)
 */
private pattern mayInRelationprivate_insurance_and_plan_category_attribute_DS_for_Private_Insurance_and_Plan(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfDS_for_Private_Insurance_and_Plan_class(problem,interpretation,source);
	find mayInstanceOfCategory_of_Private_Insurance_and_Plan_enum(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationprivate_insurance_and_plan_category_attribute_DS_for_Private_Insurance_and_Plan(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationprivate_insurance_and_plan_category_attribute_DS_for_Private_Insurance_and_Plan(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []increase_for_life_insurance attribute DS_for_Private_Insurance_and_Plan(source,target)
 */
private pattern mustInRelationincrease_for_life_insurance_attribute_DS_for_Private_Insurance_and_Plan(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"increase_for_life_insurance attribute DS_for_Private_Insurance_and_Plan");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>increase_for_life_insurance attribute DS_for_Private_Insurance_and_Plan(source,target)
 */
private pattern mayInRelationincrease_for_life_insurance_attribute_DS_for_Private_Insurance_and_Plan(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfDS_for_Private_Insurance_and_Plan_class(problem,interpretation,source);
	RealElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationincrease_for_life_insurance_attribute_DS_for_Private_Insurance_and_Plan(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationincrease_for_life_insurance_attribute_DS_for_Private_Insurance_and_Plan(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []maximum_deductible_amount_for_private_insurance attribute DS_for_Private_Insurance_and_Plan(source,target)
 */
private pattern mustInRelationmaximum_deductible_amount_for_private_insurance_attribute_DS_for_Private_Insurance_and_Plan(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"maximum_deductible_amount_for_private_insurance attribute DS_for_Private_Insurance_and_Plan");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>maximum_deductible_amount_for_private_insurance attribute DS_for_Private_Insurance_and_Plan(source,target)
 */
private pattern mayInRelationmaximum_deductible_amount_for_private_insurance_attribute_DS_for_Private_Insurance_and_Plan(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfDS_for_Private_Insurance_and_Plan_class(problem,interpretation,source);
	RealElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationmaximum_deductible_amount_for_private_insurance_attribute_DS_for_Private_Insurance_and_Plan(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationmaximum_deductible_amount_for_private_insurance_attribute_DS_for_Private_Insurance_and_Plan(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []maximum_deductible_amount_for_old_age_pension_plan attribute DS_for_Private_Insurance_and_Plan(source,target)
 */
private pattern mustInRelationmaximum_deductible_amount_for_old_age_pension_plan_attribute_DS_for_Private_Insurance_and_Plan(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"maximum_deductible_amount_for_old_age_pension_plan attribute DS_for_Private_Insurance_and_Plan");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>maximum_deductible_amount_for_old_age_pension_plan attribute DS_for_Private_Insurance_and_Plan(source,target)
 */
private pattern mayInRelationmaximum_deductible_amount_for_old_age_pension_plan_attribute_DS_for_Private_Insurance_and_Plan(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfDS_for_Private_Insurance_and_Plan_class(problem,interpretation,source);
	RealElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationmaximum_deductible_amount_for_old_age_pension_plan_attribute_DS_for_Private_Insurance_and_Plan(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationmaximum_deductible_amount_for_old_age_pension_plan_attribute_DS_for_Private_Insurance_and_Plan(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []category attribute Permanent_Expense(source,target)
 */
private pattern mustInRelationcategory_attribute_Permanent_Expense(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"category attribute Permanent_Expense");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>category attribute Permanent_Expense(source,target)
 */
private pattern mayInRelationcategory_attribute_Permanent_Expense(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfPermanent_Expense_class(problem,interpretation,source);
	find mayInstanceOfCategory_of_Permanent_Expense_enum(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationcategory_attribute_Permanent_Expense(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationcategory_attribute_Permanent_Expense(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []is_eligible_for_deduction attribute Permanent_Expense(source,target)
 */
private pattern mustInRelationis_eligible_for_deduction_attribute_Permanent_Expense(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"is_eligible_for_deduction attribute Permanent_Expense");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>is_eligible_for_deduction attribute Permanent_Expense(source,target)
 */
private pattern mayInRelationis_eligible_for_deduction_attribute_Permanent_Expense(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfPermanent_Expense_class(problem,interpretation,source);
	BooleanElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationis_eligible_for_deduction_attribute_Permanent_Expense(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationis_eligible_for_deduction_attribute_Permanent_Expense(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []category attribute Private_Insurance_and_Plan(source,target)
 */
private pattern mustInRelationcategory_attribute_Private_Insurance_and_Plan(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"category attribute Private_Insurance_and_Plan");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>category attribute Private_Insurance_and_Plan(source,target)
 */
private pattern mayInRelationcategory_attribute_Private_Insurance_and_Plan(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfPrivate_Insurance_and_Plan_class(problem,interpretation,source);
	find mayInstanceOfCategory_of_Private_Insurance_and_Plan_enum(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationcategory_attribute_Private_Insurance_and_Plan(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationcategory_attribute_Private_Insurance_and_Plan(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []duration_of_contract attribute Private_Insurance_and_Plan(source,target)
 */
private pattern mustInRelationduration_of_contract_attribute_Private_Insurance_and_Plan(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"duration_of_contract attribute Private_Insurance_and_Plan");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>duration_of_contract attribute Private_Insurance_and_Plan(source,target)
 */
private pattern mayInRelationduration_of_contract_attribute_Private_Insurance_and_Plan(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfPrivate_Insurance_and_Plan_class(problem,interpretation,source);
	IntegerElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationduration_of_contract_attribute_Private_Insurance_and_Plan(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationduration_of_contract_attribute_Private_Insurance_and_Plan(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []is_private_insurance_and_plan_eligible_for_deduction attribute Private_Insurance_and_Plan(source,target)
 */
private pattern mustInRelationis_private_insurance_and_plan_eligible_for_deduction_attribute_Private_Insurance_and_Plan(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"is_private_insurance_and_plan_eligible_for_deduction attribute Private_Insurance_and_Plan");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>is_private_insurance_and_plan_eligible_for_deduction attribute Private_Insurance_and_Plan(source,target)
 */
private pattern mayInRelationis_private_insurance_and_plan_eligible_for_deduction_attribute_Private_Insurance_and_Plan(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfPrivate_Insurance_and_Plan_class(problem,interpretation,source);
	BooleanElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationis_private_insurance_and_plan_eligible_for_deduction_attribute_Private_Insurance_and_Plan(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationis_private_insurance_and_plan_eligible_for_deduction_attribute_Private_Insurance_and_Plan(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []category attribute Health_and_Pension_Insurance(source,target)
 */
private pattern mustInRelationcategory_attribute_Health_and_Pension_Insurance(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"category attribute Health_and_Pension_Insurance");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>category attribute Health_and_Pension_Insurance(source,target)
 */
private pattern mayInRelationcategory_attribute_Health_and_Pension_Insurance(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfHealth_and_Pension_Insurance_class(problem,interpretation,source);
	find mayInstanceOfCategory_of_Health_and_Pension_Insurances_enum(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationcategory_attribute_Health_and_Pension_Insurance(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationcategory_attribute_Health_and_Pension_Insurance(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []is_related_to_additional_salary attribute Health_and_Pension_Insurance(source,target)
 */
private pattern mustInRelationis_related_to_additional_salary_attribute_Health_and_Pension_Insurance(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"is_related_to_additional_salary attribute Health_and_Pension_Insurance");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>is_related_to_additional_salary attribute Health_and_Pension_Insurance(source,target)
 */
private pattern mayInRelationis_related_to_additional_salary_attribute_Health_and_Pension_Insurance(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfHealth_and_Pension_Insurance_class(problem,interpretation,source);
	BooleanElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationis_related_to_additional_salary_attribute_Health_and_Pension_Insurance(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationis_related_to_additional_salary_attribute_Health_and_Pension_Insurance(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []beneficiary1 attribute Donation(source,target)
 */
private pattern mustInRelationbeneficiary1_attribute_Donation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"beneficiary1 attribute Donation");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>beneficiary1 attribute Donation(source,target)
 */
private pattern mayInRelationbeneficiary1_attribute_Donation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfDonation_class(problem,interpretation,source);
	StringElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationbeneficiary1_attribute_Donation(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationbeneficiary1_attribute_Donation(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []is_beneficiary_eligible attribute Donation(source,target)
 */
private pattern mustInRelationis_beneficiary_eligible_attribute_Donation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"is_beneficiary_eligible attribute Donation");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>is_beneficiary_eligible attribute Donation(source,target)
 */
private pattern mayInRelationis_beneficiary_eligible_attribute_Donation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfDonation_class(problem,interpretation,source);
	BooleanElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationis_beneficiary_eligible_attribute_Donation(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationis_beneficiary_eligible_attribute_Donation(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []is_donation_reported attribute Donation(source,target)
 */
private pattern mustInRelationis_donation_reported_attribute_Donation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"is_donation_reported attribute Donation");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>is_donation_reported attribute Donation(source,target)
 */
private pattern mayInRelationis_donation_reported_attribute_Donation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfDonation_class(problem,interpretation,source);
	BooleanElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationis_donation_reported_attribute_Donation(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationis_donation_reported_attribute_Donation(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []regular_accountability attribute Loss_Carryforward(source,target)
 */
private pattern mustInRelationregular_accountability_attribute_Loss_Carryforward(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"regular_accountability attribute Loss_Carryforward");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>regular_accountability attribute Loss_Carryforward(source,target)
 */
private pattern mayInRelationregular_accountability_attribute_Loss_Carryforward(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfLoss_Carryforward_class(problem,interpretation,source);
	BooleanElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationregular_accountability_attribute_Loss_Carryforward(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationregular_accountability_attribute_Loss_Carryforward(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []compensation_by_other_means attribute Loss_Carryforward(source,target)
 */
private pattern mustInRelationcompensation_by_other_means_attribute_Loss_Carryforward(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"compensation_by_other_means attribute Loss_Carryforward");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>compensation_by_other_means attribute Loss_Carryforward(source,target)
 */
private pattern mayInRelationcompensation_by_other_means_attribute_Loss_Carryforward(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfLoss_Carryforward_class(problem,interpretation,source);
	BooleanElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationcompensation_by_other_means_attribute_Loss_Carryforward(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationcompensation_by_other_means_attribute_Loss_Carryforward(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []tax_payer_has_inherited_business_ownership attribute Loss_Carryforward(source,target)
 */
private pattern mustInRelationtax_payer_has_inherited_business_ownership_attribute_Loss_Carryforward(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"tax_payer_has_inherited_business_ownership attribute Loss_Carryforward");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>tax_payer_has_inherited_business_ownership attribute Loss_Carryforward(source,target)
 */
private pattern mayInRelationtax_payer_has_inherited_business_ownership_attribute_Loss_Carryforward(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfLoss_Carryforward_class(problem,interpretation,source);
	BooleanElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationtax_payer_has_inherited_business_ownership_attribute_Loss_Carryforward(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationtax_payer_has_inherited_business_ownership_attribute_Loss_Carryforward(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []tax_payer_has_been_partner_in_business attribute Loss_Carryforward(source,target)
 */
private pattern mustInRelationtax_payer_has_been_partner_in_business_attribute_Loss_Carryforward(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"tax_payer_has_been_partner_in_business attribute Loss_Carryforward");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>tax_payer_has_been_partner_in_business attribute Loss_Carryforward(source,target)
 */
private pattern mayInRelationtax_payer_has_been_partner_in_business_attribute_Loss_Carryforward(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfLoss_Carryforward_class(problem,interpretation,source);
	BooleanElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationtax_payer_has_been_partner_in_business_attribute_Loss_Carryforward(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationtax_payer_has_been_partner_in_business_attribute_Loss_Carryforward(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []thresholded_deduction_percentage attribute Extraordinary_Expense_CE(source,target)
 */
private pattern mustInRelationthresholded_deduction_percentage_attribute_Extraordinary_Expense_CE(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"thresholded_deduction_percentage attribute Extraordinary_Expense_CE");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>thresholded_deduction_percentage attribute Extraordinary_Expense_CE(source,target)
 */
private pattern mayInRelationthresholded_deduction_percentage_attribute_Extraordinary_Expense_CE(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfExtraordinary_Expense_CE_class(problem,interpretation,source);
	RealElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationthresholded_deduction_percentage_attribute_Extraordinary_Expense_CE(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationthresholded_deduction_percentage_attribute_Extraordinary_Expense_CE(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []ce_type attribute Extraordinary_Expense_CE(source,target)
 */
private pattern mustInRelationce_type_attribute_Extraordinary_Expense_CE(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"ce_type attribute Extraordinary_Expense_CE");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>ce_type attribute Extraordinary_Expense_CE(source,target)
 */
private pattern mayInRelationce_type_attribute_Extraordinary_Expense_CE(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfExtraordinary_Expense_CE_class(problem,interpretation,source);
	find mayInstanceOfCE_Type_enum(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationce_type_attribute_Extraordinary_Expense_CE(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationce_type_attribute_Extraordinary_Expense_CE(problem,interpretation,source,target);
}

//////////
// 1.3 Relation Definition Indexers
//////////

//////////
// 1.4 Containment Indexer
//////////
private pattern mustContains2(source: DefinedElement, target: DefinedElement) {
	find mustContains4(_,_,source,target);
}
	
private pattern mustContains4(problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target: DefinedElement)
	{ find mustInRelationdependents_reference_Tax_Payer(problem,interpretation,source,target); }or
	
	{ find mustInRelationfrom_agent_reference_Tax_Payer(problem,interpretation,source,target); }or
	
	{ find mustInRelationincomes_reference_Tax_Payer(problem,interpretation,source,target); }or
	
	{ find mustInRelationfrom_law_reference_Tax_Payer(problem,interpretation,source,target); }or
	
	{ find mustInRelationallowances_reference_Dependent(problem,interpretation,source,target); }or
	
	{ find mustInRelationparents_reference_Household(problem,interpretation,source,target); }or
	
	{ find mustInRelationchildren_reference_Household(problem,interpretation,source,target); }or
	
	{ find mustInRelationindividual_A_reference_Legal_Union_Record(problem,interpretation,source,target); }or
	
	{ find mustInRelationindividual_B_reference_Legal_Union_Record(problem,interpretation,source,target); }or
	
	{ find mustInRelationproperties_reference_Legal_Union_Record(problem,interpretation,source,target); }or
	
	{ find mustInRelationincome_type_reference_Income(problem,interpretation,source,target); }or
	
	{ find mustInRelationtax_card_reference_Income(problem,interpretation,source,target); }or
	
	{ find mustInRelationdetails_reference_Income(problem,interpretation,source,target); }or
	
	{ find mustInRelationexpenses_reference_Income(problem,interpretation,source,target); }

private pattern mustTransitiveContains(source,target) {
	find mustContains2+(source,target);
}

//////////
// 2. Invalidation Indexers
//////////
// 2.1 Invalidated by WF Queries
//////////

//////////
// 3. Unfinishedness Indexers
//////////
// 3.1 Unfinishedness Measured by Multiplicity
//////////
pattern unfinishedLowerMultiplicity_taxPayer_reference_Income_Tax(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"taxPayer reference Income_Tax");
	find mustInstanceOfIncome_Tax_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationtaxPayer_reference_Income_Tax(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_from_agent_reference_Tax_Payer(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"from_agent reference Tax_Payer");
	find mustInstanceOfTax_Payer_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationfrom_agent_reference_Tax_Payer(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_incomes_reference_Tax_Payer(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"incomes reference Tax_Payer");
	find mustInstanceOfTax_Payer_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationincomes_reference_Tax_Payer(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_from_law_reference_Tax_Payer(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"from_law reference Tax_Payer");
	find mustInstanceOfTax_Payer_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationfrom_law_reference_Tax_Payer(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_income_reference_Expense(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"income reference Expense");
	find mustInstanceOfExpense_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationincome_reference_Expense(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_reciver_reference_External_Allowance(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"reciver reference External_Allowance");
	find mustInstanceOfExternal_Allowance_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationreciver_reference_External_Allowance(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_person_reference_External_Allowance(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"person reference External_Allowance");
	find mustInstanceOfExternal_Allowance_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationperson_reference_External_Allowance(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_parents_reference_Household(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"parents reference Household");
	find mustInstanceOfHousehold_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationparents_reference_Household(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_individual_A_reference_Legal_Union_Record(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"individual_A reference Legal_Union_Record");
	find mustInstanceOfLegal_Union_Record_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationindividual_A_reference_Legal_Union_Record(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_individual_B_reference_Legal_Union_Record(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"individual_B reference Legal_Union_Record");
	find mustInstanceOfLegal_Union_Record_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationindividual_B_reference_Legal_Union_Record(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_properties_reference_Legal_Union_Record(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"properties reference Legal_Union_Record");
	find mustInstanceOfLegal_Union_Record_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationproperties_reference_Legal_Union_Record(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_household_reference_Legal_Union_Record(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"household reference Legal_Union_Record");
	find mustInstanceOfLegal_Union_Record_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationhousehold_reference_Legal_Union_Record(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_union_record_reference_Tax_Property(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"union_record reference Tax_Property");
	find mustInstanceOfTax_Property_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationunion_record_reference_Tax_Property(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_taxPayer_reference_FromAgent(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"taxPayer reference FromAgent");
	find mustInstanceOfFromAgent_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationtaxPayer_reference_FromAgent(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_income_type_reference_Income(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"income_type reference Income");
	find mustInstanceOfIncome_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationincome_type_reference_Income(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_taxPayer_reference_Income(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"taxPayer reference Income");
	find mustInstanceOfIncome_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationtaxPayer_reference_Income(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_details_reference_Income(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"details reference Income");
	find mustInstanceOfIncome_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationdetails_reference_Income(problem,interpretation,object,_);
	check(numberOfExistingReferences < 12);
	missingMultiplicity == eval(12-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_income_reference_Income_Type(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"income reference Income_Type");
	find mustInstanceOfIncome_Type_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationincome_reference_Income_Type(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_income_reference_Tax_Card(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"income reference Tax_Card");
	find mustInstanceOfTax_Card_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationincome_reference_Tax_Card(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_income_reference_Income_Detail(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"income reference Income_Detail");
	find mustInstanceOfIncome_Detail_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationincome_reference_Income_Detail(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_taxPayer_reference_FromLaw(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"taxPayer reference FromLaw");
	find mustInstanceOfFromLaw_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationtaxPayer_reference_FromLaw(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_MAXIMUM_CE_RATE_FOR_CHILD_NOT_BEING_PART_OF_HOUSEHOLD_attribute_Constants(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"MAXIMUM_CE_RATE_FOR_CHILD_NOT_BEING_PART_OF_HOUSEHOLD attribute Constants");
	find mustInstanceOfConstants_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationMAXIMUM_CE_RATE_FOR_CHILD_NOT_BEING_PART_OF_HOUSEHOLD_attribute_Constants(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_MAXIMUM_CE_RATE_FOR_HOUSE_CARE_AND_CHILD_PART_OF_THE_HOUSEHOLD_CARE_attribute_Constants(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"MAXIMUM_CE_RATE_FOR_HOUSE_CARE_AND_CHILD_PART_OF_THE_HOUSEHOLD_CARE attribute Constants");
	find mustInstanceOfConstants_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationMAXIMUM_CE_RATE_FOR_HOUSE_CARE_AND_CHILD_PART_OF_THE_HOUSEHOLD_CARE_attribute_Constants(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_MINIMUM_SALARY_attribute_Constants(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"MINIMUM_SALARY attribute Constants");
	find mustInstanceOfConstants_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationMINIMUM_SALARY_attribute_Constants(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_FLAT_RATE_FOR_EXTRA_PROFESSIONAL_DEDUCTION_attribute_Constants(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"FLAT_RATE_FOR_EXTRA_PROFESSIONAL_DEDUCTION attribute Constants");
	find mustInstanceOfConstants_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationFLAT_RATE_FOR_EXTRA_PROFESSIONAL_DEDUCTION_attribute_Constants(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_MAXIMUM_DEDUCTIBLE_PERCENTAGE_FOR_DONATIONS_attribute_Constants(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"MAXIMUM_DEDUCTIBLE_PERCENTAGE_FOR_DONATIONS attribute Constants");
	find mustInstanceOfConstants_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationMAXIMUM_DEDUCTIBLE_PERCENTAGE_FOR_DONATIONS_attribute_Constants(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_MINIMUM_DEDUCTIBLE_AMOUNT_FOR_DONATIONS_attribute_Constants(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"MINIMUM_DEDUCTIBLE_AMOUNT_FOR_DONATIONS attribute Constants");
	find mustInstanceOfConstants_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationMINIMUM_DEDUCTIBLE_AMOUNT_FOR_DONATIONS_attribute_Constants(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_MAXIMUM_DEDUCTIBLE_AMOUNT_FOR_ADDITIONAL_PENSION_AND_INSURANC_attribute_Constants(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"MAXIMUM_DEDUCTIBLE_AMOUNT_FOR_ADDITIONAL_PENSION_AND_INSURANC attribute Constants");
	find mustInstanceOfConstants_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationMAXIMUM_DEDUCTIBLE_AMOUNT_FOR_ADDITIONAL_PENSION_AND_INSURANC_attribute_Constants(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_MAXIMUM_DEDUCTIBLE_AMOUNT_FOR_ALIMONY_EXPENSE_attribute_Constants(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"MAXIMUM_DEDUCTIBLE_AMOUNT_FOR_ALIMONY_EXPENSE attribute Constants");
	find mustInstanceOfConstants_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationMAXIMUM_DEDUCTIBLE_AMOUNT_FOR_ALIMONY_EXPENSE_attribute_Constants(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_MAXIMAL_DISTANCE_FOR_TRAVEL_EXPENSE_DEDUCTION_attribute_Constants(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"MAXIMAL_DISTANCE_FOR_TRAVEL_EXPENSE_DEDUCTION attribute Constants");
	find mustInstanceOfConstants_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationMAXIMAL_DISTANCE_FOR_TRAVEL_EXPENSE_DEDUCTION_attribute_Constants(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_MAXIMAL_FLAT_DISTANCE_FOR_TRAVEL_EXPENSE_DEDUCTION_attribute_Constants(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"MAXIMAL_FLAT_DISTANCE_FOR_TRAVEL_EXPENSE_DEDUCTION attribute Constants");
	find mustInstanceOfConstants_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationMAXIMAL_FLAT_DISTANCE_FOR_TRAVEL_EXPENSE_DEDUCTION_attribute_Constants(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_MINIMAL_DISTANCE_FOR_TRAVEL_EXPENSE_DEDUCTION_attribute_Constants(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"MINIMAL_DISTANCE_FOR_TRAVEL_EXPENSE_DEDUCTION attribute Constants");
	find mustInstanceOfConstants_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationMINIMAL_DISTANCE_FOR_TRAVEL_EXPENSE_DEDUCTION_attribute_Constants(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_FLAT_RATE_CIM_DAILY_attribute_Constants(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"FLAT_RATE_CIM_DAILY attribute Constants");
	find mustInstanceOfConstants_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationFLAT_RATE_CIM_DAILY_attribute_Constants(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_FLAT_RATE_CIM_MONTHLY_attribute_Constants(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"FLAT_RATE_CIM_MONTHLY attribute Constants");
	find mustInstanceOfConstants_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationFLAT_RATE_CIM_MONTHLY_attribute_Constants(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_FLAT_RATE_CIM_YEARLY_attribute_Constants(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"FLAT_RATE_CIM_YEARLY attribute Constants");
	find mustInstanceOfConstants_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationFLAT_RATE_CIM_YEARLY_attribute_Constants(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_FLAT_RATE_CIP_DAILY_attribute_Constants(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"FLAT_RATE_CIP_DAILY attribute Constants");
	find mustInstanceOfConstants_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationFLAT_RATE_CIP_DAILY_attribute_Constants(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_FLAT_RATE_CIP_MONTHLY_attribute_Constants(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"FLAT_RATE_CIP_MONTHLY attribute Constants");
	find mustInstanceOfConstants_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationFLAT_RATE_CIP_MONTHLY_attribute_Constants(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_FLAT_RATE_CIP_YEARLY_attribute_Constants(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"FLAT_RATE_CIP_YEARLY attribute Constants");
	find mustInstanceOfConstants_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationFLAT_RATE_CIP_YEARLY_attribute_Constants(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_FLAT_RATE_CIS_DAILY_attribute_Constants(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"FLAT_RATE_CIS_DAILY attribute Constants");
	find mustInstanceOfConstants_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationFLAT_RATE_CIS_DAILY_attribute_Constants(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_FLAT_RATE_CIS_MONTHLY_attribute_Constants(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"FLAT_RATE_CIS_MONTHLY attribute Constants");
	find mustInstanceOfConstants_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationFLAT_RATE_CIS_MONTHLY_attribute_Constants(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_FLAT_RATE_CIS_YEARLY_attribute_Constants(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"FLAT_RATE_CIS_YEARLY attribute Constants");
	find mustInstanceOfConstants_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationFLAT_RATE_CIS_YEARLY_attribute_Constants(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_FLAT_RATE_FOR_TRAVEL_EXPENSE_PER_UNIT_attribute_Constants(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"FLAT_RATE_FOR_TRAVEL_EXPENSE_PER_UNIT attribute Constants");
	find mustInstanceOfConstants_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationFLAT_RATE_FOR_TRAVEL_EXPENSE_PER_UNIT_attribute_Constants(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_MAXIMUM_DEDUCTIBLE_AMOUNT_FOR_DS_attribute_Constants(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"MAXIMUM_DEDUCTIBLE_AMOUNT_FOR_DS attribute Constants");
	find mustInstanceOfConstants_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationMAXIMUM_DEDUCTIBLE_AMOUNT_FOR_DS_attribute_Constants(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_FLAT_RATE_FOR_MISCELLANEOUS_EXPENSE_attribute_Constants(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"FLAT_RATE_FOR_MISCELLANEOUS_EXPENSE attribute Constants");
	find mustInstanceOfConstants_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationFLAT_RATE_FOR_MISCELLANEOUS_EXPENSE_attribute_Constants(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_DISABILITY_FLAT_RATE_FOR_MISCELLANEOUS_EXPENSE_attribute_Constants(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"DISABILITY_FLAT_RATE_FOR_MISCELLANEOUS_EXPENSE attribute Constants");
	find mustInstanceOfConstants_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationDISABILITY_FLAT_RATE_FOR_MISCELLANEOUS_EXPENSE_attribute_Constants(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_MAXIMUM_DEDUCTIBLE_AMOUNT_FOR_ADDITIONAL_PENSION_AND_INSURANCE_attribute_Constants(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"MAXIMUM_DEDUCTIBLE_AMOUNT_FOR_ADDITIONAL_PENSION_AND_INSURANCE attribute Constants");
	find mustInstanceOfConstants_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationMAXIMUM_DEDUCTIBLE_AMOUNT_FOR_ADDITIONAL_PENSION_AND_INSURANCE_attribute_Constants(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_tax_amount_attribute_Income_Tax(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"tax_amount attribute Income_Tax");
	find mustInstanceOfIncome_Tax_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationtax_amount_attribute_Income_Tax(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_tax_year_attribute_Income_Tax(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"tax_year attribute Income_Tax");
	find mustInstanceOfIncome_Tax_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationtax_year_attribute_Income_Tax(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_id6_attribute_Income_Tax(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"id6 attribute Income_Tax");
	find mustInstanceOfIncome_Tax_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationid6_attribute_Income_Tax(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_taxesDue_attribute_Tax_Payer(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"taxesDue attribute Tax_Payer");
	find mustInstanceOfTax_Payer_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationtaxesDue_attribute_Tax_Payer(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_is_assisting_spouse_attribute_Physical_Person(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"is_assisting_spouse attribute Physical_Person");
	find mustInstanceOfPhysical_Person_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationis_assisting_spouse_attribute_Physical_Person(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_SSNo_attribute_Physical_Person(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"SSNo attribute Physical_Person");
	find mustInstanceOfPhysical_Person_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationSSNo_attribute_Physical_Person(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_birth_year_attribute_Physical_Person(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"birth_year attribute Physical_Person");
	find mustInstanceOfPhysical_Person_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationbirth_year_attribute_Physical_Person(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_disability_percentage_attribute_Physical_Person(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"disability_percentage attribute Physical_Person");
	find mustInstanceOfPhysical_Person_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationdisability_percentage_attribute_Physical_Person(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_disability_type_attribute_Physical_Person(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"disability_type attribute Physical_Person");
	find mustInstanceOfPhysical_Person_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationdisability_type_attribute_Physical_Person(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_is_affiliated_personnaly_to_social_security_attribute_Physical_Person(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"is_affiliated_personnaly_to_social_security attribute Physical_Person");
	find mustInstanceOfPhysical_Person_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationis_affiliated_personnaly_to_social_security_attribute_Physical_Person(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_birth_month_attribute_Physical_Person(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"birth_month attribute Physical_Person");
	find mustInstanceOfPhysical_Person_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationbirth_month_attribute_Physical_Person(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_birth_day_attribute_Physical_Person(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"birth_day attribute Physical_Person");
	find mustInstanceOfPhysical_Person_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationbirth_day_attribute_Physical_Person(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_is_widower_attribute_Physical_Person(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"is_widower attribute Physical_Person");
	find mustInstanceOfPhysical_Person_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationis_widower_attribute_Physical_Person(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_country_attribute_Address(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"country attribute Address");
	find mustInstanceOfAddress_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationcountry_attribute_Address(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_street_attribute_Address(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"street attribute Address");
	find mustInstanceOfAddress_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationstreet_attribute_Address(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_zipCode_attribute_Address(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"zipCode attribute Address");
	find mustInstanceOfAddress_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationzipCode_attribute_Address(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_city_attribute_Address(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"city attribute Address");
	find mustInstanceOfAddress_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationcity_attribute_Address(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_id2_attribute_Address(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"id2 attribute Address");
	find mustInstanceOfAddress_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationid2_attribute_Address(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_declared_amount_attribute_Expense(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"declared_amount attribute Expense");
	find mustInstanceOfExpense_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationdeclared_amount_attribute_Expense(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_expense_purpose_attribute_Expense(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"expense_purpose attribute Expense");
	find mustInstanceOfExpense_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationexpense_purpose_attribute_Expense(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_id4_attribute_Expense(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"id4 attribute Expense");
	find mustInstanceOfExpense_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationid4_attribute_Expense(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_dependent_type_attribute_Dependent(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"dependent_type attribute Dependent");
	find mustInstanceOfDependent_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationdependent_type_attribute_Dependent(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_continued_studies_attribute_Dependent(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"continued_studies attribute Dependent");
	find mustInstanceOfDependent_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationcontinued_studies_attribute_Dependent(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_amount_attribute_External_Allowance(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"amount attribute External_Allowance");
	find mustInstanceOfExternal_Allowance_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationamount_attribute_External_Allowance(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_grantor_attribute_External_Allowance(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"grantor attribute External_Allowance");
	find mustInstanceOfExternal_Allowance_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationgrantor_attribute_External_Allowance(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_starting_year_attribute_External_Allowance(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"starting_year attribute External_Allowance");
	find mustInstanceOfExternal_Allowance_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationstarting_year_attribute_External_Allowance(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_ending_year_attribute_External_Allowance(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"ending_year attribute External_Allowance");
	find mustInstanceOfExternal_Allowance_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationending_year_attribute_External_Allowance(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_id5_attribute_External_Allowance(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"id5 attribute External_Allowance");
	find mustInstanceOfExternal_Allowance_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationid5_attribute_External_Allowance(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_id1_attribute_Household(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"id1 attribute Household");
	find mustInstanceOfHousehold_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationid1_attribute_Household(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_start_year_attribute_Legal_Union_Record(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"start_year attribute Legal_Union_Record");
	find mustInstanceOfLegal_Union_Record_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationstart_year_attribute_Legal_Union_Record(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_end_year_attribute_Legal_Union_Record(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"end_year attribute Legal_Union_Record");
	find mustInstanceOfLegal_Union_Record_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationend_year_attribute_Legal_Union_Record(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_separation_cause_attribute_Legal_Union_Record(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"separation_cause attribute Legal_Union_Record");
	find mustInstanceOfLegal_Union_Record_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationseparation_cause_attribute_Legal_Union_Record(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_mutual_agreement_attribute_Legal_Union_Record(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"mutual_agreement attribute Legal_Union_Record");
	find mustInstanceOfLegal_Union_Record_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationmutual_agreement_attribute_Legal_Union_Record(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_id9_attribute_Legal_Union_Record(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"id9 attribute Legal_Union_Record");
	find mustInstanceOfLegal_Union_Record_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationid9_attribute_Legal_Union_Record(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_starting_year_attribute_Tax_Property(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"starting_year attribute Tax_Property");
	find mustInstanceOfTax_Property_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationstarting_year_attribute_Tax_Property(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_id10_attribute_Tax_Property(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"id10 attribute Tax_Property");
	find mustInstanceOfTax_Property_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationid10_attribute_Tax_Property(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_is_dependent_eligible_for_CE_Not_In_Houshold_Children_Care_attribute_FromAgent(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"is_dependent_eligible_for_CE_Not_In_Houshold_Children_Care attribute FromAgent");
	find mustInstanceOfFromAgent_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationis_dependent_eligible_for_CE_Not_In_Houshold_Children_Care_attribute_FromAgent(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_is_eligible_debt_attribute_FromAgent(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"is_eligible_debt attribute FromAgent");
	find mustInstanceOfFromAgent_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationis_eligible_debt_attribute_FromAgent(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_income_amount_attribute_Income(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"income_amount attribute Income");
	find mustInstanceOfIncome_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationincome_amount_attribute_Income(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_tax_liability_attribute_Income(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"tax_liability attribute Income");
	find mustInstanceOfIncome_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationtax_liability_attribute_Income(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_num_attribute_Income(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"num attribute Income");
	find mustInstanceOfIncome_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationnum_attribute_Income(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_subjectToWithholdingTax_attribute_Income_Type(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"subjectToWithholdingTax attribute Income_Type");
	find mustInstanceOfIncome_Type_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationsubjectToWithholdingTax_attribute_Income_Type(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_id8_attribute_Income_Type(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"id8 attribute Income_Type");
	find mustInstanceOfIncome_Type_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationid8_attribute_Income_Type(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_tax_card_type_attribute_Tax_Card(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"tax_card_type attribute Tax_Card");
	find mustInstanceOfTax_Card_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationtax_card_type_attribute_Tax_Card(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_tax_office_attribute_Tax_Card(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"tax_office attribute Tax_Card");
	find mustInstanceOfTax_Card_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationtax_office_attribute_Tax_Card(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_percentage_of_witholding_attribute_Tax_Card(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"percentage_of_witholding attribute Tax_Card");
	find mustInstanceOfTax_Card_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationpercentage_of_witholding_attribute_Tax_Card(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_jobs_activity_type_attribute_Tax_Card(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"jobs_activity_type attribute Tax_Card");
	find mustInstanceOfTax_Card_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationjobs_activity_type_attribute_Tax_Card(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_jobs_place_of_work_attribute_Tax_Card(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"jobs_place_of_work attribute Tax_Card");
	find mustInstanceOfTax_Card_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationjobs_place_of_work_attribute_Tax_Card(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_deduction_FD_daily_attribute_Tax_Card(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"deduction_FD_daily attribute Tax_Card");
	find mustInstanceOfTax_Card_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationdeduction_FD_daily_attribute_Tax_Card(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_deduction_FD_monthly_attribute_Tax_Card(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"deduction_FD_monthly attribute Tax_Card");
	find mustInstanceOfTax_Card_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationdeduction_FD_monthly_attribute_Tax_Card(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_deduction_AC_daily_attribute_Tax_Card(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"deduction_AC_daily attribute Tax_Card");
	find mustInstanceOfTax_Card_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationdeduction_AC_daily_attribute_Tax_Card(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_deduction_AC_monthly_attribute_Tax_Card(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"deduction_AC_monthly attribute Tax_Card");
	find mustInstanceOfTax_Card_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationdeduction_AC_monthly_attribute_Tax_Card(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_deduction_AC_yearly_attribute_Tax_Card(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"deduction_AC_yearly attribute Tax_Card");
	find mustInstanceOfTax_Card_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationdeduction_AC_yearly_attribute_Tax_Card(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_deduction_CE_daily_attribute_Tax_Card(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"deduction_CE_daily attribute Tax_Card");
	find mustInstanceOfTax_Card_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationdeduction_CE_daily_attribute_Tax_Card(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_deduction_CE_monthly_attribute_Tax_Card(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"deduction_CE_monthly attribute Tax_Card");
	find mustInstanceOfTax_Card_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationdeduction_CE_monthly_attribute_Tax_Card(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_deduction_CE_yearly_attribute_Tax_Card(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"deduction_CE_yearly attribute Tax_Card");
	find mustInstanceOfTax_Card_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationdeduction_CE_yearly_attribute_Tax_Card(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_deduction_DS_daily_attribute_Tax_Card(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"deduction_DS_daily attribute Tax_Card");
	find mustInstanceOfTax_Card_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationdeduction_DS_daily_attribute_Tax_Card(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_deduction_DS_monthly_attribute_Tax_Card(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"deduction_DS_monthly attribute Tax_Card");
	find mustInstanceOfTax_Card_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationdeduction_DS_monthly_attribute_Tax_Card(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_deduction_FO_daily_attribute_Tax_Card(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"deduction_FO_daily attribute Tax_Card");
	find mustInstanceOfTax_Card_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationdeduction_FO_daily_attribute_Tax_Card(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_deduction_FO_monthly_attribute_Tax_Card(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"deduction_FO_monthly attribute Tax_Card");
	find mustInstanceOfTax_Card_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationdeduction_FO_monthly_attribute_Tax_Card(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_deduction_FO_yearly_attribute_Tax_Card(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"deduction_FO_yearly attribute Tax_Card");
	find mustInstanceOfTax_Card_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationdeduction_FO_yearly_attribute_Tax_Card(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_credit_CIS_daily_attribute_Tax_Card(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"credit_CIS_daily attribute Tax_Card");
	find mustInstanceOfTax_Card_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationcredit_CIS_daily_attribute_Tax_Card(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_credit_CIS_monthly_attribute_Tax_Card(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"credit_CIS_monthly attribute Tax_Card");
	find mustInstanceOfTax_Card_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationcredit_CIS_monthly_attribute_Tax_Card(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_credit_CIM_daily_attribute_Tax_Card(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"credit_CIM_daily attribute Tax_Card");
	find mustInstanceOfTax_Card_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationcredit_CIM_daily_attribute_Tax_Card(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_validity_attribute_Tax_Card(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"validity attribute Tax_Card");
	find mustInstanceOfTax_Card_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationvalidity_attribute_Tax_Card(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_credit_CIM_yearly_attribute_Tax_Card(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"credit_CIM_yearly attribute Tax_Card");
	find mustInstanceOfTax_Card_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationcredit_CIM_yearly_attribute_Tax_Card(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_deduction_DS_Alimony_yearly_attribute_Tax_Card(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"deduction_DS_Alimony_yearly attribute Tax_Card");
	find mustInstanceOfTax_Card_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationdeduction_DS_Alimony_yearly_attribute_Tax_Card(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_deduction_DS_Debt_yearly_attribute_Tax_Card(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"deduction_DS_Debt_yearly attribute Tax_Card");
	find mustInstanceOfTax_Card_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationdeduction_DS_Debt_yearly_attribute_Tax_Card(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_grantedBy_attribute_Income_Tax_Credit(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"grantedBy attribute Income_Tax_Credit");
	find mustInstanceOfIncome_Tax_Credit_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationgrantedBy_attribute_Income_Tax_Credit(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_tax_year_attribute_Income_Tax_Credit(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"tax_year attribute Income_Tax_Credit");
	find mustInstanceOfIncome_Tax_Credit_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationtax_year_attribute_Income_Tax_Credit(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_yearly_attribute_Income_Tax_Credit(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"yearly attribute Income_Tax_Credit");
	find mustInstanceOfIncome_Tax_Credit_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationyearly_attribute_Income_Tax_Credit(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_monthly_attribute_Income_Tax_Credit(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"monthly attribute Income_Tax_Credit");
	find mustInstanceOfIncome_Tax_Credit_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationmonthly_attribute_Income_Tax_Credit(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_daily_attribute_Income_Tax_Credit(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"daily attribute Income_Tax_Credit");
	find mustInstanceOfIncome_Tax_Credit_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationdaily_attribute_Income_Tax_Credit(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_id7_attribute_Income_Tax_Credit(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"id7 attribute Income_Tax_Credit");
	find mustInstanceOfIncome_Tax_Credit_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationid7_attribute_Income_Tax_Credit(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_amount_attribute_Income_Detail(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"amount attribute Income_Detail");
	find mustInstanceOfIncome_Detail_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationamount_attribute_Income_Detail(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_is_worked_attribute_Income_Detail(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"is_worked attribute Income_Detail");
	find mustInstanceOfIncome_Detail_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationis_worked_attribute_Income_Detail(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_distance_attribute_Income_Detail(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"distance attribute Income_Detail");
	find mustInstanceOfIncome_Detail_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationdistance_attribute_Income_Detail(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_worked_days_attribute_Income_Detail(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"worked_days attribute Income_Detail");
	find mustInstanceOfIncome_Detail_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationworked_days_attribute_Income_Detail(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_is_contributing_CNS_attribute_Income_Detail(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"is_contributing_CNS attribute Income_Detail");
	find mustInstanceOfIncome_Detail_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationis_contributing_CNS_attribute_Income_Detail(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_id5_attribute_Income_Detail(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"id5 attribute Income_Detail");
	find mustInstanceOfIncome_Detail_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationid5_attribute_Income_Detail(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_id_attribute_FromLaw(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"id attribute FromLaw");
	find mustInstanceOfFromLaw_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationid_attribute_FromLaw(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_is_assimilated_to_resident_attribute_Non_Resident_Tax_Payer(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"is_assimilated_to_resident attribute Non_Resident_Tax_Payer");
	find mustInstanceOfNon_Resident_Tax_Payer_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationis_assimilated_to_resident_attribute_Non_Resident_Tax_Payer(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_is_periodic_attribute_Rentals_and_Leases_Income(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"is_periodic attribute Rentals_and_Leases_Income");
	find mustInstanceOfRentals_and_Leases_Income_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationis_periodic_attribute_Rentals_and_Leases_Income(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_distance_declared_in_january_attribute_FD(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"distance_declared_in_january attribute FD");
	find mustInstanceOfFD_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationdistance_declared_in_january_attribute_FD(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_calculated_distance_attribute_FD(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"calculated_distance attribute FD");
	find mustInstanceOfFD_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationcalculated_distance_attribute_FD(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_rate_type_for_FO_attribute_FO(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"rate_type_for_FO attribute FO");
	find mustInstanceOfFO_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationrate_type_for_FO_attribute_FO(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_permanent_expense_category_attribute_DS_for_Permanent_Expense(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"permanent_expense_category attribute DS_for_Permanent_Expense");
	find mustInstanceOfDS_for_Permanent_Expense_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationpermanent_expense_category_attribute_DS_for_Permanent_Expense(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_maximum_deductible_amount_attribute_DS(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"maximum_deductible_amount attribute DS");
	find mustInstanceOfDS_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationmaximum_deductible_amount_attribute_DS(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_id3_attribute_DS(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"id3 attribute DS");
	find mustInstanceOfDS_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationid3_attribute_DS(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_insurance_category_attribute_DS_for_Health_and_Pension_Insurance(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"insurance_category attribute DS_for_Health_and_Pension_Insurance");
	find mustInstanceOfDS_for_Health_and_Pension_Insurance_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationinsurance_category_attribute_DS_for_Health_and_Pension_Insurance(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_private_insurance_and_plan_category_attribute_DS_for_Private_Insurance_and_Plan(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"private_insurance_and_plan_category attribute DS_for_Private_Insurance_and_Plan");
	find mustInstanceOfDS_for_Private_Insurance_and_Plan_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationprivate_insurance_and_plan_category_attribute_DS_for_Private_Insurance_and_Plan(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_increase_for_life_insurance_attribute_DS_for_Private_Insurance_and_Plan(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"increase_for_life_insurance attribute DS_for_Private_Insurance_and_Plan");
	find mustInstanceOfDS_for_Private_Insurance_and_Plan_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationincrease_for_life_insurance_attribute_DS_for_Private_Insurance_and_Plan(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_maximum_deductible_amount_for_private_insurance_attribute_DS_for_Private_Insurance_and_Plan(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"maximum_deductible_amount_for_private_insurance attribute DS_for_Private_Insurance_and_Plan");
	find mustInstanceOfDS_for_Private_Insurance_and_Plan_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationmaximum_deductible_amount_for_private_insurance_attribute_DS_for_Private_Insurance_and_Plan(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_maximum_deductible_amount_for_old_age_pension_plan_attribute_DS_for_Private_Insurance_and_Plan(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"maximum_deductible_amount_for_old_age_pension_plan attribute DS_for_Private_Insurance_and_Plan");
	find mustInstanceOfDS_for_Private_Insurance_and_Plan_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationmaximum_deductible_amount_for_old_age_pension_plan_attribute_DS_for_Private_Insurance_and_Plan(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_category_attribute_Permanent_Expense(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"category attribute Permanent_Expense");
	find mustInstanceOfPermanent_Expense_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationcategory_attribute_Permanent_Expense(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_is_eligible_for_deduction_attribute_Permanent_Expense(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"is_eligible_for_deduction attribute Permanent_Expense");
	find mustInstanceOfPermanent_Expense_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationis_eligible_for_deduction_attribute_Permanent_Expense(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_category_attribute_Private_Insurance_and_Plan(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"category attribute Private_Insurance_and_Plan");
	find mustInstanceOfPrivate_Insurance_and_Plan_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationcategory_attribute_Private_Insurance_and_Plan(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_duration_of_contract_attribute_Private_Insurance_and_Plan(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"duration_of_contract attribute Private_Insurance_and_Plan");
	find mustInstanceOfPrivate_Insurance_and_Plan_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationduration_of_contract_attribute_Private_Insurance_and_Plan(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_is_private_insurance_and_plan_eligible_for_deduction_attribute_Private_Insurance_and_Plan(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"is_private_insurance_and_plan_eligible_for_deduction attribute Private_Insurance_and_Plan");
	find mustInstanceOfPrivate_Insurance_and_Plan_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationis_private_insurance_and_plan_eligible_for_deduction_attribute_Private_Insurance_and_Plan(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_category_attribute_Health_and_Pension_Insurance(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"category attribute Health_and_Pension_Insurance");
	find mustInstanceOfHealth_and_Pension_Insurance_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationcategory_attribute_Health_and_Pension_Insurance(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_is_related_to_additional_salary_attribute_Health_and_Pension_Insurance(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"is_related_to_additional_salary attribute Health_and_Pension_Insurance");
	find mustInstanceOfHealth_and_Pension_Insurance_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationis_related_to_additional_salary_attribute_Health_and_Pension_Insurance(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_beneficiary1_attribute_Donation(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"beneficiary1 attribute Donation");
	find mustInstanceOfDonation_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationbeneficiary1_attribute_Donation(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_is_beneficiary_eligible_attribute_Donation(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"is_beneficiary_eligible attribute Donation");
	find mustInstanceOfDonation_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationis_beneficiary_eligible_attribute_Donation(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_is_donation_reported_attribute_Donation(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"is_donation_reported attribute Donation");
	find mustInstanceOfDonation_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationis_donation_reported_attribute_Donation(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_regular_accountability_attribute_Loss_Carryforward(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"regular_accountability attribute Loss_Carryforward");
	find mustInstanceOfLoss_Carryforward_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationregular_accountability_attribute_Loss_Carryforward(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_compensation_by_other_means_attribute_Loss_Carryforward(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"compensation_by_other_means attribute Loss_Carryforward");
	find mustInstanceOfLoss_Carryforward_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationcompensation_by_other_means_attribute_Loss_Carryforward(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_tax_payer_has_inherited_business_ownership_attribute_Loss_Carryforward(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"tax_payer_has_inherited_business_ownership attribute Loss_Carryforward");
	find mustInstanceOfLoss_Carryforward_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationtax_payer_has_inherited_business_ownership_attribute_Loss_Carryforward(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_tax_payer_has_been_partner_in_business_attribute_Loss_Carryforward(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"tax_payer_has_been_partner_in_business attribute Loss_Carryforward");
	find mustInstanceOfLoss_Carryforward_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationtax_payer_has_been_partner_in_business_attribute_Loss_Carryforward(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_thresholded_deduction_percentage_attribute_Extraordinary_Expense_CE(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"thresholded_deduction_percentage attribute Extraordinary_Expense_CE");
	find mustInstanceOfExtraordinary_Expense_CE_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationthresholded_deduction_percentage_attribute_Extraordinary_Expense_CE(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_ce_type_attribute_Extraordinary_Expense_CE(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"ce_type attribute Extraordinary_Expense_CE");
	find mustInstanceOfExtraordinary_Expense_CE_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationce_type_attribute_Extraordinary_Expense_CE(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}

//////////
// 3.2 Unfinishedness Measured by WF Queries
//////////

//////////
// 4. Refinement Indexers
//////////
// 4.1 Object constructors
//////////
private pattern hasElementInContainment(problem:LogicProblem, interpretation:PartialInterpretation)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfLegal_Union_Record_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfDS_for_Donation_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfHealth_and_Pension_Insurance_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfTax_Case_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfInterest_Expense_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfIncome_Tax_Credit_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfAgriculture_and_Forestry_Income_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfAddress_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfCapital_and_Investments_Income_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfTravel_Expense_FD_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfIncome_Detail_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfConstants_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfDS_for_Permanent_Expense_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfDS_for_Private_Insurance_and_Plan_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfCIS_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfDependent_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfSpecial_Expense_DS_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfMiscellaneous_Expense_FO_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfEmployment_Income_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfCIP_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFO_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfLoss_Carryforward_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfDS_for_Health_and_Pension_Insurance_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfTax_Property_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfSpousal_Expense_AC_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfPartnership_Record_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfTax_Payer_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfPensions_and_Annuities_Income_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfPrivate_Insurance_and_Plan_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfTax_Card_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfHabitual_Address_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfHousehold_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfExpense_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfResident_Tax_Payer_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfPermanent_Expense_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFromLaw_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfDonation_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfIncome_Tax_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfRentals_and_Leases_Income_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFD_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfExternal_Allowance_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfExtraordinary_Expense_CE_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfIncome_Type_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfIncome_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfForeign_Income_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFiscal_Address_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFromAgent_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfLocal_Income_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfDS_for_Loss_Carryforward_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfCIM_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfDS_for_Interest_Expense_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfPhysical_Person_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfProfessional_Expenses_Deduction_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfTrade_and_Business_Income_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfDS_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfNon_Resident_Tax_Payer_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfMarriage_Record_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfProfessional_Expense_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}
pattern createObject_Expense_class_by_expenses_reference_Income_with_income_reference_Expense(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Expense class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"expenses reference Income");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"income reference Expense");
	find mustInstanceOfIncome_class(problem,interpretation,container);
	find mayInstanceOfExpense_class(problem,interpretation,newObject);
	find mayInRelationexpenses_reference_Income(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Expense_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Expense class");
	find mayInstanceOfExpense_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Professional_Expense_class_by_expenses_reference_Income_with_income_reference_Expense(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Professional_Expense class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"expenses reference Income");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"income reference Expense");
	find mustInstanceOfIncome_class(problem,interpretation,container);
	find mayInstanceOfProfessional_Expense_class(problem,interpretation,newObject);
	find mayInRelationexpenses_reference_Income(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Professional_Expense_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Professional_Expense class");
	find mayInstanceOfProfessional_Expense_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Address_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Address class");
	find mayInstanceOfAddress_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Foreign_Income_class_by_incomes_reference_Tax_Payer_with_taxPayer_reference_Income(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Foreign_Income class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"incomes reference Tax_Payer");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"taxPayer reference Income");
	find mustInstanceOfTax_Payer_class(problem,interpretation,container);
	find mayInstanceOfForeign_Income_class(problem,interpretation,newObject);
	find mayInRelationincomes_reference_Tax_Payer(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Foreign_Income_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Foreign_Income class");
	find mayInstanceOfForeign_Income_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Resident_Tax_Payer_class_by_individual_A_reference_Legal_Union_Record(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Resident_Tax_Payer class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"individual_A reference Legal_Union_Record");
	find mustInstanceOfLegal_Union_Record_class(problem,interpretation,container);
	find mayInstanceOfResident_Tax_Payer_class(problem,interpretation,newObject);
	find mayInRelationindividual_A_reference_Legal_Union_Record(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Resident_Tax_Payer_class_by_individual_B_reference_Legal_Union_Record(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Resident_Tax_Payer class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"individual_B reference Legal_Union_Record");
	find mustInstanceOfLegal_Union_Record_class(problem,interpretation,container);
	find mayInstanceOfResident_Tax_Payer_class(problem,interpretation,newObject);
	find mayInRelationindividual_B_reference_Legal_Union_Record(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Resident_Tax_Payer_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Resident_Tax_Payer class");
	find mayInstanceOfResident_Tax_Payer_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_CIS_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"CIS class");
	find mayInstanceOfCIS_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Special_Expense_DS_class_by_expenses_reference_Income_with_income_reference_Expense(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Special_Expense_DS class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"expenses reference Income");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"income reference Expense");
	find mustInstanceOfIncome_class(problem,interpretation,container);
	find mayInstanceOfSpecial_Expense_DS_class(problem,interpretation,newObject);
	find mayInRelationexpenses_reference_Income(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Special_Expense_DS_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Special_Expense_DS class");
	find mayInstanceOfSpecial_Expense_DS_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_CIP_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"CIP class");
	find mayInstanceOfCIP_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Income_Tax_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Income_Tax class");
	find mayInstanceOfIncome_Tax_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Physical_Person_class_by_individual_A_reference_Legal_Union_Record(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Physical_Person class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"individual_A reference Legal_Union_Record");
	find mustInstanceOfLegal_Union_Record_class(problem,interpretation,container);
	find mayInstanceOfPhysical_Person_class(problem,interpretation,newObject);
	find mayInRelationindividual_A_reference_Legal_Union_Record(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Physical_Person_class_by_individual_B_reference_Legal_Union_Record(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Physical_Person class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"individual_B reference Legal_Union_Record");
	find mustInstanceOfLegal_Union_Record_class(problem,interpretation,container);
	find mayInstanceOfPhysical_Person_class(problem,interpretation,newObject);
	find mayInRelationindividual_B_reference_Legal_Union_Record(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Physical_Person_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Physical_Person class");
	find mayInstanceOfPhysical_Person_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Professional_Expenses_Deduction_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Professional_Expenses_Deduction class");
	find mayInstanceOfProfessional_Expenses_Deduction_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Interest_Expense_class_by_expenses_reference_Income_with_income_reference_Expense(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Interest_Expense class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"expenses reference Income");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"income reference Expense");
	find mustInstanceOfIncome_class(problem,interpretation,container);
	find mayInstanceOfInterest_Expense_class(problem,interpretation,newObject);
	find mayInRelationexpenses_reference_Income(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Interest_Expense_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Interest_Expense class");
	find mayInstanceOfInterest_Expense_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_DS_for_Health_and_Pension_Insurance_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"DS_for_Health_and_Pension_Insurance class");
	find mayInstanceOfDS_for_Health_and_Pension_Insurance_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Tax_Card_class_by_tax_card_reference_Income_with_income_reference_Tax_Card(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Tax_Card class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"tax_card reference Income");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"income reference Tax_Card");
	find mustInstanceOfIncome_class(problem,interpretation,container);
	find mayInstanceOfTax_Card_class(problem,interpretation,newObject);
	find mayInRelationtax_card_reference_Income(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Tax_Card_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Tax_Card class");
	find mayInstanceOfTax_Card_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Donation_class_by_expenses_reference_Income_with_income_reference_Expense(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Donation class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"expenses reference Income");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"income reference Expense");
	find mustInstanceOfIncome_class(problem,interpretation,container);
	find mayInstanceOfDonation_class(problem,interpretation,newObject);
	find mayInRelationexpenses_reference_Income(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Donation_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Donation class");
	find mayInstanceOfDonation_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FromAgent_class_by_from_agent_reference_Tax_Payer_with_taxPayer_reference_FromAgent(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FromAgent class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"from_agent reference Tax_Payer");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"taxPayer reference FromAgent");
	find mustInstanceOfTax_Payer_class(problem,interpretation,container);
	find mayInstanceOfFromAgent_class(problem,interpretation,newObject);
	find mayInRelationfrom_agent_reference_Tax_Payer(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FromAgent_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FromAgent class");
	find mayInstanceOfFromAgent_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Capital_and_Investments_Income_class_by_income_type_reference_Income_with_income_reference_Income_Type(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Capital_and_Investments_Income class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"income_type reference Income");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"income reference Income_Type");
	find mustInstanceOfIncome_class(problem,interpretation,container);
	find mayInstanceOfCapital_and_Investments_Income_class(problem,interpretation,newObject);
	find mayInRelationincome_type_reference_Income(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Capital_and_Investments_Income_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Capital_and_Investments_Income class");
	find mayInstanceOfCapital_and_Investments_Income_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_DS_for_Permanent_Expense_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"DS_for_Permanent_Expense class");
	find mayInstanceOfDS_for_Permanent_Expense_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Rentals_and_Leases_Income_class_by_income_type_reference_Income_with_income_reference_Income_Type(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Rentals_and_Leases_Income class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"income_type reference Income");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"income reference Income_Type");
	find mustInstanceOfIncome_class(problem,interpretation,container);
	find mayInstanceOfRentals_and_Leases_Income_class(problem,interpretation,newObject);
	find mayInRelationincome_type_reference_Income(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Rentals_and_Leases_Income_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Rentals_and_Leases_Income class");
	find mayInstanceOfRentals_and_Leases_Income_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Permanent_Expense_class_by_expenses_reference_Income_with_income_reference_Expense(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Permanent_Expense class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"expenses reference Income");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"income reference Expense");
	find mustInstanceOfIncome_class(problem,interpretation,container);
	find mayInstanceOfPermanent_Expense_class(problem,interpretation,newObject);
	find mayInRelationexpenses_reference_Income(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Permanent_Expense_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Permanent_Expense class");
	find mayInstanceOfPermanent_Expense_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Miscellaneous_Expense_FO_class_by_expenses_reference_Income_with_income_reference_Expense(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Miscellaneous_Expense_FO class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"expenses reference Income");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"income reference Expense");
	find mustInstanceOfIncome_class(problem,interpretation,container);
	find mayInstanceOfMiscellaneous_Expense_FO_class(problem,interpretation,newObject);
	find mayInRelationexpenses_reference_Income(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Miscellaneous_Expense_FO_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Miscellaneous_Expense_FO class");
	find mayInstanceOfMiscellaneous_Expense_FO_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Tax_Property_class_by_properties_reference_Legal_Union_Record_with_union_record_reference_Tax_Property(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Tax_Property class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"properties reference Legal_Union_Record");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"union_record reference Tax_Property");
	find mustInstanceOfLegal_Union_Record_class(problem,interpretation,container);
	find mayInstanceOfTax_Property_class(problem,interpretation,newObject);
	find mayInRelationproperties_reference_Legal_Union_Record(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Tax_Property_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Tax_Property class");
	find mayInstanceOfTax_Property_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_DS_for_Donation_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"DS_for_Donation class");
	find mayInstanceOfDS_for_Donation_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Loss_Carryforward_class_by_expenses_reference_Income_with_income_reference_Expense(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Loss_Carryforward class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"expenses reference Income");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"income reference Expense");
	find mustInstanceOfIncome_class(problem,interpretation,container);
	find mayInstanceOfLoss_Carryforward_class(problem,interpretation,newObject);
	find mayInRelationexpenses_reference_Income(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Loss_Carryforward_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Loss_Carryforward class");
	find mayInstanceOfLoss_Carryforward_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Employment_Income_class_by_income_type_reference_Income_with_income_reference_Income_Type(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Employment_Income class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"income_type reference Income");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"income reference Income_Type");
	find mustInstanceOfIncome_class(problem,interpretation,container);
	find mayInstanceOfEmployment_Income_class(problem,interpretation,newObject);
	find mayInRelationincome_type_reference_Income(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Employment_Income_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Employment_Income class");
	find mayInstanceOfEmployment_Income_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Household_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Household class");
	find mayInstanceOfHousehold_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Agriculture_and_Forestry_Income_class_by_income_type_reference_Income_with_income_reference_Income_Type(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Agriculture_and_Forestry_Income class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"income_type reference Income");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"income reference Income_Type");
	find mustInstanceOfIncome_class(problem,interpretation,container);
	find mayInstanceOfAgriculture_and_Forestry_Income_class(problem,interpretation,newObject);
	find mayInRelationincome_type_reference_Income(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Agriculture_and_Forestry_Income_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Agriculture_and_Forestry_Income class");
	find mayInstanceOfAgriculture_and_Forestry_Income_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Habitual_Address_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Habitual_Address class");
	find mayInstanceOfHabitual_Address_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_DS_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"DS class");
	find mayInstanceOfDS_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Fiscal_Address_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Fiscal_Address class");
	find mayInstanceOfFiscal_Address_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FO_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FO class");
	find mayInstanceOfFO_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Pensions_and_Annuities_Income_class_by_income_type_reference_Income_with_income_reference_Income_Type(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Pensions_and_Annuities_Income class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"income_type reference Income");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"income reference Income_Type");
	find mustInstanceOfIncome_class(problem,interpretation,container);
	find mayInstanceOfPensions_and_Annuities_Income_class(problem,interpretation,newObject);
	find mayInRelationincome_type_reference_Income(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Pensions_and_Annuities_Income_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Pensions_and_Annuities_Income class");
	find mayInstanceOfPensions_and_Annuities_Income_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_DS_for_Loss_Carryforward_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"DS_for_Loss_Carryforward class");
	find mayInstanceOfDS_for_Loss_Carryforward_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Spousal_Expense_AC_class_by_expenses_reference_Income_with_income_reference_Expense(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Spousal_Expense_AC class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"expenses reference Income");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"income reference Expense");
	find mustInstanceOfIncome_class(problem,interpretation,container);
	find mayInstanceOfSpousal_Expense_AC_class(problem,interpretation,newObject);
	find mayInRelationexpenses_reference_Income(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Spousal_Expense_AC_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Spousal_Expense_AC class");
	find mayInstanceOfSpousal_Expense_AC_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Local_Income_class_by_incomes_reference_Tax_Payer_with_taxPayer_reference_Income(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Local_Income class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"incomes reference Tax_Payer");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"taxPayer reference Income");
	find mustInstanceOfTax_Payer_class(problem,interpretation,container);
	find mayInstanceOfLocal_Income_class(problem,interpretation,newObject);
	find mayInRelationincomes_reference_Tax_Payer(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Local_Income_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Local_Income class");
	find mayInstanceOfLocal_Income_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Extraordinary_Expense_CE_class_by_expenses_reference_Income_with_income_reference_Expense(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Extraordinary_Expense_CE class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"expenses reference Income");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"income reference Expense");
	find mustInstanceOfIncome_class(problem,interpretation,container);
	find mayInstanceOfExtraordinary_Expense_CE_class(problem,interpretation,newObject);
	find mayInRelationexpenses_reference_Income(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Extraordinary_Expense_CE_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Extraordinary_Expense_CE class");
	find mayInstanceOfExtraordinary_Expense_CE_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Private_Insurance_and_Plan_class_by_expenses_reference_Income_with_income_reference_Expense(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Private_Insurance_and_Plan class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"expenses reference Income");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"income reference Expense");
	find mustInstanceOfIncome_class(problem,interpretation,container);
	find mayInstanceOfPrivate_Insurance_and_Plan_class(problem,interpretation,newObject);
	find mayInRelationexpenses_reference_Income(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Private_Insurance_and_Plan_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Private_Insurance_and_Plan class");
	find mayInstanceOfPrivate_Insurance_and_Plan_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_DS_for_Interest_Expense_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"DS_for_Interest_Expense class");
	find mayInstanceOfDS_for_Interest_Expense_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Health_and_Pension_Insurance_class_by_expenses_reference_Income_with_income_reference_Expense(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Health_and_Pension_Insurance class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"expenses reference Income");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"income reference Expense");
	find mustInstanceOfIncome_class(problem,interpretation,container);
	find mayInstanceOfHealth_and_Pension_Insurance_class(problem,interpretation,newObject);
	find mayInRelationexpenses_reference_Income(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Health_and_Pension_Insurance_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Health_and_Pension_Insurance class");
	find mayInstanceOfHealth_and_Pension_Insurance_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Travel_Expense_FD_class_by_expenses_reference_Income_with_income_reference_Expense(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Travel_Expense_FD class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"expenses reference Income");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"income reference Expense");
	find mustInstanceOfIncome_class(problem,interpretation,container);
	find mayInstanceOfTravel_Expense_FD_class(problem,interpretation,newObject);
	find mayInRelationexpenses_reference_Income(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Travel_Expense_FD_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Travel_Expense_FD class");
	find mayInstanceOfTravel_Expense_FD_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Trade_and_Business_Income_class_by_income_type_reference_Income_with_income_reference_Income_Type(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Trade_and_Business_Income class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"income_type reference Income");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"income reference Income_Type");
	find mustInstanceOfIncome_class(problem,interpretation,container);
	find mayInstanceOfTrade_and_Business_Income_class(problem,interpretation,newObject);
	find mayInRelationincome_type_reference_Income(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Trade_and_Business_Income_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Trade_and_Business_Income class");
	find mayInstanceOfTrade_and_Business_Income_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FromLaw_class_by_from_law_reference_Tax_Payer_with_taxPayer_reference_FromLaw(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FromLaw class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"from_law reference Tax_Payer");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"taxPayer reference FromLaw");
	find mustInstanceOfTax_Payer_class(problem,interpretation,container);
	find mayInstanceOfFromLaw_class(problem,interpretation,newObject);
	find mayInRelationfrom_law_reference_Tax_Payer(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FromLaw_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FromLaw class");
	find mayInstanceOfFromLaw_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FD_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FD class");
	find mayInstanceOfFD_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Non_Resident_Tax_Payer_class_by_individual_A_reference_Legal_Union_Record(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Non_Resident_Tax_Payer class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"individual_A reference Legal_Union_Record");
	find mustInstanceOfLegal_Union_Record_class(problem,interpretation,container);
	find mayInstanceOfNon_Resident_Tax_Payer_class(problem,interpretation,newObject);
	find mayInRelationindividual_A_reference_Legal_Union_Record(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Non_Resident_Tax_Payer_class_by_individual_B_reference_Legal_Union_Record(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Non_Resident_Tax_Payer class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"individual_B reference Legal_Union_Record");
	find mustInstanceOfLegal_Union_Record_class(problem,interpretation,container);
	find mayInstanceOfNon_Resident_Tax_Payer_class(problem,interpretation,newObject);
	find mayInRelationindividual_B_reference_Legal_Union_Record(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Non_Resident_Tax_Payer_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Non_Resident_Tax_Payer class");
	find mayInstanceOfNon_Resident_Tax_Payer_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Marriage_Record_class_by_parents_reference_Household_with_household_reference_Legal_Union_Record(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Marriage_Record class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"parents reference Household");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"household reference Legal_Union_Record");
	find mustInstanceOfHousehold_class(problem,interpretation,container);
	find mayInstanceOfMarriage_Record_class(problem,interpretation,newObject);
	find mayInRelationparents_reference_Household(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Marriage_Record_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Marriage_Record class");
	find mayInstanceOfMarriage_Record_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Dependent_class_by_dependents_reference_Tax_Payer_with_responsible_person_reference_Dependent(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Dependent class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"dependents reference Tax_Payer");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"responsible_person reference Dependent");
	find mustInstanceOfTax_Payer_class(problem,interpretation,container);
	find mayInstanceOfDependent_class(problem,interpretation,newObject);
	find mayInRelationdependents_reference_Tax_Payer(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Dependent_class_by_children_reference_Household_with_household_reference_Dependent(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Dependent class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"children reference Household");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"household reference Dependent");
	find mustInstanceOfHousehold_class(problem,interpretation,container);
	find mayInstanceOfDependent_class(problem,interpretation,newObject);
	find mayInRelationchildren_reference_Household(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Dependent_class_by_individual_A_reference_Legal_Union_Record(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Dependent class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"individual_A reference Legal_Union_Record");
	find mustInstanceOfLegal_Union_Record_class(problem,interpretation,container);
	find mayInstanceOfDependent_class(problem,interpretation,newObject);
	find mayInRelationindividual_A_reference_Legal_Union_Record(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Dependent_class_by_individual_B_reference_Legal_Union_Record(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Dependent class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"individual_B reference Legal_Union_Record");
	find mustInstanceOfLegal_Union_Record_class(problem,interpretation,container);
	find mayInstanceOfDependent_class(problem,interpretation,newObject);
	find mayInRelationindividual_B_reference_Legal_Union_Record(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Dependent_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Dependent class");
	find mayInstanceOfDependent_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Partnership_Record_class_by_parents_reference_Household_with_household_reference_Legal_Union_Record(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Partnership_Record class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"parents reference Household");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"household reference Legal_Union_Record");
	find mustInstanceOfHousehold_class(problem,interpretation,container);
	find mayInstanceOfPartnership_Record_class(problem,interpretation,newObject);
	find mayInRelationparents_reference_Household(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Partnership_Record_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Partnership_Record class");
	find mayInstanceOfPartnership_Record_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_External_Allowance_class_by_allowances_reference_Dependent_with_person_reference_External_Allowance(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"External_Allowance class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"allowances reference Dependent");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"person reference External_Allowance");
	find mustInstanceOfDependent_class(problem,interpretation,container);
	find mayInstanceOfExternal_Allowance_class(problem,interpretation,newObject);
	find mayInRelationallowances_reference_Dependent(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_External_Allowance_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"External_Allowance class");
	find mayInstanceOfExternal_Allowance_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Income_Tax_Credit_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Income_Tax_Credit class");
	find mayInstanceOfIncome_Tax_Credit_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Income_Detail_class_by_details_reference_Income_with_income_reference_Income_Detail(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Income_Detail class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"details reference Income");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"income reference Income_Detail");
	find mustInstanceOfIncome_class(problem,interpretation,container);
	find mayInstanceOfIncome_Detail_class(problem,interpretation,newObject);
	find mayInRelationdetails_reference_Income(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Income_Detail_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Income_Detail class");
	find mayInstanceOfIncome_Detail_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_DS_for_Private_Insurance_and_Plan_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"DS_for_Private_Insurance_and_Plan class");
	find mayInstanceOfDS_for_Private_Insurance_and_Plan_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_CIM_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"CIM class");
	find mayInstanceOfCIM_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}

//////////
// 4.2 Type refinement
//////////
pattern refineTypeTo_Expense_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfExpense_class(problem,interpretation,element);
	neg find mustInstanceOfFromAgent_class(problem,interpretation,element);
	neg find mustInstanceOfFromLaw_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Case_class(problem,interpretation,element);
	neg find mustInstanceOfProfessional_Expense_class(problem,interpretation,element);
	neg find mustInstanceOfConstants_class(problem,interpretation,element);
	neg find mustInstanceOfExpense_class(problem,interpretation,element);
	neg find mustInstanceOfAddress_class(problem,interpretation,element);
	neg find mustInstanceOfDS_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Type_class(problem,interpretation,element);
	neg find mustInstanceOfSpecial_Expense_DS_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_class(problem,interpretation,element);
	neg find mustInstanceOfPhysical_Person_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Property_class(problem,interpretation,element);
	neg find mustInstanceOfSpousal_Expense_AC_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_class(problem,interpretation,element);
	neg find mustInstanceOfProfessional_Expenses_Deduction_class(problem,interpretation,element);
	neg find mustInstanceOfExtraordinary_Expense_CE_class(problem,interpretation,element);
	neg find mustInstanceOfExternal_Allowance_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_Credit_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Detail_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Card_class(problem,interpretation,element);
	neg find mustInstanceOfLegal_Union_Record_class(problem,interpretation,element);
}
pattern refineTypeTo_Professional_Expense_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfProfessional_Expense_class(problem,interpretation,element);
	neg find mustInstanceOfFromAgent_class(problem,interpretation,element);
	neg find mustInstanceOfFromLaw_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Case_class(problem,interpretation,element);
	neg find mustInstanceOfProfessional_Expense_class(problem,interpretation,element);
	neg find mustInstanceOfConstants_class(problem,interpretation,element);
	neg find mustInstanceOfAddress_class(problem,interpretation,element);
	neg find mustInstanceOfDS_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Type_class(problem,interpretation,element);
	neg find mustInstanceOfSpecial_Expense_DS_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_class(problem,interpretation,element);
	neg find mustInstanceOfPhysical_Person_class(problem,interpretation,element);
	neg find mustInstanceOfMiscellaneous_Expense_FO_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Property_class(problem,interpretation,element);
	neg find mustInstanceOfSpousal_Expense_AC_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_class(problem,interpretation,element);
	neg find mustInstanceOfProfessional_Expenses_Deduction_class(problem,interpretation,element);
	neg find mustInstanceOfExternal_Allowance_class(problem,interpretation,element);
	neg find mustInstanceOfExtraordinary_Expense_CE_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_Credit_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Detail_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Card_class(problem,interpretation,element);
	neg find mustInstanceOfTravel_Expense_FD_class(problem,interpretation,element);
	neg find mustInstanceOfLegal_Union_Record_class(problem,interpretation,element);
}
pattern refineTypeTo_Address_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfAddress_class(problem,interpretation,element);
	neg find mustInstanceOfFromAgent_class(problem,interpretation,element);
	neg find mustInstanceOfFromLaw_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Case_class(problem,interpretation,element);
	neg find mustInstanceOfExpense_class(problem,interpretation,element);
	neg find mustInstanceOfConstants_class(problem,interpretation,element);
	neg find mustInstanceOfAddress_class(problem,interpretation,element);
	neg find mustInstanceOfDS_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Type_class(problem,interpretation,element);
	neg find mustInstanceOfPhysical_Person_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_class(problem,interpretation,element);
	neg find mustInstanceOfFiscal_Address_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Property_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_class(problem,interpretation,element);
	neg find mustInstanceOfProfessional_Expenses_Deduction_class(problem,interpretation,element);
	neg find mustInstanceOfExternal_Allowance_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Detail_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_Credit_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Card_class(problem,interpretation,element);
	neg find mustInstanceOfLegal_Union_Record_class(problem,interpretation,element);
	neg find mustInstanceOfHabitual_Address_class(problem,interpretation,element);
}
pattern refineTypeTo_Foreign_Income_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfForeign_Income_class(problem,interpretation,element);
	neg find mustInstanceOfFromAgent_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Case_class(problem,interpretation,element);
	neg find mustInstanceOfFromLaw_class(problem,interpretation,element);
	neg find mustInstanceOfExpense_class(problem,interpretation,element);
	neg find mustInstanceOfConstants_class(problem,interpretation,element);
	neg find mustInstanceOfAddress_class(problem,interpretation,element);
	neg find mustInstanceOfForeign_Income_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Type_class(problem,interpretation,element);
	neg find mustInstanceOfDS_class(problem,interpretation,element);
	neg find mustInstanceOfPhysical_Person_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Property_class(problem,interpretation,element);
	neg find mustInstanceOfLocal_Income_class(problem,interpretation,element);
	neg find mustInstanceOfProfessional_Expenses_Deduction_class(problem,interpretation,element);
	neg find mustInstanceOfExternal_Allowance_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Detail_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_Credit_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Card_class(problem,interpretation,element);
	neg find mustInstanceOfLegal_Union_Record_class(problem,interpretation,element);
}
pattern refineTypeTo_Resident_Tax_Payer_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfResident_Tax_Payer_class(problem,interpretation,element);
	neg find mustInstanceOfFromAgent_class(problem,interpretation,element);
	neg find mustInstanceOfFromLaw_class(problem,interpretation,element);
	neg find mustInstanceOfExpense_class(problem,interpretation,element);
	neg find mustInstanceOfConstants_class(problem,interpretation,element);
	neg find mustInstanceOfAddress_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Type_class(problem,interpretation,element);
	neg find mustInstanceOfDS_class(problem,interpretation,element);
	neg find mustInstanceOfResident_Tax_Payer_class(problem,interpretation,element);
	neg find mustInstanceOfNon_Resident_Tax_Payer_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Property_class(problem,interpretation,element);
	neg find mustInstanceOfDependent_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_class(problem,interpretation,element);
	neg find mustInstanceOfProfessional_Expenses_Deduction_class(problem,interpretation,element);
	neg find mustInstanceOfExternal_Allowance_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_Credit_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Detail_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Card_class(problem,interpretation,element);
	neg find mustInstanceOfHousehold_class(problem,interpretation,element);
	neg find mustInstanceOfLegal_Union_Record_class(problem,interpretation,element);
}
pattern refineTypeTo_CIS_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfCIS_class(problem,interpretation,element);
	neg find mustInstanceOfFromAgent_class(problem,interpretation,element);
	neg find mustInstanceOfFromLaw_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Case_class(problem,interpretation,element);
	neg find mustInstanceOfConstants_class(problem,interpretation,element);
	neg find mustInstanceOfExpense_class(problem,interpretation,element);
	neg find mustInstanceOfAddress_class(problem,interpretation,element);
	neg find mustInstanceOfDS_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Type_class(problem,interpretation,element);
	neg find mustInstanceOfCIP_class(problem,interpretation,element);
	neg find mustInstanceOfCIS_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_class(problem,interpretation,element);
	neg find mustInstanceOfPhysical_Person_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Property_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_class(problem,interpretation,element);
	neg find mustInstanceOfProfessional_Expenses_Deduction_class(problem,interpretation,element);
	neg find mustInstanceOfExternal_Allowance_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Detail_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Card_class(problem,interpretation,element);
	neg find mustInstanceOfCIM_class(problem,interpretation,element);
	neg find mustInstanceOfLegal_Union_Record_class(problem,interpretation,element);
}
pattern refineTypeTo_Special_Expense_DS_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfSpecial_Expense_DS_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Case_class(problem,interpretation,element);
	neg find mustInstanceOfProfessional_Expense_class(problem,interpretation,element);
	neg find mustInstanceOfAddress_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Type_class(problem,interpretation,element);
	neg find mustInstanceOfDS_class(problem,interpretation,element);
	neg find mustInstanceOfSpecial_Expense_DS_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_class(problem,interpretation,element);
	neg find mustInstanceOfPhysical_Person_class(problem,interpretation,element);
	neg find mustInstanceOfSpousal_Expense_AC_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_class(problem,interpretation,element);
	neg find mustInstanceOfProfessional_Expenses_Deduction_class(problem,interpretation,element);
	neg find mustInstanceOfInterest_Expense_class(problem,interpretation,element);
	neg find mustInstanceOfExtraordinary_Expense_CE_class(problem,interpretation,element);
	neg find mustInstanceOfPrivate_Insurance_and_Plan_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Card_class(problem,interpretation,element);
	neg find mustInstanceOfHealth_and_Pension_Insurance_class(problem,interpretation,element);
	neg find mustInstanceOfDonation_class(problem,interpretation,element);
	neg find mustInstanceOfFromAgent_class(problem,interpretation,element);
	neg find mustInstanceOfFromLaw_class(problem,interpretation,element);
	neg find mustInstanceOfConstants_class(problem,interpretation,element);
	neg find mustInstanceOfPermanent_Expense_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Property_class(problem,interpretation,element);
	neg find mustInstanceOfLoss_Carryforward_class(problem,interpretation,element);
	neg find mustInstanceOfExternal_Allowance_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_Credit_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Detail_class(problem,interpretation,element);
	neg find mustInstanceOfLegal_Union_Record_class(problem,interpretation,element);
}
pattern refineTypeTo_CIP_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfCIP_class(problem,interpretation,element);
	neg find mustInstanceOfFromAgent_class(problem,interpretation,element);
	neg find mustInstanceOfFromLaw_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Case_class(problem,interpretation,element);
	neg find mustInstanceOfConstants_class(problem,interpretation,element);
	neg find mustInstanceOfExpense_class(problem,interpretation,element);
	neg find mustInstanceOfAddress_class(problem,interpretation,element);
	neg find mustInstanceOfDS_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Type_class(problem,interpretation,element);
	neg find mustInstanceOfCIS_class(problem,interpretation,element);
	neg find mustInstanceOfCIP_class(problem,interpretation,element);
	neg find mustInstanceOfPhysical_Person_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Property_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_class(problem,interpretation,element);
	neg find mustInstanceOfProfessional_Expenses_Deduction_class(problem,interpretation,element);
	neg find mustInstanceOfExternal_Allowance_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Detail_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Card_class(problem,interpretation,element);
	neg find mustInstanceOfCIM_class(problem,interpretation,element);
	neg find mustInstanceOfLegal_Union_Record_class(problem,interpretation,element);
}
pattern refineTypeTo_Income_Tax_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfIncome_Tax_class(problem,interpretation,element);
	neg find mustInstanceOfFromAgent_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Case_class(problem,interpretation,element);
	neg find mustInstanceOfFromLaw_class(problem,interpretation,element);
	neg find mustInstanceOfConstants_class(problem,interpretation,element);
	neg find mustInstanceOfExpense_class(problem,interpretation,element);
	neg find mustInstanceOfAddress_class(problem,interpretation,element);
	neg find mustInstanceOfDS_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Type_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_class(problem,interpretation,element);
	neg find mustInstanceOfPhysical_Person_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Property_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_class(problem,interpretation,element);
	neg find mustInstanceOfProfessional_Expenses_Deduction_class(problem,interpretation,element);
	neg find mustInstanceOfExternal_Allowance_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_Credit_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Detail_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Card_class(problem,interpretation,element);
	neg find mustInstanceOfLegal_Union_Record_class(problem,interpretation,element);
}
pattern refineTypeTo_Physical_Person_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfPhysical_Person_class(problem,interpretation,element);
	neg find mustInstanceOfFromAgent_class(problem,interpretation,element);
	neg find mustInstanceOfFromLaw_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Case_class(problem,interpretation,element);
	neg find mustInstanceOfExpense_class(problem,interpretation,element);
	neg find mustInstanceOfConstants_class(problem,interpretation,element);
	neg find mustInstanceOfAddress_class(problem,interpretation,element);
	neg find mustInstanceOfDS_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Type_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_class(problem,interpretation,element);
	neg find mustInstanceOfPhysical_Person_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Property_class(problem,interpretation,element);
	neg find mustInstanceOfDependent_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_class(problem,interpretation,element);
	neg find mustInstanceOfProfessional_Expenses_Deduction_class(problem,interpretation,element);
	neg find mustInstanceOfExternal_Allowance_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_Credit_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Detail_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Card_class(problem,interpretation,element);
	neg find mustInstanceOfLegal_Union_Record_class(problem,interpretation,element);
}
pattern refineTypeTo_Professional_Expenses_Deduction_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfProfessional_Expenses_Deduction_class(problem,interpretation,element);
	neg find mustInstanceOfFromAgent_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Case_class(problem,interpretation,element);
	neg find mustInstanceOfFromLaw_class(problem,interpretation,element);
	neg find mustInstanceOfExpense_class(problem,interpretation,element);
	neg find mustInstanceOfConstants_class(problem,interpretation,element);
	neg find mustInstanceOfFD_class(problem,interpretation,element);
	neg find mustInstanceOfAddress_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Type_class(problem,interpretation,element);
	neg find mustInstanceOfDS_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_class(problem,interpretation,element);
	neg find mustInstanceOfPhysical_Person_class(problem,interpretation,element);
	neg find mustInstanceOfFO_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Property_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_class(problem,interpretation,element);
	neg find mustInstanceOfProfessional_Expenses_Deduction_class(problem,interpretation,element);
	neg find mustInstanceOfExternal_Allowance_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_Credit_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Detail_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Card_class(problem,interpretation,element);
	neg find mustInstanceOfLegal_Union_Record_class(problem,interpretation,element);
}
pattern refineTypeTo_Interest_Expense_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfInterest_Expense_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Case_class(problem,interpretation,element);
	neg find mustInstanceOfProfessional_Expense_class(problem,interpretation,element);
	neg find mustInstanceOfAddress_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Type_class(problem,interpretation,element);
	neg find mustInstanceOfDS_class(problem,interpretation,element);
	neg find mustInstanceOfPhysical_Person_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_class(problem,interpretation,element);
	neg find mustInstanceOfSpousal_Expense_AC_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_class(problem,interpretation,element);
	neg find mustInstanceOfProfessional_Expenses_Deduction_class(problem,interpretation,element);
	neg find mustInstanceOfInterest_Expense_class(problem,interpretation,element);
	neg find mustInstanceOfExtraordinary_Expense_CE_class(problem,interpretation,element);
	neg find mustInstanceOfPrivate_Insurance_and_Plan_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Card_class(problem,interpretation,element);
	neg find mustInstanceOfDonation_class(problem,interpretation,element);
	neg find mustInstanceOfHealth_and_Pension_Insurance_class(problem,interpretation,element);
	neg find mustInstanceOfFromAgent_class(problem,interpretation,element);
	neg find mustInstanceOfFromLaw_class(problem,interpretation,element);
	neg find mustInstanceOfConstants_class(problem,interpretation,element);
	neg find mustInstanceOfPermanent_Expense_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Property_class(problem,interpretation,element);
	neg find mustInstanceOfLoss_Carryforward_class(problem,interpretation,element);
	neg find mustInstanceOfExternal_Allowance_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Detail_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_Credit_class(problem,interpretation,element);
	neg find mustInstanceOfLegal_Union_Record_class(problem,interpretation,element);
}
pattern refineTypeTo_DS_for_Health_and_Pension_Insurance_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfDS_for_Health_and_Pension_Insurance_class(problem,interpretation,element);
	neg find mustInstanceOfFromAgent_class(problem,interpretation,element);
	neg find mustInstanceOfDS_for_Permanent_Expense_class(problem,interpretation,element);
	neg find mustInstanceOfFromLaw_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Case_class(problem,interpretation,element);
	neg find mustInstanceOfExpense_class(problem,interpretation,element);
	neg find mustInstanceOfConstants_class(problem,interpretation,element);
	neg find mustInstanceOfAddress_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Type_class(problem,interpretation,element);
	neg find mustInstanceOfPhysical_Person_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Property_class(problem,interpretation,element);
	neg find mustInstanceOfDS_for_Loss_Carryforward_class(problem,interpretation,element);
	neg find mustInstanceOfDS_for_Donation_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_class(problem,interpretation,element);
	neg find mustInstanceOfProfessional_Expenses_Deduction_class(problem,interpretation,element);
	neg find mustInstanceOfExternal_Allowance_class(problem,interpretation,element);
	neg find mustInstanceOfDS_for_Interest_Expense_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Detail_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_Credit_class(problem,interpretation,element);
	neg find mustInstanceOfDS_for_Health_and_Pension_Insurance_class(problem,interpretation,element);
	neg find mustInstanceOfDS_for_Private_Insurance_and_Plan_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Card_class(problem,interpretation,element);
	neg find mustInstanceOfLegal_Union_Record_class(problem,interpretation,element);
}
pattern refineTypeTo_Tax_Card_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfTax_Card_class(problem,interpretation,element);
	neg find mustInstanceOfFromAgent_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Case_class(problem,interpretation,element);
	neg find mustInstanceOfFromLaw_class(problem,interpretation,element);
	neg find mustInstanceOfConstants_class(problem,interpretation,element);
	neg find mustInstanceOfExpense_class(problem,interpretation,element);
	neg find mustInstanceOfAddress_class(problem,interpretation,element);
	neg find mustInstanceOfDS_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Type_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_class(problem,interpretation,element);
	neg find mustInstanceOfPhysical_Person_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Property_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_class(problem,interpretation,element);
	neg find mustInstanceOfProfessional_Expenses_Deduction_class(problem,interpretation,element);
	neg find mustInstanceOfExternal_Allowance_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Detail_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_Credit_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Card_class(problem,interpretation,element);
	neg find mustInstanceOfLegal_Union_Record_class(problem,interpretation,element);
}
pattern refineTypeTo_Donation_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfDonation_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Case_class(problem,interpretation,element);
	neg find mustInstanceOfProfessional_Expense_class(problem,interpretation,element);
	neg find mustInstanceOfAddress_class(problem,interpretation,element);
	neg find mustInstanceOfDS_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Type_class(problem,interpretation,element);
	neg find mustInstanceOfPhysical_Person_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_class(problem,interpretation,element);
	neg find mustInstanceOfSpousal_Expense_AC_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_class(problem,interpretation,element);
	neg find mustInstanceOfProfessional_Expenses_Deduction_class(problem,interpretation,element);
	neg find mustInstanceOfInterest_Expense_class(problem,interpretation,element);
	neg find mustInstanceOfExtraordinary_Expense_CE_class(problem,interpretation,element);
	neg find mustInstanceOfPrivate_Insurance_and_Plan_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Card_class(problem,interpretation,element);
	neg find mustInstanceOfDonation_class(problem,interpretation,element);
	neg find mustInstanceOfHealth_and_Pension_Insurance_class(problem,interpretation,element);
	neg find mustInstanceOfFromAgent_class(problem,interpretation,element);
	neg find mustInstanceOfFromLaw_class(problem,interpretation,element);
	neg find mustInstanceOfConstants_class(problem,interpretation,element);
	neg find mustInstanceOfPermanent_Expense_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Property_class(problem,interpretation,element);
	neg find mustInstanceOfLoss_Carryforward_class(problem,interpretation,element);
	neg find mustInstanceOfExternal_Allowance_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Detail_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_Credit_class(problem,interpretation,element);
	neg find mustInstanceOfLegal_Union_Record_class(problem,interpretation,element);
}
pattern refineTypeTo_FromAgent_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFromAgent_class(problem,interpretation,element);
	neg find mustInstanceOfFromAgent_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Case_class(problem,interpretation,element);
	neg find mustInstanceOfFromLaw_class(problem,interpretation,element);
	neg find mustInstanceOfExpense_class(problem,interpretation,element);
	neg find mustInstanceOfConstants_class(problem,interpretation,element);
	neg find mustInstanceOfAddress_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Type_class(problem,interpretation,element);
	neg find mustInstanceOfDS_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_class(problem,interpretation,element);
	neg find mustInstanceOfPhysical_Person_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Property_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_class(problem,interpretation,element);
	neg find mustInstanceOfProfessional_Expenses_Deduction_class(problem,interpretation,element);
	neg find mustInstanceOfExternal_Allowance_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Detail_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_Credit_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Card_class(problem,interpretation,element);
	neg find mustInstanceOfLegal_Union_Record_class(problem,interpretation,element);
}
pattern refineTypeTo_Capital_and_Investments_Income_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfCapital_and_Investments_Income_class(problem,interpretation,element);
	neg find mustInstanceOfFromAgent_class(problem,interpretation,element);
	neg find mustInstanceOfFromLaw_class(problem,interpretation,element);
	neg find mustInstanceOfCapital_and_Investments_Income_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Case_class(problem,interpretation,element);
	neg find mustInstanceOfRentals_and_Leases_Income_class(problem,interpretation,element);
	neg find mustInstanceOfExpense_class(problem,interpretation,element);
	neg find mustInstanceOfConstants_class(problem,interpretation,element);
	neg find mustInstanceOfAddress_class(problem,interpretation,element);
	neg find mustInstanceOfDS_class(problem,interpretation,element);
	neg find mustInstanceOfPhysical_Person_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_class(problem,interpretation,element);
	neg find mustInstanceOfPensions_and_Annuities_Income_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Property_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_class(problem,interpretation,element);
	neg find mustInstanceOfProfessional_Expenses_Deduction_class(problem,interpretation,element);
	neg find mustInstanceOfEmployment_Income_class(problem,interpretation,element);
	neg find mustInstanceOfExternal_Allowance_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_Credit_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Detail_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Card_class(problem,interpretation,element);
	neg find mustInstanceOfLegal_Union_Record_class(problem,interpretation,element);
	neg find mustInstanceOfAgriculture_and_Forestry_Income_class(problem,interpretation,element);
	neg find mustInstanceOfTrade_and_Business_Income_class(problem,interpretation,element);
}
pattern refineTypeTo_DS_for_Permanent_Expense_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfDS_for_Permanent_Expense_class(problem,interpretation,element);
	neg find mustInstanceOfFromAgent_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Case_class(problem,interpretation,element);
	neg find mustInstanceOfFromLaw_class(problem,interpretation,element);
	neg find mustInstanceOfDS_for_Permanent_Expense_class(problem,interpretation,element);
	neg find mustInstanceOfExpense_class(problem,interpretation,element);
	neg find mustInstanceOfConstants_class(problem,interpretation,element);
	neg find mustInstanceOfAddress_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Type_class(problem,interpretation,element);
	neg find mustInstanceOfPhysical_Person_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Property_class(problem,interpretation,element);
	neg find mustInstanceOfDS_for_Loss_Carryforward_class(problem,interpretation,element);
	neg find mustInstanceOfDS_for_Donation_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_class(problem,interpretation,element);
	neg find mustInstanceOfProfessional_Expenses_Deduction_class(problem,interpretation,element);
	neg find mustInstanceOfExternal_Allowance_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Detail_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_Credit_class(problem,interpretation,element);
	neg find mustInstanceOfDS_for_Interest_Expense_class(problem,interpretation,element);
	neg find mustInstanceOfDS_for_Health_and_Pension_Insurance_class(problem,interpretation,element);
	neg find mustInstanceOfDS_for_Private_Insurance_and_Plan_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Card_class(problem,interpretation,element);
	neg find mustInstanceOfLegal_Union_Record_class(problem,interpretation,element);
}
pattern refineTypeTo_Rentals_and_Leases_Income_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfRentals_and_Leases_Income_class(problem,interpretation,element);
	neg find mustInstanceOfFromAgent_class(problem,interpretation,element);
	neg find mustInstanceOfFromLaw_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Case_class(problem,interpretation,element);
	neg find mustInstanceOfRentals_and_Leases_Income_class(problem,interpretation,element);
	neg find mustInstanceOfCapital_and_Investments_Income_class(problem,interpretation,element);
	neg find mustInstanceOfConstants_class(problem,interpretation,element);
	neg find mustInstanceOfExpense_class(problem,interpretation,element);
	neg find mustInstanceOfAddress_class(problem,interpretation,element);
	neg find mustInstanceOfDS_class(problem,interpretation,element);
	neg find mustInstanceOfPhysical_Person_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Property_class(problem,interpretation,element);
	neg find mustInstanceOfPensions_and_Annuities_Income_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_class(problem,interpretation,element);
	neg find mustInstanceOfProfessional_Expenses_Deduction_class(problem,interpretation,element);
	neg find mustInstanceOfExternal_Allowance_class(problem,interpretation,element);
	neg find mustInstanceOfEmployment_Income_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Detail_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_Credit_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Card_class(problem,interpretation,element);
	neg find mustInstanceOfAgriculture_and_Forestry_Income_class(problem,interpretation,element);
	neg find mustInstanceOfLegal_Union_Record_class(problem,interpretation,element);
	neg find mustInstanceOfTrade_and_Business_Income_class(problem,interpretation,element);
}
pattern refineTypeTo_Permanent_Expense_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfPermanent_Expense_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Case_class(problem,interpretation,element);
	neg find mustInstanceOfProfessional_Expense_class(problem,interpretation,element);
	neg find mustInstanceOfAddress_class(problem,interpretation,element);
	neg find mustInstanceOfDS_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Type_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_class(problem,interpretation,element);
	neg find mustInstanceOfPhysical_Person_class(problem,interpretation,element);
	neg find mustInstanceOfSpousal_Expense_AC_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_class(problem,interpretation,element);
	neg find mustInstanceOfProfessional_Expenses_Deduction_class(problem,interpretation,element);
	neg find mustInstanceOfInterest_Expense_class(problem,interpretation,element);
	neg find mustInstanceOfExtraordinary_Expense_CE_class(problem,interpretation,element);
	neg find mustInstanceOfPrivate_Insurance_and_Plan_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Card_class(problem,interpretation,element);
	neg find mustInstanceOfHealth_and_Pension_Insurance_class(problem,interpretation,element);
	neg find mustInstanceOfDonation_class(problem,interpretation,element);
	neg find mustInstanceOfFromAgent_class(problem,interpretation,element);
	neg find mustInstanceOfFromLaw_class(problem,interpretation,element);
	neg find mustInstanceOfConstants_class(problem,interpretation,element);
	neg find mustInstanceOfPermanent_Expense_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Property_class(problem,interpretation,element);
	neg find mustInstanceOfLoss_Carryforward_class(problem,interpretation,element);
	neg find mustInstanceOfExternal_Allowance_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Detail_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_Credit_class(problem,interpretation,element);
	neg find mustInstanceOfLegal_Union_Record_class(problem,interpretation,element);
}
pattern refineTypeTo_Miscellaneous_Expense_FO_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfMiscellaneous_Expense_FO_class(problem,interpretation,element);
	neg find mustInstanceOfFromAgent_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Case_class(problem,interpretation,element);
	neg find mustInstanceOfFromLaw_class(problem,interpretation,element);
	neg find mustInstanceOfConstants_class(problem,interpretation,element);
	neg find mustInstanceOfAddress_class(problem,interpretation,element);
	neg find mustInstanceOfDS_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Type_class(problem,interpretation,element);
	neg find mustInstanceOfSpecial_Expense_DS_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_class(problem,interpretation,element);
	neg find mustInstanceOfPhysical_Person_class(problem,interpretation,element);
	neg find mustInstanceOfMiscellaneous_Expense_FO_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Property_class(problem,interpretation,element);
	neg find mustInstanceOfSpousal_Expense_AC_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_class(problem,interpretation,element);
	neg find mustInstanceOfProfessional_Expenses_Deduction_class(problem,interpretation,element);
	neg find mustInstanceOfExternal_Allowance_class(problem,interpretation,element);
	neg find mustInstanceOfExtraordinary_Expense_CE_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_Credit_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Detail_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Card_class(problem,interpretation,element);
	neg find mustInstanceOfTravel_Expense_FD_class(problem,interpretation,element);
	neg find mustInstanceOfLegal_Union_Record_class(problem,interpretation,element);
}
pattern refineTypeTo_Tax_Property_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfTax_Property_class(problem,interpretation,element);
	neg find mustInstanceOfFromAgent_class(problem,interpretation,element);
	neg find mustInstanceOfFromLaw_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Case_class(problem,interpretation,element);
	neg find mustInstanceOfExpense_class(problem,interpretation,element);
	neg find mustInstanceOfConstants_class(problem,interpretation,element);
	neg find mustInstanceOfAddress_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Type_class(problem,interpretation,element);
	neg find mustInstanceOfDS_class(problem,interpretation,element);
	neg find mustInstanceOfPhysical_Person_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Property_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_class(problem,interpretation,element);
	neg find mustInstanceOfProfessional_Expenses_Deduction_class(problem,interpretation,element);
	neg find mustInstanceOfExternal_Allowance_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Detail_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_Credit_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Card_class(problem,interpretation,element);
	neg find mustInstanceOfLegal_Union_Record_class(problem,interpretation,element);
}
pattern refineTypeTo_DS_for_Donation_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfDS_for_Donation_class(problem,interpretation,element);
	neg find mustInstanceOfFromAgent_class(problem,interpretation,element);
	neg find mustInstanceOfDS_for_Permanent_Expense_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Case_class(problem,interpretation,element);
	neg find mustInstanceOfFromLaw_class(problem,interpretation,element);
	neg find mustInstanceOfConstants_class(problem,interpretation,element);
	neg find mustInstanceOfExpense_class(problem,interpretation,element);
	neg find mustInstanceOfAddress_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Type_class(problem,interpretation,element);
	neg find mustInstanceOfPhysical_Person_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Property_class(problem,interpretation,element);
	neg find mustInstanceOfDS_for_Loss_Carryforward_class(problem,interpretation,element);
	neg find mustInstanceOfDS_for_Donation_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_class(problem,interpretation,element);
	neg find mustInstanceOfProfessional_Expenses_Deduction_class(problem,interpretation,element);
	neg find mustInstanceOfExternal_Allowance_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_Credit_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Detail_class(problem,interpretation,element);
	neg find mustInstanceOfDS_for_Interest_Expense_class(problem,interpretation,element);
	neg find mustInstanceOfDS_for_Health_and_Pension_Insurance_class(problem,interpretation,element);
	neg find mustInstanceOfDS_for_Private_Insurance_and_Plan_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Card_class(problem,interpretation,element);
	neg find mustInstanceOfLegal_Union_Record_class(problem,interpretation,element);
}
pattern refineTypeTo_Loss_Carryforward_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfLoss_Carryforward_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Case_class(problem,interpretation,element);
	neg find mustInstanceOfProfessional_Expense_class(problem,interpretation,element);
	neg find mustInstanceOfAddress_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Type_class(problem,interpretation,element);
	neg find mustInstanceOfDS_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_class(problem,interpretation,element);
	neg find mustInstanceOfPhysical_Person_class(problem,interpretation,element);
	neg find mustInstanceOfSpousal_Expense_AC_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_class(problem,interpretation,element);
	neg find mustInstanceOfProfessional_Expenses_Deduction_class(problem,interpretation,element);
	neg find mustInstanceOfInterest_Expense_class(problem,interpretation,element);
	neg find mustInstanceOfExtraordinary_Expense_CE_class(problem,interpretation,element);
	neg find mustInstanceOfPrivate_Insurance_and_Plan_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Card_class(problem,interpretation,element);
	neg find mustInstanceOfHealth_and_Pension_Insurance_class(problem,interpretation,element);
	neg find mustInstanceOfDonation_class(problem,interpretation,element);
	neg find mustInstanceOfFromAgent_class(problem,interpretation,element);
	neg find mustInstanceOfFromLaw_class(problem,interpretation,element);
	neg find mustInstanceOfConstants_class(problem,interpretation,element);
	neg find mustInstanceOfPermanent_Expense_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Property_class(problem,interpretation,element);
	neg find mustInstanceOfLoss_Carryforward_class(problem,interpretation,element);
	neg find mustInstanceOfExternal_Allowance_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_Credit_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Detail_class(problem,interpretation,element);
	neg find mustInstanceOfLegal_Union_Record_class(problem,interpretation,element);
}
pattern refineTypeTo_Employment_Income_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfEmployment_Income_class(problem,interpretation,element);
	neg find mustInstanceOfFromAgent_class(problem,interpretation,element);
	neg find mustInstanceOfFromLaw_class(problem,interpretation,element);
	neg find mustInstanceOfRentals_and_Leases_Income_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Case_class(problem,interpretation,element);
	neg find mustInstanceOfCapital_and_Investments_Income_class(problem,interpretation,element);
	neg find mustInstanceOfExpense_class(problem,interpretation,element);
	neg find mustInstanceOfConstants_class(problem,interpretation,element);
	neg find mustInstanceOfAddress_class(problem,interpretation,element);
	neg find mustInstanceOfDS_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_class(problem,interpretation,element);
	neg find mustInstanceOfPhysical_Person_class(problem,interpretation,element);
	neg find mustInstanceOfPensions_and_Annuities_Income_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Property_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_class(problem,interpretation,element);
	neg find mustInstanceOfProfessional_Expenses_Deduction_class(problem,interpretation,element);
	neg find mustInstanceOfEmployment_Income_class(problem,interpretation,element);
	neg find mustInstanceOfExternal_Allowance_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Detail_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_Credit_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Card_class(problem,interpretation,element);
	neg find mustInstanceOfAgriculture_and_Forestry_Income_class(problem,interpretation,element);
	neg find mustInstanceOfLegal_Union_Record_class(problem,interpretation,element);
	neg find mustInstanceOfTrade_and_Business_Income_class(problem,interpretation,element);
}
pattern refineTypeTo_Household_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfHousehold_class(problem,interpretation,element);
	neg find mustInstanceOfFromAgent_class(problem,interpretation,element);
	neg find mustInstanceOfFromLaw_class(problem,interpretation,element);
	neg find mustInstanceOfExpense_class(problem,interpretation,element);
	neg find mustInstanceOfConstants_class(problem,interpretation,element);
	neg find mustInstanceOfAddress_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Type_class(problem,interpretation,element);
	neg find mustInstanceOfDS_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_class(problem,interpretation,element);
	neg find mustInstanceOfPhysical_Person_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Property_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_class(problem,interpretation,element);
	neg find mustInstanceOfProfessional_Expenses_Deduction_class(problem,interpretation,element);
	neg find mustInstanceOfExternal_Allowance_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Detail_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_Credit_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Card_class(problem,interpretation,element);
	neg find mustInstanceOfHousehold_class(problem,interpretation,element);
	neg find mustInstanceOfLegal_Union_Record_class(problem,interpretation,element);
}
pattern refineTypeTo_Agriculture_and_Forestry_Income_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfAgriculture_and_Forestry_Income_class(problem,interpretation,element);
	neg find mustInstanceOfFromAgent_class(problem,interpretation,element);
	neg find mustInstanceOfRentals_and_Leases_Income_class(problem,interpretation,element);
	neg find mustInstanceOfCapital_and_Investments_Income_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Case_class(problem,interpretation,element);
	neg find mustInstanceOfFromLaw_class(problem,interpretation,element);
	neg find mustInstanceOfConstants_class(problem,interpretation,element);
	neg find mustInstanceOfExpense_class(problem,interpretation,element);
	neg find mustInstanceOfAddress_class(problem,interpretation,element);
	neg find mustInstanceOfDS_class(problem,interpretation,element);
	neg find mustInstanceOfPhysical_Person_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_class(problem,interpretation,element);
	neg find mustInstanceOfPensions_and_Annuities_Income_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Property_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_class(problem,interpretation,element);
	neg find mustInstanceOfProfessional_Expenses_Deduction_class(problem,interpretation,element);
	neg find mustInstanceOfEmployment_Income_class(problem,interpretation,element);
	neg find mustInstanceOfExternal_Allowance_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_Credit_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Detail_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Card_class(problem,interpretation,element);
	neg find mustInstanceOfAgriculture_and_Forestry_Income_class(problem,interpretation,element);
	neg find mustInstanceOfLegal_Union_Record_class(problem,interpretation,element);
	neg find mustInstanceOfTrade_and_Business_Income_class(problem,interpretation,element);
}
pattern refineTypeTo_Habitual_Address_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfHabitual_Address_class(problem,interpretation,element);
	neg find mustInstanceOfFromAgent_class(problem,interpretation,element);
	neg find mustInstanceOfFromLaw_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Case_class(problem,interpretation,element);
	neg find mustInstanceOfExpense_class(problem,interpretation,element);
	neg find mustInstanceOfConstants_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Type_class(problem,interpretation,element);
	neg find mustInstanceOfDS_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_class(problem,interpretation,element);
	neg find mustInstanceOfPhysical_Person_class(problem,interpretation,element);
	neg find mustInstanceOfFiscal_Address_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Property_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_class(problem,interpretation,element);
	neg find mustInstanceOfProfessional_Expenses_Deduction_class(problem,interpretation,element);
	neg find mustInstanceOfExternal_Allowance_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_Credit_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Detail_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Card_class(problem,interpretation,element);
	neg find mustInstanceOfLegal_Union_Record_class(problem,interpretation,element);
	neg find mustInstanceOfHabitual_Address_class(problem,interpretation,element);
}
pattern refineTypeTo_DS_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfDS_class(problem,interpretation,element);
	neg find mustInstanceOfFromAgent_class(problem,interpretation,element);
	neg find mustInstanceOfDS_for_Permanent_Expense_class(problem,interpretation,element);
	neg find mustInstanceOfFromLaw_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Case_class(problem,interpretation,element);
	neg find mustInstanceOfConstants_class(problem,interpretation,element);
	neg find mustInstanceOfExpense_class(problem,interpretation,element);
	neg find mustInstanceOfAddress_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Type_class(problem,interpretation,element);
	neg find mustInstanceOfDS_class(problem,interpretation,element);
	neg find mustInstanceOfPhysical_Person_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Property_class(problem,interpretation,element);
	neg find mustInstanceOfDS_for_Loss_Carryforward_class(problem,interpretation,element);
	neg find mustInstanceOfDS_for_Donation_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_class(problem,interpretation,element);
	neg find mustInstanceOfProfessional_Expenses_Deduction_class(problem,interpretation,element);
	neg find mustInstanceOfExternal_Allowance_class(problem,interpretation,element);
	neg find mustInstanceOfDS_for_Interest_Expense_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_Credit_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Detail_class(problem,interpretation,element);
	neg find mustInstanceOfDS_for_Health_and_Pension_Insurance_class(problem,interpretation,element);
	neg find mustInstanceOfDS_for_Private_Insurance_and_Plan_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Card_class(problem,interpretation,element);
	neg find mustInstanceOfLegal_Union_Record_class(problem,interpretation,element);
}
pattern refineTypeTo_Fiscal_Address_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFiscal_Address_class(problem,interpretation,element);
	neg find mustInstanceOfFromAgent_class(problem,interpretation,element);
	neg find mustInstanceOfFromLaw_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Case_class(problem,interpretation,element);
	neg find mustInstanceOfConstants_class(problem,interpretation,element);
	neg find mustInstanceOfExpense_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Type_class(problem,interpretation,element);
	neg find mustInstanceOfDS_class(problem,interpretation,element);
	neg find mustInstanceOfPhysical_Person_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_class(problem,interpretation,element);
	neg find mustInstanceOfFiscal_Address_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Property_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_class(problem,interpretation,element);
	neg find mustInstanceOfProfessional_Expenses_Deduction_class(problem,interpretation,element);
	neg find mustInstanceOfExternal_Allowance_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_Credit_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Detail_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Card_class(problem,interpretation,element);
	neg find mustInstanceOfLegal_Union_Record_class(problem,interpretation,element);
	neg find mustInstanceOfHabitual_Address_class(problem,interpretation,element);
}
pattern refineTypeTo_FO_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFO_class(problem,interpretation,element);
	neg find mustInstanceOfFromAgent_class(problem,interpretation,element);
	neg find mustInstanceOfFromLaw_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Case_class(problem,interpretation,element);
	neg find mustInstanceOfConstants_class(problem,interpretation,element);
	neg find mustInstanceOfExpense_class(problem,interpretation,element);
	neg find mustInstanceOfFD_class(problem,interpretation,element);
	neg find mustInstanceOfAddress_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Type_class(problem,interpretation,element);
	neg find mustInstanceOfDS_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_class(problem,interpretation,element);
	neg find mustInstanceOfPhysical_Person_class(problem,interpretation,element);
	neg find mustInstanceOfFO_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Property_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_class(problem,interpretation,element);
	neg find mustInstanceOfExternal_Allowance_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Detail_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_Credit_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Card_class(problem,interpretation,element);
	neg find mustInstanceOfLegal_Union_Record_class(problem,interpretation,element);
}
pattern refineTypeTo_Pensions_and_Annuities_Income_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfPensions_and_Annuities_Income_class(problem,interpretation,element);
	neg find mustInstanceOfFromAgent_class(problem,interpretation,element);
	neg find mustInstanceOfFromLaw_class(problem,interpretation,element);
	neg find mustInstanceOfRentals_and_Leases_Income_class(problem,interpretation,element);
	neg find mustInstanceOfCapital_and_Investments_Income_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Case_class(problem,interpretation,element);
	neg find mustInstanceOfExpense_class(problem,interpretation,element);
	neg find mustInstanceOfConstants_class(problem,interpretation,element);
	neg find mustInstanceOfAddress_class(problem,interpretation,element);
	neg find mustInstanceOfDS_class(problem,interpretation,element);
	neg find mustInstanceOfPhysical_Person_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Property_class(problem,interpretation,element);
	neg find mustInstanceOfPensions_and_Annuities_Income_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_class(problem,interpretation,element);
	neg find mustInstanceOfProfessional_Expenses_Deduction_class(problem,interpretation,element);
	neg find mustInstanceOfExternal_Allowance_class(problem,interpretation,element);
	neg find mustInstanceOfEmployment_Income_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Detail_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_Credit_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Card_class(problem,interpretation,element);
	neg find mustInstanceOfLegal_Union_Record_class(problem,interpretation,element);
	neg find mustInstanceOfAgriculture_and_Forestry_Income_class(problem,interpretation,element);
	neg find mustInstanceOfTrade_and_Business_Income_class(problem,interpretation,element);
}
pattern refineTypeTo_DS_for_Loss_Carryforward_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfDS_for_Loss_Carryforward_class(problem,interpretation,element);
	neg find mustInstanceOfFromAgent_class(problem,interpretation,element);
	neg find mustInstanceOfDS_for_Permanent_Expense_class(problem,interpretation,element);
	neg find mustInstanceOfFromLaw_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Case_class(problem,interpretation,element);
	neg find mustInstanceOfConstants_class(problem,interpretation,element);
	neg find mustInstanceOfExpense_class(problem,interpretation,element);
	neg find mustInstanceOfAddress_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Type_class(problem,interpretation,element);
	neg find mustInstanceOfPhysical_Person_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Property_class(problem,interpretation,element);
	neg find mustInstanceOfDS_for_Loss_Carryforward_class(problem,interpretation,element);
	neg find mustInstanceOfDS_for_Donation_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_class(problem,interpretation,element);
	neg find mustInstanceOfProfessional_Expenses_Deduction_class(problem,interpretation,element);
	neg find mustInstanceOfExternal_Allowance_class(problem,interpretation,element);
	neg find mustInstanceOfDS_for_Interest_Expense_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_Credit_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Detail_class(problem,interpretation,element);
	neg find mustInstanceOfDS_for_Health_and_Pension_Insurance_class(problem,interpretation,element);
	neg find mustInstanceOfDS_for_Private_Insurance_and_Plan_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Card_class(problem,interpretation,element);
	neg find mustInstanceOfLegal_Union_Record_class(problem,interpretation,element);
}
pattern refineTypeTo_Spousal_Expense_AC_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfSpousal_Expense_AC_class(problem,interpretation,element);
	neg find mustInstanceOfFromAgent_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Case_class(problem,interpretation,element);
	neg find mustInstanceOfFromLaw_class(problem,interpretation,element);
	neg find mustInstanceOfProfessional_Expense_class(problem,interpretation,element);
	neg find mustInstanceOfConstants_class(problem,interpretation,element);
	neg find mustInstanceOfAddress_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Type_class(problem,interpretation,element);
	neg find mustInstanceOfDS_class(problem,interpretation,element);
	neg find mustInstanceOfSpecial_Expense_DS_class(problem,interpretation,element);
	neg find mustInstanceOfPhysical_Person_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Property_class(problem,interpretation,element);
	neg find mustInstanceOfSpousal_Expense_AC_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_class(problem,interpretation,element);
	neg find mustInstanceOfProfessional_Expenses_Deduction_class(problem,interpretation,element);
	neg find mustInstanceOfExtraordinary_Expense_CE_class(problem,interpretation,element);
	neg find mustInstanceOfExternal_Allowance_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Detail_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_Credit_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Card_class(problem,interpretation,element);
	neg find mustInstanceOfLegal_Union_Record_class(problem,interpretation,element);
}
pattern refineTypeTo_Local_Income_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfLocal_Income_class(problem,interpretation,element);
	neg find mustInstanceOfFromAgent_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Case_class(problem,interpretation,element);
	neg find mustInstanceOfFromLaw_class(problem,interpretation,element);
	neg find mustInstanceOfConstants_class(problem,interpretation,element);
	neg find mustInstanceOfExpense_class(problem,interpretation,element);
	neg find mustInstanceOfAddress_class(problem,interpretation,element);
	neg find mustInstanceOfForeign_Income_class(problem,interpretation,element);
	neg find mustInstanceOfDS_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Type_class(problem,interpretation,element);
	neg find mustInstanceOfPhysical_Person_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Property_class(problem,interpretation,element);
	neg find mustInstanceOfLocal_Income_class(problem,interpretation,element);
	neg find mustInstanceOfProfessional_Expenses_Deduction_class(problem,interpretation,element);
	neg find mustInstanceOfExternal_Allowance_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Detail_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_Credit_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Card_class(problem,interpretation,element);
	neg find mustInstanceOfLegal_Union_Record_class(problem,interpretation,element);
}
pattern refineTypeTo_Extraordinary_Expense_CE_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfExtraordinary_Expense_CE_class(problem,interpretation,element);
	neg find mustInstanceOfFromAgent_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Case_class(problem,interpretation,element);
	neg find mustInstanceOfFromLaw_class(problem,interpretation,element);
	neg find mustInstanceOfConstants_class(problem,interpretation,element);
	neg find mustInstanceOfProfessional_Expense_class(problem,interpretation,element);
	neg find mustInstanceOfAddress_class(problem,interpretation,element);
	neg find mustInstanceOfDS_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Type_class(problem,interpretation,element);
	neg find mustInstanceOfSpecial_Expense_DS_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_class(problem,interpretation,element);
	neg find mustInstanceOfPhysical_Person_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Property_class(problem,interpretation,element);
	neg find mustInstanceOfSpousal_Expense_AC_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_class(problem,interpretation,element);
	neg find mustInstanceOfProfessional_Expenses_Deduction_class(problem,interpretation,element);
	neg find mustInstanceOfExtraordinary_Expense_CE_class(problem,interpretation,element);
	neg find mustInstanceOfExternal_Allowance_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_Credit_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Detail_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Card_class(problem,interpretation,element);
	neg find mustInstanceOfLegal_Union_Record_class(problem,interpretation,element);
}
pattern refineTypeTo_Private_Insurance_and_Plan_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfPrivate_Insurance_and_Plan_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Case_class(problem,interpretation,element);
	neg find mustInstanceOfProfessional_Expense_class(problem,interpretation,element);
	neg find mustInstanceOfAddress_class(problem,interpretation,element);
	neg find mustInstanceOfDS_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Type_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_class(problem,interpretation,element);
	neg find mustInstanceOfPhysical_Person_class(problem,interpretation,element);
	neg find mustInstanceOfSpousal_Expense_AC_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_class(problem,interpretation,element);
	neg find mustInstanceOfProfessional_Expenses_Deduction_class(problem,interpretation,element);
	neg find mustInstanceOfInterest_Expense_class(problem,interpretation,element);
	neg find mustInstanceOfExtraordinary_Expense_CE_class(problem,interpretation,element);
	neg find mustInstanceOfPrivate_Insurance_and_Plan_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Card_class(problem,interpretation,element);
	neg find mustInstanceOfDonation_class(problem,interpretation,element);
	neg find mustInstanceOfHealth_and_Pension_Insurance_class(problem,interpretation,element);
	neg find mustInstanceOfFromAgent_class(problem,interpretation,element);
	neg find mustInstanceOfFromLaw_class(problem,interpretation,element);
	neg find mustInstanceOfConstants_class(problem,interpretation,element);
	neg find mustInstanceOfPermanent_Expense_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Property_class(problem,interpretation,element);
	neg find mustInstanceOfLoss_Carryforward_class(problem,interpretation,element);
	neg find mustInstanceOfExternal_Allowance_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_Credit_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Detail_class(problem,interpretation,element);
	neg find mustInstanceOfLegal_Union_Record_class(problem,interpretation,element);
}
pattern refineTypeTo_DS_for_Interest_Expense_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfDS_for_Interest_Expense_class(problem,interpretation,element);
	neg find mustInstanceOfFromAgent_class(problem,interpretation,element);
	neg find mustInstanceOfDS_for_Permanent_Expense_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Case_class(problem,interpretation,element);
	neg find mustInstanceOfFromLaw_class(problem,interpretation,element);
	neg find mustInstanceOfExpense_class(problem,interpretation,element);
	neg find mustInstanceOfConstants_class(problem,interpretation,element);
	neg find mustInstanceOfAddress_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Type_class(problem,interpretation,element);
	neg find mustInstanceOfPhysical_Person_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Property_class(problem,interpretation,element);
	neg find mustInstanceOfDS_for_Loss_Carryforward_class(problem,interpretation,element);
	neg find mustInstanceOfDS_for_Donation_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_class(problem,interpretation,element);
	neg find mustInstanceOfProfessional_Expenses_Deduction_class(problem,interpretation,element);
	neg find mustInstanceOfExternal_Allowance_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_Credit_class(problem,interpretation,element);
	neg find mustInstanceOfDS_for_Interest_Expense_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Detail_class(problem,interpretation,element);
	neg find mustInstanceOfDS_for_Health_and_Pension_Insurance_class(problem,interpretation,element);
	neg find mustInstanceOfDS_for_Private_Insurance_and_Plan_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Card_class(problem,interpretation,element);
	neg find mustInstanceOfLegal_Union_Record_class(problem,interpretation,element);
}
pattern refineTypeTo_Health_and_Pension_Insurance_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfHealth_and_Pension_Insurance_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Case_class(problem,interpretation,element);
	neg find mustInstanceOfProfessional_Expense_class(problem,interpretation,element);
	neg find mustInstanceOfAddress_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Type_class(problem,interpretation,element);
	neg find mustInstanceOfDS_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_class(problem,interpretation,element);
	neg find mustInstanceOfPhysical_Person_class(problem,interpretation,element);
	neg find mustInstanceOfSpousal_Expense_AC_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_class(problem,interpretation,element);
	neg find mustInstanceOfProfessional_Expenses_Deduction_class(problem,interpretation,element);
	neg find mustInstanceOfInterest_Expense_class(problem,interpretation,element);
	neg find mustInstanceOfExtraordinary_Expense_CE_class(problem,interpretation,element);
	neg find mustInstanceOfPrivate_Insurance_and_Plan_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Card_class(problem,interpretation,element);
	neg find mustInstanceOfHealth_and_Pension_Insurance_class(problem,interpretation,element);
	neg find mustInstanceOfDonation_class(problem,interpretation,element);
	neg find mustInstanceOfFromAgent_class(problem,interpretation,element);
	neg find mustInstanceOfFromLaw_class(problem,interpretation,element);
	neg find mustInstanceOfConstants_class(problem,interpretation,element);
	neg find mustInstanceOfPermanent_Expense_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Property_class(problem,interpretation,element);
	neg find mustInstanceOfLoss_Carryforward_class(problem,interpretation,element);
	neg find mustInstanceOfExternal_Allowance_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Detail_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_Credit_class(problem,interpretation,element);
	neg find mustInstanceOfLegal_Union_Record_class(problem,interpretation,element);
}
pattern refineTypeTo_Travel_Expense_FD_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfTravel_Expense_FD_class(problem,interpretation,element);
	neg find mustInstanceOfFromAgent_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Case_class(problem,interpretation,element);
	neg find mustInstanceOfFromLaw_class(problem,interpretation,element);
	neg find mustInstanceOfConstants_class(problem,interpretation,element);
	neg find mustInstanceOfAddress_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Type_class(problem,interpretation,element);
	neg find mustInstanceOfDS_class(problem,interpretation,element);
	neg find mustInstanceOfSpecial_Expense_DS_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_class(problem,interpretation,element);
	neg find mustInstanceOfPhysical_Person_class(problem,interpretation,element);
	neg find mustInstanceOfMiscellaneous_Expense_FO_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Property_class(problem,interpretation,element);
	neg find mustInstanceOfSpousal_Expense_AC_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_class(problem,interpretation,element);
	neg find mustInstanceOfProfessional_Expenses_Deduction_class(problem,interpretation,element);
	neg find mustInstanceOfExtraordinary_Expense_CE_class(problem,interpretation,element);
	neg find mustInstanceOfExternal_Allowance_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_Credit_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Detail_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Card_class(problem,interpretation,element);
	neg find mustInstanceOfTravel_Expense_FD_class(problem,interpretation,element);
	neg find mustInstanceOfLegal_Union_Record_class(problem,interpretation,element);
}
pattern refineTypeTo_Trade_and_Business_Income_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfTrade_and_Business_Income_class(problem,interpretation,element);
	neg find mustInstanceOfFromAgent_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Case_class(problem,interpretation,element);
	neg find mustInstanceOfFromLaw_class(problem,interpretation,element);
	neg find mustInstanceOfCapital_and_Investments_Income_class(problem,interpretation,element);
	neg find mustInstanceOfRentals_and_Leases_Income_class(problem,interpretation,element);
	neg find mustInstanceOfExpense_class(problem,interpretation,element);
	neg find mustInstanceOfConstants_class(problem,interpretation,element);
	neg find mustInstanceOfAddress_class(problem,interpretation,element);
	neg find mustInstanceOfDS_class(problem,interpretation,element);
	neg find mustInstanceOfPhysical_Person_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_class(problem,interpretation,element);
	neg find mustInstanceOfPensions_and_Annuities_Income_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Property_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_class(problem,interpretation,element);
	neg find mustInstanceOfProfessional_Expenses_Deduction_class(problem,interpretation,element);
	neg find mustInstanceOfEmployment_Income_class(problem,interpretation,element);
	neg find mustInstanceOfExternal_Allowance_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Detail_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_Credit_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Card_class(problem,interpretation,element);
	neg find mustInstanceOfAgriculture_and_Forestry_Income_class(problem,interpretation,element);
	neg find mustInstanceOfLegal_Union_Record_class(problem,interpretation,element);
	neg find mustInstanceOfTrade_and_Business_Income_class(problem,interpretation,element);
}
pattern refineTypeTo_FromLaw_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFromLaw_class(problem,interpretation,element);
	neg find mustInstanceOfFromAgent_class(problem,interpretation,element);
	neg find mustInstanceOfFromLaw_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Case_class(problem,interpretation,element);
	neg find mustInstanceOfConstants_class(problem,interpretation,element);
	neg find mustInstanceOfExpense_class(problem,interpretation,element);
	neg find mustInstanceOfAddress_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Type_class(problem,interpretation,element);
	neg find mustInstanceOfDS_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_class(problem,interpretation,element);
	neg find mustInstanceOfPhysical_Person_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Property_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_class(problem,interpretation,element);
	neg find mustInstanceOfProfessional_Expenses_Deduction_class(problem,interpretation,element);
	neg find mustInstanceOfExternal_Allowance_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Detail_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_Credit_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Card_class(problem,interpretation,element);
	neg find mustInstanceOfLegal_Union_Record_class(problem,interpretation,element);
}
pattern refineTypeTo_FD_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFD_class(problem,interpretation,element);
	neg find mustInstanceOfFromAgent_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Case_class(problem,interpretation,element);
	neg find mustInstanceOfFromLaw_class(problem,interpretation,element);
	neg find mustInstanceOfExpense_class(problem,interpretation,element);
	neg find mustInstanceOfConstants_class(problem,interpretation,element);
	neg find mustInstanceOfAddress_class(problem,interpretation,element);
	neg find mustInstanceOfFD_class(problem,interpretation,element);
	neg find mustInstanceOfDS_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Type_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_class(problem,interpretation,element);
	neg find mustInstanceOfPhysical_Person_class(problem,interpretation,element);
	neg find mustInstanceOfFO_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Property_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_class(problem,interpretation,element);
	neg find mustInstanceOfExternal_Allowance_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_Credit_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Detail_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Card_class(problem,interpretation,element);
	neg find mustInstanceOfLegal_Union_Record_class(problem,interpretation,element);
}
pattern refineTypeTo_Non_Resident_Tax_Payer_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfNon_Resident_Tax_Payer_class(problem,interpretation,element);
	neg find mustInstanceOfFromAgent_class(problem,interpretation,element);
	neg find mustInstanceOfFromLaw_class(problem,interpretation,element);
	neg find mustInstanceOfExpense_class(problem,interpretation,element);
	neg find mustInstanceOfConstants_class(problem,interpretation,element);
	neg find mustInstanceOfAddress_class(problem,interpretation,element);
	neg find mustInstanceOfDS_class(problem,interpretation,element);
	neg find mustInstanceOfResident_Tax_Payer_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Type_class(problem,interpretation,element);
	neg find mustInstanceOfNon_Resident_Tax_Payer_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Property_class(problem,interpretation,element);
	neg find mustInstanceOfDependent_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_class(problem,interpretation,element);
	neg find mustInstanceOfProfessional_Expenses_Deduction_class(problem,interpretation,element);
	neg find mustInstanceOfExternal_Allowance_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Detail_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_Credit_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Card_class(problem,interpretation,element);
	neg find mustInstanceOfHousehold_class(problem,interpretation,element);
	neg find mustInstanceOfLegal_Union_Record_class(problem,interpretation,element);
}
pattern refineTypeTo_Marriage_Record_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfMarriage_Record_class(problem,interpretation,element);
	neg find mustInstanceOfFromAgent_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Case_class(problem,interpretation,element);
	neg find mustInstanceOfFromLaw_class(problem,interpretation,element);
	neg find mustInstanceOfExpense_class(problem,interpretation,element);
	neg find mustInstanceOfConstants_class(problem,interpretation,element);
	neg find mustInstanceOfAddress_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Type_class(problem,interpretation,element);
	neg find mustInstanceOfDS_class(problem,interpretation,element);
	neg find mustInstanceOfMarriage_Record_class(problem,interpretation,element);
	neg find mustInstanceOfPhysical_Person_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Property_class(problem,interpretation,element);
	neg find mustInstanceOfPartnership_Record_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_class(problem,interpretation,element);
	neg find mustInstanceOfProfessional_Expenses_Deduction_class(problem,interpretation,element);
	neg find mustInstanceOfExternal_Allowance_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Detail_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_Credit_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Card_class(problem,interpretation,element);
}
pattern refineTypeTo_Dependent_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfDependent_class(problem,interpretation,element);
	neg find mustInstanceOfFromAgent_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Case_class(problem,interpretation,element);
	neg find mustInstanceOfFromLaw_class(problem,interpretation,element);
	neg find mustInstanceOfExpense_class(problem,interpretation,element);
	neg find mustInstanceOfConstants_class(problem,interpretation,element);
	neg find mustInstanceOfAddress_class(problem,interpretation,element);
	neg find mustInstanceOfDS_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Type_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Property_class(problem,interpretation,element);
	neg find mustInstanceOfDependent_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_class(problem,interpretation,element);
	neg find mustInstanceOfProfessional_Expenses_Deduction_class(problem,interpretation,element);
	neg find mustInstanceOfExternal_Allowance_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_Credit_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Detail_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Card_class(problem,interpretation,element);
	neg find mustInstanceOfLegal_Union_Record_class(problem,interpretation,element);
}
pattern refineTypeTo_Partnership_Record_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfPartnership_Record_class(problem,interpretation,element);
	neg find mustInstanceOfFromAgent_class(problem,interpretation,element);
	neg find mustInstanceOfFromLaw_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Case_class(problem,interpretation,element);
	neg find mustInstanceOfExpense_class(problem,interpretation,element);
	neg find mustInstanceOfConstants_class(problem,interpretation,element);
	neg find mustInstanceOfAddress_class(problem,interpretation,element);
	neg find mustInstanceOfDS_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Type_class(problem,interpretation,element);
	neg find mustInstanceOfMarriage_Record_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_class(problem,interpretation,element);
	neg find mustInstanceOfPhysical_Person_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Property_class(problem,interpretation,element);
	neg find mustInstanceOfPartnership_Record_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_class(problem,interpretation,element);
	neg find mustInstanceOfProfessional_Expenses_Deduction_class(problem,interpretation,element);
	neg find mustInstanceOfExternal_Allowance_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Detail_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_Credit_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Card_class(problem,interpretation,element);
}
pattern refineTypeTo_External_Allowance_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfExternal_Allowance_class(problem,interpretation,element);
	neg find mustInstanceOfFromAgent_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Case_class(problem,interpretation,element);
	neg find mustInstanceOfFromLaw_class(problem,interpretation,element);
	neg find mustInstanceOfConstants_class(problem,interpretation,element);
	neg find mustInstanceOfExpense_class(problem,interpretation,element);
	neg find mustInstanceOfAddress_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Type_class(problem,interpretation,element);
	neg find mustInstanceOfDS_class(problem,interpretation,element);
	neg find mustInstanceOfPhysical_Person_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Property_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_class(problem,interpretation,element);
	neg find mustInstanceOfProfessional_Expenses_Deduction_class(problem,interpretation,element);
	neg find mustInstanceOfExternal_Allowance_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_Credit_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Detail_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Card_class(problem,interpretation,element);
	neg find mustInstanceOfLegal_Union_Record_class(problem,interpretation,element);
}
pattern refineTypeTo_Income_Tax_Credit_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfIncome_Tax_Credit_class(problem,interpretation,element);
	neg find mustInstanceOfFromAgent_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Case_class(problem,interpretation,element);
	neg find mustInstanceOfFromLaw_class(problem,interpretation,element);
	neg find mustInstanceOfExpense_class(problem,interpretation,element);
	neg find mustInstanceOfConstants_class(problem,interpretation,element);
	neg find mustInstanceOfAddress_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Type_class(problem,interpretation,element);
	neg find mustInstanceOfDS_class(problem,interpretation,element);
	neg find mustInstanceOfCIS_class(problem,interpretation,element);
	neg find mustInstanceOfCIP_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_class(problem,interpretation,element);
	neg find mustInstanceOfPhysical_Person_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Property_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_class(problem,interpretation,element);
	neg find mustInstanceOfProfessional_Expenses_Deduction_class(problem,interpretation,element);
	neg find mustInstanceOfExternal_Allowance_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_Credit_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Detail_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Card_class(problem,interpretation,element);
	neg find mustInstanceOfCIM_class(problem,interpretation,element);
	neg find mustInstanceOfLegal_Union_Record_class(problem,interpretation,element);
}
pattern refineTypeTo_Income_Detail_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfIncome_Detail_class(problem,interpretation,element);
	neg find mustInstanceOfFromAgent_class(problem,interpretation,element);
	neg find mustInstanceOfFromLaw_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Case_class(problem,interpretation,element);
	neg find mustInstanceOfConstants_class(problem,interpretation,element);
	neg find mustInstanceOfExpense_class(problem,interpretation,element);
	neg find mustInstanceOfAddress_class(problem,interpretation,element);
	neg find mustInstanceOfDS_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Type_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_class(problem,interpretation,element);
	neg find mustInstanceOfPhysical_Person_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Property_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_class(problem,interpretation,element);
	neg find mustInstanceOfProfessional_Expenses_Deduction_class(problem,interpretation,element);
	neg find mustInstanceOfExternal_Allowance_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_Credit_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Detail_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Card_class(problem,interpretation,element);
	neg find mustInstanceOfLegal_Union_Record_class(problem,interpretation,element);
}
pattern refineTypeTo_DS_for_Private_Insurance_and_Plan_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfDS_for_Private_Insurance_and_Plan_class(problem,interpretation,element);
	neg find mustInstanceOfFromAgent_class(problem,interpretation,element);
	neg find mustInstanceOfDS_for_Permanent_Expense_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Case_class(problem,interpretation,element);
	neg find mustInstanceOfFromLaw_class(problem,interpretation,element);
	neg find mustInstanceOfExpense_class(problem,interpretation,element);
	neg find mustInstanceOfConstants_class(problem,interpretation,element);
	neg find mustInstanceOfAddress_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Type_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_class(problem,interpretation,element);
	neg find mustInstanceOfPhysical_Person_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Property_class(problem,interpretation,element);
	neg find mustInstanceOfDS_for_Loss_Carryforward_class(problem,interpretation,element);
	neg find mustInstanceOfDS_for_Donation_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_class(problem,interpretation,element);
	neg find mustInstanceOfProfessional_Expenses_Deduction_class(problem,interpretation,element);
	neg find mustInstanceOfExternal_Allowance_class(problem,interpretation,element);
	neg find mustInstanceOfDS_for_Interest_Expense_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Detail_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_Credit_class(problem,interpretation,element);
	neg find mustInstanceOfDS_for_Health_and_Pension_Insurance_class(problem,interpretation,element);
	neg find mustInstanceOfDS_for_Private_Insurance_and_Plan_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Card_class(problem,interpretation,element);
	neg find mustInstanceOfLegal_Union_Record_class(problem,interpretation,element);
}
pattern refineTypeTo_CIM_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfCIM_class(problem,interpretation,element);
	neg find mustInstanceOfFromAgent_class(problem,interpretation,element);
	neg find mustInstanceOfFromLaw_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Case_class(problem,interpretation,element);
	neg find mustInstanceOfConstants_class(problem,interpretation,element);
	neg find mustInstanceOfExpense_class(problem,interpretation,element);
	neg find mustInstanceOfAddress_class(problem,interpretation,element);
	neg find mustInstanceOfDS_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Type_class(problem,interpretation,element);
	neg find mustInstanceOfCIS_class(problem,interpretation,element);
	neg find mustInstanceOfCIP_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Tax_class(problem,interpretation,element);
	neg find mustInstanceOfPhysical_Person_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Property_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_class(problem,interpretation,element);
	neg find mustInstanceOfProfessional_Expenses_Deduction_class(problem,interpretation,element);
	neg find mustInstanceOfExternal_Allowance_class(problem,interpretation,element);
	neg find mustInstanceOfIncome_Detail_class(problem,interpretation,element);
	neg find mustInstanceOfTax_Card_class(problem,interpretation,element);
	neg find mustInstanceOfCIM_class(problem,interpretation,element);
	neg find mustInstanceOfLegal_Union_Record_class(problem,interpretation,element);
}

//////////
// 4.3 Relation refinement
//////////
pattern refineRelation_taxPayer_reference_Income_Tax(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"taxPayer reference Income_Tax");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfIncome_Tax_class(problem,interpretation,from);
	find mustInstanceOfTax_Payer_class(problem,interpretation,to);
	find mayInRelationtaxPayer_reference_Income_Tax(problem,interpretation,from,to);
	neg find mustInRelationtaxPayer_reference_Income_Tax(problem,interpretation,from,to);
}
pattern refineRelation_addresses_reference_Physical_Person_and_taxPayer_reference_Address(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation, oppositeInterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"addresses reference Physical_Person");
	PartialInterpretation.partialrelationinterpretation(interpretation,oppositeInterpretation);
	PartialRelationInterpretation.interpretationOf.name(oppositeInterpretation,"taxPayer reference Address");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfPhysical_Person_class(problem,interpretation,from);
	find mustInstanceOfAddress_class(problem,interpretation,to);
	find mayInRelationaddresses_reference_Physical_Person(problem,interpretation,from,to);
	neg find mustInRelationaddresses_reference_Physical_Person(problem,interpretation,from,to);
}
pattern refineRelation_dependent_reference_Expense_and_expense_reference_Dependent(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation, oppositeInterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"dependent reference Expense");
	PartialInterpretation.partialrelationinterpretation(interpretation,oppositeInterpretation);
	PartialRelationInterpretation.interpretationOf.name(oppositeInterpretation,"expense reference Dependent");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfExpense_class(problem,interpretation,from);
	find mustInstanceOfDependent_class(problem,interpretation,to);
	find mayInRelationdependent_reference_Expense(problem,interpretation,from,to);
	neg find mustInRelationdependent_reference_Expense(problem,interpretation,from,to);
}
pattern refineRelation_beneficiary_reference_Expense_and_expenses_reference_Physical_Person(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation, oppositeInterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"beneficiary reference Expense");
	PartialInterpretation.partialrelationinterpretation(interpretation,oppositeInterpretation);
	PartialRelationInterpretation.interpretationOf.name(oppositeInterpretation,"expenses reference Physical_Person");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfExpense_class(problem,interpretation,from);
	find mustInstanceOfPhysical_Person_class(problem,interpretation,to);
	find mayInRelationbeneficiary_reference_Expense(problem,interpretation,from,to);
	neg find mustInRelationbeneficiary_reference_Expense(problem,interpretation,from,to);
}
pattern refineRelation_reciver_reference_External_Allowance(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"reciver reference External_Allowance");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfExternal_Allowance_class(problem,interpretation,from);
	find mustInstanceOfPhysical_Person_class(problem,interpretation,to);
	find mayInRelationreciver_reference_External_Allowance(problem,interpretation,from,to);
	neg find mustInRelationreciver_reference_External_Allowance(problem,interpretation,from,to);
}
pattern refineRelation_expense_reference_FromAgent_and_from_agent_reference_Expense(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation, oppositeInterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"expense reference FromAgent");
	PartialInterpretation.partialrelationinterpretation(interpretation,oppositeInterpretation);
	PartialRelationInterpretation.interpretationOf.name(oppositeInterpretation,"from_agent reference Expense");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFromAgent_class(problem,interpretation,from);
	find mustInstanceOfExpense_class(problem,interpretation,to);
	find mayInRelationexpense_reference_FromAgent(problem,interpretation,from,to);
	neg find mustInRelationexpense_reference_FromAgent(problem,interpretation,from,to);
}
pattern refineRelation_dependent_reference_FromAgent_and_from_agent_reference_Dependent(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation, oppositeInterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"dependent reference FromAgent");
	PartialInterpretation.partialrelationinterpretation(interpretation,oppositeInterpretation);
	PartialRelationInterpretation.interpretationOf.name(oppositeInterpretation,"from_agent reference Dependent");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFromAgent_class(problem,interpretation,from);
	find mustInstanceOfDependent_class(problem,interpretation,to);
	find mayInRelationdependent_reference_FromAgent(problem,interpretation,from,to);
	neg find mustInRelationdependent_reference_FromAgent(problem,interpretation,from,to);
}
pattern refineRelation_tax_payers_address_reference_Tax_Card(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"tax_payers_address reference Tax_Card");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfTax_Card_class(problem,interpretation,from);
	find mustInstanceOfAddress_class(problem,interpretation,to);
	find mayInRelationtax_payers_address_reference_Tax_Card(problem,interpretation,from,to);
	neg find mustInRelationtax_payers_address_reference_Tax_Card(problem,interpretation,from,to);
}
pattern refineRelation_income_Tax_Credit_reference_Tax_Card_and_taxation_Frame_reference_Income_Tax_Credit(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation, oppositeInterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"income_Tax_Credit reference Tax_Card");
	PartialInterpretation.partialrelationinterpretation(interpretation,oppositeInterpretation);
	PartialRelationInterpretation.interpretationOf.name(oppositeInterpretation,"taxation_Frame reference Income_Tax_Credit");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfTax_Card_class(problem,interpretation,from);
	find mustInstanceOfIncome_Tax_Credit_class(problem,interpretation,to);
	find mayInRelationincome_Tax_Credit_reference_Tax_Card(problem,interpretation,from,to);
	neg find mustInRelationincome_Tax_Credit_reference_Tax_Card(problem,interpretation,from,to);
}
pattern refineRelation_current_tax_card_reference_Tax_Card_and_previous_reference_Tax_Card(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation, oppositeInterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"current_tax_card reference Tax_Card");
	PartialInterpretation.partialrelationinterpretation(interpretation,oppositeInterpretation);
	PartialRelationInterpretation.interpretationOf.name(oppositeInterpretation,"previous reference Tax_Card");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfTax_Card_class(problem,interpretation,from);
	find mustInstanceOfTax_Card_class(problem,interpretation,to);
	find mayInRelationcurrent_tax_card_reference_Tax_Card(problem,interpretation,from,to);
	neg find mustInRelationcurrent_tax_card_reference_Tax_Card(problem,interpretation,from,to);
}
pattern refineRelation_taxPayer_reference_Income_Tax_Credit(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"taxPayer reference Income_Tax_Credit");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfIncome_Tax_Credit_class(problem,interpretation,from);
	find mustInstanceOfTax_Payer_class(problem,interpretation,to);
	find mayInRelationtaxPayer_reference_Income_Tax_Credit(problem,interpretation,from,to);
	neg find mustInRelationtaxPayer_reference_Income_Tax_Credit(problem,interpretation,from,to);
}
pattern refineRelation_MAXIMUM_CE_RATE_FOR_CHILD_NOT_BEING_PART_OF_HOUSEHOLD_attribute_Constants(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"MAXIMUM_CE_RATE_FOR_CHILD_NOT_BEING_PART_OF_HOUSEHOLD attribute Constants");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfConstants_class(problem,interpretation,from);
	RealElement(to);
	find mayInRelationMAXIMUM_CE_RATE_FOR_CHILD_NOT_BEING_PART_OF_HOUSEHOLD_attribute_Constants(problem,interpretation,from,to);
	neg find mustInRelationMAXIMUM_CE_RATE_FOR_CHILD_NOT_BEING_PART_OF_HOUSEHOLD_attribute_Constants(problem,interpretation,from,to);
}
pattern refineRelation_MAXIMUM_CE_RATE_FOR_HOUSE_CARE_AND_CHILD_PART_OF_THE_HOUSEHOLD_CARE_attribute_Constants(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"MAXIMUM_CE_RATE_FOR_HOUSE_CARE_AND_CHILD_PART_OF_THE_HOUSEHOLD_CARE attribute Constants");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfConstants_class(problem,interpretation,from);
	RealElement(to);
	find mayInRelationMAXIMUM_CE_RATE_FOR_HOUSE_CARE_AND_CHILD_PART_OF_THE_HOUSEHOLD_CARE_attribute_Constants(problem,interpretation,from,to);
	neg find mustInRelationMAXIMUM_CE_RATE_FOR_HOUSE_CARE_AND_CHILD_PART_OF_THE_HOUSEHOLD_CARE_attribute_Constants(problem,interpretation,from,to);
}
pattern refineRelation_MINIMUM_SALARY_attribute_Constants(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"MINIMUM_SALARY attribute Constants");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfConstants_class(problem,interpretation,from);
	RealElement(to);
	find mayInRelationMINIMUM_SALARY_attribute_Constants(problem,interpretation,from,to);
	neg find mustInRelationMINIMUM_SALARY_attribute_Constants(problem,interpretation,from,to);
}
pattern refineRelation_FLAT_RATE_FOR_EXTRA_PROFESSIONAL_DEDUCTION_attribute_Constants(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"FLAT_RATE_FOR_EXTRA_PROFESSIONAL_DEDUCTION attribute Constants");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfConstants_class(problem,interpretation,from);
	RealElement(to);
	find mayInRelationFLAT_RATE_FOR_EXTRA_PROFESSIONAL_DEDUCTION_attribute_Constants(problem,interpretation,from,to);
	neg find mustInRelationFLAT_RATE_FOR_EXTRA_PROFESSIONAL_DEDUCTION_attribute_Constants(problem,interpretation,from,to);
}
pattern refineRelation_MAXIMUM_DEDUCTIBLE_PERCENTAGE_FOR_DONATIONS_attribute_Constants(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"MAXIMUM_DEDUCTIBLE_PERCENTAGE_FOR_DONATIONS attribute Constants");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfConstants_class(problem,interpretation,from);
	RealElement(to);
	find mayInRelationMAXIMUM_DEDUCTIBLE_PERCENTAGE_FOR_DONATIONS_attribute_Constants(problem,interpretation,from,to);
	neg find mustInRelationMAXIMUM_DEDUCTIBLE_PERCENTAGE_FOR_DONATIONS_attribute_Constants(problem,interpretation,from,to);
}
pattern refineRelation_MINIMUM_DEDUCTIBLE_AMOUNT_FOR_DONATIONS_attribute_Constants(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"MINIMUM_DEDUCTIBLE_AMOUNT_FOR_DONATIONS attribute Constants");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfConstants_class(problem,interpretation,from);
	RealElement(to);
	find mayInRelationMINIMUM_DEDUCTIBLE_AMOUNT_FOR_DONATIONS_attribute_Constants(problem,interpretation,from,to);
	neg find mustInRelationMINIMUM_DEDUCTIBLE_AMOUNT_FOR_DONATIONS_attribute_Constants(problem,interpretation,from,to);
}
pattern refineRelation_MAXIMUM_DEDUCTIBLE_AMOUNT_FOR_ADDITIONAL_PENSION_AND_INSURANC_attribute_Constants(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"MAXIMUM_DEDUCTIBLE_AMOUNT_FOR_ADDITIONAL_PENSION_AND_INSURANC attribute Constants");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfConstants_class(problem,interpretation,from);
	RealElement(to);
	find mayInRelationMAXIMUM_DEDUCTIBLE_AMOUNT_FOR_ADDITIONAL_PENSION_AND_INSURANC_attribute_Constants(problem,interpretation,from,to);
	neg find mustInRelationMAXIMUM_DEDUCTIBLE_AMOUNT_FOR_ADDITIONAL_PENSION_AND_INSURANC_attribute_Constants(problem,interpretation,from,to);
}
pattern refineRelation_MAXIMUM_DEDUCTIBLE_AMOUNT_FOR_ALIMONY_EXPENSE_attribute_Constants(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"MAXIMUM_DEDUCTIBLE_AMOUNT_FOR_ALIMONY_EXPENSE attribute Constants");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfConstants_class(problem,interpretation,from);
	RealElement(to);
	find mayInRelationMAXIMUM_DEDUCTIBLE_AMOUNT_FOR_ALIMONY_EXPENSE_attribute_Constants(problem,interpretation,from,to);
	neg find mustInRelationMAXIMUM_DEDUCTIBLE_AMOUNT_FOR_ALIMONY_EXPENSE_attribute_Constants(problem,interpretation,from,to);
}
pattern refineRelation_MAXIMAL_DISTANCE_FOR_TRAVEL_EXPENSE_DEDUCTION_attribute_Constants(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"MAXIMAL_DISTANCE_FOR_TRAVEL_EXPENSE_DEDUCTION attribute Constants");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfConstants_class(problem,interpretation,from);
	RealElement(to);
	find mayInRelationMAXIMAL_DISTANCE_FOR_TRAVEL_EXPENSE_DEDUCTION_attribute_Constants(problem,interpretation,from,to);
	neg find mustInRelationMAXIMAL_DISTANCE_FOR_TRAVEL_EXPENSE_DEDUCTION_attribute_Constants(problem,interpretation,from,to);
}
pattern refineRelation_MAXIMAL_FLAT_DISTANCE_FOR_TRAVEL_EXPENSE_DEDUCTION_attribute_Constants(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"MAXIMAL_FLAT_DISTANCE_FOR_TRAVEL_EXPENSE_DEDUCTION attribute Constants");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfConstants_class(problem,interpretation,from);
	RealElement(to);
	find mayInRelationMAXIMAL_FLAT_DISTANCE_FOR_TRAVEL_EXPENSE_DEDUCTION_attribute_Constants(problem,interpretation,from,to);
	neg find mustInRelationMAXIMAL_FLAT_DISTANCE_FOR_TRAVEL_EXPENSE_DEDUCTION_attribute_Constants(problem,interpretation,from,to);
}
pattern refineRelation_MINIMAL_DISTANCE_FOR_TRAVEL_EXPENSE_DEDUCTION_attribute_Constants(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"MINIMAL_DISTANCE_FOR_TRAVEL_EXPENSE_DEDUCTION attribute Constants");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfConstants_class(problem,interpretation,from);
	RealElement(to);
	find mayInRelationMINIMAL_DISTANCE_FOR_TRAVEL_EXPENSE_DEDUCTION_attribute_Constants(problem,interpretation,from,to);
	neg find mustInRelationMINIMAL_DISTANCE_FOR_TRAVEL_EXPENSE_DEDUCTION_attribute_Constants(problem,interpretation,from,to);
}
pattern refineRelation_FLAT_RATE_CIM_DAILY_attribute_Constants(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"FLAT_RATE_CIM_DAILY attribute Constants");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfConstants_class(problem,interpretation,from);
	RealElement(to);
	find mayInRelationFLAT_RATE_CIM_DAILY_attribute_Constants(problem,interpretation,from,to);
	neg find mustInRelationFLAT_RATE_CIM_DAILY_attribute_Constants(problem,interpretation,from,to);
}
pattern refineRelation_FLAT_RATE_CIM_MONTHLY_attribute_Constants(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"FLAT_RATE_CIM_MONTHLY attribute Constants");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfConstants_class(problem,interpretation,from);
	RealElement(to);
	find mayInRelationFLAT_RATE_CIM_MONTHLY_attribute_Constants(problem,interpretation,from,to);
	neg find mustInRelationFLAT_RATE_CIM_MONTHLY_attribute_Constants(problem,interpretation,from,to);
}
pattern refineRelation_FLAT_RATE_CIM_YEARLY_attribute_Constants(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"FLAT_RATE_CIM_YEARLY attribute Constants");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfConstants_class(problem,interpretation,from);
	RealElement(to);
	find mayInRelationFLAT_RATE_CIM_YEARLY_attribute_Constants(problem,interpretation,from,to);
	neg find mustInRelationFLAT_RATE_CIM_YEARLY_attribute_Constants(problem,interpretation,from,to);
}
pattern refineRelation_FLAT_RATE_CIP_DAILY_attribute_Constants(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"FLAT_RATE_CIP_DAILY attribute Constants");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfConstants_class(problem,interpretation,from);
	RealElement(to);
	find mayInRelationFLAT_RATE_CIP_DAILY_attribute_Constants(problem,interpretation,from,to);
	neg find mustInRelationFLAT_RATE_CIP_DAILY_attribute_Constants(problem,interpretation,from,to);
}
pattern refineRelation_FLAT_RATE_CIP_MONTHLY_attribute_Constants(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"FLAT_RATE_CIP_MONTHLY attribute Constants");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfConstants_class(problem,interpretation,from);
	RealElement(to);
	find mayInRelationFLAT_RATE_CIP_MONTHLY_attribute_Constants(problem,interpretation,from,to);
	neg find mustInRelationFLAT_RATE_CIP_MONTHLY_attribute_Constants(problem,interpretation,from,to);
}
pattern refineRelation_FLAT_RATE_CIP_YEARLY_attribute_Constants(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"FLAT_RATE_CIP_YEARLY attribute Constants");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfConstants_class(problem,interpretation,from);
	RealElement(to);
	find mayInRelationFLAT_RATE_CIP_YEARLY_attribute_Constants(problem,interpretation,from,to);
	neg find mustInRelationFLAT_RATE_CIP_YEARLY_attribute_Constants(problem,interpretation,from,to);
}
pattern refineRelation_FLAT_RATE_CIS_DAILY_attribute_Constants(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"FLAT_RATE_CIS_DAILY attribute Constants");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfConstants_class(problem,interpretation,from);
	RealElement(to);
	find mayInRelationFLAT_RATE_CIS_DAILY_attribute_Constants(problem,interpretation,from,to);
	neg find mustInRelationFLAT_RATE_CIS_DAILY_attribute_Constants(problem,interpretation,from,to);
}
pattern refineRelation_FLAT_RATE_CIS_MONTHLY_attribute_Constants(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"FLAT_RATE_CIS_MONTHLY attribute Constants");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfConstants_class(problem,interpretation,from);
	RealElement(to);
	find mayInRelationFLAT_RATE_CIS_MONTHLY_attribute_Constants(problem,interpretation,from,to);
	neg find mustInRelationFLAT_RATE_CIS_MONTHLY_attribute_Constants(problem,interpretation,from,to);
}
pattern refineRelation_FLAT_RATE_CIS_YEARLY_attribute_Constants(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"FLAT_RATE_CIS_YEARLY attribute Constants");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfConstants_class(problem,interpretation,from);
	RealElement(to);
	find mayInRelationFLAT_RATE_CIS_YEARLY_attribute_Constants(problem,interpretation,from,to);
	neg find mustInRelationFLAT_RATE_CIS_YEARLY_attribute_Constants(problem,interpretation,from,to);
}
pattern refineRelation_FLAT_RATE_FOR_TRAVEL_EXPENSE_PER_UNIT_attribute_Constants(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"FLAT_RATE_FOR_TRAVEL_EXPENSE_PER_UNIT attribute Constants");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfConstants_class(problem,interpretation,from);
	RealElement(to);
	find mayInRelationFLAT_RATE_FOR_TRAVEL_EXPENSE_PER_UNIT_attribute_Constants(problem,interpretation,from,to);
	neg find mustInRelationFLAT_RATE_FOR_TRAVEL_EXPENSE_PER_UNIT_attribute_Constants(problem,interpretation,from,to);
}
pattern refineRelation_MAXIMUM_DEDUCTIBLE_AMOUNT_FOR_DS_attribute_Constants(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"MAXIMUM_DEDUCTIBLE_AMOUNT_FOR_DS attribute Constants");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfConstants_class(problem,interpretation,from);
	RealElement(to);
	find mayInRelationMAXIMUM_DEDUCTIBLE_AMOUNT_FOR_DS_attribute_Constants(problem,interpretation,from,to);
	neg find mustInRelationMAXIMUM_DEDUCTIBLE_AMOUNT_FOR_DS_attribute_Constants(problem,interpretation,from,to);
}
pattern refineRelation_FLAT_RATE_FOR_MISCELLANEOUS_EXPENSE_attribute_Constants(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"FLAT_RATE_FOR_MISCELLANEOUS_EXPENSE attribute Constants");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfConstants_class(problem,interpretation,from);
	RealElement(to);
	find mayInRelationFLAT_RATE_FOR_MISCELLANEOUS_EXPENSE_attribute_Constants(problem,interpretation,from,to);
	neg find mustInRelationFLAT_RATE_FOR_MISCELLANEOUS_EXPENSE_attribute_Constants(problem,interpretation,from,to);
}
pattern refineRelation_DISABILITY_FLAT_RATE_FOR_MISCELLANEOUS_EXPENSE_attribute_Constants(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"DISABILITY_FLAT_RATE_FOR_MISCELLANEOUS_EXPENSE attribute Constants");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfConstants_class(problem,interpretation,from);
	RealElement(to);
	find mayInRelationDISABILITY_FLAT_RATE_FOR_MISCELLANEOUS_EXPENSE_attribute_Constants(problem,interpretation,from,to);
	neg find mustInRelationDISABILITY_FLAT_RATE_FOR_MISCELLANEOUS_EXPENSE_attribute_Constants(problem,interpretation,from,to);
}
pattern refineRelation_MAXIMUM_DEDUCTIBLE_AMOUNT_FOR_ADDITIONAL_PENSION_AND_INSURANCE_attribute_Constants(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"MAXIMUM_DEDUCTIBLE_AMOUNT_FOR_ADDITIONAL_PENSION_AND_INSURANCE attribute Constants");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfConstants_class(problem,interpretation,from);
	RealElement(to);
	find mayInRelationMAXIMUM_DEDUCTIBLE_AMOUNT_FOR_ADDITIONAL_PENSION_AND_INSURANCE_attribute_Constants(problem,interpretation,from,to);
	neg find mustInRelationMAXIMUM_DEDUCTIBLE_AMOUNT_FOR_ADDITIONAL_PENSION_AND_INSURANCE_attribute_Constants(problem,interpretation,from,to);
}
pattern refineRelation_tax_amount_attribute_Income_Tax(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"tax_amount attribute Income_Tax");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfIncome_Tax_class(problem,interpretation,from);
	RealElement(to);
	find mayInRelationtax_amount_attribute_Income_Tax(problem,interpretation,from,to);
	neg find mustInRelationtax_amount_attribute_Income_Tax(problem,interpretation,from,to);
}
pattern refineRelation_tax_year_attribute_Income_Tax(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"tax_year attribute Income_Tax");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfIncome_Tax_class(problem,interpretation,from);
	IntegerElement(to);
	find mayInRelationtax_year_attribute_Income_Tax(problem,interpretation,from,to);
	neg find mustInRelationtax_year_attribute_Income_Tax(problem,interpretation,from,to);
}
pattern refineRelation_id6_attribute_Income_Tax(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"id6 attribute Income_Tax");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfIncome_Tax_class(problem,interpretation,from);
	StringElement(to);
	find mayInRelationid6_attribute_Income_Tax(problem,interpretation,from,to);
	neg find mustInRelationid6_attribute_Income_Tax(problem,interpretation,from,to);
}
pattern refineRelation_taxesDue_attribute_Tax_Payer(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"taxesDue attribute Tax_Payer");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfTax_Payer_class(problem,interpretation,from);
	RealElement(to);
	find mayInRelationtaxesDue_attribute_Tax_Payer(problem,interpretation,from,to);
	neg find mustInRelationtaxesDue_attribute_Tax_Payer(problem,interpretation,from,to);
}
pattern refineRelation_is_assisting_spouse_attribute_Physical_Person(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"is_assisting_spouse attribute Physical_Person");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfPhysical_Person_class(problem,interpretation,from);
	BooleanElement(to);
	find mayInRelationis_assisting_spouse_attribute_Physical_Person(problem,interpretation,from,to);
	neg find mustInRelationis_assisting_spouse_attribute_Physical_Person(problem,interpretation,from,to);
}
pattern refineRelation_SSNo_attribute_Physical_Person(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"SSNo attribute Physical_Person");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfPhysical_Person_class(problem,interpretation,from);
	StringElement(to);
	find mayInRelationSSNo_attribute_Physical_Person(problem,interpretation,from,to);
	neg find mustInRelationSSNo_attribute_Physical_Person(problem,interpretation,from,to);
}
pattern refineRelation_birth_year_attribute_Physical_Person(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"birth_year attribute Physical_Person");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfPhysical_Person_class(problem,interpretation,from);
	IntegerElement(to);
	find mayInRelationbirth_year_attribute_Physical_Person(problem,interpretation,from,to);
	neg find mustInRelationbirth_year_attribute_Physical_Person(problem,interpretation,from,to);
}
pattern refineRelation_disability_percentage_attribute_Physical_Person(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"disability_percentage attribute Physical_Person");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfPhysical_Person_class(problem,interpretation,from);
	RealElement(to);
	find mayInRelationdisability_percentage_attribute_Physical_Person(problem,interpretation,from,to);
	neg find mustInRelationdisability_percentage_attribute_Physical_Person(problem,interpretation,from,to);
}
pattern refineRelation_disability_type_attribute_Physical_Person(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"disability_type attribute Physical_Person");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfPhysical_Person_class(problem,interpretation,from);
	find mustInstanceOfDisability_Types_enum(problem,interpretation,to);
	find mayInRelationdisability_type_attribute_Physical_Person(problem,interpretation,from,to);
	neg find mustInRelationdisability_type_attribute_Physical_Person(problem,interpretation,from,to);
}
pattern refineRelation_is_affiliated_personnaly_to_social_security_attribute_Physical_Person(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"is_affiliated_personnaly_to_social_security attribute Physical_Person");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfPhysical_Person_class(problem,interpretation,from);
	BooleanElement(to);
	find mayInRelationis_affiliated_personnaly_to_social_security_attribute_Physical_Person(problem,interpretation,from,to);
	neg find mustInRelationis_affiliated_personnaly_to_social_security_attribute_Physical_Person(problem,interpretation,from,to);
}
pattern refineRelation_birth_month_attribute_Physical_Person(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"birth_month attribute Physical_Person");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfPhysical_Person_class(problem,interpretation,from);
	IntegerElement(to);
	find mayInRelationbirth_month_attribute_Physical_Person(problem,interpretation,from,to);
	neg find mustInRelationbirth_month_attribute_Physical_Person(problem,interpretation,from,to);
}
pattern refineRelation_birth_day_attribute_Physical_Person(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"birth_day attribute Physical_Person");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfPhysical_Person_class(problem,interpretation,from);
	IntegerElement(to);
	find mayInRelationbirth_day_attribute_Physical_Person(problem,interpretation,from,to);
	neg find mustInRelationbirth_day_attribute_Physical_Person(problem,interpretation,from,to);
}
pattern refineRelation_is_widower_attribute_Physical_Person(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"is_widower attribute Physical_Person");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfPhysical_Person_class(problem,interpretation,from);
	BooleanElement(to);
	find mayInRelationis_widower_attribute_Physical_Person(problem,interpretation,from,to);
	neg find mustInRelationis_widower_attribute_Physical_Person(problem,interpretation,from,to);
}
pattern refineRelation_country_attribute_Address(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"country attribute Address");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfAddress_class(problem,interpretation,from);
	find mustInstanceOfCountry_enum(problem,interpretation,to);
	find mayInRelationcountry_attribute_Address(problem,interpretation,from,to);
	neg find mustInRelationcountry_attribute_Address(problem,interpretation,from,to);
}
pattern refineRelation_street_attribute_Address(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"street attribute Address");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfAddress_class(problem,interpretation,from);
	StringElement(to);
	find mayInRelationstreet_attribute_Address(problem,interpretation,from,to);
	neg find mustInRelationstreet_attribute_Address(problem,interpretation,from,to);
}
pattern refineRelation_zipCode_attribute_Address(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"zipCode attribute Address");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfAddress_class(problem,interpretation,from);
	StringElement(to);
	find mayInRelationzipCode_attribute_Address(problem,interpretation,from,to);
	neg find mustInRelationzipCode_attribute_Address(problem,interpretation,from,to);
}
pattern refineRelation_city_attribute_Address(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"city attribute Address");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfAddress_class(problem,interpretation,from);
	StringElement(to);
	find mayInRelationcity_attribute_Address(problem,interpretation,from,to);
	neg find mustInRelationcity_attribute_Address(problem,interpretation,from,to);
}
pattern refineRelation_id2_attribute_Address(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"id2 attribute Address");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfAddress_class(problem,interpretation,from);
	StringElement(to);
	find mayInRelationid2_attribute_Address(problem,interpretation,from,to);
	neg find mustInRelationid2_attribute_Address(problem,interpretation,from,to);
}
pattern refineRelation_declared_amount_attribute_Expense(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"declared_amount attribute Expense");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfExpense_class(problem,interpretation,from);
	RealElement(to);
	find mayInRelationdeclared_amount_attribute_Expense(problem,interpretation,from,to);
	neg find mustInRelationdeclared_amount_attribute_Expense(problem,interpretation,from,to);
}
pattern refineRelation_expense_purpose_attribute_Expense(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"expense_purpose attribute Expense");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfExpense_class(problem,interpretation,from);
	find mustInstanceOfExpense_Purpose_enum(problem,interpretation,to);
	find mayInRelationexpense_purpose_attribute_Expense(problem,interpretation,from,to);
	neg find mustInRelationexpense_purpose_attribute_Expense(problem,interpretation,from,to);
}
pattern refineRelation_id4_attribute_Expense(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"id4 attribute Expense");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfExpense_class(problem,interpretation,from);
	StringElement(to);
	find mayInRelationid4_attribute_Expense(problem,interpretation,from,to);
	neg find mustInRelationid4_attribute_Expense(problem,interpretation,from,to);
}
pattern refineRelation_dependent_type_attribute_Dependent(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"dependent_type attribute Dependent");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfDependent_class(problem,interpretation,from);
	find mustInstanceOfDependent_Type_enum(problem,interpretation,to);
	find mayInRelationdependent_type_attribute_Dependent(problem,interpretation,from,to);
	neg find mustInRelationdependent_type_attribute_Dependent(problem,interpretation,from,to);
}
pattern refineRelation_continued_studies_attribute_Dependent(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"continued_studies attribute Dependent");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfDependent_class(problem,interpretation,from);
	BooleanElement(to);
	find mayInRelationcontinued_studies_attribute_Dependent(problem,interpretation,from,to);
	neg find mustInRelationcontinued_studies_attribute_Dependent(problem,interpretation,from,to);
}
pattern refineRelation_amount_attribute_External_Allowance(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"amount attribute External_Allowance");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfExternal_Allowance_class(problem,interpretation,from);
	RealElement(to);
	find mayInRelationamount_attribute_External_Allowance(problem,interpretation,from,to);
	neg find mustInRelationamount_attribute_External_Allowance(problem,interpretation,from,to);
}
pattern refineRelation_grantor_attribute_External_Allowance(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"grantor attribute External_Allowance");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfExternal_Allowance_class(problem,interpretation,from);
	find mustInstanceOfGrantor_enum(problem,interpretation,to);
	find mayInRelationgrantor_attribute_External_Allowance(problem,interpretation,from,to);
	neg find mustInRelationgrantor_attribute_External_Allowance(problem,interpretation,from,to);
}
pattern refineRelation_starting_year_attribute_External_Allowance(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"starting_year attribute External_Allowance");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfExternal_Allowance_class(problem,interpretation,from);
	IntegerElement(to);
	find mayInRelationstarting_year_attribute_External_Allowance(problem,interpretation,from,to);
	neg find mustInRelationstarting_year_attribute_External_Allowance(problem,interpretation,from,to);
}
pattern refineRelation_ending_year_attribute_External_Allowance(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"ending_year attribute External_Allowance");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfExternal_Allowance_class(problem,interpretation,from);
	IntegerElement(to);
	find mayInRelationending_year_attribute_External_Allowance(problem,interpretation,from,to);
	neg find mustInRelationending_year_attribute_External_Allowance(problem,interpretation,from,to);
}
pattern refineRelation_id5_attribute_External_Allowance(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"id5 attribute External_Allowance");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfExternal_Allowance_class(problem,interpretation,from);
	StringElement(to);
	find mayInRelationid5_attribute_External_Allowance(problem,interpretation,from,to);
	neg find mustInRelationid5_attribute_External_Allowance(problem,interpretation,from,to);
}
pattern refineRelation_id1_attribute_Household(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"id1 attribute Household");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfHousehold_class(problem,interpretation,from);
	StringElement(to);
	find mayInRelationid1_attribute_Household(problem,interpretation,from,to);
	neg find mustInRelationid1_attribute_Household(problem,interpretation,from,to);
}
pattern refineRelation_start_year_attribute_Legal_Union_Record(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"start_year attribute Legal_Union_Record");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfLegal_Union_Record_class(problem,interpretation,from);
	IntegerElement(to);
	find mayInRelationstart_year_attribute_Legal_Union_Record(problem,interpretation,from,to);
	neg find mustInRelationstart_year_attribute_Legal_Union_Record(problem,interpretation,from,to);
}
pattern refineRelation_end_year_attribute_Legal_Union_Record(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"end_year attribute Legal_Union_Record");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfLegal_Union_Record_class(problem,interpretation,from);
	IntegerElement(to);
	find mayInRelationend_year_attribute_Legal_Union_Record(problem,interpretation,from,to);
	neg find mustInRelationend_year_attribute_Legal_Union_Record(problem,interpretation,from,to);
}
pattern refineRelation_separation_cause_attribute_Legal_Union_Record(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"separation_cause attribute Legal_Union_Record");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfLegal_Union_Record_class(problem,interpretation,from);
	find mustInstanceOfSeparation_Causes_enum(problem,interpretation,to);
	find mayInRelationseparation_cause_attribute_Legal_Union_Record(problem,interpretation,from,to);
	neg find mustInRelationseparation_cause_attribute_Legal_Union_Record(problem,interpretation,from,to);
}
pattern refineRelation_mutual_agreement_attribute_Legal_Union_Record(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"mutual_agreement attribute Legal_Union_Record");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfLegal_Union_Record_class(problem,interpretation,from);
	BooleanElement(to);
	find mayInRelationmutual_agreement_attribute_Legal_Union_Record(problem,interpretation,from,to);
	neg find mustInRelationmutual_agreement_attribute_Legal_Union_Record(problem,interpretation,from,to);
}
pattern refineRelation_id9_attribute_Legal_Union_Record(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"id9 attribute Legal_Union_Record");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfLegal_Union_Record_class(problem,interpretation,from);
	StringElement(to);
	find mayInRelationid9_attribute_Legal_Union_Record(problem,interpretation,from,to);
	neg find mustInRelationid9_attribute_Legal_Union_Record(problem,interpretation,from,to);
}
pattern refineRelation_starting_year_attribute_Tax_Property(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"starting_year attribute Tax_Property");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfTax_Property_class(problem,interpretation,from);
	IntegerElement(to);
	find mayInRelationstarting_year_attribute_Tax_Property(problem,interpretation,from,to);
	neg find mustInRelationstarting_year_attribute_Tax_Property(problem,interpretation,from,to);
}
pattern refineRelation_id10_attribute_Tax_Property(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"id10 attribute Tax_Property");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfTax_Property_class(problem,interpretation,from);
	StringElement(to);
	find mayInRelationid10_attribute_Tax_Property(problem,interpretation,from,to);
	neg find mustInRelationid10_attribute_Tax_Property(problem,interpretation,from,to);
}
pattern refineRelation_is_dependent_eligible_for_CE_Not_In_Houshold_Children_Care_attribute_FromAgent(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"is_dependent_eligible_for_CE_Not_In_Houshold_Children_Care attribute FromAgent");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFromAgent_class(problem,interpretation,from);
	BooleanElement(to);
	find mayInRelationis_dependent_eligible_for_CE_Not_In_Houshold_Children_Care_attribute_FromAgent(problem,interpretation,from,to);
	neg find mustInRelationis_dependent_eligible_for_CE_Not_In_Houshold_Children_Care_attribute_FromAgent(problem,interpretation,from,to);
}
pattern refineRelation_is_eligible_debt_attribute_FromAgent(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"is_eligible_debt attribute FromAgent");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFromAgent_class(problem,interpretation,from);
	BooleanElement(to);
	find mayInRelationis_eligible_debt_attribute_FromAgent(problem,interpretation,from,to);
	neg find mustInRelationis_eligible_debt_attribute_FromAgent(problem,interpretation,from,to);
}
pattern refineRelation_income_amount_attribute_Income(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"income_amount attribute Income");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfIncome_class(problem,interpretation,from);
	RealElement(to);
	find mayInRelationincome_amount_attribute_Income(problem,interpretation,from,to);
	neg find mustInRelationincome_amount_attribute_Income(problem,interpretation,from,to);
}
pattern refineRelation_tax_liability_attribute_Income(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"tax_liability attribute Income");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfIncome_class(problem,interpretation,from);
	RealElement(to);
	find mayInRelationtax_liability_attribute_Income(problem,interpretation,from,to);
	neg find mustInRelationtax_liability_attribute_Income(problem,interpretation,from,to);
}
pattern refineRelation_num_attribute_Income(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"num attribute Income");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfIncome_class(problem,interpretation,from);
	IntegerElement(to);
	find mayInRelationnum_attribute_Income(problem,interpretation,from,to);
	neg find mustInRelationnum_attribute_Income(problem,interpretation,from,to);
}
pattern refineRelation_subjectToWithholdingTax_attribute_Income_Type(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"subjectToWithholdingTax attribute Income_Type");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfIncome_Type_class(problem,interpretation,from);
	BooleanElement(to);
	find mayInRelationsubjectToWithholdingTax_attribute_Income_Type(problem,interpretation,from,to);
	neg find mustInRelationsubjectToWithholdingTax_attribute_Income_Type(problem,interpretation,from,to);
}
pattern refineRelation_id8_attribute_Income_Type(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"id8 attribute Income_Type");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfIncome_Type_class(problem,interpretation,from);
	StringElement(to);
	find mayInRelationid8_attribute_Income_Type(problem,interpretation,from,to);
	neg find mustInRelationid8_attribute_Income_Type(problem,interpretation,from,to);
}
pattern refineRelation_card_identifier_attribute_Tax_Card(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"card_identifier attribute Tax_Card");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfTax_Card_class(problem,interpretation,from);
	StringElement(to);
	find mayInRelationcard_identifier_attribute_Tax_Card(problem,interpretation,from,to);
	neg find mustInRelationcard_identifier_attribute_Tax_Card(problem,interpretation,from,to);
}
pattern refineRelation_tax_card_type_attribute_Tax_Card(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"tax_card_type attribute Tax_Card");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfTax_Card_class(problem,interpretation,from);
	find mustInstanceOfTax_Card_Type_enum(problem,interpretation,to);
	find mayInRelationtax_card_type_attribute_Tax_Card(problem,interpretation,from,to);
	neg find mustInRelationtax_card_type_attribute_Tax_Card(problem,interpretation,from,to);
}
pattern refineRelation_tax_office_attribute_Tax_Card(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"tax_office attribute Tax_Card");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfTax_Card_class(problem,interpretation,from);
	find mustInstanceOfTax_Office_enum(problem,interpretation,to);
	find mayInRelationtax_office_attribute_Tax_Card(problem,interpretation,from,to);
	neg find mustInRelationtax_office_attribute_Tax_Card(problem,interpretation,from,to);
}
pattern refineRelation_percentage_of_witholding_attribute_Tax_Card(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"percentage_of_witholding attribute Tax_Card");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfTax_Card_class(problem,interpretation,from);
	RealElement(to);
	find mayInRelationpercentage_of_witholding_attribute_Tax_Card(problem,interpretation,from,to);
	neg find mustInRelationpercentage_of_witholding_attribute_Tax_Card(problem,interpretation,from,to);
}
pattern refineRelation_tax_payers_name_surname_attribute_Tax_Card(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"tax_payers_name_surname attribute Tax_Card");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfTax_Card_class(problem,interpretation,from);
	StringElement(to);
	find mayInRelationtax_payers_name_surname_attribute_Tax_Card(problem,interpretation,from,to);
	neg find mustInRelationtax_payers_name_surname_attribute_Tax_Card(problem,interpretation,from,to);
}
pattern refineRelation_tax_payers_partner_name_surname_attribute_Tax_Card(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"tax_payers_partner_name_surname attribute Tax_Card");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfTax_Card_class(problem,interpretation,from);
	StringElement(to);
	find mayInRelationtax_payers_partner_name_surname_attribute_Tax_Card(problem,interpretation,from,to);
	neg find mustInRelationtax_payers_partner_name_surname_attribute_Tax_Card(problem,interpretation,from,to);
}
pattern refineRelation_jobs_Employer_SSNo_attribute_Tax_Card(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"jobs_Employer_SSNo attribute Tax_Card");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfTax_Card_class(problem,interpretation,from);
	StringElement(to);
	find mayInRelationjobs_Employer_SSNo_attribute_Tax_Card(problem,interpretation,from,to);
	neg find mustInRelationjobs_Employer_SSNo_attribute_Tax_Card(problem,interpretation,from,to);
}
pattern refineRelation_jobs_employers_name_attribute_Tax_Card(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"jobs_employers_name attribute Tax_Card");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfTax_Card_class(problem,interpretation,from);
	StringElement(to);
	find mayInRelationjobs_employers_name_attribute_Tax_Card(problem,interpretation,from,to);
	neg find mustInRelationjobs_employers_name_attribute_Tax_Card(problem,interpretation,from,to);
}
pattern refineRelation_jobs_activity_type_attribute_Tax_Card(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"jobs_activity_type attribute Tax_Card");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfTax_Card_class(problem,interpretation,from);
	find mustInstanceOfJob_Activity_enum(problem,interpretation,to);
	find mayInRelationjobs_activity_type_attribute_Tax_Card(problem,interpretation,from,to);
	neg find mustInRelationjobs_activity_type_attribute_Tax_Card(problem,interpretation,from,to);
}
pattern refineRelation_jobs_place_of_work_attribute_Tax_Card(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"jobs_place_of_work attribute Tax_Card");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfTax_Card_class(problem,interpretation,from);
	find mustInstanceOfTown_enum(problem,interpretation,to);
	find mayInRelationjobs_place_of_work_attribute_Tax_Card(problem,interpretation,from,to);
	neg find mustInRelationjobs_place_of_work_attribute_Tax_Card(problem,interpretation,from,to);
}
pattern refineRelation_deduction_FD_daily_attribute_Tax_Card(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"deduction_FD_daily attribute Tax_Card");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfTax_Card_class(problem,interpretation,from);
	RealElement(to);
	find mayInRelationdeduction_FD_daily_attribute_Tax_Card(problem,interpretation,from,to);
	neg find mustInRelationdeduction_FD_daily_attribute_Tax_Card(problem,interpretation,from,to);
}
pattern refineRelation_deduction_FD_monthly_attribute_Tax_Card(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"deduction_FD_monthly attribute Tax_Card");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfTax_Card_class(problem,interpretation,from);
	RealElement(to);
	find mayInRelationdeduction_FD_monthly_attribute_Tax_Card(problem,interpretation,from,to);
	neg find mustInRelationdeduction_FD_monthly_attribute_Tax_Card(problem,interpretation,from,to);
}
pattern refineRelation_deduction_AC_daily_attribute_Tax_Card(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"deduction_AC_daily attribute Tax_Card");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfTax_Card_class(problem,interpretation,from);
	RealElement(to);
	find mayInRelationdeduction_AC_daily_attribute_Tax_Card(problem,interpretation,from,to);
	neg find mustInRelationdeduction_AC_daily_attribute_Tax_Card(problem,interpretation,from,to);
}
pattern refineRelation_deduction_AC_monthly_attribute_Tax_Card(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"deduction_AC_monthly attribute Tax_Card");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfTax_Card_class(problem,interpretation,from);
	RealElement(to);
	find mayInRelationdeduction_AC_monthly_attribute_Tax_Card(problem,interpretation,from,to);
	neg find mustInRelationdeduction_AC_monthly_attribute_Tax_Card(problem,interpretation,from,to);
}
pattern refineRelation_deduction_AC_yearly_attribute_Tax_Card(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"deduction_AC_yearly attribute Tax_Card");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfTax_Card_class(problem,interpretation,from);
	RealElement(to);
	find mayInRelationdeduction_AC_yearly_attribute_Tax_Card(problem,interpretation,from,to);
	neg find mustInRelationdeduction_AC_yearly_attribute_Tax_Card(problem,interpretation,from,to);
}
pattern refineRelation_deduction_CE_daily_attribute_Tax_Card(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"deduction_CE_daily attribute Tax_Card");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfTax_Card_class(problem,interpretation,from);
	RealElement(to);
	find mayInRelationdeduction_CE_daily_attribute_Tax_Card(problem,interpretation,from,to);
	neg find mustInRelationdeduction_CE_daily_attribute_Tax_Card(problem,interpretation,from,to);
}
pattern refineRelation_deduction_CE_monthly_attribute_Tax_Card(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"deduction_CE_monthly attribute Tax_Card");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfTax_Card_class(problem,interpretation,from);
	RealElement(to);
	find mayInRelationdeduction_CE_monthly_attribute_Tax_Card(problem,interpretation,from,to);
	neg find mustInRelationdeduction_CE_monthly_attribute_Tax_Card(problem,interpretation,from,to);
}
pattern refineRelation_deduction_CE_yearly_attribute_Tax_Card(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"deduction_CE_yearly attribute Tax_Card");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfTax_Card_class(problem,interpretation,from);
	RealElement(to);
	find mayInRelationdeduction_CE_yearly_attribute_Tax_Card(problem,interpretation,from,to);
	neg find mustInRelationdeduction_CE_yearly_attribute_Tax_Card(problem,interpretation,from,to);
}
pattern refineRelation_deduction_DS_daily_attribute_Tax_Card(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"deduction_DS_daily attribute Tax_Card");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfTax_Card_class(problem,interpretation,from);
	RealElement(to);
	find mayInRelationdeduction_DS_daily_attribute_Tax_Card(problem,interpretation,from,to);
	neg find mustInRelationdeduction_DS_daily_attribute_Tax_Card(problem,interpretation,from,to);
}
pattern refineRelation_deduction_DS_monthly_attribute_Tax_Card(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"deduction_DS_monthly attribute Tax_Card");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfTax_Card_class(problem,interpretation,from);
	RealElement(to);
	find mayInRelationdeduction_DS_monthly_attribute_Tax_Card(problem,interpretation,from,to);
	neg find mustInRelationdeduction_DS_monthly_attribute_Tax_Card(problem,interpretation,from,to);
}
pattern refineRelation_deduction_FO_daily_attribute_Tax_Card(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"deduction_FO_daily attribute Tax_Card");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfTax_Card_class(problem,interpretation,from);
	RealElement(to);
	find mayInRelationdeduction_FO_daily_attribute_Tax_Card(problem,interpretation,from,to);
	neg find mustInRelationdeduction_FO_daily_attribute_Tax_Card(problem,interpretation,from,to);
}
pattern refineRelation_deduction_FO_monthly_attribute_Tax_Card(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"deduction_FO_monthly attribute Tax_Card");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfTax_Card_class(problem,interpretation,from);
	RealElement(to);
	find mayInRelationdeduction_FO_monthly_attribute_Tax_Card(problem,interpretation,from,to);
	neg find mustInRelationdeduction_FO_monthly_attribute_Tax_Card(problem,interpretation,from,to);
}
pattern refineRelation_deduction_FO_yearly_attribute_Tax_Card(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"deduction_FO_yearly attribute Tax_Card");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfTax_Card_class(problem,interpretation,from);
	RealElement(to);
	find mayInRelationdeduction_FO_yearly_attribute_Tax_Card(problem,interpretation,from,to);
	neg find mustInRelationdeduction_FO_yearly_attribute_Tax_Card(problem,interpretation,from,to);
}
pattern refineRelation_credit_CIS_daily_attribute_Tax_Card(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"credit_CIS_daily attribute Tax_Card");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfTax_Card_class(problem,interpretation,from);
	RealElement(to);
	find mayInRelationcredit_CIS_daily_attribute_Tax_Card(problem,interpretation,from,to);
	neg find mustInRelationcredit_CIS_daily_attribute_Tax_Card(problem,interpretation,from,to);
}
pattern refineRelation_credit_CIS_monthly_attribute_Tax_Card(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"credit_CIS_monthly attribute Tax_Card");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfTax_Card_class(problem,interpretation,from);
	RealElement(to);
	find mayInRelationcredit_CIS_monthly_attribute_Tax_Card(problem,interpretation,from,to);
	neg find mustInRelationcredit_CIS_monthly_attribute_Tax_Card(problem,interpretation,from,to);
}
pattern refineRelation_credit_CIM_daily_attribute_Tax_Card(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"credit_CIM_daily attribute Tax_Card");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfTax_Card_class(problem,interpretation,from);
	RealElement(to);
	find mayInRelationcredit_CIM_daily_attribute_Tax_Card(problem,interpretation,from,to);
	neg find mustInRelationcredit_CIM_daily_attribute_Tax_Card(problem,interpretation,from,to);
}
pattern refineRelation_validity_attribute_Tax_Card(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"validity attribute Tax_Card");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfTax_Card_class(problem,interpretation,from);
	BooleanElement(to);
	find mayInRelationvalidity_attribute_Tax_Card(problem,interpretation,from,to);
	neg find mustInRelationvalidity_attribute_Tax_Card(problem,interpretation,from,to);
}
pattern refineRelation_credit_CIM_yearly_attribute_Tax_Card(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"credit_CIM_yearly attribute Tax_Card");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfTax_Card_class(problem,interpretation,from);
	RealElement(to);
	find mayInRelationcredit_CIM_yearly_attribute_Tax_Card(problem,interpretation,from,to);
	neg find mustInRelationcredit_CIM_yearly_attribute_Tax_Card(problem,interpretation,from,to);
}
pattern refineRelation_deduction_DS_Alimony_yearly_attribute_Tax_Card(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"deduction_DS_Alimony_yearly attribute Tax_Card");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfTax_Card_class(problem,interpretation,from);
	RealElement(to);
	find mayInRelationdeduction_DS_Alimony_yearly_attribute_Tax_Card(problem,interpretation,from,to);
	neg find mustInRelationdeduction_DS_Alimony_yearly_attribute_Tax_Card(problem,interpretation,from,to);
}
pattern refineRelation_deduction_DS_Debt_yearly_attribute_Tax_Card(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"deduction_DS_Debt_yearly attribute Tax_Card");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfTax_Card_class(problem,interpretation,from);
	RealElement(to);
	find mayInRelationdeduction_DS_Debt_yearly_attribute_Tax_Card(problem,interpretation,from,to);
	neg find mustInRelationdeduction_DS_Debt_yearly_attribute_Tax_Card(problem,interpretation,from,to);
}
pattern refineRelation_grantedBy_attribute_Income_Tax_Credit(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"grantedBy attribute Income_Tax_Credit");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfIncome_Tax_Credit_class(problem,interpretation,from);
	find mustInstanceOfGrantor_enum(problem,interpretation,to);
	find mayInRelationgrantedBy_attribute_Income_Tax_Credit(problem,interpretation,from,to);
	neg find mustInRelationgrantedBy_attribute_Income_Tax_Credit(problem,interpretation,from,to);
}
pattern refineRelation_tax_year_attribute_Income_Tax_Credit(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"tax_year attribute Income_Tax_Credit");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfIncome_Tax_Credit_class(problem,interpretation,from);
	IntegerElement(to);
	find mayInRelationtax_year_attribute_Income_Tax_Credit(problem,interpretation,from,to);
	neg find mustInRelationtax_year_attribute_Income_Tax_Credit(problem,interpretation,from,to);
}
pattern refineRelation_yearly_attribute_Income_Tax_Credit(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"yearly attribute Income_Tax_Credit");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfIncome_Tax_Credit_class(problem,interpretation,from);
	RealElement(to);
	find mayInRelationyearly_attribute_Income_Tax_Credit(problem,interpretation,from,to);
	neg find mustInRelationyearly_attribute_Income_Tax_Credit(problem,interpretation,from,to);
}
pattern refineRelation_monthly_attribute_Income_Tax_Credit(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"monthly attribute Income_Tax_Credit");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfIncome_Tax_Credit_class(problem,interpretation,from);
	RealElement(to);
	find mayInRelationmonthly_attribute_Income_Tax_Credit(problem,interpretation,from,to);
	neg find mustInRelationmonthly_attribute_Income_Tax_Credit(problem,interpretation,from,to);
}
pattern refineRelation_daily_attribute_Income_Tax_Credit(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"daily attribute Income_Tax_Credit");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfIncome_Tax_Credit_class(problem,interpretation,from);
	RealElement(to);
	find mayInRelationdaily_attribute_Income_Tax_Credit(problem,interpretation,from,to);
	neg find mustInRelationdaily_attribute_Income_Tax_Credit(problem,interpretation,from,to);
}
pattern refineRelation_id7_attribute_Income_Tax_Credit(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"id7 attribute Income_Tax_Credit");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfIncome_Tax_Credit_class(problem,interpretation,from);
	StringElement(to);
	find mayInRelationid7_attribute_Income_Tax_Credit(problem,interpretation,from,to);
	neg find mustInRelationid7_attribute_Income_Tax_Credit(problem,interpretation,from,to);
}
pattern refineRelation_amount_attribute_Income_Detail(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"amount attribute Income_Detail");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfIncome_Detail_class(problem,interpretation,from);
	RealElement(to);
	find mayInRelationamount_attribute_Income_Detail(problem,interpretation,from,to);
	neg find mustInRelationamount_attribute_Income_Detail(problem,interpretation,from,to);
}
pattern refineRelation_is_worked_attribute_Income_Detail(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"is_worked attribute Income_Detail");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfIncome_Detail_class(problem,interpretation,from);
	BooleanElement(to);
	find mayInRelationis_worked_attribute_Income_Detail(problem,interpretation,from,to);
	neg find mustInRelationis_worked_attribute_Income_Detail(problem,interpretation,from,to);
}
pattern refineRelation_distance_attribute_Income_Detail(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"distance attribute Income_Detail");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfIncome_Detail_class(problem,interpretation,from);
	RealElement(to);
	find mayInRelationdistance_attribute_Income_Detail(problem,interpretation,from,to);
	neg find mustInRelationdistance_attribute_Income_Detail(problem,interpretation,from,to);
}
pattern refineRelation_worked_days_attribute_Income_Detail(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"worked_days attribute Income_Detail");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfIncome_Detail_class(problem,interpretation,from);
	IntegerElement(to);
	find mayInRelationworked_days_attribute_Income_Detail(problem,interpretation,from,to);
	neg find mustInRelationworked_days_attribute_Income_Detail(problem,interpretation,from,to);
}
pattern refineRelation_is_contributing_CNS_attribute_Income_Detail(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"is_contributing_CNS attribute Income_Detail");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfIncome_Detail_class(problem,interpretation,from);
	BooleanElement(to);
	find mayInRelationis_contributing_CNS_attribute_Income_Detail(problem,interpretation,from,to);
	neg find mustInRelationis_contributing_CNS_attribute_Income_Detail(problem,interpretation,from,to);
}
pattern refineRelation_id5_attribute_Income_Detail(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"id5 attribute Income_Detail");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfIncome_Detail_class(problem,interpretation,from);
	StringElement(to);
	find mayInRelationid5_attribute_Income_Detail(problem,interpretation,from,to);
	neg find mustInRelationid5_attribute_Income_Detail(problem,interpretation,from,to);
}
pattern refineRelation_id_attribute_FromLaw(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"id attribute FromLaw");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFromLaw_class(problem,interpretation,from);
	StringElement(to);
	find mayInRelationid_attribute_FromLaw(problem,interpretation,from,to);
	neg find mustInRelationid_attribute_FromLaw(problem,interpretation,from,to);
}
pattern refineRelation_is_assimilated_to_resident_attribute_Non_Resident_Tax_Payer(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"is_assimilated_to_resident attribute Non_Resident_Tax_Payer");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfNon_Resident_Tax_Payer_class(problem,interpretation,from);
	BooleanElement(to);
	find mayInRelationis_assimilated_to_resident_attribute_Non_Resident_Tax_Payer(problem,interpretation,from,to);
	neg find mustInRelationis_assimilated_to_resident_attribute_Non_Resident_Tax_Payer(problem,interpretation,from,to);
}
pattern refineRelation_occasional_payement_attribute_Pensions_and_Annuities_Income(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"occasional_payement attribute Pensions_and_Annuities_Income");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfPensions_and_Annuities_Income_class(problem,interpretation,from);
	BooleanElement(to);
	find mayInRelationoccasional_payement_attribute_Pensions_and_Annuities_Income(problem,interpretation,from,to);
	neg find mustInRelationoccasional_payement_attribute_Pensions_and_Annuities_Income(problem,interpretation,from,to);
}
pattern refineRelation_is_periodic_attribute_Rentals_and_Leases_Income(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"is_periodic attribute Rentals_and_Leases_Income");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfRentals_and_Leases_Income_class(problem,interpretation,from);
	BooleanElement(to);
	find mayInRelationis_periodic_attribute_Rentals_and_Leases_Income(problem,interpretation,from,to);
	neg find mustInRelationis_periodic_attribute_Rentals_and_Leases_Income(problem,interpretation,from,to);
}
pattern refineRelation_distance_declared_in_january_attribute_FD(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"distance_declared_in_january attribute FD");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFD_class(problem,interpretation,from);
	RealElement(to);
	find mayInRelationdistance_declared_in_january_attribute_FD(problem,interpretation,from,to);
	neg find mustInRelationdistance_declared_in_january_attribute_FD(problem,interpretation,from,to);
}
pattern refineRelation_calculated_distance_attribute_FD(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"calculated_distance attribute FD");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFD_class(problem,interpretation,from);
	RealElement(to);
	find mayInRelationcalculated_distance_attribute_FD(problem,interpretation,from,to);
	neg find mustInRelationcalculated_distance_attribute_FD(problem,interpretation,from,to);
}
pattern refineRelation_rate_type_for_FO_attribute_FO(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"rate_type_for_FO attribute FO");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfFO_class(problem,interpretation,from);
	find mustInstanceOfType_of_Rate_enum(problem,interpretation,to);
	find mayInRelationrate_type_for_FO_attribute_FO(problem,interpretation,from,to);
	neg find mustInRelationrate_type_for_FO_attribute_FO(problem,interpretation,from,to);
}
pattern refineRelation_permanent_expense_category_attribute_DS_for_Permanent_Expense(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"permanent_expense_category attribute DS_for_Permanent_Expense");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfDS_for_Permanent_Expense_class(problem,interpretation,from);
	find mustInstanceOfCategory_of_Permanent_Expense_enum(problem,interpretation,to);
	find mayInRelationpermanent_expense_category_attribute_DS_for_Permanent_Expense(problem,interpretation,from,to);
	neg find mustInRelationpermanent_expense_category_attribute_DS_for_Permanent_Expense(problem,interpretation,from,to);
}
pattern refineRelation_maximum_deductible_amount_attribute_DS(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"maximum_deductible_amount attribute DS");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfDS_class(problem,interpretation,from);
	RealElement(to);
	find mayInRelationmaximum_deductible_amount_attribute_DS(problem,interpretation,from,to);
	neg find mustInRelationmaximum_deductible_amount_attribute_DS(problem,interpretation,from,to);
}
pattern refineRelation_id3_attribute_DS(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"id3 attribute DS");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfDS_class(problem,interpretation,from);
	StringElement(to);
	find mayInRelationid3_attribute_DS(problem,interpretation,from,to);
	neg find mustInRelationid3_attribute_DS(problem,interpretation,from,to);
}
pattern refineRelation_insurance_category_attribute_DS_for_Health_and_Pension_Insurance(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"insurance_category attribute DS_for_Health_and_Pension_Insurance");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfDS_for_Health_and_Pension_Insurance_class(problem,interpretation,from);
	find mustInstanceOfCategory_of_Health_and_Pension_Insurances_enum(problem,interpretation,to);
	find mayInRelationinsurance_category_attribute_DS_for_Health_and_Pension_Insurance(problem,interpretation,from,to);
	neg find mustInRelationinsurance_category_attribute_DS_for_Health_and_Pension_Insurance(problem,interpretation,from,to);
}
pattern refineRelation_private_insurance_and_plan_category_attribute_DS_for_Private_Insurance_and_Plan(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"private_insurance_and_plan_category attribute DS_for_Private_Insurance_and_Plan");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfDS_for_Private_Insurance_and_Plan_class(problem,interpretation,from);
	find mustInstanceOfCategory_of_Private_Insurance_and_Plan_enum(problem,interpretation,to);
	find mayInRelationprivate_insurance_and_plan_category_attribute_DS_for_Private_Insurance_and_Plan(problem,interpretation,from,to);
	neg find mustInRelationprivate_insurance_and_plan_category_attribute_DS_for_Private_Insurance_and_Plan(problem,interpretation,from,to);
}
pattern refineRelation_increase_for_life_insurance_attribute_DS_for_Private_Insurance_and_Plan(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"increase_for_life_insurance attribute DS_for_Private_Insurance_and_Plan");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfDS_for_Private_Insurance_and_Plan_class(problem,interpretation,from);
	RealElement(to);
	find mayInRelationincrease_for_life_insurance_attribute_DS_for_Private_Insurance_and_Plan(problem,interpretation,from,to);
	neg find mustInRelationincrease_for_life_insurance_attribute_DS_for_Private_Insurance_and_Plan(problem,interpretation,from,to);
}
pattern refineRelation_maximum_deductible_amount_for_private_insurance_attribute_DS_for_Private_Insurance_and_Plan(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"maximum_deductible_amount_for_private_insurance attribute DS_for_Private_Insurance_and_Plan");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfDS_for_Private_Insurance_and_Plan_class(problem,interpretation,from);
	RealElement(to);
	find mayInRelationmaximum_deductible_amount_for_private_insurance_attribute_DS_for_Private_Insurance_and_Plan(problem,interpretation,from,to);
	neg find mustInRelationmaximum_deductible_amount_for_private_insurance_attribute_DS_for_Private_Insurance_and_Plan(problem,interpretation,from,to);
}
pattern refineRelation_maximum_deductible_amount_for_old_age_pension_plan_attribute_DS_for_Private_Insurance_and_Plan(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"maximum_deductible_amount_for_old_age_pension_plan attribute DS_for_Private_Insurance_and_Plan");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfDS_for_Private_Insurance_and_Plan_class(problem,interpretation,from);
	RealElement(to);
	find mayInRelationmaximum_deductible_amount_for_old_age_pension_plan_attribute_DS_for_Private_Insurance_and_Plan(problem,interpretation,from,to);
	neg find mustInRelationmaximum_deductible_amount_for_old_age_pension_plan_attribute_DS_for_Private_Insurance_and_Plan(problem,interpretation,from,to);
}
pattern refineRelation_category_attribute_Permanent_Expense(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"category attribute Permanent_Expense");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfPermanent_Expense_class(problem,interpretation,from);
	find mustInstanceOfCategory_of_Permanent_Expense_enum(problem,interpretation,to);
	find mayInRelationcategory_attribute_Permanent_Expense(problem,interpretation,from,to);
	neg find mustInRelationcategory_attribute_Permanent_Expense(problem,interpretation,from,to);
}
pattern refineRelation_is_eligible_for_deduction_attribute_Permanent_Expense(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"is_eligible_for_deduction attribute Permanent_Expense");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfPermanent_Expense_class(problem,interpretation,from);
	BooleanElement(to);
	find mayInRelationis_eligible_for_deduction_attribute_Permanent_Expense(problem,interpretation,from,to);
	neg find mustInRelationis_eligible_for_deduction_attribute_Permanent_Expense(problem,interpretation,from,to);
}
pattern refineRelation_category_attribute_Private_Insurance_and_Plan(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"category attribute Private_Insurance_and_Plan");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfPrivate_Insurance_and_Plan_class(problem,interpretation,from);
	find mustInstanceOfCategory_of_Private_Insurance_and_Plan_enum(problem,interpretation,to);
	find mayInRelationcategory_attribute_Private_Insurance_and_Plan(problem,interpretation,from,to);
	neg find mustInRelationcategory_attribute_Private_Insurance_and_Plan(problem,interpretation,from,to);
}
pattern refineRelation_duration_of_contract_attribute_Private_Insurance_and_Plan(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"duration_of_contract attribute Private_Insurance_and_Plan");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfPrivate_Insurance_and_Plan_class(problem,interpretation,from);
	IntegerElement(to);
	find mayInRelationduration_of_contract_attribute_Private_Insurance_and_Plan(problem,interpretation,from,to);
	neg find mustInRelationduration_of_contract_attribute_Private_Insurance_and_Plan(problem,interpretation,from,to);
}
pattern refineRelation_is_private_insurance_and_plan_eligible_for_deduction_attribute_Private_Insurance_and_Plan(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"is_private_insurance_and_plan_eligible_for_deduction attribute Private_Insurance_and_Plan");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfPrivate_Insurance_and_Plan_class(problem,interpretation,from);
	BooleanElement(to);
	find mayInRelationis_private_insurance_and_plan_eligible_for_deduction_attribute_Private_Insurance_and_Plan(problem,interpretation,from,to);
	neg find mustInRelationis_private_insurance_and_plan_eligible_for_deduction_attribute_Private_Insurance_and_Plan(problem,interpretation,from,to);
}
pattern refineRelation_category_attribute_Health_and_Pension_Insurance(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"category attribute Health_and_Pension_Insurance");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfHealth_and_Pension_Insurance_class(problem,interpretation,from);
	find mustInstanceOfCategory_of_Health_and_Pension_Insurances_enum(problem,interpretation,to);
	find mayInRelationcategory_attribute_Health_and_Pension_Insurance(problem,interpretation,from,to);
	neg find mustInRelationcategory_attribute_Health_and_Pension_Insurance(problem,interpretation,from,to);
}
pattern refineRelation_is_related_to_additional_salary_attribute_Health_and_Pension_Insurance(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"is_related_to_additional_salary attribute Health_and_Pension_Insurance");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfHealth_and_Pension_Insurance_class(problem,interpretation,from);
	BooleanElement(to);
	find mayInRelationis_related_to_additional_salary_attribute_Health_and_Pension_Insurance(problem,interpretation,from,to);
	neg find mustInRelationis_related_to_additional_salary_attribute_Health_and_Pension_Insurance(problem,interpretation,from,to);
}
pattern refineRelation_beneficiary1_attribute_Donation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"beneficiary1 attribute Donation");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfDonation_class(problem,interpretation,from);
	StringElement(to);
	find mayInRelationbeneficiary1_attribute_Donation(problem,interpretation,from,to);
	neg find mustInRelationbeneficiary1_attribute_Donation(problem,interpretation,from,to);
}
pattern refineRelation_is_beneficiary_eligible_attribute_Donation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"is_beneficiary_eligible attribute Donation");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfDonation_class(problem,interpretation,from);
	BooleanElement(to);
	find mayInRelationis_beneficiary_eligible_attribute_Donation(problem,interpretation,from,to);
	neg find mustInRelationis_beneficiary_eligible_attribute_Donation(problem,interpretation,from,to);
}
pattern refineRelation_is_donation_reported_attribute_Donation(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"is_donation_reported attribute Donation");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfDonation_class(problem,interpretation,from);
	BooleanElement(to);
	find mayInRelationis_donation_reported_attribute_Donation(problem,interpretation,from,to);
	neg find mustInRelationis_donation_reported_attribute_Donation(problem,interpretation,from,to);
}
pattern refineRelation_regular_accountability_attribute_Loss_Carryforward(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"regular_accountability attribute Loss_Carryforward");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfLoss_Carryforward_class(problem,interpretation,from);
	BooleanElement(to);
	find mayInRelationregular_accountability_attribute_Loss_Carryforward(problem,interpretation,from,to);
	neg find mustInRelationregular_accountability_attribute_Loss_Carryforward(problem,interpretation,from,to);
}
pattern refineRelation_compensation_by_other_means_attribute_Loss_Carryforward(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"compensation_by_other_means attribute Loss_Carryforward");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfLoss_Carryforward_class(problem,interpretation,from);
	BooleanElement(to);
	find mayInRelationcompensation_by_other_means_attribute_Loss_Carryforward(problem,interpretation,from,to);
	neg find mustInRelationcompensation_by_other_means_attribute_Loss_Carryforward(problem,interpretation,from,to);
}
pattern refineRelation_tax_payer_has_inherited_business_ownership_attribute_Loss_Carryforward(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"tax_payer_has_inherited_business_ownership attribute Loss_Carryforward");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfLoss_Carryforward_class(problem,interpretation,from);
	BooleanElement(to);
	find mayInRelationtax_payer_has_inherited_business_ownership_attribute_Loss_Carryforward(problem,interpretation,from,to);
	neg find mustInRelationtax_payer_has_inherited_business_ownership_attribute_Loss_Carryforward(problem,interpretation,from,to);
}
pattern refineRelation_tax_payer_has_been_partner_in_business_attribute_Loss_Carryforward(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"tax_payer_has_been_partner_in_business attribute Loss_Carryforward");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfLoss_Carryforward_class(problem,interpretation,from);
	BooleanElement(to);
	find mayInRelationtax_payer_has_been_partner_in_business_attribute_Loss_Carryforward(problem,interpretation,from,to);
	neg find mustInRelationtax_payer_has_been_partner_in_business_attribute_Loss_Carryforward(problem,interpretation,from,to);
}
pattern refineRelation_thresholded_deduction_percentage_attribute_Extraordinary_Expense_CE(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"thresholded_deduction_percentage attribute Extraordinary_Expense_CE");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfExtraordinary_Expense_CE_class(problem,interpretation,from);
	RealElement(to);
	find mayInRelationthresholded_deduction_percentage_attribute_Extraordinary_Expense_CE(problem,interpretation,from,to);
	neg find mustInRelationthresholded_deduction_percentage_attribute_Extraordinary_Expense_CE(problem,interpretation,from,to);
}
pattern refineRelation_ce_type_attribute_Extraordinary_Expense_CE(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"ce_type attribute Extraordinary_Expense_CE");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfExtraordinary_Expense_CE_class(problem,interpretation,from);
	find mustInstanceOfCE_Type_enum(problem,interpretation,to);
	find mayInRelationce_type_attribute_Extraordinary_Expense_CE(problem,interpretation,from,to);
	neg find mustInRelationce_type_attribute_Extraordinary_Expense_CE(problem,interpretation,from,to);
}

