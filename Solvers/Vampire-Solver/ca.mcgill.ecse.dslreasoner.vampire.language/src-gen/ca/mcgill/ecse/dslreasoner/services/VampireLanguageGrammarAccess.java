/*
 * generated by Xtext 2.12.0
 */
package ca.mcgill.ecse.dslreasoner.services;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import java.util.List;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Alternatives;
import org.eclipse.xtext.Assignment;
import org.eclipse.xtext.Grammar;
import org.eclipse.xtext.GrammarUtil;
import org.eclipse.xtext.Group;
import org.eclipse.xtext.Keyword;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.RuleCall;
import org.eclipse.xtext.TerminalRule;
import org.eclipse.xtext.common.services.TerminalsGrammarAccess;
import org.eclipse.xtext.service.AbstractElementFinder.AbstractGrammarElementFinder;
import org.eclipse.xtext.service.GrammarProvider;

@Singleton
public class VampireLanguageGrammarAccess extends AbstractGrammarElementFinder {
	
	public class VampireModelElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ca.mcgill.ecse.dslreasoner.VampireLanguage.VampireModel");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Assignment cIncludesAssignment_0 = (Assignment)cAlternatives.eContents().get(0);
		private final RuleCall cIncludesVLSIncludeParserRuleCall_0_0 = (RuleCall)cIncludesAssignment_0.eContents().get(0);
		private final Assignment cCommentsAssignment_1 = (Assignment)cAlternatives.eContents().get(1);
		private final RuleCall cCommentsVLSCommentParserRuleCall_1_0 = (RuleCall)cCommentsAssignment_1.eContents().get(0);
		private final Assignment cConfirmationsAssignment_2 = (Assignment)cAlternatives.eContents().get(2);
		private final RuleCall cConfirmationsVLSConfirmationsParserRuleCall_2_0 = (RuleCall)cConfirmationsAssignment_2.eContents().get(0);
		private final Assignment cFormulasAssignment_3 = (Assignment)cAlternatives.eContents().get(3);
		private final RuleCall cFormulasVLSFofFormulaParserRuleCall_3_0 = (RuleCall)cFormulasAssignment_3.eContents().get(0);
		private final Assignment cTfformulasAssignment_4 = (Assignment)cAlternatives.eContents().get(4);
		private final RuleCall cTfformulasVLSTffFormulaParserRuleCall_4_0 = (RuleCall)cTfformulasAssignment_4.eContents().get(0);
		
		////@@@@@@@@@@@
		////2 things TODO:
		////1. fix anotations (ln77)
		////2. can only use declared variables in formula (ln 158)
		////@@@@@@@@@@@
		//VampireModel:
		//	(includes+=VLSInclude | comments+=VLSComment | confirmations+=VLSConfirmations | formulas+=VLSFofFormula |
		//	tfformulas+=VLSTffFormula)*;
		@Override public ParserRule getRule() { return rule; }
		
		//(includes+=VLSInclude | comments+=VLSComment | confirmations+=VLSConfirmations | formulas+=VLSFofFormula |
		//tfformulas+=VLSTffFormula)*
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//includes+=VLSInclude
		public Assignment getIncludesAssignment_0() { return cIncludesAssignment_0; }
		
		//VLSInclude
		public RuleCall getIncludesVLSIncludeParserRuleCall_0_0() { return cIncludesVLSIncludeParserRuleCall_0_0; }
		
		//comments+=VLSComment
		public Assignment getCommentsAssignment_1() { return cCommentsAssignment_1; }
		
		//VLSComment
		public RuleCall getCommentsVLSCommentParserRuleCall_1_0() { return cCommentsVLSCommentParserRuleCall_1_0; }
		
		//confirmations+=VLSConfirmations
		public Assignment getConfirmationsAssignment_2() { return cConfirmationsAssignment_2; }
		
		//VLSConfirmations
		public RuleCall getConfirmationsVLSConfirmationsParserRuleCall_2_0() { return cConfirmationsVLSConfirmationsParserRuleCall_2_0; }
		
		//formulas+=VLSFofFormula
		public Assignment getFormulasAssignment_3() { return cFormulasAssignment_3; }
		
		//VLSFofFormula
		public RuleCall getFormulasVLSFofFormulaParserRuleCall_3_0() { return cFormulasVLSFofFormulaParserRuleCall_3_0; }
		
		//tfformulas+=VLSTffFormula
		public Assignment getTfformulasAssignment_4() { return cTfformulasAssignment_4; }
		
		//VLSTffFormula
		public RuleCall getTfformulasVLSTffFormulaParserRuleCall_4_0() { return cTfformulasVLSTffFormulaParserRuleCall_4_0; }
	}
	public class VLSIncludeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ca.mcgill.ecse.dslreasoner.VampireLanguage.VLSInclude");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cIncludeKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cFileNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cFileNameSINGLE_QUOTETerminalRuleCall_1_0 = (RuleCall)cFileNameAssignment_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cCommaLeftSquareBracketKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Assignment cNamesAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cNamesVLSNameParserRuleCall_2_1_0 = (RuleCall)cNamesAssignment_2_1.eContents().get(0);
		private final Group cGroup_2_2 = (Group)cGroup_2.eContents().get(2);
		private final Keyword cCommaKeyword_2_2_0 = (Keyword)cGroup_2_2.eContents().get(0);
		private final Assignment cNamesAssignment_2_2_1 = (Assignment)cGroup_2_2.eContents().get(1);
		private final RuleCall cNamesVLSNameParserRuleCall_2_2_1_0 = (RuleCall)cNamesAssignment_2_2_1.eContents().get(0);
		private final Keyword cRightSquareBracketKeyword_2_3 = (Keyword)cGroup_2.eContents().get(3);
		
		////terminal ID:  ( !('('|')'|'\r'|'\n') )+ ;
		////////////////////////////////////
		//// VLS types
		////////////////////////////////////
		//// <includes>
		//VLSInclude:
		//	'include(' fileName=SINGLE_QUOTE (',[' names+=VLSName (',' names+=VLSName)* ']')?;
		@Override public ParserRule getRule() { return rule; }
		
		//'include(' fileName=SINGLE_QUOTE (',[' names+=VLSName (',' names+=VLSName)* ']')?
		public Group getGroup() { return cGroup; }
		
		//'include('
		public Keyword getIncludeKeyword_0() { return cIncludeKeyword_0; }
		
		//fileName=SINGLE_QUOTE
		public Assignment getFileNameAssignment_1() { return cFileNameAssignment_1; }
		
		//SINGLE_QUOTE
		public RuleCall getFileNameSINGLE_QUOTETerminalRuleCall_1_0() { return cFileNameSINGLE_QUOTETerminalRuleCall_1_0; }
		
		//(',[' names+=VLSName (',' names+=VLSName)* ']')?
		public Group getGroup_2() { return cGroup_2; }
		
		//',['
		public Keyword getCommaLeftSquareBracketKeyword_2_0() { return cCommaLeftSquareBracketKeyword_2_0; }
		
		//names+=VLSName
		public Assignment getNamesAssignment_2_1() { return cNamesAssignment_2_1; }
		
		//VLSName
		public RuleCall getNamesVLSNameParserRuleCall_2_1_0() { return cNamesVLSNameParserRuleCall_2_1_0; }
		
		//(',' names+=VLSName)*
		public Group getGroup_2_2() { return cGroup_2_2; }
		
		//','
		public Keyword getCommaKeyword_2_2_0() { return cCommaKeyword_2_2_0; }
		
		//names+=VLSName
		public Assignment getNamesAssignment_2_2_1() { return cNamesAssignment_2_2_1; }
		
		//VLSName
		public RuleCall getNamesVLSNameParserRuleCall_2_2_1_0() { return cNamesVLSNameParserRuleCall_2_2_1_0; }
		
		//']'
		public Keyword getRightSquareBracketKeyword_2_3() { return cRightSquareBracketKeyword_2_3; }
	}
	public class VLSNameElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ca.mcgill.ecse.dslreasoner.VampireLanguage.VLSName");
		private final Assignment cNameAssignment = (Assignment)rule.eContents().get(1);
		private final Alternatives cNameAlternatives_0 = (Alternatives)cNameAssignment.eContents().get(0);
		private final RuleCall cNameLOWER_WORD_IDTerminalRuleCall_0_0 = (RuleCall)cNameAlternatives_0.eContents().get(0);
		private final RuleCall cNameSINGLE_QUOTETerminalRuleCall_0_1 = (RuleCall)cNameAlternatives_0.eContents().get(1);
		private final RuleCall cNameLITERALTerminalRuleCall_0_2 = (RuleCall)cNameAlternatives_0.eContents().get(2);
		private final RuleCall cNameSIGNED_LITERALTerminalRuleCall_0_3 = (RuleCall)cNameAlternatives_0.eContents().get(3);
		
		//VLSName:
		//	name=(LOWER_WORD_ID | SINGLE_QUOTE | LITERAL | SIGNED_LITERAL);
		@Override public ParserRule getRule() { return rule; }
		
		//name=(LOWER_WORD_ID | SINGLE_QUOTE | LITERAL | SIGNED_LITERAL)
		public Assignment getNameAssignment() { return cNameAssignment; }
		
		//(LOWER_WORD_ID | SINGLE_QUOTE | LITERAL | SIGNED_LITERAL)
		public Alternatives getNameAlternatives_0() { return cNameAlternatives_0; }
		
		//LOWER_WORD_ID
		public RuleCall getNameLOWER_WORD_IDTerminalRuleCall_0_0() { return cNameLOWER_WORD_IDTerminalRuleCall_0_0; }
		
		//SINGLE_QUOTE
		public RuleCall getNameSINGLE_QUOTETerminalRuleCall_0_1() { return cNameSINGLE_QUOTETerminalRuleCall_0_1; }
		
		//LITERAL
		public RuleCall getNameLITERALTerminalRuleCall_0_2() { return cNameLITERALTerminalRuleCall_0_2; }
		
		//SIGNED_LITERAL
		public RuleCall getNameSIGNED_LITERALTerminalRuleCall_0_3() { return cNameSIGNED_LITERALTerminalRuleCall_0_3; }
	}
	public class VLSCommentElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ca.mcgill.ecse.dslreasoner.VampireLanguage.VLSComment");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cPercentSignKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cCommentAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cCommentSINGLE_COMMENTTerminalRuleCall_1_0 = (RuleCall)cCommentAssignment_1.eContents().get(0);
		
		//// <comments>
		//VLSComment:
		//	'%' comment=SINGLE_COMMENT
		//	//need to add a new line at the end of the file for the case where the last line is a comment
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//'%' comment=SINGLE_COMMENT
		public Group getGroup() { return cGroup; }
		
		//'%'
		public Keyword getPercentSignKeyword_0() { return cPercentSignKeyword_0; }
		
		//comment=SINGLE_COMMENT
		public Assignment getCommentAssignment_1() { return cCommentAssignment_1; }
		
		//SINGLE_COMMENT
		public RuleCall getCommentSINGLE_COMMENTTerminalRuleCall_1_0() { return cCommentSINGLE_COMMENTTerminalRuleCall_1_0; }
	}
	public class VLSConfirmationsElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ca.mcgill.ecse.dslreasoner.VampireLanguage.VLSConfirmations");
		private final RuleCall cVLSSatisfiableParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		////VLSConstantDeclaration: name = (LOWER_WORD_ID | SINGLE_QUOTE | DOLLAR_ID | DOUBLE_DOLLAR_ID );
		//VLSConfirmations:
		//	VLSSatisfiable //| VLSFiniteModel// | VLSTrying
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//VLSSatisfiable
		public RuleCall getVLSSatisfiableParserRuleCall() { return cVLSSatisfiableParserRuleCall; }
	}
	public class VLSSatisfiableElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ca.mcgill.ecse.dslreasoner.VampireLanguage.VLSSatisfiable");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cVLSSatisfiableAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cSatisfiableKeyword_1 = (Keyword)cGroup.eContents().get(1);
		
		//VLSSatisfiable:
		//	{VLSSatisfiable} 'Satisfiable!';
		@Override public ParserRule getRule() { return rule; }
		
		//{VLSSatisfiable} 'Satisfiable!'
		public Group getGroup() { return cGroup; }
		
		//{VLSSatisfiable}
		public Action getVLSSatisfiableAction_0() { return cVLSSatisfiableAction_0; }
		
		//'Satisfiable!'
		public Keyword getSatisfiableKeyword_1() { return cSatisfiableKeyword_1; }
	}
	public class VLSTryingElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ca.mcgill.ecse.dslreasoner.VampireLanguage.VLSTrying");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cTRYINGKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cLeftSquareBracketKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cNameAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cNameLITERALTerminalRuleCall_2_0 = (RuleCall)cNameAssignment_2.eContents().get(0);
		private final Keyword cRightSquareBracketKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//VLSTrying:
		//	'TRYING' '[' name=LITERAL ']';
		@Override public ParserRule getRule() { return rule; }
		
		//'TRYING' '[' name=LITERAL ']'
		public Group getGroup() { return cGroup; }
		
		//'TRYING'
		public Keyword getTRYINGKeyword_0() { return cTRYINGKeyword_0; }
		
		//'['
		public Keyword getLeftSquareBracketKeyword_1() { return cLeftSquareBracketKeyword_1; }
		
		//name=LITERAL
		public Assignment getNameAssignment_2() { return cNameAssignment_2; }
		
		//LITERAL
		public RuleCall getNameLITERALTerminalRuleCall_2_0() { return cNameLITERALTerminalRuleCall_2_0; }
		
		//']'
		public Keyword getRightSquareBracketKeyword_3() { return cRightSquareBracketKeyword_3; }
	}
	public class VLSFiniteModelElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ca.mcgill.ecse.dslreasoner.VampireLanguage.VLSFiniteModel");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cVLSFiniteModelAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cFiniteKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Keyword cModelKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Keyword cFoundKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//VLSFiniteModel:
		//	{VLSFiniteModel} 'Finite' 'Model' 'Found!';
		@Override public ParserRule getRule() { return rule; }
		
		//{VLSFiniteModel} 'Finite' 'Model' 'Found!'
		public Group getGroup() { return cGroup; }
		
		//{VLSFiniteModel}
		public Action getVLSFiniteModelAction_0() { return cVLSFiniteModelAction_0; }
		
		//'Finite'
		public Keyword getFiniteKeyword_1() { return cFiniteKeyword_1; }
		
		//'Model'
		public Keyword getModelKeyword_2() { return cModelKeyword_2; }
		
		//'Found!'
		public Keyword getFoundKeyword_3() { return cFoundKeyword_3; }
	}
	public class VLSFofFormulaElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ca.mcgill.ecse.dslreasoner.VampireLanguage.VLSFofFormula");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cFofKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cNameAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final Alternatives cNameAlternatives_2_0 = (Alternatives)cNameAssignment_2.eContents().get(0);
		private final RuleCall cNameLOWER_WORD_IDTerminalRuleCall_2_0_0 = (RuleCall)cNameAlternatives_2_0.eContents().get(0);
		private final RuleCall cNameSIGNED_LITERALTerminalRuleCall_2_0_1 = (RuleCall)cNameAlternatives_2_0.eContents().get(1);
		private final RuleCall cNameSINGLE_QUOTETerminalRuleCall_2_0_2 = (RuleCall)cNameAlternatives_2_0.eContents().get(2);
		private final Keyword cCommaKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cFofRoleAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cFofRoleVLSRoleParserRuleCall_4_0 = (RuleCall)cFofRoleAssignment_4.eContents().get(0);
		private final Keyword cCommaKeyword_5 = (Keyword)cGroup.eContents().get(5);
		private final Assignment cFofFormulaAssignment_6 = (Assignment)cGroup.eContents().get(6);
		private final RuleCall cFofFormulaVLSTermParserRuleCall_6_0 = (RuleCall)cFofFormulaAssignment_6.eContents().get(0);
		private final Group cGroup_7 = (Group)cGroup.eContents().get(7);
		private final Keyword cCommaKeyword_7_0 = (Keyword)cGroup_7.eContents().get(0);
		private final Assignment cAnnotationsAssignment_7_1 = (Assignment)cGroup_7.eContents().get(1);
		private final RuleCall cAnnotationsVLSAnnotationParserRuleCall_7_1_0 = (RuleCall)cAnnotationsAssignment_7_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_8 = (Keyword)cGroup.eContents().get(8);
		private final Keyword cFullStopKeyword_9 = (Keyword)cGroup.eContents().get(9);
		
		//// <FOF formulas>
		//VLSFofFormula:
		//	'fof' '(' name=(LOWER_WORD_ID | SIGNED_LITERAL | SINGLE_QUOTE) ',' fofRole=VLSRole ',' fofFormula=VLSTerm (','
		//	annotations=VLSAnnotation)? ')' '.';
		@Override public ParserRule getRule() { return rule; }
		
		//'fof' '(' name=(LOWER_WORD_ID | SIGNED_LITERAL | SINGLE_QUOTE) ',' fofRole=VLSRole ',' fofFormula=VLSTerm (','
		//annotations=VLSAnnotation)? ')' '.'
		public Group getGroup() { return cGroup; }
		
		//'fof'
		public Keyword getFofKeyword_0() { return cFofKeyword_0; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }
		
		//name=(LOWER_WORD_ID | SIGNED_LITERAL | SINGLE_QUOTE)
		public Assignment getNameAssignment_2() { return cNameAssignment_2; }
		
		//(LOWER_WORD_ID | SIGNED_LITERAL | SINGLE_QUOTE)
		public Alternatives getNameAlternatives_2_0() { return cNameAlternatives_2_0; }
		
		//LOWER_WORD_ID
		public RuleCall getNameLOWER_WORD_IDTerminalRuleCall_2_0_0() { return cNameLOWER_WORD_IDTerminalRuleCall_2_0_0; }
		
		//SIGNED_LITERAL
		public RuleCall getNameSIGNED_LITERALTerminalRuleCall_2_0_1() { return cNameSIGNED_LITERALTerminalRuleCall_2_0_1; }
		
		//SINGLE_QUOTE
		public RuleCall getNameSINGLE_QUOTETerminalRuleCall_2_0_2() { return cNameSINGLE_QUOTETerminalRuleCall_2_0_2; }
		
		//','
		public Keyword getCommaKeyword_3() { return cCommaKeyword_3; }
		
		//fofRole=VLSRole
		public Assignment getFofRoleAssignment_4() { return cFofRoleAssignment_4; }
		
		//VLSRole
		public RuleCall getFofRoleVLSRoleParserRuleCall_4_0() { return cFofRoleVLSRoleParserRuleCall_4_0; }
		
		//','
		public Keyword getCommaKeyword_5() { return cCommaKeyword_5; }
		
		//fofFormula=VLSTerm
		public Assignment getFofFormulaAssignment_6() { return cFofFormulaAssignment_6; }
		
		//VLSTerm
		public RuleCall getFofFormulaVLSTermParserRuleCall_6_0() { return cFofFormulaVLSTermParserRuleCall_6_0; }
		
		//(',' annotations=VLSAnnotation)?
		public Group getGroup_7() { return cGroup_7; }
		
		//','
		public Keyword getCommaKeyword_7_0() { return cCommaKeyword_7_0; }
		
		//annotations=VLSAnnotation
		public Assignment getAnnotationsAssignment_7_1() { return cAnnotationsAssignment_7_1; }
		
		//VLSAnnotation
		public RuleCall getAnnotationsVLSAnnotationParserRuleCall_7_1_0() { return cAnnotationsVLSAnnotationParserRuleCall_7_1_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_8() { return cRightParenthesisKeyword_8; }
		
		//'.'
		public Keyword getFullStopKeyword_9() { return cFullStopKeyword_9; }
	}
	public class VLSTffFormulaElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ca.mcgill.ecse.dslreasoner.VampireLanguage.VLSTffFormula");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cTffKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cNameAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final Alternatives cNameAlternatives_2_0 = (Alternatives)cNameAssignment_2.eContents().get(0);
		private final RuleCall cNameLOWER_WORD_IDTerminalRuleCall_2_0_0 = (RuleCall)cNameAlternatives_2_0.eContents().get(0);
		private final RuleCall cNameSIGNED_LITERALTerminalRuleCall_2_0_1 = (RuleCall)cNameAlternatives_2_0.eContents().get(1);
		private final RuleCall cNameSINGLE_QUOTETerminalRuleCall_2_0_2 = (RuleCall)cNameAlternatives_2_0.eContents().get(2);
		private final Keyword cCommaKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cFofRoleAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cFofRoleVLSRoleParserRuleCall_4_0 = (RuleCall)cFofRoleAssignment_4.eContents().get(0);
		private final Keyword cCommaKeyword_5 = (Keyword)cGroup.eContents().get(5);
		private final Assignment cFofFormulaAssignment_6 = (Assignment)cGroup.eContents().get(6);
		private final RuleCall cFofFormulaVLSTermParserRuleCall_6_0 = (RuleCall)cFofFormulaAssignment_6.eContents().get(0);
		private final Group cGroup_7 = (Group)cGroup.eContents().get(7);
		private final Keyword cCommaKeyword_7_0 = (Keyword)cGroup_7.eContents().get(0);
		private final Assignment cAnnotationsAssignment_7_1 = (Assignment)cGroup_7.eContents().get(1);
		private final RuleCall cAnnotationsVLSAnnotationParserRuleCall_7_1_0 = (RuleCall)cAnnotationsAssignment_7_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_8 = (Keyword)cGroup.eContents().get(8);
		private final Keyword cFullStopKeyword_9 = (Keyword)cGroup.eContents().get(9);
		
		//VLSTffFormula:
		//	'tff' '(' name=(LOWER_WORD_ID | SIGNED_LITERAL | SINGLE_QUOTE) ',' fofRole=VLSRole ',' fofFormula=VLSTerm (','
		//	annotations=VLSAnnotation)? ')' '.';
		@Override public ParserRule getRule() { return rule; }
		
		//'tff' '(' name=(LOWER_WORD_ID | SIGNED_LITERAL | SINGLE_QUOTE) ',' fofRole=VLSRole ',' fofFormula=VLSTerm (','
		//annotations=VLSAnnotation)? ')' '.'
		public Group getGroup() { return cGroup; }
		
		//'tff'
		public Keyword getTffKeyword_0() { return cTffKeyword_0; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }
		
		//name=(LOWER_WORD_ID | SIGNED_LITERAL | SINGLE_QUOTE)
		public Assignment getNameAssignment_2() { return cNameAssignment_2; }
		
		//(LOWER_WORD_ID | SIGNED_LITERAL | SINGLE_QUOTE)
		public Alternatives getNameAlternatives_2_0() { return cNameAlternatives_2_0; }
		
		//LOWER_WORD_ID
		public RuleCall getNameLOWER_WORD_IDTerminalRuleCall_2_0_0() { return cNameLOWER_WORD_IDTerminalRuleCall_2_0_0; }
		
		//SIGNED_LITERAL
		public RuleCall getNameSIGNED_LITERALTerminalRuleCall_2_0_1() { return cNameSIGNED_LITERALTerminalRuleCall_2_0_1; }
		
		//SINGLE_QUOTE
		public RuleCall getNameSINGLE_QUOTETerminalRuleCall_2_0_2() { return cNameSINGLE_QUOTETerminalRuleCall_2_0_2; }
		
		//','
		public Keyword getCommaKeyword_3() { return cCommaKeyword_3; }
		
		//fofRole=VLSRole
		public Assignment getFofRoleAssignment_4() { return cFofRoleAssignment_4; }
		
		//VLSRole
		public RuleCall getFofRoleVLSRoleParserRuleCall_4_0() { return cFofRoleVLSRoleParserRuleCall_4_0; }
		
		//','
		public Keyword getCommaKeyword_5() { return cCommaKeyword_5; }
		
		//fofFormula=VLSTerm
		public Assignment getFofFormulaAssignment_6() { return cFofFormulaAssignment_6; }
		
		//VLSTerm
		public RuleCall getFofFormulaVLSTermParserRuleCall_6_0() { return cFofFormulaVLSTermParserRuleCall_6_0; }
		
		//(',' annotations=VLSAnnotation)?
		public Group getGroup_7() { return cGroup_7; }
		
		//','
		public Keyword getCommaKeyword_7_0() { return cCommaKeyword_7_0; }
		
		//annotations=VLSAnnotation
		public Assignment getAnnotationsAssignment_7_1() { return cAnnotationsAssignment_7_1; }
		
		//VLSAnnotation
		public RuleCall getAnnotationsVLSAnnotationParserRuleCall_7_1_0() { return cAnnotationsVLSAnnotationParserRuleCall_7_1_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_8() { return cRightParenthesisKeyword_8; }
		
		//'.'
		public Keyword getFullStopKeyword_9() { return cFullStopKeyword_9; }
	}
	public class VLSRoleElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ca.mcgill.ecse.dslreasoner.VampireLanguage.VLSRole");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cAxiomKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cConjectureKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cHypothesisKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		private final Keyword cDefinitionKeyword_3 = (Keyword)cAlternatives.eContents().get(3);
		private final Keyword cAssumptionKeyword_4 = (Keyword)cAlternatives.eContents().get(4);
		private final Keyword cLemmaKeyword_5 = (Keyword)cAlternatives.eContents().get(5);
		private final Keyword cTheoremKeyword_6 = (Keyword)cAlternatives.eContents().get(6);
		private final Keyword cCorollaryKeyword_7 = (Keyword)cAlternatives.eContents().get(7);
		private final Keyword cNegated_conjectureKeyword_8 = (Keyword)cAlternatives.eContents().get(8);
		private final Keyword cPlainKeyword_9 = (Keyword)cAlternatives.eContents().get(9);
		private final Keyword cTypeKeyword_10 = (Keyword)cAlternatives.eContents().get(10);
		private final Keyword cFi_domainKeyword_11 = (Keyword)cAlternatives.eContents().get(11);
		private final Keyword cFi_functorsKeyword_12 = (Keyword)cAlternatives.eContents().get(12);
		private final Keyword cFi_predicatesKeyword_13 = (Keyword)cAlternatives.eContents().get(13);
		private final Keyword cUnknownKeyword_14 = (Keyword)cAlternatives.eContents().get(14);
		
		///*
		////NAME
		//VLSName:
		//	//(atomic_Word = Atomic_Word | integer = Integer | single_quote_word = Single_Quote_Word)
		//	name = (LOWER_WORD_ID | SIGNED_INT_ID | SINGLE_QUOTE)
		//;
		//*/ //<ROLE>
		//VLSRole:
		//	"axiom" | "conjecture" | "hypothesis" | "definition" | "assumption" | "lemma"
		//	| "theorem" | "corollary" | "negated_conjecture" | "plain" | "type" |
		//	"fi_domain" | "fi_functors" | "fi_predicates" | "unknown";
		@Override public ParserRule getRule() { return rule; }
		
		//"axiom" | "conjecture" | "hypothesis" | "definition" | "assumption" | "lemma" | "theorem" | "corollary" |
		//"negated_conjecture" | "plain" | "type" | "fi_domain" | "fi_functors" | "fi_predicates" | "unknown"
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//"axiom"
		public Keyword getAxiomKeyword_0() { return cAxiomKeyword_0; }
		
		//"conjecture"
		public Keyword getConjectureKeyword_1() { return cConjectureKeyword_1; }
		
		//"hypothesis"
		public Keyword getHypothesisKeyword_2() { return cHypothesisKeyword_2; }
		
		//"definition"
		public Keyword getDefinitionKeyword_3() { return cDefinitionKeyword_3; }
		
		//"assumption"
		public Keyword getAssumptionKeyword_4() { return cAssumptionKeyword_4; }
		
		//"lemma"
		public Keyword getLemmaKeyword_5() { return cLemmaKeyword_5; }
		
		//"theorem"
		public Keyword getTheoremKeyword_6() { return cTheoremKeyword_6; }
		
		//"corollary"
		public Keyword getCorollaryKeyword_7() { return cCorollaryKeyword_7; }
		
		//"negated_conjecture"
		public Keyword getNegated_conjectureKeyword_8() { return cNegated_conjectureKeyword_8; }
		
		//"plain"
		public Keyword getPlainKeyword_9() { return cPlainKeyword_9; }
		
		//"type"
		public Keyword getTypeKeyword_10() { return cTypeKeyword_10; }
		
		//"fi_domain"
		public Keyword getFi_domainKeyword_11() { return cFi_domainKeyword_11; }
		
		//"fi_functors"
		public Keyword getFi_functorsKeyword_12() { return cFi_functorsKeyword_12; }
		
		//"fi_predicates"
		public Keyword getFi_predicatesKeyword_13() { return cFi_predicatesKeyword_13; }
		
		//"unknown"
		public Keyword getUnknownKeyword_14() { return cUnknownKeyword_14; }
	}
	public class VLSAnnotationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ca.mcgill.ecse.dslreasoner.VampireLanguage.VLSAnnotation");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLeftSquareBracketKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final Alternatives cNameAlternatives_1_0 = (Alternatives)cNameAssignment_1.eContents().get(0);
		private final RuleCall cNameLOWER_WORD_IDTerminalRuleCall_1_0_0 = (RuleCall)cNameAlternatives_1_0.eContents().get(0);
		private final RuleCall cNameSINGLE_QUOTETerminalRuleCall_1_0_1 = (RuleCall)cNameAlternatives_1_0.eContents().get(1);
		private final RuleCall cNameVLSRoleParserRuleCall_1_0_2 = (RuleCall)cNameAlternatives_1_0.eContents().get(2);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cLeftParenthesisKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Assignment cFollowupAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cFollowupVLSAnnotationTermsParserRuleCall_2_1_0 = (RuleCall)cFollowupAssignment_2_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_2_2 = (Keyword)cGroup_2.eContents().get(2);
		private final Keyword cRightSquareBracketKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		////VLSRole:
		////	VLSAxiom | VLSConjecture | VLSHypothesis | VLSDefinition |
		////	VLSAssumption | VLSLemma | VLSTheorem | VLSCorollary | VLSNegated_Conjecture |
		////	VLSPlain | VLSType |VLSFi_Domain | VLSFi_Functors | VLSFi_Predicates | VLSUnknown
		////;
		////
		////VLSAxiom:
		////	"axiom"
		////;
		////
		////VLSConjecture:
		////	"conjecture"
		////;
		////
		////VLSHypothesis:
		////	"hypothesis"
		////;
		////	
		////VLSDefinition:
		////	"definition"
		////;
		////
		////VLSAssumption:
		////	"assumption"
		////;
		////		
		////VLSLemma:
		////	"lemma"
		////;
		////			
		////VLSTheorem:
		////	"theorem"
		////;
		////				
		////VLSCorollary:
		////	"corollary"
		////;
		////			
		////VLSNegated_Conjecture:
		////	"negated_conjecture"	
		////;
		////
		////VLSPlain:
		////	"plain"
		////;
		////
		////VLSType:
		////	"type"
		////;
		////
		////VLSFi_Domain:
		////	"fi_domain"
		////;
		////
		////VLSFi_Functors:
		////	"fi_functors"
		////;
		////
		////VLSFi_Predicates:
		////	"fi_predicates"
		////;
		////
		////VLSUnknown:
		////	"unknown"
		////;
		//// <ANNOTATION>
		//// Not at all based on the website. based on what we think the output will be like 
		//VLSAnnotation:
		//	'['? name=(LOWER_WORD_ID | SINGLE_QUOTE | VLSRole)? ('(' followup=VLSAnnotationTerms ')')? ']'?;
		@Override public ParserRule getRule() { return rule; }
		
		//'['? name=(LOWER_WORD_ID | SINGLE_QUOTE | VLSRole)? ('(' followup=VLSAnnotationTerms ')')? ']'?
		public Group getGroup() { return cGroup; }
		
		//'['?
		public Keyword getLeftSquareBracketKeyword_0() { return cLeftSquareBracketKeyword_0; }
		
		//name=(LOWER_WORD_ID | SINGLE_QUOTE | VLSRole)?
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }
		
		//(LOWER_WORD_ID | SINGLE_QUOTE | VLSRole)
		public Alternatives getNameAlternatives_1_0() { return cNameAlternatives_1_0; }
		
		//LOWER_WORD_ID
		public RuleCall getNameLOWER_WORD_IDTerminalRuleCall_1_0_0() { return cNameLOWER_WORD_IDTerminalRuleCall_1_0_0; }
		
		//SINGLE_QUOTE
		public RuleCall getNameSINGLE_QUOTETerminalRuleCall_1_0_1() { return cNameSINGLE_QUOTETerminalRuleCall_1_0_1; }
		
		//VLSRole
		public RuleCall getNameVLSRoleParserRuleCall_1_0_2() { return cNameVLSRoleParserRuleCall_1_0_2; }
		
		//('(' followup=VLSAnnotationTerms ')')?
		public Group getGroup_2() { return cGroup_2; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_2_0() { return cLeftParenthesisKeyword_2_0; }
		
		//followup=VLSAnnotationTerms
		public Assignment getFollowupAssignment_2_1() { return cFollowupAssignment_2_1; }
		
		//VLSAnnotationTerms
		public RuleCall getFollowupVLSAnnotationTermsParserRuleCall_2_1_0() { return cFollowupVLSAnnotationTermsParserRuleCall_2_1_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_2_2() { return cRightParenthesisKeyword_2_2; }
		
		//']'?
		public Keyword getRightSquareBracketKeyword_3() { return cRightSquareBracketKeyword_3; }
	}
	public class VLSAnnotationTermsElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ca.mcgill.ecse.dslreasoner.VampireLanguage.VLSAnnotationTerms");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cTermsAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cTermsVLSAnnotationParserRuleCall_0_0 = (RuleCall)cTermsAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cCommaKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cTermsAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cTermsVLSAnnotationParserRuleCall_1_1_0 = (RuleCall)cTermsAssignment_1_1.eContents().get(0);
		
		//VLSAnnotationTerms VLSAnnotation:
		//	terms+=VLSAnnotation (',' terms+=VLSAnnotation)*;
		@Override public ParserRule getRule() { return rule; }
		
		//terms+=VLSAnnotation (',' terms+=VLSAnnotation)*
		public Group getGroup() { return cGroup; }
		
		//terms+=VLSAnnotation
		public Assignment getTermsAssignment_0() { return cTermsAssignment_0; }
		
		//VLSAnnotation
		public RuleCall getTermsVLSAnnotationParserRuleCall_0_0() { return cTermsVLSAnnotationParserRuleCall_0_0; }
		
		//(',' terms+=VLSAnnotation)*
		public Group getGroup_1() { return cGroup_1; }
		
		//','
		public Keyword getCommaKeyword_1_0() { return cCommaKeyword_1_0; }
		
		//terms+=VLSAnnotation
		public Assignment getTermsAssignment_1_1() { return cTermsAssignment_1_1; }
		
		//VLSAnnotation
		public RuleCall getTermsVLSAnnotationParserRuleCall_1_1_0() { return cTermsVLSAnnotationParserRuleCall_1_1_0; }
	}
	public class VLSTermElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ca.mcgill.ecse.dslreasoner.VampireLanguage.VLSTerm");
		private final RuleCall cVLSBinaryParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		////////////////////////////////////
		//// VLS Terms
		////////////////////////////////////
		//VLSTerm:
		//	VLSBinary;
		@Override public ParserRule getRule() { return rule; }
		
		////( VLSLogic | VLSSequent)
		//VLSBinary
		public RuleCall getVLSBinaryParserRuleCall() { return cVLSBinaryParserRuleCall; }
	}
	public class VLSBinaryElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ca.mcgill.ecse.dslreasoner.VampireLanguage.VLSBinary");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cVLSUnitaryFormulaParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Alternatives cAlternatives_1 = (Alternatives)cGroup.eContents().get(1);
		private final Group cGroup_1_0 = (Group)cAlternatives_1.eContents().get(0);
		private final Alternatives cAlternatives_1_0_0 = (Alternatives)cGroup_1_0.eContents().get(0);
		private final Group cGroup_1_0_0_0 = (Group)cAlternatives_1_0_0.eContents().get(0);
		private final Action cVLSEquivalentLeftAction_1_0_0_0_0 = (Action)cGroup_1_0_0_0.eContents().get(0);
		private final Keyword cLessThanSignEqualsSignGreaterThanSignKeyword_1_0_0_0_1 = (Keyword)cGroup_1_0_0_0.eContents().get(1);
		private final Group cGroup_1_0_0_1 = (Group)cAlternatives_1_0_0.eContents().get(1);
		private final Action cVLSImpliesLeftAction_1_0_0_1_0 = (Action)cGroup_1_0_0_1.eContents().get(0);
		private final Keyword cEqualsSignGreaterThanSignKeyword_1_0_0_1_1 = (Keyword)cGroup_1_0_0_1.eContents().get(1);
		private final Group cGroup_1_0_0_2 = (Group)cAlternatives_1_0_0.eContents().get(2);
		private final Action cVLSRevImpliesLeftAction_1_0_0_2_0 = (Action)cGroup_1_0_0_2.eContents().get(0);
		private final Keyword cLessThanSignEqualsSignKeyword_1_0_0_2_1 = (Keyword)cGroup_1_0_0_2.eContents().get(1);
		private final Group cGroup_1_0_0_3 = (Group)cAlternatives_1_0_0.eContents().get(3);
		private final Action cVLSXnorLeftAction_1_0_0_3_0 = (Action)cGroup_1_0_0_3.eContents().get(0);
		private final Keyword cLessThanSignTildeGreaterThanSignKeyword_1_0_0_3_1 = (Keyword)cGroup_1_0_0_3.eContents().get(1);
		private final Group cGroup_1_0_0_4 = (Group)cAlternatives_1_0_0.eContents().get(4);
		private final Action cVLSNorLeftAction_1_0_0_4_0 = (Action)cGroup_1_0_0_4.eContents().get(0);
		private final Keyword cTildeVerticalLineKeyword_1_0_0_4_1 = (Keyword)cGroup_1_0_0_4.eContents().get(1);
		private final Group cGroup_1_0_0_5 = (Group)cAlternatives_1_0_0.eContents().get(5);
		private final Action cVLSNandLeftAction_1_0_0_5_0 = (Action)cGroup_1_0_0_5.eContents().get(0);
		private final Keyword cTildeAmpersandKeyword_1_0_0_5_1 = (Keyword)cGroup_1_0_0_5.eContents().get(1);
		private final Assignment cRightAssignment_1_0_1 = (Assignment)cGroup_1_0.eContents().get(1);
		private final RuleCall cRightVLSUnitaryFormulaParserRuleCall_1_0_1_0 = (RuleCall)cRightAssignment_1_0_1.eContents().get(0);
		private final Group cGroup_1_1 = (Group)cAlternatives_1.eContents().get(1);
		private final Action cVLSAndLeftAction_1_1_0 = (Action)cGroup_1_1.eContents().get(0);
		private final Keyword cAmpersandKeyword_1_1_1 = (Keyword)cGroup_1_1.eContents().get(1);
		private final Assignment cRightAssignment_1_1_2 = (Assignment)cGroup_1_1.eContents().get(2);
		private final RuleCall cRightVLSUnitaryFormulaParserRuleCall_1_1_2_0 = (RuleCall)cRightAssignment_1_1_2.eContents().get(0);
		private final Group cGroup_1_2 = (Group)cAlternatives_1.eContents().get(2);
		private final Action cVLSOrLeftAction_1_2_0 = (Action)cGroup_1_2.eContents().get(0);
		private final Keyword cVerticalLineKeyword_1_2_1 = (Keyword)cGroup_1_2.eContents().get(1);
		private final Assignment cRightAssignment_1_2_2 = (Assignment)cGroup_1_2.eContents().get(2);
		private final RuleCall cRightVLSUnitaryFormulaParserRuleCall_1_2_2_0 = (RuleCall)cRightAssignment_1_2_2.eContents().get(0);
		
		////*
		////VLSBinaryFormula
		//VLSBinary VLSTerm:
		//	VLSUnitaryFormula (({VLSEquivalent.left=current} "<=>" | {VLSImplies.left=current} "=>" |
		//	{VLSRevImplies.left=current} "<=" | {VLSXnor.left=current} "<~>" | {VLSNor.left=current} "~|" |
		//	{VLSNand.left=current} "~&") right=VLSUnitaryFormula | ({VLSAnd.left=current} '&' right=VLSUnitaryFormula)+
		//	| ({VLSOr.left=current} '|' right=VLSUnitaryFormula)+)?;
		@Override public ParserRule getRule() { return rule; }
		
		//VLSUnitaryFormula (({VLSEquivalent.left=current} "<=>" | {VLSImplies.left=current} "=>" | {VLSRevImplies.left=current}
		//"<=" | {VLSXnor.left=current} "<~>" | {VLSNor.left=current} "~|" | {VLSNand.left=current} "~&")
		//right=VLSUnitaryFormula | ({VLSAnd.left=current} '&' right=VLSUnitaryFormula)+ | ({VLSOr.left=current} '|'
		//right=VLSUnitaryFormula)+)?
		public Group getGroup() { return cGroup; }
		
		//VLSUnitaryFormula
		public RuleCall getVLSUnitaryFormulaParserRuleCall_0() { return cVLSUnitaryFormulaParserRuleCall_0; }
		
		//(({VLSEquivalent.left=current} "<=>" | {VLSImplies.left=current} "=>" | {VLSRevImplies.left=current} "<=" |
		//{VLSXnor.left=current} "<~>" | {VLSNor.left=current} "~|" | {VLSNand.left=current} "~&") right=VLSUnitaryFormula |
		//({VLSAnd.left=current} '&' right=VLSUnitaryFormula)+ | ({VLSOr.left=current} '|' right=VLSUnitaryFormula)+)?
		public Alternatives getAlternatives_1() { return cAlternatives_1; }
		
		//({VLSEquivalent.left=current} "<=>" | {VLSImplies.left=current} "=>" | {VLSRevImplies.left=current} "<=" |
		//{VLSXnor.left=current} "<~>" | {VLSNor.left=current} "~|" | {VLSNand.left=current} "~&") right=VLSUnitaryFormula
		public Group getGroup_1_0() { return cGroup_1_0; }
		
		//{VLSEquivalent.left=current} "<=>" | {VLSImplies.left=current} "=>" | {VLSRevImplies.left=current} "<=" |
		//{VLSXnor.left=current} "<~>" | {VLSNor.left=current} "~|" | {VLSNand.left=current} "~&"
		public Alternatives getAlternatives_1_0_0() { return cAlternatives_1_0_0; }
		
		//{VLSEquivalent.left=current} "<=>"
		public Group getGroup_1_0_0_0() { return cGroup_1_0_0_0; }
		
		//{VLSEquivalent.left=current}
		public Action getVLSEquivalentLeftAction_1_0_0_0_0() { return cVLSEquivalentLeftAction_1_0_0_0_0; }
		
		//"<=>"
		public Keyword getLessThanSignEqualsSignGreaterThanSignKeyword_1_0_0_0_1() { return cLessThanSignEqualsSignGreaterThanSignKeyword_1_0_0_0_1; }
		
		//{VLSImplies.left=current} "=>"
		public Group getGroup_1_0_0_1() { return cGroup_1_0_0_1; }
		
		//{VLSImplies.left=current}
		public Action getVLSImpliesLeftAction_1_0_0_1_0() { return cVLSImpliesLeftAction_1_0_0_1_0; }
		
		//"=>"
		public Keyword getEqualsSignGreaterThanSignKeyword_1_0_0_1_1() { return cEqualsSignGreaterThanSignKeyword_1_0_0_1_1; }
		
		//{VLSRevImplies.left=current} "<="
		public Group getGroup_1_0_0_2() { return cGroup_1_0_0_2; }
		
		//{VLSRevImplies.left=current}
		public Action getVLSRevImpliesLeftAction_1_0_0_2_0() { return cVLSRevImpliesLeftAction_1_0_0_2_0; }
		
		//"<="
		public Keyword getLessThanSignEqualsSignKeyword_1_0_0_2_1() { return cLessThanSignEqualsSignKeyword_1_0_0_2_1; }
		
		//{VLSXnor.left=current} "<~>"
		public Group getGroup_1_0_0_3() { return cGroup_1_0_0_3; }
		
		//{VLSXnor.left=current}
		public Action getVLSXnorLeftAction_1_0_0_3_0() { return cVLSXnorLeftAction_1_0_0_3_0; }
		
		//"<~>"
		public Keyword getLessThanSignTildeGreaterThanSignKeyword_1_0_0_3_1() { return cLessThanSignTildeGreaterThanSignKeyword_1_0_0_3_1; }
		
		//{VLSNor.left=current} "~|"
		public Group getGroup_1_0_0_4() { return cGroup_1_0_0_4; }
		
		//{VLSNor.left=current}
		public Action getVLSNorLeftAction_1_0_0_4_0() { return cVLSNorLeftAction_1_0_0_4_0; }
		
		//"~|"
		public Keyword getTildeVerticalLineKeyword_1_0_0_4_1() { return cTildeVerticalLineKeyword_1_0_0_4_1; }
		
		//{VLSNand.left=current} "~&"
		public Group getGroup_1_0_0_5() { return cGroup_1_0_0_5; }
		
		//{VLSNand.left=current}
		public Action getVLSNandLeftAction_1_0_0_5_0() { return cVLSNandLeftAction_1_0_0_5_0; }
		
		//"~&"
		public Keyword getTildeAmpersandKeyword_1_0_0_5_1() { return cTildeAmpersandKeyword_1_0_0_5_1; }
		
		//right=VLSUnitaryFormula
		public Assignment getRightAssignment_1_0_1() { return cRightAssignment_1_0_1; }
		
		//VLSUnitaryFormula
		public RuleCall getRightVLSUnitaryFormulaParserRuleCall_1_0_1_0() { return cRightVLSUnitaryFormulaParserRuleCall_1_0_1_0; }
		
		//({VLSAnd.left=current} '&' right=VLSUnitaryFormula)+
		public Group getGroup_1_1() { return cGroup_1_1; }
		
		//{VLSAnd.left=current}
		public Action getVLSAndLeftAction_1_1_0() { return cVLSAndLeftAction_1_1_0; }
		
		//'&'
		public Keyword getAmpersandKeyword_1_1_1() { return cAmpersandKeyword_1_1_1; }
		
		//right=VLSUnitaryFormula
		public Assignment getRightAssignment_1_1_2() { return cRightAssignment_1_1_2; }
		
		//VLSUnitaryFormula
		public RuleCall getRightVLSUnitaryFormulaParserRuleCall_1_1_2_0() { return cRightVLSUnitaryFormulaParserRuleCall_1_1_2_0; }
		
		//({VLSOr.left=current} '|' right=VLSUnitaryFormula)+
		public Group getGroup_1_2() { return cGroup_1_2; }
		
		//{VLSOr.left=current}
		public Action getVLSOrLeftAction_1_2_0() { return cVLSOrLeftAction_1_2_0; }
		
		//'|'
		public Keyword getVerticalLineKeyword_1_2_1() { return cVerticalLineKeyword_1_2_1; }
		
		//right=VLSUnitaryFormula
		public Assignment getRightAssignment_1_2_2() { return cRightAssignment_1_2_2; }
		
		//VLSUnitaryFormula
		public RuleCall getRightVLSUnitaryFormulaParserRuleCall_1_2_2_0() { return cRightVLSUnitaryFormulaParserRuleCall_1_2_2_0; }
	}
	public class VLSUnitaryFormulaElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ca.mcgill.ecse.dslreasoner.VampireLanguage.VLSUnitaryFormula");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cVLSUniversalQuantifierParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cVLSExistentialQuantifierParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cVLSUnaryNegationParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cVLSUnaryInfixParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		private final Group cGroup_4 = (Group)cAlternatives.eContents().get(4);
		private final Keyword cLeftParenthesisKeyword_4_0 = (Keyword)cGroup_4.eContents().get(0);
		private final RuleCall cVLSTermParserRuleCall_4_1 = (RuleCall)cGroup_4.eContents().get(1);
		private final Keyword cRightParenthesisKeyword_4_2 = (Keyword)cGroup_4.eContents().get(2);
		
		////VLSUnitaryFormula
		//VLSUnitaryFormula VLSTerm:
		//	VLSUniversalQuantifier | VLSExistentialQuantifier | VLSUnaryNegation | VLSUnaryInfix
		//	//| VLSEquality 
		//	| '(' VLSTerm ')';
		@Override public ParserRule getRule() { return rule; }
		
		//VLSUniversalQuantifier | VLSExistentialQuantifier | VLSUnaryNegation | VLSUnaryInfix //| VLSEquality 
		//| '(' VLSTerm ')'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//VLSUniversalQuantifier
		public RuleCall getVLSUniversalQuantifierParserRuleCall_0() { return cVLSUniversalQuantifierParserRuleCall_0; }
		
		//VLSExistentialQuantifier
		public RuleCall getVLSExistentialQuantifierParserRuleCall_1() { return cVLSExistentialQuantifierParserRuleCall_1; }
		
		//VLSUnaryNegation
		public RuleCall getVLSUnaryNegationParserRuleCall_2() { return cVLSUnaryNegationParserRuleCall_2; }
		
		//VLSUnaryInfix
		public RuleCall getVLSUnaryInfixParserRuleCall_3() { return cVLSUnaryInfixParserRuleCall_3; }
		
		//'(' VLSTerm ')'
		public Group getGroup_4() { return cGroup_4; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_4_0() { return cLeftParenthesisKeyword_4_0; }
		
		//VLSTerm
		public RuleCall getVLSTermParserRuleCall_4_1() { return cVLSTermParserRuleCall_4_1; }
		
		//')'
		public Keyword getRightParenthesisKeyword_4_2() { return cRightParenthesisKeyword_4_2; }
	}
	public class VLSUniversalQuantifierElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ca.mcgill.ecse.dslreasoner.VampireLanguage.VLSUniversalQuantifier");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cVLSUniversalQuantifierAction_0 = (Action)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cExclamationMarkKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Keyword cLeftSquareBracketKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cVariablesAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cVariablesVLSVariableParserRuleCall_1_2_0 = (RuleCall)cVariablesAssignment_1_2.eContents().get(0);
		private final Group cGroup_1_3 = (Group)cGroup_1.eContents().get(3);
		private final Keyword cCommaKeyword_1_3_0 = (Keyword)cGroup_1_3.eContents().get(0);
		private final Assignment cVariablesAssignment_1_3_1 = (Assignment)cGroup_1_3.eContents().get(1);
		private final RuleCall cVariablesVLSVariableParserRuleCall_1_3_1_0 = (RuleCall)cVariablesAssignment_1_3_1.eContents().get(0);
		private final Keyword cRightSquareBracketKeyword_1_4 = (Keyword)cGroup_1.eContents().get(4);
		private final Keyword cColonKeyword_1_5 = (Keyword)cGroup_1.eContents().get(5);
		private final Assignment cOperandAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cOperandVLSUnitaryFormulaParserRuleCall_2_0 = (RuleCall)cOperandAssignment_2.eContents().get(0);
		
		//VLSUniversalQuantifier VLSTerm:
		//	{VLSUniversalQuantifier} ("!" '[' variables+=VLSVariable (',' variables+=VLSVariable)* ']' ':')
		//	operand=VLSUnitaryFormula;
		@Override public ParserRule getRule() { return rule; }
		
		//{VLSUniversalQuantifier} ("!" '[' variables+=VLSVariable (',' variables+=VLSVariable)* ']' ':')
		//operand=VLSUnitaryFormula
		public Group getGroup() { return cGroup; }
		
		//{VLSUniversalQuantifier}
		public Action getVLSUniversalQuantifierAction_0() { return cVLSUniversalQuantifierAction_0; }
		
		//"!" '[' variables+=VLSVariable (',' variables+=VLSVariable)* ']' ':'
		public Group getGroup_1() { return cGroup_1; }
		
		//"!"
		public Keyword getExclamationMarkKeyword_1_0() { return cExclamationMarkKeyword_1_0; }
		
		//'['
		public Keyword getLeftSquareBracketKeyword_1_1() { return cLeftSquareBracketKeyword_1_1; }
		
		//variables+=VLSVariable
		public Assignment getVariablesAssignment_1_2() { return cVariablesAssignment_1_2; }
		
		//VLSVariable
		public RuleCall getVariablesVLSVariableParserRuleCall_1_2_0() { return cVariablesVLSVariableParserRuleCall_1_2_0; }
		
		//(',' variables+=VLSVariable)*
		public Group getGroup_1_3() { return cGroup_1_3; }
		
		//','
		public Keyword getCommaKeyword_1_3_0() { return cCommaKeyword_1_3_0; }
		
		//variables+=VLSVariable
		public Assignment getVariablesAssignment_1_3_1() { return cVariablesAssignment_1_3_1; }
		
		//VLSVariable
		public RuleCall getVariablesVLSVariableParserRuleCall_1_3_1_0() { return cVariablesVLSVariableParserRuleCall_1_3_1_0; }
		
		//']'
		public Keyword getRightSquareBracketKeyword_1_4() { return cRightSquareBracketKeyword_1_4; }
		
		//':'
		public Keyword getColonKeyword_1_5() { return cColonKeyword_1_5; }
		
		//operand=VLSUnitaryFormula
		public Assignment getOperandAssignment_2() { return cOperandAssignment_2; }
		
		//VLSUnitaryFormula
		public RuleCall getOperandVLSUnitaryFormulaParserRuleCall_2_0() { return cOperandVLSUnitaryFormulaParserRuleCall_2_0; }
	}
	public class VLSExistentialQuantifierElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ca.mcgill.ecse.dslreasoner.VampireLanguage.VLSExistentialQuantifier");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cVLSExistentialQuantifierAction_0 = (Action)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cQuestionMarkKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Keyword cLeftSquareBracketKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cVariablesAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cVariablesVLSVariableParserRuleCall_1_2_0 = (RuleCall)cVariablesAssignment_1_2.eContents().get(0);
		private final Group cGroup_1_3 = (Group)cGroup_1.eContents().get(3);
		private final Keyword cCommaKeyword_1_3_0 = (Keyword)cGroup_1_3.eContents().get(0);
		private final Assignment cVariablesAssignment_1_3_1 = (Assignment)cGroup_1_3.eContents().get(1);
		private final RuleCall cVariablesVLSVariableParserRuleCall_1_3_1_0 = (RuleCall)cVariablesAssignment_1_3_1.eContents().get(0);
		private final Keyword cRightSquareBracketKeyword_1_4 = (Keyword)cGroup_1.eContents().get(4);
		private final Keyword cColonKeyword_1_5 = (Keyword)cGroup_1.eContents().get(5);
		private final Assignment cOperandAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cOperandVLSUnitaryFormulaParserRuleCall_2_0 = (RuleCall)cOperandAssignment_2.eContents().get(0);
		
		//VLSExistentialQuantifier VLSTerm:
		//	{VLSExistentialQuantifier} ("?" '[' variables+=VLSVariable (',' variables+=VLSVariable)* ']' ':')
		//	operand=VLSUnitaryFormula;
		@Override public ParserRule getRule() { return rule; }
		
		//{VLSExistentialQuantifier} ("?" '[' variables+=VLSVariable (',' variables+=VLSVariable)* ']' ':')
		//operand=VLSUnitaryFormula
		public Group getGroup() { return cGroup; }
		
		//{VLSExistentialQuantifier}
		public Action getVLSExistentialQuantifierAction_0() { return cVLSExistentialQuantifierAction_0; }
		
		//"?" '[' variables+=VLSVariable (',' variables+=VLSVariable)* ']' ':'
		public Group getGroup_1() { return cGroup_1; }
		
		//"?"
		public Keyword getQuestionMarkKeyword_1_0() { return cQuestionMarkKeyword_1_0; }
		
		//'['
		public Keyword getLeftSquareBracketKeyword_1_1() { return cLeftSquareBracketKeyword_1_1; }
		
		//variables+=VLSVariable
		public Assignment getVariablesAssignment_1_2() { return cVariablesAssignment_1_2; }
		
		//VLSVariable
		public RuleCall getVariablesVLSVariableParserRuleCall_1_2_0() { return cVariablesVLSVariableParserRuleCall_1_2_0; }
		
		//(',' variables+=VLSVariable)*
		public Group getGroup_1_3() { return cGroup_1_3; }
		
		//','
		public Keyword getCommaKeyword_1_3_0() { return cCommaKeyword_1_3_0; }
		
		//variables+=VLSVariable
		public Assignment getVariablesAssignment_1_3_1() { return cVariablesAssignment_1_3_1; }
		
		//VLSVariable
		public RuleCall getVariablesVLSVariableParserRuleCall_1_3_1_0() { return cVariablesVLSVariableParserRuleCall_1_3_1_0; }
		
		//']'
		public Keyword getRightSquareBracketKeyword_1_4() { return cRightSquareBracketKeyword_1_4; }
		
		//':'
		public Keyword getColonKeyword_1_5() { return cColonKeyword_1_5; }
		
		//operand=VLSUnitaryFormula
		public Assignment getOperandAssignment_2() { return cOperandAssignment_2; }
		
		//VLSUnitaryFormula
		public RuleCall getOperandVLSUnitaryFormulaParserRuleCall_2_0() { return cOperandVLSUnitaryFormulaParserRuleCall_2_0; }
	}
	public class VLSUnaryNegationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ca.mcgill.ecse.dslreasoner.VampireLanguage.VLSUnaryNegation");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cVLSUnaryNegationAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cTildeKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cOperandAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cOperandVLSUnitaryFormulaParserRuleCall_2_0 = (RuleCall)cOperandAssignment_2.eContents().get(0);
		
		//VLSUnaryNegation VLSTerm:
		//	{VLSUnaryNegation} '~' operand=VLSUnitaryFormula;
		@Override public ParserRule getRule() { return rule; }
		
		//{VLSUnaryNegation} '~' operand=VLSUnitaryFormula
		public Group getGroup() { return cGroup; }
		
		//{VLSUnaryNegation}
		public Action getVLSUnaryNegationAction_0() { return cVLSUnaryNegationAction_0; }
		
		//'~'
		public Keyword getTildeKeyword_1() { return cTildeKeyword_1; }
		
		//operand=VLSUnitaryFormula
		public Assignment getOperandAssignment_2() { return cOperandAssignment_2; }
		
		//VLSUnitaryFormula
		public RuleCall getOperandVLSUnitaryFormulaParserRuleCall_2_0() { return cOperandVLSUnitaryFormulaParserRuleCall_2_0; }
	}
	public class VLSUnaryInfixElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ca.mcgill.ecse.dslreasoner.VampireLanguage.VLSUnaryInfix");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cVLSAtomicParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Alternatives cAlternatives_1_0 = (Alternatives)cGroup_1.eContents().get(0);
		private final Group cGroup_1_0_0 = (Group)cAlternatives_1_0.eContents().get(0);
		private final Action cVLSInequalityLeftAction_1_0_0_0 = (Action)cGroup_1_0_0.eContents().get(0);
		private final Keyword cExclamationMarkEqualsSignKeyword_1_0_0_1 = (Keyword)cGroup_1_0_0.eContents().get(1);
		private final Group cGroup_1_0_1 = (Group)cAlternatives_1_0.eContents().get(1);
		private final Action cVLSEqualityLeftAction_1_0_1_0 = (Action)cGroup_1_0_1.eContents().get(0);
		private final Keyword cEqualsSignKeyword_1_0_1_1 = (Keyword)cGroup_1_0_1.eContents().get(1);
		private final Group cGroup_1_0_2 = (Group)cAlternatives_1_0.eContents().get(2);
		private final Action cVLSAssignmentLeftAction_1_0_2_0 = (Action)cGroup_1_0_2.eContents().get(0);
		private final Keyword cColonEqualsSignKeyword_1_0_2_1 = (Keyword)cGroup_1_0_2.eContents().get(1);
		private final Assignment cRightAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cRightVLSAtomicParserRuleCall_1_1_0 = (RuleCall)cRightAssignment_1_1.eContents().get(0);
		
		//VLSUnaryInfix VLSTerm:
		//	VLSAtomic (({VLSInequality.left=current} "!=" | {VLSEquality.left=current} "=" | {VLSAssignment.left=current} ":=")
		//	right=VLSAtomic)?;
		@Override public ParserRule getRule() { return rule; }
		
		//VLSAtomic (({VLSInequality.left=current} "!=" | {VLSEquality.left=current} "=" | {VLSAssignment.left=current} ":=")
		//right=VLSAtomic)?
		public Group getGroup() { return cGroup; }
		
		//VLSAtomic
		public RuleCall getVLSAtomicParserRuleCall_0() { return cVLSAtomicParserRuleCall_0; }
		
		//(({VLSInequality.left=current} "!=" | {VLSEquality.left=current} "=" | {VLSAssignment.left=current} ":=")
		//right=VLSAtomic)?
		public Group getGroup_1() { return cGroup_1; }
		
		//{VLSInequality.left=current} "!=" | {VLSEquality.left=current} "=" | {VLSAssignment.left=current} ":="
		public Alternatives getAlternatives_1_0() { return cAlternatives_1_0; }
		
		//{VLSInequality.left=current} "!="
		public Group getGroup_1_0_0() { return cGroup_1_0_0; }
		
		//{VLSInequality.left=current}
		public Action getVLSInequalityLeftAction_1_0_0_0() { return cVLSInequalityLeftAction_1_0_0_0; }
		
		//"!="
		public Keyword getExclamationMarkEqualsSignKeyword_1_0_0_1() { return cExclamationMarkEqualsSignKeyword_1_0_0_1; }
		
		//{VLSEquality.left=current} "="
		public Group getGroup_1_0_1() { return cGroup_1_0_1; }
		
		//{VLSEquality.left=current}
		public Action getVLSEqualityLeftAction_1_0_1_0() { return cVLSEqualityLeftAction_1_0_1_0; }
		
		//"="
		public Keyword getEqualsSignKeyword_1_0_1_1() { return cEqualsSignKeyword_1_0_1_1; }
		
		//{VLSAssignment.left=current} ":="
		public Group getGroup_1_0_2() { return cGroup_1_0_2; }
		
		//{VLSAssignment.left=current}
		public Action getVLSAssignmentLeftAction_1_0_2_0() { return cVLSAssignmentLeftAction_1_0_2_0; }
		
		//":="
		public Keyword getColonEqualsSignKeyword_1_0_2_1() { return cColonEqualsSignKeyword_1_0_2_1; }
		
		//right=VLSAtomic
		public Assignment getRightAssignment_1_1() { return cRightAssignment_1_1; }
		
		//VLSAtomic
		public RuleCall getRightVLSAtomicParserRuleCall_1_1_0() { return cRightVLSAtomicParserRuleCall_1_1_0; }
	}
	public class VLSAtomicElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ca.mcgill.ecse.dslreasoner.VampireLanguage.VLSAtomic");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cVLSAtomicConstantParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cVLSAtomicFunctionParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cVLSVariableParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cVLSDefinedTermParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		
		////NOT SUREEEE
		////VLSEquality returns VLSTerm:
		////	VLSFofTerm ({VLSEquality.left = current} "=" right = VLSFofTerm)?
		////	
		////;
		///*
		//enum VLSDefinedFunctor:
		//		UMINUS='$uminus' | SUM='$sum' | DIFFERENCE='$difference' | PRODUCT='$product' | QUOTIENT='$quotient' | 
		//		QUOTIENT_E='$quotient_e' | QUOTIENT_T='$quotient_t' | QUOTIENT_F='$quotient_f' | REMAINDER_E='$remainder_e' |
		//		 REMAINDER_T='$remainder_t' | REMAINDER_F='$remainder_f' | FLOOR='$floor' | CEILING='$ceiling' |
		//		 TRUNCATE='$truncate' | ROUND='$round' | TO_INT='$to_int' | TO_RAT='$to_rat' | TO_REAL='$to_real'
		//    ;
		//*/ VLSAtomic VLSTerm:
		//	VLSAtomicConstant | VLSAtomicFunction | VLSVariable
		//	| VLSDefinedTerm //temporary solution. this is only valid for equality, not for != or :=
		//	//| VLSEquality
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//VLSAtomicConstant | VLSAtomicFunction | VLSVariable | VLSDefinedTerm
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//VLSAtomicConstant
		public RuleCall getVLSAtomicConstantParserRuleCall_0() { return cVLSAtomicConstantParserRuleCall_0; }
		
		//VLSAtomicFunction
		public RuleCall getVLSAtomicFunctionParserRuleCall_1() { return cVLSAtomicFunctionParserRuleCall_1; }
		
		//VLSVariable
		public RuleCall getVLSVariableParserRuleCall_2() { return cVLSVariableParserRuleCall_2; }
		
		//VLSDefinedTerm
		public RuleCall getVLSDefinedTermParserRuleCall_3() { return cVLSDefinedTermParserRuleCall_3; }
	}
	public class VLSAtomicConstantElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ca.mcgill.ecse.dslreasoner.VampireLanguage.VLSAtomicConstant");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Action cVLSConstantAction_0_0 = (Action)cGroup_0.eContents().get(0);
		private final Assignment cNameAssignment_0_1 = (Assignment)cGroup_0.eContents().get(1);
		private final Alternatives cNameAlternatives_0_1_0 = (Alternatives)cNameAssignment_0_1.eContents().get(0);
		private final RuleCall cNameLOWER_WORD_IDTerminalRuleCall_0_1_0_0 = (RuleCall)cNameAlternatives_0_1_0.eContents().get(0);
		private final RuleCall cNameSINGLE_QUOTETerminalRuleCall_0_1_0_1 = (RuleCall)cNameAlternatives_0_1_0.eContents().get(1);
		private final RuleCall cNameDOLLAR_IDTerminalRuleCall_0_1_0_2 = (RuleCall)cNameAlternatives_0_1_0.eContents().get(2);
		private final RuleCall cNameDOUBLE_DOLLAR_IDTerminalRuleCall_0_1_0_3 = (RuleCall)cNameAlternatives_0_1_0.eContents().get(3);
		private final RuleCall cNameVLSRoleParserRuleCall_0_1_0_4 = (RuleCall)cNameAlternatives_0_1_0.eContents().get(4);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Action cVLSTrueAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cTrueKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Group cGroup_2 = (Group)cAlternatives.eContents().get(2);
		private final Action cVLSFalseAction_2_0 = (Action)cGroup_2.eContents().get(0);
		private final Keyword cFalseKeyword_2_1 = (Keyword)cGroup_2.eContents().get(1);
		
		//VLSAtomicConstant VLSTerm:
		//	{VLSConstant} name=(LOWER_WORD_ID | SINGLE_QUOTE | DOLLAR_ID | DOUBLE_DOLLAR_ID | VLSRole) | {VLSTrue} '$true' |
		//	{VLSFalse} '$false';
		@Override public ParserRule getRule() { return rule; }
		
		//{VLSConstant} name=(LOWER_WORD_ID | SINGLE_QUOTE | DOLLAR_ID | DOUBLE_DOLLAR_ID | VLSRole) | {VLSTrue} '$true' |
		//{VLSFalse} '$false'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//{VLSConstant} name=(LOWER_WORD_ID | SINGLE_QUOTE | DOLLAR_ID | DOUBLE_DOLLAR_ID | VLSRole)
		public Group getGroup_0() { return cGroup_0; }
		
		//{VLSConstant}
		public Action getVLSConstantAction_0_0() { return cVLSConstantAction_0_0; }
		
		//name=(LOWER_WORD_ID | SINGLE_QUOTE | DOLLAR_ID | DOUBLE_DOLLAR_ID | VLSRole)
		public Assignment getNameAssignment_0_1() { return cNameAssignment_0_1; }
		
		//(LOWER_WORD_ID | SINGLE_QUOTE | DOLLAR_ID | DOUBLE_DOLLAR_ID | VLSRole)
		public Alternatives getNameAlternatives_0_1_0() { return cNameAlternatives_0_1_0; }
		
		//LOWER_WORD_ID
		public RuleCall getNameLOWER_WORD_IDTerminalRuleCall_0_1_0_0() { return cNameLOWER_WORD_IDTerminalRuleCall_0_1_0_0; }
		
		//SINGLE_QUOTE
		public RuleCall getNameSINGLE_QUOTETerminalRuleCall_0_1_0_1() { return cNameSINGLE_QUOTETerminalRuleCall_0_1_0_1; }
		
		//DOLLAR_ID
		public RuleCall getNameDOLLAR_IDTerminalRuleCall_0_1_0_2() { return cNameDOLLAR_IDTerminalRuleCall_0_1_0_2; }
		
		//DOUBLE_DOLLAR_ID
		public RuleCall getNameDOUBLE_DOLLAR_IDTerminalRuleCall_0_1_0_3() { return cNameDOUBLE_DOLLAR_IDTerminalRuleCall_0_1_0_3; }
		
		//VLSRole
		public RuleCall getNameVLSRoleParserRuleCall_0_1_0_4() { return cNameVLSRoleParserRuleCall_0_1_0_4; }
		
		//{VLSTrue} '$true'
		public Group getGroup_1() { return cGroup_1; }
		
		//{VLSTrue}
		public Action getVLSTrueAction_1_0() { return cVLSTrueAction_1_0; }
		
		//'$true'
		public Keyword getTrueKeyword_1_1() { return cTrueKeyword_1_1; }
		
		//{VLSFalse} '$false'
		public Group getGroup_2() { return cGroup_2; }
		
		//{VLSFalse}
		public Action getVLSFalseAction_2_0() { return cVLSFalseAction_2_0; }
		
		//'$false'
		public Keyword getFalseKeyword_2_1() { return cFalseKeyword_2_1; }
	}
	public class VLSAtomicFunctionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ca.mcgill.ecse.dslreasoner.VampireLanguage.VLSAtomicFunction");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Action cVLSFunctionAction_0_0 = (Action)cGroup_0.eContents().get(0);
		private final Assignment cConstantAssignment_0_1 = (Assignment)cGroup_0.eContents().get(1);
		private final Alternatives cConstantAlternatives_0_1_0 = (Alternatives)cConstantAssignment_0_1.eContents().get(0);
		private final RuleCall cConstantLOWER_WORD_IDTerminalRuleCall_0_1_0_0 = (RuleCall)cConstantAlternatives_0_1_0.eContents().get(0);
		private final RuleCall cConstantSINGLE_QUOTETerminalRuleCall_0_1_0_1 = (RuleCall)cConstantAlternatives_0_1_0.eContents().get(1);
		private final RuleCall cConstantDOLLAR_IDTerminalRuleCall_0_1_0_2 = (RuleCall)cConstantAlternatives_0_1_0.eContents().get(2);
		private final RuleCall cConstantDOUBLE_DOLLAR_IDTerminalRuleCall_0_1_0_3 = (RuleCall)cConstantAlternatives_0_1_0.eContents().get(3);
		private final RuleCall cConstantVLSRoleParserRuleCall_0_1_0_4 = (RuleCall)cConstantAlternatives_0_1_0.eContents().get(4);
		private final Group cGroup_0_2 = (Group)cGroup_0.eContents().get(2);
		private final Keyword cLeftParenthesisKeyword_0_2_0 = (Keyword)cGroup_0_2.eContents().get(0);
		private final Assignment cTermsAssignment_0_2_1 = (Assignment)cGroup_0_2.eContents().get(1);
		private final RuleCall cTermsVLSFofTermParserRuleCall_0_2_1_0 = (RuleCall)cTermsAssignment_0_2_1.eContents().get(0);
		private final Group cGroup_0_2_2 = (Group)cGroup_0_2.eContents().get(2);
		private final Keyword cCommaKeyword_0_2_2_0 = (Keyword)cGroup_0_2_2.eContents().get(0);
		private final Assignment cTermsAssignment_0_2_2_1 = (Assignment)cGroup_0_2_2.eContents().get(1);
		private final RuleCall cTermsVLSFofTermParserRuleCall_0_2_2_1_0 = (RuleCall)cTermsAssignment_0_2_2_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_0_2_3 = (Keyword)cGroup_0_2.eContents().get(3);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Action cVLSLessAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cNameAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final Keyword cNameLessKeyword_1_1_0 = (Keyword)cNameAssignment_1_1.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1_2 = (Keyword)cGroup_1.eContents().get(2);
		private final Assignment cTermsAssignment_1_3 = (Assignment)cGroup_1.eContents().get(3);
		private final RuleCall cTermsVLSFofTermParserRuleCall_1_3_0 = (RuleCall)cTermsAssignment_1_3.eContents().get(0);
		private final Keyword cCommaKeyword_1_4 = (Keyword)cGroup_1.eContents().get(4);
		private final Assignment cTermsAssignment_1_5 = (Assignment)cGroup_1.eContents().get(5);
		private final RuleCall cTermsVLSFofTermParserRuleCall_1_5_0 = (RuleCall)cTermsAssignment_1_5.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_1_6 = (Keyword)cGroup_1.eContents().get(6);
		
		//VLSAtomicFunction VLSTerm:
		//	{VLSFunction} constant=(LOWER_WORD_ID | SINGLE_QUOTE | DOLLAR_ID | DOUBLE_DOLLAR_ID | VLSRole) ('(' terms+=VLSFofTerm
		//	(',' terms+=VLSFofTerm)* ')') | {VLSLess} name='$less' '(' terms+=VLSFofTerm ',' terms+=VLSFofTerm ')';
		@Override public ParserRule getRule() { return rule; }
		
		//{VLSFunction} constant=(LOWER_WORD_ID | SINGLE_QUOTE | DOLLAR_ID | DOUBLE_DOLLAR_ID | VLSRole) ('(' terms+=VLSFofTerm
		//(',' terms+=VLSFofTerm)* ')') | {VLSLess} name='$less' '(' terms+=VLSFofTerm ',' terms+=VLSFofTerm ')'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//{VLSFunction} constant=(LOWER_WORD_ID | SINGLE_QUOTE | DOLLAR_ID | DOUBLE_DOLLAR_ID | VLSRole) ('(' terms+=VLSFofTerm
		//(',' terms+=VLSFofTerm)* ')')
		public Group getGroup_0() { return cGroup_0; }
		
		//{VLSFunction}
		public Action getVLSFunctionAction_0_0() { return cVLSFunctionAction_0_0; }
		
		//constant=(LOWER_WORD_ID | SINGLE_QUOTE | DOLLAR_ID | DOUBLE_DOLLAR_ID | VLSRole)
		public Assignment getConstantAssignment_0_1() { return cConstantAssignment_0_1; }
		
		//(LOWER_WORD_ID | SINGLE_QUOTE | DOLLAR_ID | DOUBLE_DOLLAR_ID | VLSRole)
		public Alternatives getConstantAlternatives_0_1_0() { return cConstantAlternatives_0_1_0; }
		
		//LOWER_WORD_ID
		public RuleCall getConstantLOWER_WORD_IDTerminalRuleCall_0_1_0_0() { return cConstantLOWER_WORD_IDTerminalRuleCall_0_1_0_0; }
		
		//SINGLE_QUOTE
		public RuleCall getConstantSINGLE_QUOTETerminalRuleCall_0_1_0_1() { return cConstantSINGLE_QUOTETerminalRuleCall_0_1_0_1; }
		
		//DOLLAR_ID
		public RuleCall getConstantDOLLAR_IDTerminalRuleCall_0_1_0_2() { return cConstantDOLLAR_IDTerminalRuleCall_0_1_0_2; }
		
		//DOUBLE_DOLLAR_ID
		public RuleCall getConstantDOUBLE_DOLLAR_IDTerminalRuleCall_0_1_0_3() { return cConstantDOUBLE_DOLLAR_IDTerminalRuleCall_0_1_0_3; }
		
		//VLSRole
		public RuleCall getConstantVLSRoleParserRuleCall_0_1_0_4() { return cConstantVLSRoleParserRuleCall_0_1_0_4; }
		
		//'(' terms+=VLSFofTerm (',' terms+=VLSFofTerm)* ')'
		public Group getGroup_0_2() { return cGroup_0_2; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_0_2_0() { return cLeftParenthesisKeyword_0_2_0; }
		
		//terms+=VLSFofTerm
		public Assignment getTermsAssignment_0_2_1() { return cTermsAssignment_0_2_1; }
		
		//VLSFofTerm
		public RuleCall getTermsVLSFofTermParserRuleCall_0_2_1_0() { return cTermsVLSFofTermParserRuleCall_0_2_1_0; }
		
		//(',' terms+=VLSFofTerm)*
		public Group getGroup_0_2_2() { return cGroup_0_2_2; }
		
		//','
		public Keyword getCommaKeyword_0_2_2_0() { return cCommaKeyword_0_2_2_0; }
		
		//terms+=VLSFofTerm
		public Assignment getTermsAssignment_0_2_2_1() { return cTermsAssignment_0_2_2_1; }
		
		//VLSFofTerm
		public RuleCall getTermsVLSFofTermParserRuleCall_0_2_2_1_0() { return cTermsVLSFofTermParserRuleCall_0_2_2_1_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_0_2_3() { return cRightParenthesisKeyword_0_2_3; }
		
		//{VLSLess} name='$less' '(' terms+=VLSFofTerm ',' terms+=VLSFofTerm ')'
		public Group getGroup_1() { return cGroup_1; }
		
		//{VLSLess}
		public Action getVLSLessAction_1_0() { return cVLSLessAction_1_0; }
		
		//name='$less'
		public Assignment getNameAssignment_1_1() { return cNameAssignment_1_1; }
		
		//'$less'
		public Keyword getNameLessKeyword_1_1_0() { return cNameLessKeyword_1_1_0; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_1_2() { return cLeftParenthesisKeyword_1_2; }
		
		//terms+=VLSFofTerm
		public Assignment getTermsAssignment_1_3() { return cTermsAssignment_1_3; }
		
		//VLSFofTerm
		public RuleCall getTermsVLSFofTermParserRuleCall_1_3_0() { return cTermsVLSFofTermParserRuleCall_1_3_0; }
		
		//','
		public Keyword getCommaKeyword_1_4() { return cCommaKeyword_1_4; }
		
		//terms+=VLSFofTerm
		public Assignment getTermsAssignment_1_5() { return cTermsAssignment_1_5; }
		
		//VLSFofTerm
		public RuleCall getTermsVLSFofTermParserRuleCall_1_5_0() { return cTermsVLSFofTermParserRuleCall_1_5_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_1_6() { return cRightParenthesisKeyword_1_6; }
	}
	public class VLSVariableElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ca.mcgill.ecse.dslreasoner.VampireLanguage.VLSVariable");
		private final Assignment cNameAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cNameUPPER_WORD_IDTerminalRuleCall_0 = (RuleCall)cNameAssignment.eContents().get(0);
		
		//VLSVariable:
		//	name=UPPER_WORD_ID;
		@Override public ParserRule getRule() { return rule; }
		
		//name=UPPER_WORD_ID
		public Assignment getNameAssignment() { return cNameAssignment; }
		
		//UPPER_WORD_ID
		public RuleCall getNameUPPER_WORD_IDTerminalRuleCall_0() { return cNameUPPER_WORD_IDTerminalRuleCall_0; }
	}
	public class VLSFofTermElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ca.mcgill.ecse.dslreasoner.VampireLanguage.VLSFofTerm");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cVLSVariableParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cVLSFunctionFofParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cVLSDefinedTermParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		
		//VLSFofTerm VLSTerm:
		//	VLSVariable | VLSFunctionFof | VLSDefinedTerm;
		@Override public ParserRule getRule() { return rule; }
		
		////(VLSVariable | VLSFunction | VLSTffConditional | VLSTffLet | VLSTffTuple)
		//VLSVariable | VLSFunctionFof | VLSDefinedTerm
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//VLSVariable
		public RuleCall getVLSVariableParserRuleCall_0() { return cVLSVariableParserRuleCall_0; }
		
		//VLSFunctionFof
		public RuleCall getVLSFunctionFofParserRuleCall_1() { return cVLSFunctionFofParserRuleCall_1; }
		
		//VLSDefinedTerm
		public RuleCall getVLSDefinedTermParserRuleCall_2() { return cVLSDefinedTermParserRuleCall_2; }
	}
	public class VLSFunctionFofElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ca.mcgill.ecse.dslreasoner.VampireLanguage.VLSFunctionFof");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cFunctorAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Alternatives cFunctorAlternatives_0_0 = (Alternatives)cFunctorAssignment_0.eContents().get(0);
		private final RuleCall cFunctorLOWER_WORD_IDTerminalRuleCall_0_0_0 = (RuleCall)cFunctorAlternatives_0_0.eContents().get(0);
		private final RuleCall cFunctorSINGLE_QUOTETerminalRuleCall_0_0_1 = (RuleCall)cFunctorAlternatives_0_0.eContents().get(1);
		private final RuleCall cFunctorDOLLAR_IDTerminalRuleCall_0_0_2 = (RuleCall)cFunctorAlternatives_0_0.eContents().get(2);
		private final RuleCall cFunctorDOUBLE_DOLLAR_IDTerminalRuleCall_0_0_3 = (RuleCall)cFunctorAlternatives_0_0.eContents().get(3);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cTermsAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cTermsVLSFofTermParserRuleCall_1_1_0 = (RuleCall)cTermsAssignment_1_1.eContents().get(0);
		private final Group cGroup_1_2 = (Group)cGroup_1.eContents().get(2);
		private final Keyword cCommaKeyword_1_2_0 = (Keyword)cGroup_1_2.eContents().get(0);
		private final Assignment cTermsAssignment_1_2_1 = (Assignment)cGroup_1_2.eContents().get(1);
		private final RuleCall cTermsVLSFofTermParserRuleCall_1_2_1_0 = (RuleCall)cTermsAssignment_1_2_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_1_3 = (Keyword)cGroup_1.eContents().get(3);
		
		//VLSFunctionFof:
		//	functor=(LOWER_WORD_ID | SINGLE_QUOTE | DOLLAR_ID | DOUBLE_DOLLAR_ID) ('(' terms+=VLSFofTerm (',' terms+=VLSFofTerm)*
		//	')')?;
		@Override public ParserRule getRule() { return rule; }
		
		////? on next line causes warning
		////TODO might need replace DOLLAR_ID with enum rule 
		//functor=(LOWER_WORD_ID | SINGLE_QUOTE | DOLLAR_ID | DOUBLE_DOLLAR_ID) ('(' terms+=VLSFofTerm (',' terms+=VLSFofTerm)*
		//')')?
		public Group getGroup() { return cGroup; }
		
		////? on next line causes warning
		////TODO might need replace DOLLAR_ID with enum rule 
		//functor=(LOWER_WORD_ID | SINGLE_QUOTE | DOLLAR_ID | DOUBLE_DOLLAR_ID)
		public Assignment getFunctorAssignment_0() { return cFunctorAssignment_0; }
		
		//(LOWER_WORD_ID | SINGLE_QUOTE | DOLLAR_ID | DOUBLE_DOLLAR_ID)
		public Alternatives getFunctorAlternatives_0_0() { return cFunctorAlternatives_0_0; }
		
		//LOWER_WORD_ID
		public RuleCall getFunctorLOWER_WORD_IDTerminalRuleCall_0_0_0() { return cFunctorLOWER_WORD_IDTerminalRuleCall_0_0_0; }
		
		//SINGLE_QUOTE
		public RuleCall getFunctorSINGLE_QUOTETerminalRuleCall_0_0_1() { return cFunctorSINGLE_QUOTETerminalRuleCall_0_0_1; }
		
		//DOLLAR_ID
		public RuleCall getFunctorDOLLAR_IDTerminalRuleCall_0_0_2() { return cFunctorDOLLAR_IDTerminalRuleCall_0_0_2; }
		
		//DOUBLE_DOLLAR_ID
		public RuleCall getFunctorDOUBLE_DOLLAR_IDTerminalRuleCall_0_0_3() { return cFunctorDOUBLE_DOLLAR_IDTerminalRuleCall_0_0_3; }
		
		//('(' terms+=VLSFofTerm (',' terms+=VLSFofTerm)* ')')?
		public Group getGroup_1() { return cGroup_1; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_1_0() { return cLeftParenthesisKeyword_1_0; }
		
		//terms+=VLSFofTerm
		public Assignment getTermsAssignment_1_1() { return cTermsAssignment_1_1; }
		
		//VLSFofTerm
		public RuleCall getTermsVLSFofTermParserRuleCall_1_1_0() { return cTermsVLSFofTermParserRuleCall_1_1_0; }
		
		//(',' terms+=VLSFofTerm)*
		public Group getGroup_1_2() { return cGroup_1_2; }
		
		//','
		public Keyword getCommaKeyword_1_2_0() { return cCommaKeyword_1_2_0; }
		
		//terms+=VLSFofTerm
		public Assignment getTermsAssignment_1_2_1() { return cTermsAssignment_1_2_1; }
		
		//VLSFofTerm
		public RuleCall getTermsVLSFofTermParserRuleCall_1_2_1_0() { return cTermsVLSFofTermParserRuleCall_1_2_1_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_1_3() { return cRightParenthesisKeyword_1_3; }
	}
	public class VLSDefinedTermElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ca.mcgill.ecse.dslreasoner.VampireLanguage.VLSDefinedTerm");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Action cVLSIntAction_0_0 = (Action)cGroup_0.eContents().get(0);
		private final Assignment cValueAssignment_0_1 = (Assignment)cGroup_0.eContents().get(1);
		private final RuleCall cValueSIGNED_LITERALTerminalRuleCall_0_1_0 = (RuleCall)cValueAssignment_0_1.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Action cVLSRealAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cValueAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cValueSIGNED_REAL_IDTerminalRuleCall_1_1_0 = (RuleCall)cValueAssignment_1_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cAlternatives.eContents().get(2);
		private final Action cVLSRationalAction_2_0 = (Action)cGroup_2.eContents().get(0);
		private final Assignment cValueAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cValueSIGNED_RAT_IDTerminalRuleCall_2_1_0 = (RuleCall)cValueAssignment_2_1.eContents().get(0);
		private final Group cGroup_3 = (Group)cAlternatives.eContents().get(3);
		private final Action cVLSDoubleQuoteAction_3_0 = (Action)cGroup_3.eContents().get(0);
		private final Assignment cValueAssignment_3_1 = (Assignment)cGroup_3.eContents().get(1);
		private final RuleCall cValueDOUBLE_QUOTETerminalRuleCall_3_1_0 = (RuleCall)cValueAssignment_3_1.eContents().get(0);
		
		//VLSDefinedTerm:
		//	{VLSInt} value=SIGNED_LITERAL | {VLSReal} value=SIGNED_REAL_ID | {VLSRational} value=SIGNED_RAT_ID | {VLSDoubleQuote}
		//	value=DOUBLE_QUOTE;
		@Override public ParserRule getRule() { return rule; }
		
		//{VLSInt} value=SIGNED_LITERAL | {VLSReal} value=SIGNED_REAL_ID | {VLSRational} value=SIGNED_RAT_ID | {VLSDoubleQuote}
		//value=DOUBLE_QUOTE
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//{VLSInt} value=SIGNED_LITERAL
		public Group getGroup_0() { return cGroup_0; }
		
		//{VLSInt}
		public Action getVLSIntAction_0_0() { return cVLSIntAction_0_0; }
		
		//value=SIGNED_LITERAL
		public Assignment getValueAssignment_0_1() { return cValueAssignment_0_1; }
		
		//SIGNED_LITERAL
		public RuleCall getValueSIGNED_LITERALTerminalRuleCall_0_1_0() { return cValueSIGNED_LITERALTerminalRuleCall_0_1_0; }
		
		//{VLSReal} value=SIGNED_REAL_ID
		public Group getGroup_1() { return cGroup_1; }
		
		//{VLSReal}
		public Action getVLSRealAction_1_0() { return cVLSRealAction_1_0; }
		
		//value=SIGNED_REAL_ID
		public Assignment getValueAssignment_1_1() { return cValueAssignment_1_1; }
		
		//SIGNED_REAL_ID
		public RuleCall getValueSIGNED_REAL_IDTerminalRuleCall_1_1_0() { return cValueSIGNED_REAL_IDTerminalRuleCall_1_1_0; }
		
		//{VLSRational} value=SIGNED_RAT_ID
		public Group getGroup_2() { return cGroup_2; }
		
		//{VLSRational}
		public Action getVLSRationalAction_2_0() { return cVLSRationalAction_2_0; }
		
		//value=SIGNED_RAT_ID
		public Assignment getValueAssignment_2_1() { return cValueAssignment_2_1; }
		
		//SIGNED_RAT_ID
		public RuleCall getValueSIGNED_RAT_IDTerminalRuleCall_2_1_0() { return cValueSIGNED_RAT_IDTerminalRuleCall_2_1_0; }
		
		//{VLSDoubleQuote} value=DOUBLE_QUOTE
		public Group getGroup_3() { return cGroup_3; }
		
		//{VLSDoubleQuote}
		public Action getVLSDoubleQuoteAction_3_0() { return cVLSDoubleQuoteAction_3_0; }
		
		//value=DOUBLE_QUOTE
		public Assignment getValueAssignment_3_1() { return cValueAssignment_3_1; }
		
		//DOUBLE_QUOTE
		public RuleCall getValueDOUBLE_QUOTETerminalRuleCall_3_1_0() { return cValueDOUBLE_QUOTETerminalRuleCall_3_1_0; }
	}
	
	
	private final VampireModelElements pVampireModel;
	private final TerminalRule tALPHA_NUMERIC;
	private final TerminalRule tUPPER_WORD_ID;
	private final TerminalRule tLOWER_WORD_ID;
	private final TerminalRule tDOUBLE_QUOTE;
	private final TerminalRule tSINGLE_QUOTE;
	private final TerminalRule tSIGN;
	private final TerminalRule tDOLLAR_ID;
	private final TerminalRule tDOUBLE_DOLLAR_ID;
	private final TerminalRule tLITERAL;
	private final TerminalRule tSIGNED_LITERAL;
	private final TerminalRule tUNSIGNED_REAL_FRAC_ID;
	private final TerminalRule tUNSIGNED_REAL_EXP_ID;
	private final TerminalRule tSIGNED_REAL_ID;
	private final TerminalRule tUNSIGNED_RAT_ID;
	private final TerminalRule tSIGNED_RAT_ID;
	private final TerminalRule tID;
	private final TerminalRule tANY_OTHER;
	private final TerminalRule tSINGLE_COMMENT;
	private final VLSIncludeElements pVLSInclude;
	private final VLSNameElements pVLSName;
	private final VLSCommentElements pVLSComment;
	private final VLSConfirmationsElements pVLSConfirmations;
	private final VLSSatisfiableElements pVLSSatisfiable;
	private final VLSTryingElements pVLSTrying;
	private final VLSFiniteModelElements pVLSFiniteModel;
	private final VLSFofFormulaElements pVLSFofFormula;
	private final VLSTffFormulaElements pVLSTffFormula;
	private final VLSRoleElements pVLSRole;
	private final VLSAnnotationElements pVLSAnnotation;
	private final VLSAnnotationTermsElements pVLSAnnotationTerms;
	private final VLSTermElements pVLSTerm;
	private final VLSBinaryElements pVLSBinary;
	private final VLSUnitaryFormulaElements pVLSUnitaryFormula;
	private final VLSUniversalQuantifierElements pVLSUniversalQuantifier;
	private final VLSExistentialQuantifierElements pVLSExistentialQuantifier;
	private final VLSUnaryNegationElements pVLSUnaryNegation;
	private final VLSUnaryInfixElements pVLSUnaryInfix;
	private final VLSAtomicElements pVLSAtomic;
	private final VLSAtomicConstantElements pVLSAtomicConstant;
	private final VLSAtomicFunctionElements pVLSAtomicFunction;
	private final VLSVariableElements pVLSVariable;
	private final VLSFofTermElements pVLSFofTerm;
	private final VLSFunctionFofElements pVLSFunctionFof;
	private final VLSDefinedTermElements pVLSDefinedTerm;
	
	private final Grammar grammar;
	
	private final TerminalsGrammarAccess gaTerminals;

	@Inject
	public VampireLanguageGrammarAccess(GrammarProvider grammarProvider,
			TerminalsGrammarAccess gaTerminals) {
		this.grammar = internalFindGrammar(grammarProvider);
		this.gaTerminals = gaTerminals;
		this.pVampireModel = new VampireModelElements();
		this.tALPHA_NUMERIC = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "ca.mcgill.ecse.dslreasoner.VampireLanguage.ALPHA_NUMERIC");
		this.tUPPER_WORD_ID = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "ca.mcgill.ecse.dslreasoner.VampireLanguage.UPPER_WORD_ID");
		this.tLOWER_WORD_ID = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "ca.mcgill.ecse.dslreasoner.VampireLanguage.LOWER_WORD_ID");
		this.tDOUBLE_QUOTE = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "ca.mcgill.ecse.dslreasoner.VampireLanguage.DOUBLE_QUOTE");
		this.tSINGLE_QUOTE = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "ca.mcgill.ecse.dslreasoner.VampireLanguage.SINGLE_QUOTE");
		this.tSIGN = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "ca.mcgill.ecse.dslreasoner.VampireLanguage.SIGN");
		this.tDOLLAR_ID = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "ca.mcgill.ecse.dslreasoner.VampireLanguage.DOLLAR_ID");
		this.tDOUBLE_DOLLAR_ID = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "ca.mcgill.ecse.dslreasoner.VampireLanguage.DOUBLE_DOLLAR_ID");
		this.tLITERAL = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "ca.mcgill.ecse.dslreasoner.VampireLanguage.LITERAL");
		this.tSIGNED_LITERAL = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "ca.mcgill.ecse.dslreasoner.VampireLanguage.SIGNED_LITERAL");
		this.tUNSIGNED_REAL_FRAC_ID = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "ca.mcgill.ecse.dslreasoner.VampireLanguage.UNSIGNED_REAL_FRAC_ID");
		this.tUNSIGNED_REAL_EXP_ID = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "ca.mcgill.ecse.dslreasoner.VampireLanguage.UNSIGNED_REAL_EXP_ID");
		this.tSIGNED_REAL_ID = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "ca.mcgill.ecse.dslreasoner.VampireLanguage.SIGNED_REAL_ID");
		this.tUNSIGNED_RAT_ID = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "ca.mcgill.ecse.dslreasoner.VampireLanguage.UNSIGNED_RAT_ID");
		this.tSIGNED_RAT_ID = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "ca.mcgill.ecse.dslreasoner.VampireLanguage.SIGNED_RAT_ID");
		this.tID = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "ca.mcgill.ecse.dslreasoner.VampireLanguage.ID");
		this.tANY_OTHER = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "ca.mcgill.ecse.dslreasoner.VampireLanguage.ANY_OTHER");
		this.tSINGLE_COMMENT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "ca.mcgill.ecse.dslreasoner.VampireLanguage.SINGLE_COMMENT");
		this.pVLSInclude = new VLSIncludeElements();
		this.pVLSName = new VLSNameElements();
		this.pVLSComment = new VLSCommentElements();
		this.pVLSConfirmations = new VLSConfirmationsElements();
		this.pVLSSatisfiable = new VLSSatisfiableElements();
		this.pVLSTrying = new VLSTryingElements();
		this.pVLSFiniteModel = new VLSFiniteModelElements();
		this.pVLSFofFormula = new VLSFofFormulaElements();
		this.pVLSTffFormula = new VLSTffFormulaElements();
		this.pVLSRole = new VLSRoleElements();
		this.pVLSAnnotation = new VLSAnnotationElements();
		this.pVLSAnnotationTerms = new VLSAnnotationTermsElements();
		this.pVLSTerm = new VLSTermElements();
		this.pVLSBinary = new VLSBinaryElements();
		this.pVLSUnitaryFormula = new VLSUnitaryFormulaElements();
		this.pVLSUniversalQuantifier = new VLSUniversalQuantifierElements();
		this.pVLSExistentialQuantifier = new VLSExistentialQuantifierElements();
		this.pVLSUnaryNegation = new VLSUnaryNegationElements();
		this.pVLSUnaryInfix = new VLSUnaryInfixElements();
		this.pVLSAtomic = new VLSAtomicElements();
		this.pVLSAtomicConstant = new VLSAtomicConstantElements();
		this.pVLSAtomicFunction = new VLSAtomicFunctionElements();
		this.pVLSVariable = new VLSVariableElements();
		this.pVLSFofTerm = new VLSFofTermElements();
		this.pVLSFunctionFof = new VLSFunctionFofElements();
		this.pVLSDefinedTerm = new VLSDefinedTermElements();
	}
	
	protected Grammar internalFindGrammar(GrammarProvider grammarProvider) {
		Grammar grammar = grammarProvider.getGrammar(this);
		while (grammar != null) {
			if ("ca.mcgill.ecse.dslreasoner.VampireLanguage".equals(grammar.getName())) {
				return grammar;
			}
			List<Grammar> grammars = grammar.getUsedGrammars();
			if (!grammars.isEmpty()) {
				grammar = grammars.iterator().next();
			} else {
				return null;
			}
		}
		return grammar;
	}
	
	@Override
	public Grammar getGrammar() {
		return grammar;
	}
	
	
	public TerminalsGrammarAccess getTerminalsGrammarAccess() {
		return gaTerminals;
	}

	
	////@@@@@@@@@@@
	////2 things TODO:
	////1. fix anotations (ln77)
	////2. can only use declared variables in formula (ln 158)
	////@@@@@@@@@@@
	//VampireModel:
	//	(includes+=VLSInclude | comments+=VLSComment | confirmations+=VLSConfirmations | formulas+=VLSFofFormula |
	//	tfformulas+=VLSTffFormula)*;
	public VampireModelElements getVampireModelAccess() {
		return pVampireModel;
	}
	
	public ParserRule getVampireModelRule() {
		return getVampireModelAccess().getRule();
	}
	
	//terminal ALPHA_NUMERIC:
	//	'a'..'z' | 'A'..'Z' | '0'..'9' | '_';
	public TerminalRule getALPHA_NUMERICRule() {
		return tALPHA_NUMERIC;
	}
	
	//terminal UPPER_WORD_ID:
	//	'A'..'Z' ALPHA_NUMERIC*;
	public TerminalRule getUPPER_WORD_IDRule() {
		return tUPPER_WORD_ID;
	}
	
	//terminal LOWER_WORD_ID:
	//	'a'..'z' ALPHA_NUMERIC*;
	public TerminalRule getLOWER_WORD_IDRule() {
		return tLOWER_WORD_ID;
	}
	
	//terminal DOUBLE_QUOTE:
	//	'"' ('\\' ('"' | '\\') | !('\\' | '"'))* '"';
	public TerminalRule getDOUBLE_QUOTERule() {
		return tDOUBLE_QUOTE;
	}
	
	//terminal SINGLE_QUOTE:
	//	"'" ('\\' ("'" | '\\') | !('\\' | "'"))+ "'";
	public TerminalRule getSINGLE_QUOTERule() {
		return tSINGLE_QUOTE;
	}
	
	//terminal SIGN:
	//	'+' | '-';
	public TerminalRule getSIGNRule() {
		return tSIGN;
	}
	
	//terminal DOLLAR_ID:
	//	'$' LOWER_WORD_ID;
	public TerminalRule getDOLLAR_IDRule() {
		return tDOLLAR_ID;
	}
	
	//terminal DOUBLE_DOLLAR_ID:
	//	'$$' LOWER_WORD_ID;
	public TerminalRule getDOUBLE_DOLLAR_IDRule() {
		return tDOUBLE_DOLLAR_ID;
	}
	
	//terminal LITERAL:
	//	'0' | '1'..'9' INT?;
	public TerminalRule getLITERALRule() {
		return tLITERAL;
	}
	
	//terminal SIGNED_LITERAL:
	//	SIGN* LITERAL;
	public TerminalRule getSIGNED_LITERALRule() {
		return tSIGNED_LITERAL;
	}
	
	//terminal UNSIGNED_REAL_FRAC_ID:
	//	LITERAL '.' INT;
	public TerminalRule getUNSIGNED_REAL_FRAC_IDRule() {
		return tUNSIGNED_REAL_FRAC_ID;
	}
	
	//terminal UNSIGNED_REAL_EXP_ID:
	//	(LITERAL | UNSIGNED_REAL_FRAC_ID) 'Ee' SIGN* INT;
	public TerminalRule getUNSIGNED_REAL_EXP_IDRule() {
		return tUNSIGNED_REAL_EXP_ID;
	}
	
	//terminal SIGNED_REAL_ID:
	//	SIGN* (UNSIGNED_REAL_FRAC_ID | UNSIGNED_REAL_EXP_ID);
	public TerminalRule getSIGNED_REAL_IDRule() {
		return tSIGNED_REAL_ID;
	}
	
	//terminal UNSIGNED_RAT_ID:
	//	LITERAL '/' '1'..'9' INT?;
	public TerminalRule getUNSIGNED_RAT_IDRule() {
		return tUNSIGNED_RAT_ID;
	}
	
	//terminal SIGNED_RAT_ID:
	//	SIGN* UNSIGNED_RAT_ID;
	public TerminalRule getSIGNED_RAT_IDRule() {
		return tSIGNED_RAT_ID;
	}
	
	//terminal ID:
	//	!('\n' | '\r')*;
	public TerminalRule getIDRule() {
		return tID;
	}
	
	//terminal ANY_OTHER:
	//	ID;
	public TerminalRule getANY_OTHERRule() {
		return tANY_OTHER;
	}
	
	//terminal SINGLE_COMMENT:
	//	ANY_OTHER;
	public TerminalRule getSINGLE_COMMENTRule() {
		return tSINGLE_COMMENT;
	}
	
	////terminal ID:  ( !('('|')'|'\r'|'\n') )+ ;
	////////////////////////////////////
	//// VLS types
	////////////////////////////////////
	//// <includes>
	//VLSInclude:
	//	'include(' fileName=SINGLE_QUOTE (',[' names+=VLSName (',' names+=VLSName)* ']')?;
	public VLSIncludeElements getVLSIncludeAccess() {
		return pVLSInclude;
	}
	
	public ParserRule getVLSIncludeRule() {
		return getVLSIncludeAccess().getRule();
	}
	
	//VLSName:
	//	name=(LOWER_WORD_ID | SINGLE_QUOTE | LITERAL | SIGNED_LITERAL);
	public VLSNameElements getVLSNameAccess() {
		return pVLSName;
	}
	
	public ParserRule getVLSNameRule() {
		return getVLSNameAccess().getRule();
	}
	
	//// <comments>
	//VLSComment:
	//	'%' comment=SINGLE_COMMENT
	//	//need to add a new line at the end of the file for the case where the last line is a comment
	//;
	public VLSCommentElements getVLSCommentAccess() {
		return pVLSComment;
	}
	
	public ParserRule getVLSCommentRule() {
		return getVLSCommentAccess().getRule();
	}
	
	////VLSConstantDeclaration: name = (LOWER_WORD_ID | SINGLE_QUOTE | DOLLAR_ID | DOUBLE_DOLLAR_ID );
	//VLSConfirmations:
	//	VLSSatisfiable //| VLSFiniteModel// | VLSTrying
	//;
	public VLSConfirmationsElements getVLSConfirmationsAccess() {
		return pVLSConfirmations;
	}
	
	public ParserRule getVLSConfirmationsRule() {
		return getVLSConfirmationsAccess().getRule();
	}
	
	//VLSSatisfiable:
	//	{VLSSatisfiable} 'Satisfiable!';
	public VLSSatisfiableElements getVLSSatisfiableAccess() {
		return pVLSSatisfiable;
	}
	
	public ParserRule getVLSSatisfiableRule() {
		return getVLSSatisfiableAccess().getRule();
	}
	
	//VLSTrying:
	//	'TRYING' '[' name=LITERAL ']';
	public VLSTryingElements getVLSTryingAccess() {
		return pVLSTrying;
	}
	
	public ParserRule getVLSTryingRule() {
		return getVLSTryingAccess().getRule();
	}
	
	//VLSFiniteModel:
	//	{VLSFiniteModel} 'Finite' 'Model' 'Found!';
	public VLSFiniteModelElements getVLSFiniteModelAccess() {
		return pVLSFiniteModel;
	}
	
	public ParserRule getVLSFiniteModelRule() {
		return getVLSFiniteModelAccess().getRule();
	}
	
	//// <FOF formulas>
	//VLSFofFormula:
	//	'fof' '(' name=(LOWER_WORD_ID | SIGNED_LITERAL | SINGLE_QUOTE) ',' fofRole=VLSRole ',' fofFormula=VLSTerm (','
	//	annotations=VLSAnnotation)? ')' '.';
	public VLSFofFormulaElements getVLSFofFormulaAccess() {
		return pVLSFofFormula;
	}
	
	public ParserRule getVLSFofFormulaRule() {
		return getVLSFofFormulaAccess().getRule();
	}
	
	//VLSTffFormula:
	//	'tff' '(' name=(LOWER_WORD_ID | SIGNED_LITERAL | SINGLE_QUOTE) ',' fofRole=VLSRole ',' fofFormula=VLSTerm (','
	//	annotations=VLSAnnotation)? ')' '.';
	public VLSTffFormulaElements getVLSTffFormulaAccess() {
		return pVLSTffFormula;
	}
	
	public ParserRule getVLSTffFormulaRule() {
		return getVLSTffFormulaAccess().getRule();
	}
	
	///*
	////NAME
	//VLSName:
	//	//(atomic_Word = Atomic_Word | integer = Integer | single_quote_word = Single_Quote_Word)
	//	name = (LOWER_WORD_ID | SIGNED_INT_ID | SINGLE_QUOTE)
	//;
	//*/ //<ROLE>
	//VLSRole:
	//	"axiom" | "conjecture" | "hypothesis" | "definition" | "assumption" | "lemma"
	//	| "theorem" | "corollary" | "negated_conjecture" | "plain" | "type" |
	//	"fi_domain" | "fi_functors" | "fi_predicates" | "unknown";
	public VLSRoleElements getVLSRoleAccess() {
		return pVLSRole;
	}
	
	public ParserRule getVLSRoleRule() {
		return getVLSRoleAccess().getRule();
	}
	
	////VLSRole:
	////	VLSAxiom | VLSConjecture | VLSHypothesis | VLSDefinition |
	////	VLSAssumption | VLSLemma | VLSTheorem | VLSCorollary | VLSNegated_Conjecture |
	////	VLSPlain | VLSType |VLSFi_Domain | VLSFi_Functors | VLSFi_Predicates | VLSUnknown
	////;
	////
	////VLSAxiom:
	////	"axiom"
	////;
	////
	////VLSConjecture:
	////	"conjecture"
	////;
	////
	////VLSHypothesis:
	////	"hypothesis"
	////;
	////	
	////VLSDefinition:
	////	"definition"
	////;
	////
	////VLSAssumption:
	////	"assumption"
	////;
	////		
	////VLSLemma:
	////	"lemma"
	////;
	////			
	////VLSTheorem:
	////	"theorem"
	////;
	////				
	////VLSCorollary:
	////	"corollary"
	////;
	////			
	////VLSNegated_Conjecture:
	////	"negated_conjecture"	
	////;
	////
	////VLSPlain:
	////	"plain"
	////;
	////
	////VLSType:
	////	"type"
	////;
	////
	////VLSFi_Domain:
	////	"fi_domain"
	////;
	////
	////VLSFi_Functors:
	////	"fi_functors"
	////;
	////
	////VLSFi_Predicates:
	////	"fi_predicates"
	////;
	////
	////VLSUnknown:
	////	"unknown"
	////;
	//// <ANNOTATION>
	//// Not at all based on the website. based on what we think the output will be like 
	//VLSAnnotation:
	//	'['? name=(LOWER_WORD_ID | SINGLE_QUOTE | VLSRole)? ('(' followup=VLSAnnotationTerms ')')? ']'?;
	public VLSAnnotationElements getVLSAnnotationAccess() {
		return pVLSAnnotation;
	}
	
	public ParserRule getVLSAnnotationRule() {
		return getVLSAnnotationAccess().getRule();
	}
	
	//VLSAnnotationTerms VLSAnnotation:
	//	terms+=VLSAnnotation (',' terms+=VLSAnnotation)*;
	public VLSAnnotationTermsElements getVLSAnnotationTermsAccess() {
		return pVLSAnnotationTerms;
	}
	
	public ParserRule getVLSAnnotationTermsRule() {
		return getVLSAnnotationTermsAccess().getRule();
	}
	
	////////////////////////////////////
	//// VLS Terms
	////////////////////////////////////
	//VLSTerm:
	//	VLSBinary;
	public VLSTermElements getVLSTermAccess() {
		return pVLSTerm;
	}
	
	public ParserRule getVLSTermRule() {
		return getVLSTermAccess().getRule();
	}
	
	////*
	////VLSBinaryFormula
	//VLSBinary VLSTerm:
	//	VLSUnitaryFormula (({VLSEquivalent.left=current} "<=>" | {VLSImplies.left=current} "=>" |
	//	{VLSRevImplies.left=current} "<=" | {VLSXnor.left=current} "<~>" | {VLSNor.left=current} "~|" |
	//	{VLSNand.left=current} "~&") right=VLSUnitaryFormula | ({VLSAnd.left=current} '&' right=VLSUnitaryFormula)+
	//	| ({VLSOr.left=current} '|' right=VLSUnitaryFormula)+)?;
	public VLSBinaryElements getVLSBinaryAccess() {
		return pVLSBinary;
	}
	
	public ParserRule getVLSBinaryRule() {
		return getVLSBinaryAccess().getRule();
	}
	
	////VLSUnitaryFormula
	//VLSUnitaryFormula VLSTerm:
	//	VLSUniversalQuantifier | VLSExistentialQuantifier | VLSUnaryNegation | VLSUnaryInfix
	//	//| VLSEquality 
	//	| '(' VLSTerm ')';
	public VLSUnitaryFormulaElements getVLSUnitaryFormulaAccess() {
		return pVLSUnitaryFormula;
	}
	
	public ParserRule getVLSUnitaryFormulaRule() {
		return getVLSUnitaryFormulaAccess().getRule();
	}
	
	//VLSUniversalQuantifier VLSTerm:
	//	{VLSUniversalQuantifier} ("!" '[' variables+=VLSVariable (',' variables+=VLSVariable)* ']' ':')
	//	operand=VLSUnitaryFormula;
	public VLSUniversalQuantifierElements getVLSUniversalQuantifierAccess() {
		return pVLSUniversalQuantifier;
	}
	
	public ParserRule getVLSUniversalQuantifierRule() {
		return getVLSUniversalQuantifierAccess().getRule();
	}
	
	//VLSExistentialQuantifier VLSTerm:
	//	{VLSExistentialQuantifier} ("?" '[' variables+=VLSVariable (',' variables+=VLSVariable)* ']' ':')
	//	operand=VLSUnitaryFormula;
	public VLSExistentialQuantifierElements getVLSExistentialQuantifierAccess() {
		return pVLSExistentialQuantifier;
	}
	
	public ParserRule getVLSExistentialQuantifierRule() {
		return getVLSExistentialQuantifierAccess().getRule();
	}
	
	//VLSUnaryNegation VLSTerm:
	//	{VLSUnaryNegation} '~' operand=VLSUnitaryFormula;
	public VLSUnaryNegationElements getVLSUnaryNegationAccess() {
		return pVLSUnaryNegation;
	}
	
	public ParserRule getVLSUnaryNegationRule() {
		return getVLSUnaryNegationAccess().getRule();
	}
	
	//VLSUnaryInfix VLSTerm:
	//	VLSAtomic (({VLSInequality.left=current} "!=" | {VLSEquality.left=current} "=" | {VLSAssignment.left=current} ":=")
	//	right=VLSAtomic)?;
	public VLSUnaryInfixElements getVLSUnaryInfixAccess() {
		return pVLSUnaryInfix;
	}
	
	public ParserRule getVLSUnaryInfixRule() {
		return getVLSUnaryInfixAccess().getRule();
	}
	
	////NOT SUREEEE
	////VLSEquality returns VLSTerm:
	////	VLSFofTerm ({VLSEquality.left = current} "=" right = VLSFofTerm)?
	////	
	////;
	///*
	//enum VLSDefinedFunctor:
	//		UMINUS='$uminus' | SUM='$sum' | DIFFERENCE='$difference' | PRODUCT='$product' | QUOTIENT='$quotient' | 
	//		QUOTIENT_E='$quotient_e' | QUOTIENT_T='$quotient_t' | QUOTIENT_F='$quotient_f' | REMAINDER_E='$remainder_e' |
	//		 REMAINDER_T='$remainder_t' | REMAINDER_F='$remainder_f' | FLOOR='$floor' | CEILING='$ceiling' |
	//		 TRUNCATE='$truncate' | ROUND='$round' | TO_INT='$to_int' | TO_RAT='$to_rat' | TO_REAL='$to_real'
	//    ;
	//*/ VLSAtomic VLSTerm:
	//	VLSAtomicConstant | VLSAtomicFunction | VLSVariable
	//	| VLSDefinedTerm //temporary solution. this is only valid for equality, not for != or :=
	//	//| VLSEquality
	//;
	public VLSAtomicElements getVLSAtomicAccess() {
		return pVLSAtomic;
	}
	
	public ParserRule getVLSAtomicRule() {
		return getVLSAtomicAccess().getRule();
	}
	
	//VLSAtomicConstant VLSTerm:
	//	{VLSConstant} name=(LOWER_WORD_ID | SINGLE_QUOTE | DOLLAR_ID | DOUBLE_DOLLAR_ID | VLSRole) | {VLSTrue} '$true' |
	//	{VLSFalse} '$false';
	public VLSAtomicConstantElements getVLSAtomicConstantAccess() {
		return pVLSAtomicConstant;
	}
	
	public ParserRule getVLSAtomicConstantRule() {
		return getVLSAtomicConstantAccess().getRule();
	}
	
	//VLSAtomicFunction VLSTerm:
	//	{VLSFunction} constant=(LOWER_WORD_ID | SINGLE_QUOTE | DOLLAR_ID | DOUBLE_DOLLAR_ID | VLSRole) ('(' terms+=VLSFofTerm
	//	(',' terms+=VLSFofTerm)* ')') | {VLSLess} name='$less' '(' terms+=VLSFofTerm ',' terms+=VLSFofTerm ')';
	public VLSAtomicFunctionElements getVLSAtomicFunctionAccess() {
		return pVLSAtomicFunction;
	}
	
	public ParserRule getVLSAtomicFunctionRule() {
		return getVLSAtomicFunctionAccess().getRule();
	}
	
	//VLSVariable:
	//	name=UPPER_WORD_ID;
	public VLSVariableElements getVLSVariableAccess() {
		return pVLSVariable;
	}
	
	public ParserRule getVLSVariableRule() {
		return getVLSVariableAccess().getRule();
	}
	
	//VLSFofTerm VLSTerm:
	//	VLSVariable | VLSFunctionFof | VLSDefinedTerm;
	public VLSFofTermElements getVLSFofTermAccess() {
		return pVLSFofTerm;
	}
	
	public ParserRule getVLSFofTermRule() {
		return getVLSFofTermAccess().getRule();
	}
	
	//VLSFunctionFof:
	//	functor=(LOWER_WORD_ID | SINGLE_QUOTE | DOLLAR_ID | DOUBLE_DOLLAR_ID) ('(' terms+=VLSFofTerm (',' terms+=VLSFofTerm)*
	//	')')?;
	public VLSFunctionFofElements getVLSFunctionFofAccess() {
		return pVLSFunctionFof;
	}
	
	public ParserRule getVLSFunctionFofRule() {
		return getVLSFunctionFofAccess().getRule();
	}
	
	//VLSDefinedTerm:
	//	{VLSInt} value=SIGNED_LITERAL | {VLSReal} value=SIGNED_REAL_ID | {VLSRational} value=SIGNED_RAT_ID | {VLSDoubleQuote}
	//	value=DOUBLE_QUOTE;
	public VLSDefinedTermElements getVLSDefinedTermAccess() {
		return pVLSDefinedTerm;
	}
	
	public ParserRule getVLSDefinedTermRule() {
		return getVLSDefinedTermAccess().getRule();
	}
	
	//terminal INT returns ecore::EInt:
	//	'0'..'9'+;
	public TerminalRule getINTRule() {
		return gaTerminals.getINTRule();
	}
	
	//terminal STRING:
	//	'"' ('\\' . | !('\\' | '"'))* '"' | "'" ('\\' . | !('\\' | "'"))* "'";
	public TerminalRule getSTRINGRule() {
		return gaTerminals.getSTRINGRule();
	}
	
	//terminal ML_COMMENT:
	//	'/*'->'*/';
	public TerminalRule getML_COMMENTRule() {
		return gaTerminals.getML_COMMENTRule();
	}
	
	//terminal SL_COMMENT:
	//	'//' !('\n' | '\r')* ('\r'? '\n')?;
	public TerminalRule getSL_COMMENTRule() {
		return gaTerminals.getSL_COMMENTRule();
	}
	
	//terminal WS:
	//	' ' | '\t' | '\r' | '\n'+;
	public TerminalRule getWSRule() {
		return gaTerminals.getWSRule();
	}
}
