/**
 * generated by Xtext 2.12.0
 */
package hu.bme.mit.inf.dslreasoner.vampireLanguage.impl;

import hu.bme.mit.inf.dslreasoner.vampireLanguage.*;

import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;

import org.eclipse.emf.ecore.impl.EFactoryImpl;

import org.eclipse.emf.ecore.plugin.EcorePlugin;

/**
 * <!-- begin-user-doc -->
 * An implementation of the model <b>Factory</b>.
 * <!-- end-user-doc -->
 * @generated
 */
public class VampireLanguageFactoryImpl extends EFactoryImpl implements VampireLanguageFactory
{
  /**
   * Creates the default factory implementation.
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  public static VampireLanguageFactory init()
  {
    try
    {
      VampireLanguageFactory theVampireLanguageFactory = (VampireLanguageFactory)EPackage.Registry.INSTANCE.getEFactory(VampireLanguagePackage.eNS_URI);
      if (theVampireLanguageFactory != null)
      {
        return theVampireLanguageFactory;
      }
    }
    catch (Exception exception)
    {
      EcorePlugin.INSTANCE.log(exception);
    }
    return new VampireLanguageFactoryImpl();
  }

  /**
   * Creates an instance of the factory.
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  public VampireLanguageFactoryImpl()
  {
    super();
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  @Override
  public EObject create(EClass eClass)
  {
    switch (eClass.getClassifierID())
    {
      case VampireLanguagePackage.VAMPIRE_MODEL: return createVampireModel();
      case VampireLanguagePackage.VLS_COMMENT: return createVLSComment();
      case VampireLanguagePackage.VLS_FUNCTION_DECLARATION: return createVLSFunctionDeclaration();
      case VampireLanguagePackage.VLS_FOF_FORMULA: return createVLSFofFormula();
      case VampireLanguagePackage.VLS_ANNOTATION: return createVLSAnnotation();
      case VampireLanguagePackage.VLS_TERM: return createVLSTerm();
      case VampireLanguagePackage.VLS_FOF_TERM: return createVLSFofTerm();
      case VampireLanguagePackage.VLS_VARIABLE: return createVLSVariable();
      case VampireLanguagePackage.VLS_FUNCTION_FOF: return createVLSFunctionFof();
      case VampireLanguagePackage.VLS_DEFINED_TERM: return createVLSDefinedTerm();
      case VampireLanguagePackage.VLS_EQUIVALENT: return createVLSEquivalent();
      case VampireLanguagePackage.VLS_IMPLIES: return createVLSImplies();
      case VampireLanguagePackage.VLS_REV_IMPLIES: return createVLSRevImplies();
      case VampireLanguagePackage.VLS_XNOR: return createVLSXnor();
      case VampireLanguagePackage.VLS_NOR: return createVLSNor();
      case VampireLanguagePackage.VLS_NAND: return createVLSNand();
      case VampireLanguagePackage.VLS_AND: return createVLSAnd();
      case VampireLanguagePackage.VLS_OR: return createVLSOr();
      case VampireLanguagePackage.VLS_UNIVERSAL_QUANTIFIER: return createVLSUniversalQuantifier();
      case VampireLanguagePackage.VLS_EXISTENTIAL_QUANTIFIER: return createVLSExistentialQuantifier();
      case VampireLanguagePackage.VLS_UNARY_NEGATION: return createVLSUnaryNegation();
      case VampireLanguagePackage.VLS_INEQUALITY: return createVLSInequality();
      case VampireLanguagePackage.VLS_EQUALITY: return createVLSEquality();
      case VampireLanguagePackage.VLS_ASSIGNMENT: return createVLSAssignment();
      case VampireLanguagePackage.VLS_FUNCTION: return createVLSFunction();
      default:
        throw new IllegalArgumentException("The class '" + eClass.getName() + "' is not a valid classifier");
    }
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  public VampireModel createVampireModel()
  {
    VampireModelImpl vampireModel = new VampireModelImpl();
    return vampireModel;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  public VLSComment createVLSComment()
  {
    VLSCommentImpl vlsComment = new VLSCommentImpl();
    return vlsComment;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  public VLSFunctionDeclaration createVLSFunctionDeclaration()
  {
    VLSFunctionDeclarationImpl vlsFunctionDeclaration = new VLSFunctionDeclarationImpl();
    return vlsFunctionDeclaration;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  public VLSFofFormula createVLSFofFormula()
  {
    VLSFofFormulaImpl vlsFofFormula = new VLSFofFormulaImpl();
    return vlsFofFormula;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  public VLSAnnotation createVLSAnnotation()
  {
    VLSAnnotationImpl vlsAnnotation = new VLSAnnotationImpl();
    return vlsAnnotation;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  public VLSTerm createVLSTerm()
  {
    VLSTermImpl vlsTerm = new VLSTermImpl();
    return vlsTerm;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  public VLSFofTerm createVLSFofTerm()
  {
    VLSFofTermImpl vlsFofTerm = new VLSFofTermImpl();
    return vlsFofTerm;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  public VLSVariable createVLSVariable()
  {
    VLSVariableImpl vlsVariable = new VLSVariableImpl();
    return vlsVariable;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  public VLSFunctionFof createVLSFunctionFof()
  {
    VLSFunctionFofImpl vlsFunctionFof = new VLSFunctionFofImpl();
    return vlsFunctionFof;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  public VLSDefinedTerm createVLSDefinedTerm()
  {
    VLSDefinedTermImpl vlsDefinedTerm = new VLSDefinedTermImpl();
    return vlsDefinedTerm;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  public VLSEquivalent createVLSEquivalent()
  {
    VLSEquivalentImpl vlsEquivalent = new VLSEquivalentImpl();
    return vlsEquivalent;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  public VLSImplies createVLSImplies()
  {
    VLSImpliesImpl vlsImplies = new VLSImpliesImpl();
    return vlsImplies;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  public VLSRevImplies createVLSRevImplies()
  {
    VLSRevImpliesImpl vlsRevImplies = new VLSRevImpliesImpl();
    return vlsRevImplies;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  public VLSXnor createVLSXnor()
  {
    VLSXnorImpl vlsXnor = new VLSXnorImpl();
    return vlsXnor;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  public VLSNor createVLSNor()
  {
    VLSNorImpl vlsNor = new VLSNorImpl();
    return vlsNor;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  public VLSNand createVLSNand()
  {
    VLSNandImpl vlsNand = new VLSNandImpl();
    return vlsNand;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  public VLSAnd createVLSAnd()
  {
    VLSAndImpl vlsAnd = new VLSAndImpl();
    return vlsAnd;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  public VLSOr createVLSOr()
  {
    VLSOrImpl vlsOr = new VLSOrImpl();
    return vlsOr;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  public VLSUniversalQuantifier createVLSUniversalQuantifier()
  {
    VLSUniversalQuantifierImpl vlsUniversalQuantifier = new VLSUniversalQuantifierImpl();
    return vlsUniversalQuantifier;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  public VLSExistentialQuantifier createVLSExistentialQuantifier()
  {
    VLSExistentialQuantifierImpl vlsExistentialQuantifier = new VLSExistentialQuantifierImpl();
    return vlsExistentialQuantifier;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  public VLSUnaryNegation createVLSUnaryNegation()
  {
    VLSUnaryNegationImpl vlsUnaryNegation = new VLSUnaryNegationImpl();
    return vlsUnaryNegation;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  public VLSInequality createVLSInequality()
  {
    VLSInequalityImpl vlsInequality = new VLSInequalityImpl();
    return vlsInequality;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  public VLSEquality createVLSEquality()
  {
    VLSEqualityImpl vlsEquality = new VLSEqualityImpl();
    return vlsEquality;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  public VLSAssignment createVLSAssignment()
  {
    VLSAssignmentImpl vlsAssignment = new VLSAssignmentImpl();
    return vlsAssignment;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  public VLSFunction createVLSFunction()
  {
    VLSFunctionImpl vlsFunction = new VLSFunctionImpl();
    return vlsFunction;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  public VampireLanguagePackage getVampireLanguagePackage()
  {
    return (VampireLanguagePackage)getEPackage();
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @deprecated
   * @generated
   */
  @Deprecated
  public static VampireLanguagePackage getPackage()
  {
    return VampireLanguagePackage.eINSTANCE;
  }

} //VampireLanguageFactoryImpl
