/*
 * generated by Xtext 2.12.0
 */
package hu.bme.mit.inf.dslreasoner.services;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import java.util.List;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Alternatives;
import org.eclipse.xtext.Assignment;
import org.eclipse.xtext.Grammar;
import org.eclipse.xtext.GrammarUtil;
import org.eclipse.xtext.Group;
import org.eclipse.xtext.Keyword;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.RuleCall;
import org.eclipse.xtext.TerminalRule;
import org.eclipse.xtext.common.services.TerminalsGrammarAccess;
import org.eclipse.xtext.service.AbstractElementFinder.AbstractGrammarElementFinder;
import org.eclipse.xtext.service.GrammarProvider;

@Singleton
public class VampireLanguageGrammarAccess extends AbstractGrammarElementFinder {
	
	public class VampireModelElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "hu.bme.mit.inf.dslreasoner.VampireLanguage.VampireModel");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Assignment cCommentsAssignment_0 = (Assignment)cAlternatives.eContents().get(0);
		private final RuleCall cCommentsVLSCommentParserRuleCall_0_0 = (RuleCall)cCommentsAssignment_0.eContents().get(0);
		private final Assignment cFormulasAssignment_1 = (Assignment)cAlternatives.eContents().get(1);
		private final RuleCall cFormulasVLSFofFormulaParserRuleCall_1_0 = (RuleCall)cFormulasAssignment_1.eContents().get(0);
		
		////@@@@@@@@@@@
		////2 things TODO:
		////1. fix anotations (ln77)
		////2. can only use declared variables in formula (ln 158)
		////@@@@@@@@@@@
		//VampireModel:
		//	(comments+=VLSComment | formulas+=VLSFofFormula)*;
		@Override public ParserRule getRule() { return rule; }
		
		//(comments+=VLSComment | formulas+=VLSFofFormula)*
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//comments+=VLSComment
		public Assignment getCommentsAssignment_0() { return cCommentsAssignment_0; }
		
		//VLSComment
		public RuleCall getCommentsVLSCommentParserRuleCall_0_0() { return cCommentsVLSCommentParserRuleCall_0_0; }
		
		//formulas+=VLSFofFormula
		public Assignment getFormulasAssignment_1() { return cFormulasAssignment_1; }
		
		//VLSFofFormula
		public RuleCall getFormulasVLSFofFormulaParserRuleCall_1_0() { return cFormulasVLSFofFormulaParserRuleCall_1_0; }
	}
	public class VLSCommentElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "hu.bme.mit.inf.dslreasoner.VampireLanguage.VLSComment");
		private final Assignment cCommentAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cCommentSINGLE_COMMENTTerminalRuleCall_0 = (RuleCall)cCommentAssignment.eContents().get(0);
		
		////terminal ID:  ( !('('|')'|'\r'|'\n') )+ ;
		////////////////////////////////////
		//// VLS types
		////////////////////////////////////
		//// <COMMENT>
		//VLSComment:
		//	comment=SINGLE_COMMENT
		//	//need to add a new line at the end of the file for the case where the last line is a comment
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//comment=SINGLE_COMMENT
		public Assignment getCommentAssignment() { return cCommentAssignment; }
		
		//SINGLE_COMMENT
		public RuleCall getCommentSINGLE_COMMENTTerminalRuleCall_0() { return cCommentSINGLE_COMMENTTerminalRuleCall_0; }
	}
	public class VLSFunctionDeclarationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "hu.bme.mit.inf.dslreasoner.VampireLanguage.VLSFunctionDeclaration");
		private final Assignment cNameAssignment = (Assignment)rule.eContents().get(1);
		private final Alternatives cNameAlternatives_0 = (Alternatives)cNameAssignment.eContents().get(0);
		private final RuleCall cNameLOWER_WORD_IDTerminalRuleCall_0_0 = (RuleCall)cNameAlternatives_0.eContents().get(0);
		private final RuleCall cNameSINGLE_QUOTETerminalRuleCall_0_1 = (RuleCall)cNameAlternatives_0.eContents().get(1);
		private final RuleCall cNameDOLLAR_IDTerminalRuleCall_0_2 = (RuleCall)cNameAlternatives_0.eContents().get(2);
		private final RuleCall cNameDOUBLE_DOLLAR_IDTerminalRuleCall_0_3 = (RuleCall)cNameAlternatives_0.eContents().get(3);
		
		//VLSFunctionDeclaration:
		//	name=(LOWER_WORD_ID | SINGLE_QUOTE | DOLLAR_ID | DOUBLE_DOLLAR_ID);
		@Override public ParserRule getRule() { return rule; }
		
		//name=(LOWER_WORD_ID | SINGLE_QUOTE | DOLLAR_ID | DOUBLE_DOLLAR_ID)
		public Assignment getNameAssignment() { return cNameAssignment; }
		
		//(LOWER_WORD_ID | SINGLE_QUOTE | DOLLAR_ID | DOUBLE_DOLLAR_ID)
		public Alternatives getNameAlternatives_0() { return cNameAlternatives_0; }
		
		//LOWER_WORD_ID
		public RuleCall getNameLOWER_WORD_IDTerminalRuleCall_0_0() { return cNameLOWER_WORD_IDTerminalRuleCall_0_0; }
		
		//SINGLE_QUOTE
		public RuleCall getNameSINGLE_QUOTETerminalRuleCall_0_1() { return cNameSINGLE_QUOTETerminalRuleCall_0_1; }
		
		//DOLLAR_ID
		public RuleCall getNameDOLLAR_IDTerminalRuleCall_0_2() { return cNameDOLLAR_IDTerminalRuleCall_0_2; }
		
		//DOUBLE_DOLLAR_ID
		public RuleCall getNameDOUBLE_DOLLAR_IDTerminalRuleCall_0_3() { return cNameDOUBLE_DOLLAR_IDTerminalRuleCall_0_3; }
	}
	public class VLSFofFormulaElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "hu.bme.mit.inf.dslreasoner.VampireLanguage.VLSFofFormula");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cFofKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cNameAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final Alternatives cNameAlternatives_2_0 = (Alternatives)cNameAssignment_2.eContents().get(0);
		private final RuleCall cNameLOWER_WORD_IDTerminalRuleCall_2_0_0 = (RuleCall)cNameAlternatives_2_0.eContents().get(0);
		private final RuleCall cNameSIGNED_LITERALTerminalRuleCall_2_0_1 = (RuleCall)cNameAlternatives_2_0.eContents().get(1);
		private final RuleCall cNameSINGLE_QUOTETerminalRuleCall_2_0_2 = (RuleCall)cNameAlternatives_2_0.eContents().get(2);
		private final Keyword cCommaKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cFofRoleAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cFofRoleVLSRoleParserRuleCall_4_0 = (RuleCall)cFofRoleAssignment_4.eContents().get(0);
		private final Keyword cCommaKeyword_5 = (Keyword)cGroup.eContents().get(5);
		private final Assignment cFofFormulaAssignment_6 = (Assignment)cGroup.eContents().get(6);
		private final RuleCall cFofFormulaVLSTermParserRuleCall_6_0 = (RuleCall)cFofFormulaAssignment_6.eContents().get(0);
		private final Group cGroup_7 = (Group)cGroup.eContents().get(7);
		private final Keyword cCommaKeyword_7_0 = (Keyword)cGroup_7.eContents().get(0);
		private final Assignment cAnnotationsAssignment_7_1 = (Assignment)cGroup_7.eContents().get(1);
		private final RuleCall cAnnotationsVLSAnnotationParserRuleCall_7_1_0 = (RuleCall)cAnnotationsAssignment_7_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_8 = (Keyword)cGroup.eContents().get(8);
		private final Keyword cFullStopKeyword_9 = (Keyword)cGroup.eContents().get(9);
		
		////Formulas
		//VLSFofFormula:
		//	'fof' '(' name=(LOWER_WORD_ID | SIGNED_LITERAL | SINGLE_QUOTE) ',' fofRole=VLSRole ',' fofFormula=VLSTerm (','
		//	annotations=VLSAnnotation)? ')' '.';
		@Override public ParserRule getRule() { return rule; }
		
		//'fof' '(' name=(LOWER_WORD_ID | SIGNED_LITERAL | SINGLE_QUOTE) ',' fofRole=VLSRole ',' fofFormula=VLSTerm (','
		//annotations=VLSAnnotation)? ')' '.'
		public Group getGroup() { return cGroup; }
		
		//'fof'
		public Keyword getFofKeyword_0() { return cFofKeyword_0; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }
		
		//name=(LOWER_WORD_ID | SIGNED_LITERAL | SINGLE_QUOTE)
		public Assignment getNameAssignment_2() { return cNameAssignment_2; }
		
		//(LOWER_WORD_ID | SIGNED_LITERAL | SINGLE_QUOTE)
		public Alternatives getNameAlternatives_2_0() { return cNameAlternatives_2_0; }
		
		//LOWER_WORD_ID
		public RuleCall getNameLOWER_WORD_IDTerminalRuleCall_2_0_0() { return cNameLOWER_WORD_IDTerminalRuleCall_2_0_0; }
		
		//SIGNED_LITERAL
		public RuleCall getNameSIGNED_LITERALTerminalRuleCall_2_0_1() { return cNameSIGNED_LITERALTerminalRuleCall_2_0_1; }
		
		//SINGLE_QUOTE
		public RuleCall getNameSINGLE_QUOTETerminalRuleCall_2_0_2() { return cNameSINGLE_QUOTETerminalRuleCall_2_0_2; }
		
		//','
		public Keyword getCommaKeyword_3() { return cCommaKeyword_3; }
		
		//fofRole=VLSRole
		public Assignment getFofRoleAssignment_4() { return cFofRoleAssignment_4; }
		
		//VLSRole
		public RuleCall getFofRoleVLSRoleParserRuleCall_4_0() { return cFofRoleVLSRoleParserRuleCall_4_0; }
		
		//','
		public Keyword getCommaKeyword_5() { return cCommaKeyword_5; }
		
		//fofFormula=VLSTerm
		public Assignment getFofFormulaAssignment_6() { return cFofFormulaAssignment_6; }
		
		//VLSTerm
		public RuleCall getFofFormulaVLSTermParserRuleCall_6_0() { return cFofFormulaVLSTermParserRuleCall_6_0; }
		
		//(',' annotations=VLSAnnotation)?
		public Group getGroup_7() { return cGroup_7; }
		
		//','
		public Keyword getCommaKeyword_7_0() { return cCommaKeyword_7_0; }
		
		//annotations=VLSAnnotation
		public Assignment getAnnotationsAssignment_7_1() { return cAnnotationsAssignment_7_1; }
		
		//VLSAnnotation
		public RuleCall getAnnotationsVLSAnnotationParserRuleCall_7_1_0() { return cAnnotationsVLSAnnotationParserRuleCall_7_1_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_8() { return cRightParenthesisKeyword_8; }
		
		//'.'
		public Keyword getFullStopKeyword_9() { return cFullStopKeyword_9; }
	}
	public class VLSRoleElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "hu.bme.mit.inf.dslreasoner.VampireLanguage.VLSRole");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cVLSAxiomParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cVLSConjectureParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cVLSHypothesisParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cVLSDefinitionParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		private final RuleCall cVLSAssumptionParserRuleCall_4 = (RuleCall)cAlternatives.eContents().get(4);
		private final RuleCall cVLSLemmaParserRuleCall_5 = (RuleCall)cAlternatives.eContents().get(5);
		private final RuleCall cVLSTheoremParserRuleCall_6 = (RuleCall)cAlternatives.eContents().get(6);
		private final RuleCall cVLSCorollaryParserRuleCall_7 = (RuleCall)cAlternatives.eContents().get(7);
		private final RuleCall cVLSNegated_ConjectureParserRuleCall_8 = (RuleCall)cAlternatives.eContents().get(8);
		private final RuleCall cVLSPlainParserRuleCall_9 = (RuleCall)cAlternatives.eContents().get(9);
		private final RuleCall cVLSTypeParserRuleCall_10 = (RuleCall)cAlternatives.eContents().get(10);
		private final RuleCall cVLSFi_DomainParserRuleCall_11 = (RuleCall)cAlternatives.eContents().get(11);
		private final RuleCall cVLSFi_FunctorsParserRuleCall_12 = (RuleCall)cAlternatives.eContents().get(12);
		private final RuleCall cVLSFi_PredicatesParserRuleCall_13 = (RuleCall)cAlternatives.eContents().get(13);
		private final RuleCall cVLSUnknownParserRuleCall_14 = (RuleCall)cAlternatives.eContents().get(14);
		
		///*
		////NAME
		//VLSName:
		//	//(atomic_Word = Atomic_Word | integer = Integer | single_quote_word = Single_Quote_Word)
		//	name = (LOWER_WORD_ID | SIGNED_INT_ID | SINGLE_QUOTE)
		//;
		//*/ //<ROLE>
		//VLSRole:
		//	VLSAxiom | VLSConjecture | VLSHypothesis | VLSDefinition | VLSAssumption | VLSLemma | VLSTheorem | VLSCorollary |
		//	VLSNegated_Conjecture | VLSPlain | VLSType | VLSFi_Domain | VLSFi_Functors | VLSFi_Predicates | VLSUnknown;
		@Override public ParserRule getRule() { return rule; }
		
		//VLSAxiom | VLSConjecture | VLSHypothesis | VLSDefinition | VLSAssumption | VLSLemma | VLSTheorem | VLSCorollary |
		//VLSNegated_Conjecture | VLSPlain | VLSType | VLSFi_Domain | VLSFi_Functors | VLSFi_Predicates | VLSUnknown
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//VLSAxiom
		public RuleCall getVLSAxiomParserRuleCall_0() { return cVLSAxiomParserRuleCall_0; }
		
		//VLSConjecture
		public RuleCall getVLSConjectureParserRuleCall_1() { return cVLSConjectureParserRuleCall_1; }
		
		//VLSHypothesis
		public RuleCall getVLSHypothesisParserRuleCall_2() { return cVLSHypothesisParserRuleCall_2; }
		
		//VLSDefinition
		public RuleCall getVLSDefinitionParserRuleCall_3() { return cVLSDefinitionParserRuleCall_3; }
		
		//VLSAssumption
		public RuleCall getVLSAssumptionParserRuleCall_4() { return cVLSAssumptionParserRuleCall_4; }
		
		//VLSLemma
		public RuleCall getVLSLemmaParserRuleCall_5() { return cVLSLemmaParserRuleCall_5; }
		
		//VLSTheorem
		public RuleCall getVLSTheoremParserRuleCall_6() { return cVLSTheoremParserRuleCall_6; }
		
		//VLSCorollary
		public RuleCall getVLSCorollaryParserRuleCall_7() { return cVLSCorollaryParserRuleCall_7; }
		
		//VLSNegated_Conjecture
		public RuleCall getVLSNegated_ConjectureParserRuleCall_8() { return cVLSNegated_ConjectureParserRuleCall_8; }
		
		//VLSPlain
		public RuleCall getVLSPlainParserRuleCall_9() { return cVLSPlainParserRuleCall_9; }
		
		//VLSType
		public RuleCall getVLSTypeParserRuleCall_10() { return cVLSTypeParserRuleCall_10; }
		
		//VLSFi_Domain
		public RuleCall getVLSFi_DomainParserRuleCall_11() { return cVLSFi_DomainParserRuleCall_11; }
		
		//VLSFi_Functors
		public RuleCall getVLSFi_FunctorsParserRuleCall_12() { return cVLSFi_FunctorsParserRuleCall_12; }
		
		//VLSFi_Predicates
		public RuleCall getVLSFi_PredicatesParserRuleCall_13() { return cVLSFi_PredicatesParserRuleCall_13; }
		
		//VLSUnknown
		public RuleCall getVLSUnknownParserRuleCall_14() { return cVLSUnknownParserRuleCall_14; }
	}
	public class VLSAxiomElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "hu.bme.mit.inf.dslreasoner.VampireLanguage.VLSAxiom");
		private final Keyword cAxiomKeyword = (Keyword)rule.eContents().get(1);
		
		//VLSAxiom:
		//	"axiom";
		@Override public ParserRule getRule() { return rule; }
		
		//"axiom"
		public Keyword getAxiomKeyword() { return cAxiomKeyword; }
	}
	public class VLSConjectureElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "hu.bme.mit.inf.dslreasoner.VampireLanguage.VLSConjecture");
		private final Keyword cConjectureKeyword = (Keyword)rule.eContents().get(1);
		
		//VLSConjecture:
		//	"conjecture";
		@Override public ParserRule getRule() { return rule; }
		
		//"conjecture"
		public Keyword getConjectureKeyword() { return cConjectureKeyword; }
	}
	public class VLSHypothesisElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "hu.bme.mit.inf.dslreasoner.VampireLanguage.VLSHypothesis");
		private final Keyword cHypothesisKeyword = (Keyword)rule.eContents().get(1);
		
		//VLSHypothesis:
		//	"hypothesis";
		@Override public ParserRule getRule() { return rule; }
		
		//"hypothesis"
		public Keyword getHypothesisKeyword() { return cHypothesisKeyword; }
	}
	public class VLSDefinitionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "hu.bme.mit.inf.dslreasoner.VampireLanguage.VLSDefinition");
		private final Keyword cDefinitionKeyword = (Keyword)rule.eContents().get(1);
		
		//VLSDefinition:
		//	"definition";
		@Override public ParserRule getRule() { return rule; }
		
		//"definition"
		public Keyword getDefinitionKeyword() { return cDefinitionKeyword; }
	}
	public class VLSAssumptionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "hu.bme.mit.inf.dslreasoner.VampireLanguage.VLSAssumption");
		private final Keyword cAssumptionKeyword = (Keyword)rule.eContents().get(1);
		
		//VLSAssumption:
		//	"assumption";
		@Override public ParserRule getRule() { return rule; }
		
		//"assumption"
		public Keyword getAssumptionKeyword() { return cAssumptionKeyword; }
	}
	public class VLSLemmaElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "hu.bme.mit.inf.dslreasoner.VampireLanguage.VLSLemma");
		private final Keyword cLemmaKeyword = (Keyword)rule.eContents().get(1);
		
		//VLSLemma:
		//	"lemma";
		@Override public ParserRule getRule() { return rule; }
		
		//"lemma"
		public Keyword getLemmaKeyword() { return cLemmaKeyword; }
	}
	public class VLSTheoremElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "hu.bme.mit.inf.dslreasoner.VampireLanguage.VLSTheorem");
		private final Keyword cTheoremKeyword = (Keyword)rule.eContents().get(1);
		
		//VLSTheorem:
		//	"theorem";
		@Override public ParserRule getRule() { return rule; }
		
		//"theorem"
		public Keyword getTheoremKeyword() { return cTheoremKeyword; }
	}
	public class VLSCorollaryElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "hu.bme.mit.inf.dslreasoner.VampireLanguage.VLSCorollary");
		private final Keyword cCorollaryKeyword = (Keyword)rule.eContents().get(1);
		
		//VLSCorollary:
		//	"corollary";
		@Override public ParserRule getRule() { return rule; }
		
		//"corollary"
		public Keyword getCorollaryKeyword() { return cCorollaryKeyword; }
	}
	public class VLSNegated_ConjectureElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "hu.bme.mit.inf.dslreasoner.VampireLanguage.VLSNegated_Conjecture");
		private final Keyword cNegated_conjectureKeyword = (Keyword)rule.eContents().get(1);
		
		//VLSNegated_Conjecture:
		//	"negated_conjecture";
		@Override public ParserRule getRule() { return rule; }
		
		//"negated_conjecture"
		public Keyword getNegated_conjectureKeyword() { return cNegated_conjectureKeyword; }
	}
	public class VLSPlainElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "hu.bme.mit.inf.dslreasoner.VampireLanguage.VLSPlain");
		private final Keyword cPlainKeyword = (Keyword)rule.eContents().get(1);
		
		//VLSPlain:
		//	"plain";
		@Override public ParserRule getRule() { return rule; }
		
		//"plain"
		public Keyword getPlainKeyword() { return cPlainKeyword; }
	}
	public class VLSTypeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "hu.bme.mit.inf.dslreasoner.VampireLanguage.VLSType");
		private final Keyword cTypeKeyword = (Keyword)rule.eContents().get(1);
		
		//VLSType:
		//	"type";
		@Override public ParserRule getRule() { return rule; }
		
		//"type"
		public Keyword getTypeKeyword() { return cTypeKeyword; }
	}
	public class VLSFi_DomainElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "hu.bme.mit.inf.dslreasoner.VampireLanguage.VLSFi_Domain");
		private final Keyword cFi_domainKeyword = (Keyword)rule.eContents().get(1);
		
		//VLSFi_Domain:
		//	"fi_domain";
		@Override public ParserRule getRule() { return rule; }
		
		//"fi_domain"
		public Keyword getFi_domainKeyword() { return cFi_domainKeyword; }
	}
	public class VLSFi_FunctorsElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "hu.bme.mit.inf.dslreasoner.VampireLanguage.VLSFi_Functors");
		private final Keyword cFi_functorsKeyword = (Keyword)rule.eContents().get(1);
		
		//VLSFi_Functors:
		//	"fi_functors";
		@Override public ParserRule getRule() { return rule; }
		
		//"fi_functors"
		public Keyword getFi_functorsKeyword() { return cFi_functorsKeyword; }
	}
	public class VLSFi_PredicatesElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "hu.bme.mit.inf.dslreasoner.VampireLanguage.VLSFi_Predicates");
		private final Keyword cFi_predicatesKeyword = (Keyword)rule.eContents().get(1);
		
		//VLSFi_Predicates:
		//	"fi_predicates";
		@Override public ParserRule getRule() { return rule; }
		
		//"fi_predicates"
		public Keyword getFi_predicatesKeyword() { return cFi_predicatesKeyword; }
	}
	public class VLSUnknownElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "hu.bme.mit.inf.dslreasoner.VampireLanguage.VLSUnknown");
		private final Keyword cUnknownKeyword = (Keyword)rule.eContents().get(1);
		
		//VLSUnknown:
		//	"unknown";
		@Override public ParserRule getRule() { return rule; }
		
		//"unknown"
		public Keyword getUnknownKeyword() { return cUnknownKeyword; }
	}
	public class VLSAnnotationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "hu.bme.mit.inf.dslreasoner.VampireLanguage.VLSAnnotation");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLeftSquareBracketKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final Alternatives cNameAlternatives_1_0 = (Alternatives)cNameAssignment_1.eContents().get(0);
		private final RuleCall cNameLOWER_WORD_IDTerminalRuleCall_1_0_0 = (RuleCall)cNameAlternatives_1_0.eContents().get(0);
		private final RuleCall cNameSINGLE_QUOTETerminalRuleCall_1_0_1 = (RuleCall)cNameAlternatives_1_0.eContents().get(1);
		private final RuleCall cNameVLSRoleParserRuleCall_1_0_2 = (RuleCall)cNameAlternatives_1_0.eContents().get(2);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cLeftParenthesisKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Assignment cFollowupAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cFollowupVLSAnnotationTermsParserRuleCall_2_1_0 = (RuleCall)cFollowupAssignment_2_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_2_2 = (Keyword)cGroup_2.eContents().get(2);
		private final Keyword cRightSquareBracketKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//// <ANNOTATION>
		//// Not at all based on the website. based on what we think the output will be like 
		//VLSAnnotation:
		//	'['? name=(LOWER_WORD_ID | SINGLE_QUOTE | VLSRole)? ('(' followup=VLSAnnotationTerms ')')? ']'?;
		@Override public ParserRule getRule() { return rule; }
		
		//'['? name=(LOWER_WORD_ID | SINGLE_QUOTE | VLSRole)? ('(' followup=VLSAnnotationTerms ')')? ']'?
		public Group getGroup() { return cGroup; }
		
		//'['?
		public Keyword getLeftSquareBracketKeyword_0() { return cLeftSquareBracketKeyword_0; }
		
		//name=(LOWER_WORD_ID | SINGLE_QUOTE | VLSRole)?
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }
		
		//(LOWER_WORD_ID | SINGLE_QUOTE | VLSRole)
		public Alternatives getNameAlternatives_1_0() { return cNameAlternatives_1_0; }
		
		//LOWER_WORD_ID
		public RuleCall getNameLOWER_WORD_IDTerminalRuleCall_1_0_0() { return cNameLOWER_WORD_IDTerminalRuleCall_1_0_0; }
		
		//SINGLE_QUOTE
		public RuleCall getNameSINGLE_QUOTETerminalRuleCall_1_0_1() { return cNameSINGLE_QUOTETerminalRuleCall_1_0_1; }
		
		//VLSRole
		public RuleCall getNameVLSRoleParserRuleCall_1_0_2() { return cNameVLSRoleParserRuleCall_1_0_2; }
		
		//('(' followup=VLSAnnotationTerms ')')?
		public Group getGroup_2() { return cGroup_2; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_2_0() { return cLeftParenthesisKeyword_2_0; }
		
		//followup=VLSAnnotationTerms
		public Assignment getFollowupAssignment_2_1() { return cFollowupAssignment_2_1; }
		
		//VLSAnnotationTerms
		public RuleCall getFollowupVLSAnnotationTermsParserRuleCall_2_1_0() { return cFollowupVLSAnnotationTermsParserRuleCall_2_1_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_2_2() { return cRightParenthesisKeyword_2_2; }
		
		//']'?
		public Keyword getRightSquareBracketKeyword_3() { return cRightSquareBracketKeyword_3; }
	}
	public class VLSAnnotationTermsElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "hu.bme.mit.inf.dslreasoner.VampireLanguage.VLSAnnotationTerms");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cTermsAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cTermsVLSAnnotationParserRuleCall_0_0 = (RuleCall)cTermsAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cCommaKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cTermsAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cTermsVLSAnnotationParserRuleCall_1_1_0 = (RuleCall)cTermsAssignment_1_1.eContents().get(0);
		
		//VLSAnnotationTerms VLSAnnotation:
		//	terms+=VLSAnnotation (',' terms+=VLSAnnotation)*;
		@Override public ParserRule getRule() { return rule; }
		
		//terms+=VLSAnnotation (',' terms+=VLSAnnotation)*
		public Group getGroup() { return cGroup; }
		
		//terms+=VLSAnnotation
		public Assignment getTermsAssignment_0() { return cTermsAssignment_0; }
		
		//VLSAnnotation
		public RuleCall getTermsVLSAnnotationParserRuleCall_0_0() { return cTermsVLSAnnotationParserRuleCall_0_0; }
		
		//(',' terms+=VLSAnnotation)*
		public Group getGroup_1() { return cGroup_1; }
		
		//','
		public Keyword getCommaKeyword_1_0() { return cCommaKeyword_1_0; }
		
		//terms+=VLSAnnotation
		public Assignment getTermsAssignment_1_1() { return cTermsAssignment_1_1; }
		
		//VLSAnnotation
		public RuleCall getTermsVLSAnnotationParserRuleCall_1_1_0() { return cTermsVLSAnnotationParserRuleCall_1_1_0; }
	}
	public class VLSTermElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "hu.bme.mit.inf.dslreasoner.VampireLanguage.VLSTerm");
		private final RuleCall cVLSBinaryParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		////////////////////////////////////
		//// VLS Terms
		////////////////////////////////////
		//VLSTerm:
		//	VLSBinary;
		@Override public ParserRule getRule() { return rule; }
		
		////( VLSLogic | VLSSequent)
		//VLSBinary
		public RuleCall getVLSBinaryParserRuleCall() { return cVLSBinaryParserRuleCall; }
	}
	public class VLSBinaryElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "hu.bme.mit.inf.dslreasoner.VampireLanguage.VLSBinary");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cVLSUnitaryFormulaParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Alternatives cAlternatives_1 = (Alternatives)cGroup.eContents().get(1);
		private final Group cGroup_1_0 = (Group)cAlternatives_1.eContents().get(0);
		private final Alternatives cAlternatives_1_0_0 = (Alternatives)cGroup_1_0.eContents().get(0);
		private final Group cGroup_1_0_0_0 = (Group)cAlternatives_1_0_0.eContents().get(0);
		private final Action cVLSEquivalentLeftAction_1_0_0_0_0 = (Action)cGroup_1_0_0_0.eContents().get(0);
		private final Keyword cLessThanSignEqualsSignGreaterThanSignKeyword_1_0_0_0_1 = (Keyword)cGroup_1_0_0_0.eContents().get(1);
		private final Group cGroup_1_0_0_1 = (Group)cAlternatives_1_0_0.eContents().get(1);
		private final Action cVLSImpliesLeftAction_1_0_0_1_0 = (Action)cGroup_1_0_0_1.eContents().get(0);
		private final Keyword cEqualsSignGreaterThanSignKeyword_1_0_0_1_1 = (Keyword)cGroup_1_0_0_1.eContents().get(1);
		private final Group cGroup_1_0_0_2 = (Group)cAlternatives_1_0_0.eContents().get(2);
		private final Action cVLSRevImpliesLeftAction_1_0_0_2_0 = (Action)cGroup_1_0_0_2.eContents().get(0);
		private final Keyword cLessThanSignEqualsSignKeyword_1_0_0_2_1 = (Keyword)cGroup_1_0_0_2.eContents().get(1);
		private final Group cGroup_1_0_0_3 = (Group)cAlternatives_1_0_0.eContents().get(3);
		private final Action cVLSXnorLeftAction_1_0_0_3_0 = (Action)cGroup_1_0_0_3.eContents().get(0);
		private final Keyword cLessThanSignTildeGreaterThanSignKeyword_1_0_0_3_1 = (Keyword)cGroup_1_0_0_3.eContents().get(1);
		private final Group cGroup_1_0_0_4 = (Group)cAlternatives_1_0_0.eContents().get(4);
		private final Action cVLSNorLeftAction_1_0_0_4_0 = (Action)cGroup_1_0_0_4.eContents().get(0);
		private final Keyword cTildeVerticalLineKeyword_1_0_0_4_1 = (Keyword)cGroup_1_0_0_4.eContents().get(1);
		private final Group cGroup_1_0_0_5 = (Group)cAlternatives_1_0_0.eContents().get(5);
		private final Action cVLSNandLeftAction_1_0_0_5_0 = (Action)cGroup_1_0_0_5.eContents().get(0);
		private final Keyword cTildeAmpersandKeyword_1_0_0_5_1 = (Keyword)cGroup_1_0_0_5.eContents().get(1);
		private final Assignment cRightAssignment_1_0_1 = (Assignment)cGroup_1_0.eContents().get(1);
		private final RuleCall cRightVLSUnitaryFormulaParserRuleCall_1_0_1_0 = (RuleCall)cRightAssignment_1_0_1.eContents().get(0);
		private final Group cGroup_1_1 = (Group)cAlternatives_1.eContents().get(1);
		private final Action cVLSAndLeftAction_1_1_0 = (Action)cGroup_1_1.eContents().get(0);
		private final Keyword cAmpersandKeyword_1_1_1 = (Keyword)cGroup_1_1.eContents().get(1);
		private final Assignment cRightAssignment_1_1_2 = (Assignment)cGroup_1_1.eContents().get(2);
		private final RuleCall cRightVLSUnitaryFormulaParserRuleCall_1_1_2_0 = (RuleCall)cRightAssignment_1_1_2.eContents().get(0);
		private final Group cGroup_1_2 = (Group)cAlternatives_1.eContents().get(2);
		private final Action cVLSOrLeftAction_1_2_0 = (Action)cGroup_1_2.eContents().get(0);
		private final Keyword cVerticalLineKeyword_1_2_1 = (Keyword)cGroup_1_2.eContents().get(1);
		private final Assignment cRightAssignment_1_2_2 = (Assignment)cGroup_1_2.eContents().get(2);
		private final RuleCall cRightVLSUnitaryFormulaParserRuleCall_1_2_2_0 = (RuleCall)cRightAssignment_1_2_2.eContents().get(0);
		
		////*
		////VLSBinaryFormula
		//VLSBinary VLSTerm:
		//	VLSUnitaryFormula (({VLSEquivalent.left=current} "<=>" | {VLSImplies.left=current} "=>" |
		//	{VLSRevImplies.left=current} "<=" | {VLSXnor.left=current} "<~>" | {VLSNor.left=current} "~|" |
		//	{VLSNand.left=current} "~&") right=VLSUnitaryFormula | ({VLSAnd.left=current} '&' right=VLSUnitaryFormula)+
		//	| ({VLSOr.left=current} '|' right=VLSUnitaryFormula)+)?;
		@Override public ParserRule getRule() { return rule; }
		
		//VLSUnitaryFormula (({VLSEquivalent.left=current} "<=>" | {VLSImplies.left=current} "=>" | {VLSRevImplies.left=current}
		//"<=" | {VLSXnor.left=current} "<~>" | {VLSNor.left=current} "~|" | {VLSNand.left=current} "~&")
		//right=VLSUnitaryFormula | ({VLSAnd.left=current} '&' right=VLSUnitaryFormula)+ | ({VLSOr.left=current} '|'
		//right=VLSUnitaryFormula)+)?
		public Group getGroup() { return cGroup; }
		
		//VLSUnitaryFormula
		public RuleCall getVLSUnitaryFormulaParserRuleCall_0() { return cVLSUnitaryFormulaParserRuleCall_0; }
		
		//(({VLSEquivalent.left=current} "<=>" | {VLSImplies.left=current} "=>" | {VLSRevImplies.left=current} "<=" |
		//{VLSXnor.left=current} "<~>" | {VLSNor.left=current} "~|" | {VLSNand.left=current} "~&") right=VLSUnitaryFormula |
		//({VLSAnd.left=current} '&' right=VLSUnitaryFormula)+ | ({VLSOr.left=current} '|' right=VLSUnitaryFormula)+)?
		public Alternatives getAlternatives_1() { return cAlternatives_1; }
		
		//({VLSEquivalent.left=current} "<=>" | {VLSImplies.left=current} "=>" | {VLSRevImplies.left=current} "<=" |
		//{VLSXnor.left=current} "<~>" | {VLSNor.left=current} "~|" | {VLSNand.left=current} "~&") right=VLSUnitaryFormula
		public Group getGroup_1_0() { return cGroup_1_0; }
		
		//{VLSEquivalent.left=current} "<=>" | {VLSImplies.left=current} "=>" | {VLSRevImplies.left=current} "<=" |
		//{VLSXnor.left=current} "<~>" | {VLSNor.left=current} "~|" | {VLSNand.left=current} "~&"
		public Alternatives getAlternatives_1_0_0() { return cAlternatives_1_0_0; }
		
		//{VLSEquivalent.left=current} "<=>"
		public Group getGroup_1_0_0_0() { return cGroup_1_0_0_0; }
		
		//{VLSEquivalent.left=current}
		public Action getVLSEquivalentLeftAction_1_0_0_0_0() { return cVLSEquivalentLeftAction_1_0_0_0_0; }
		
		//"<=>"
		public Keyword getLessThanSignEqualsSignGreaterThanSignKeyword_1_0_0_0_1() { return cLessThanSignEqualsSignGreaterThanSignKeyword_1_0_0_0_1; }
		
		//{VLSImplies.left=current} "=>"
		public Group getGroup_1_0_0_1() { return cGroup_1_0_0_1; }
		
		//{VLSImplies.left=current}
		public Action getVLSImpliesLeftAction_1_0_0_1_0() { return cVLSImpliesLeftAction_1_0_0_1_0; }
		
		//"=>"
		public Keyword getEqualsSignGreaterThanSignKeyword_1_0_0_1_1() { return cEqualsSignGreaterThanSignKeyword_1_0_0_1_1; }
		
		//{VLSRevImplies.left=current} "<="
		public Group getGroup_1_0_0_2() { return cGroup_1_0_0_2; }
		
		//{VLSRevImplies.left=current}
		public Action getVLSRevImpliesLeftAction_1_0_0_2_0() { return cVLSRevImpliesLeftAction_1_0_0_2_0; }
		
		//"<="
		public Keyword getLessThanSignEqualsSignKeyword_1_0_0_2_1() { return cLessThanSignEqualsSignKeyword_1_0_0_2_1; }
		
		//{VLSXnor.left=current} "<~>"
		public Group getGroup_1_0_0_3() { return cGroup_1_0_0_3; }
		
		//{VLSXnor.left=current}
		public Action getVLSXnorLeftAction_1_0_0_3_0() { return cVLSXnorLeftAction_1_0_0_3_0; }
		
		//"<~>"
		public Keyword getLessThanSignTildeGreaterThanSignKeyword_1_0_0_3_1() { return cLessThanSignTildeGreaterThanSignKeyword_1_0_0_3_1; }
		
		//{VLSNor.left=current} "~|"
		public Group getGroup_1_0_0_4() { return cGroup_1_0_0_4; }
		
		//{VLSNor.left=current}
		public Action getVLSNorLeftAction_1_0_0_4_0() { return cVLSNorLeftAction_1_0_0_4_0; }
		
		//"~|"
		public Keyword getTildeVerticalLineKeyword_1_0_0_4_1() { return cTildeVerticalLineKeyword_1_0_0_4_1; }
		
		//{VLSNand.left=current} "~&"
		public Group getGroup_1_0_0_5() { return cGroup_1_0_0_5; }
		
		//{VLSNand.left=current}
		public Action getVLSNandLeftAction_1_0_0_5_0() { return cVLSNandLeftAction_1_0_0_5_0; }
		
		//"~&"
		public Keyword getTildeAmpersandKeyword_1_0_0_5_1() { return cTildeAmpersandKeyword_1_0_0_5_1; }
		
		//right=VLSUnitaryFormula
		public Assignment getRightAssignment_1_0_1() { return cRightAssignment_1_0_1; }
		
		//VLSUnitaryFormula
		public RuleCall getRightVLSUnitaryFormulaParserRuleCall_1_0_1_0() { return cRightVLSUnitaryFormulaParserRuleCall_1_0_1_0; }
		
		//({VLSAnd.left=current} '&' right=VLSUnitaryFormula)+
		public Group getGroup_1_1() { return cGroup_1_1; }
		
		//{VLSAnd.left=current}
		public Action getVLSAndLeftAction_1_1_0() { return cVLSAndLeftAction_1_1_0; }
		
		//'&'
		public Keyword getAmpersandKeyword_1_1_1() { return cAmpersandKeyword_1_1_1; }
		
		//right=VLSUnitaryFormula
		public Assignment getRightAssignment_1_1_2() { return cRightAssignment_1_1_2; }
		
		//VLSUnitaryFormula
		public RuleCall getRightVLSUnitaryFormulaParserRuleCall_1_1_2_0() { return cRightVLSUnitaryFormulaParserRuleCall_1_1_2_0; }
		
		//({VLSOr.left=current} '|' right=VLSUnitaryFormula)+
		public Group getGroup_1_2() { return cGroup_1_2; }
		
		//{VLSOr.left=current}
		public Action getVLSOrLeftAction_1_2_0() { return cVLSOrLeftAction_1_2_0; }
		
		//'|'
		public Keyword getVerticalLineKeyword_1_2_1() { return cVerticalLineKeyword_1_2_1; }
		
		//right=VLSUnitaryFormula
		public Assignment getRightAssignment_1_2_2() { return cRightAssignment_1_2_2; }
		
		//VLSUnitaryFormula
		public RuleCall getRightVLSUnitaryFormulaParserRuleCall_1_2_2_0() { return cRightVLSUnitaryFormulaParserRuleCall_1_2_2_0; }
	}
	public class VLSUnitaryFormulaElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "hu.bme.mit.inf.dslreasoner.VampireLanguage.VLSUnitaryFormula");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cVLSUniversalQuantifierParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cVLSExistentialQuantifierParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cVLSUnaryNegationParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cVLSUnaryInfixParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		private final Group cGroup_4 = (Group)cAlternatives.eContents().get(4);
		private final Keyword cLeftParenthesisKeyword_4_0 = (Keyword)cGroup_4.eContents().get(0);
		private final RuleCall cVLSTermParserRuleCall_4_1 = (RuleCall)cGroup_4.eContents().get(1);
		private final Keyword cRightParenthesisKeyword_4_2 = (Keyword)cGroup_4.eContents().get(2);
		
		////VLSUnitaryFormula
		//VLSUnitaryFormula VLSTerm:
		//	VLSUniversalQuantifier | VLSExistentialQuantifier | VLSUnaryNegation | VLSUnaryInfix | '(' VLSTerm ')';
		@Override public ParserRule getRule() { return rule; }
		
		//VLSUniversalQuantifier | VLSExistentialQuantifier | VLSUnaryNegation | VLSUnaryInfix | '(' VLSTerm ')'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//VLSUniversalQuantifier
		public RuleCall getVLSUniversalQuantifierParserRuleCall_0() { return cVLSUniversalQuantifierParserRuleCall_0; }
		
		//VLSExistentialQuantifier
		public RuleCall getVLSExistentialQuantifierParserRuleCall_1() { return cVLSExistentialQuantifierParserRuleCall_1; }
		
		//VLSUnaryNegation
		public RuleCall getVLSUnaryNegationParserRuleCall_2() { return cVLSUnaryNegationParserRuleCall_2; }
		
		//VLSUnaryInfix
		public RuleCall getVLSUnaryInfixParserRuleCall_3() { return cVLSUnaryInfixParserRuleCall_3; }
		
		//'(' VLSTerm ')'
		public Group getGroup_4() { return cGroup_4; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_4_0() { return cLeftParenthesisKeyword_4_0; }
		
		//VLSTerm
		public RuleCall getVLSTermParserRuleCall_4_1() { return cVLSTermParserRuleCall_4_1; }
		
		//')'
		public Keyword getRightParenthesisKeyword_4_2() { return cRightParenthesisKeyword_4_2; }
	}
	public class VLSUniversalQuantifierElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "hu.bme.mit.inf.dslreasoner.VampireLanguage.VLSUniversalQuantifier");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cVLSUniversalQuantifierAction_0 = (Action)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cExclamationMarkKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Keyword cLeftSquareBracketKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cVariablesAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cVariablesVLSVariableParserRuleCall_1_2_0 = (RuleCall)cVariablesAssignment_1_2.eContents().get(0);
		private final Group cGroup_1_3 = (Group)cGroup_1.eContents().get(3);
		private final Keyword cCommaKeyword_1_3_0 = (Keyword)cGroup_1_3.eContents().get(0);
		private final Assignment cVariablesAssignment_1_3_1 = (Assignment)cGroup_1_3.eContents().get(1);
		private final RuleCall cVariablesVLSVariableParserRuleCall_1_3_1_0 = (RuleCall)cVariablesAssignment_1_3_1.eContents().get(0);
		private final Keyword cRightSquareBracketKeyword_1_4 = (Keyword)cGroup_1.eContents().get(4);
		private final Keyword cColonKeyword_1_5 = (Keyword)cGroup_1.eContents().get(5);
		private final Assignment cOperandAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cOperandVLSUnitaryFormulaParserRuleCall_2_0 = (RuleCall)cOperandAssignment_2.eContents().get(0);
		
		//VLSUniversalQuantifier VLSTerm:
		//	{VLSUniversalQuantifier} ("!" '[' variables+=VLSVariable (',' variables+=VLSVariable)* ']' ':')
		//	operand=VLSUnitaryFormula;
		@Override public ParserRule getRule() { return rule; }
		
		//{VLSUniversalQuantifier} ("!" '[' variables+=VLSVariable (',' variables+=VLSVariable)* ']' ':')
		//operand=VLSUnitaryFormula
		public Group getGroup() { return cGroup; }
		
		//{VLSUniversalQuantifier}
		public Action getVLSUniversalQuantifierAction_0() { return cVLSUniversalQuantifierAction_0; }
		
		//"!" '[' variables+=VLSVariable (',' variables+=VLSVariable)* ']' ':'
		public Group getGroup_1() { return cGroup_1; }
		
		//"!"
		public Keyword getExclamationMarkKeyword_1_0() { return cExclamationMarkKeyword_1_0; }
		
		//'['
		public Keyword getLeftSquareBracketKeyword_1_1() { return cLeftSquareBracketKeyword_1_1; }
		
		//variables+=VLSVariable
		public Assignment getVariablesAssignment_1_2() { return cVariablesAssignment_1_2; }
		
		//VLSVariable
		public RuleCall getVariablesVLSVariableParserRuleCall_1_2_0() { return cVariablesVLSVariableParserRuleCall_1_2_0; }
		
		//(',' variables+=VLSVariable)*
		public Group getGroup_1_3() { return cGroup_1_3; }
		
		//','
		public Keyword getCommaKeyword_1_3_0() { return cCommaKeyword_1_3_0; }
		
		//variables+=VLSVariable
		public Assignment getVariablesAssignment_1_3_1() { return cVariablesAssignment_1_3_1; }
		
		//VLSVariable
		public RuleCall getVariablesVLSVariableParserRuleCall_1_3_1_0() { return cVariablesVLSVariableParserRuleCall_1_3_1_0; }
		
		//']'
		public Keyword getRightSquareBracketKeyword_1_4() { return cRightSquareBracketKeyword_1_4; }
		
		//':'
		public Keyword getColonKeyword_1_5() { return cColonKeyword_1_5; }
		
		//operand=VLSUnitaryFormula
		public Assignment getOperandAssignment_2() { return cOperandAssignment_2; }
		
		//VLSUnitaryFormula
		public RuleCall getOperandVLSUnitaryFormulaParserRuleCall_2_0() { return cOperandVLSUnitaryFormulaParserRuleCall_2_0; }
	}
	public class VLSExistentialQuantifierElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "hu.bme.mit.inf.dslreasoner.VampireLanguage.VLSExistentialQuantifier");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cVLSExistentialQuantifierAction_0 = (Action)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cQuestionMarkKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Keyword cLeftSquareBracketKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cVariablesAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cVariablesVLSVariableParserRuleCall_1_2_0 = (RuleCall)cVariablesAssignment_1_2.eContents().get(0);
		private final Group cGroup_1_3 = (Group)cGroup_1.eContents().get(3);
		private final Keyword cCommaKeyword_1_3_0 = (Keyword)cGroup_1_3.eContents().get(0);
		private final Assignment cVariablesAssignment_1_3_1 = (Assignment)cGroup_1_3.eContents().get(1);
		private final RuleCall cVariablesVLSVariableParserRuleCall_1_3_1_0 = (RuleCall)cVariablesAssignment_1_3_1.eContents().get(0);
		private final Keyword cRightSquareBracketKeyword_1_4 = (Keyword)cGroup_1.eContents().get(4);
		private final Keyword cColonKeyword_1_5 = (Keyword)cGroup_1.eContents().get(5);
		private final Assignment cOperandAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cOperandVLSUnitaryFormulaParserRuleCall_2_0 = (RuleCall)cOperandAssignment_2.eContents().get(0);
		
		//VLSExistentialQuantifier VLSTerm:
		//	{VLSExistentialQuantifier} ("?" '[' variables+=VLSVariable (',' variables+=VLSVariable)* ']' ':')
		//	operand=VLSUnitaryFormula;
		@Override public ParserRule getRule() { return rule; }
		
		//{VLSExistentialQuantifier} ("?" '[' variables+=VLSVariable (',' variables+=VLSVariable)* ']' ':')
		//operand=VLSUnitaryFormula
		public Group getGroup() { return cGroup; }
		
		//{VLSExistentialQuantifier}
		public Action getVLSExistentialQuantifierAction_0() { return cVLSExistentialQuantifierAction_0; }
		
		//"?" '[' variables+=VLSVariable (',' variables+=VLSVariable)* ']' ':'
		public Group getGroup_1() { return cGroup_1; }
		
		//"?"
		public Keyword getQuestionMarkKeyword_1_0() { return cQuestionMarkKeyword_1_0; }
		
		//'['
		public Keyword getLeftSquareBracketKeyword_1_1() { return cLeftSquareBracketKeyword_1_1; }
		
		//variables+=VLSVariable
		public Assignment getVariablesAssignment_1_2() { return cVariablesAssignment_1_2; }
		
		//VLSVariable
		public RuleCall getVariablesVLSVariableParserRuleCall_1_2_0() { return cVariablesVLSVariableParserRuleCall_1_2_0; }
		
		//(',' variables+=VLSVariable)*
		public Group getGroup_1_3() { return cGroup_1_3; }
		
		//','
		public Keyword getCommaKeyword_1_3_0() { return cCommaKeyword_1_3_0; }
		
		//variables+=VLSVariable
		public Assignment getVariablesAssignment_1_3_1() { return cVariablesAssignment_1_3_1; }
		
		//VLSVariable
		public RuleCall getVariablesVLSVariableParserRuleCall_1_3_1_0() { return cVariablesVLSVariableParserRuleCall_1_3_1_0; }
		
		//']'
		public Keyword getRightSquareBracketKeyword_1_4() { return cRightSquareBracketKeyword_1_4; }
		
		//':'
		public Keyword getColonKeyword_1_5() { return cColonKeyword_1_5; }
		
		//operand=VLSUnitaryFormula
		public Assignment getOperandAssignment_2() { return cOperandAssignment_2; }
		
		//VLSUnitaryFormula
		public RuleCall getOperandVLSUnitaryFormulaParserRuleCall_2_0() { return cOperandVLSUnitaryFormulaParserRuleCall_2_0; }
	}
	public class VLSUnaryNegationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "hu.bme.mit.inf.dslreasoner.VampireLanguage.VLSUnaryNegation");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cVLSUnaryNegationAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cTildeKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cOperandAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cOperandVLSUnitaryFormulaParserRuleCall_2_0 = (RuleCall)cOperandAssignment_2.eContents().get(0);
		
		//VLSUnaryNegation VLSTerm:
		//	{VLSUnaryNegation} '~' operand=VLSUnitaryFormula;
		@Override public ParserRule getRule() { return rule; }
		
		//{VLSUnaryNegation} '~' operand=VLSUnitaryFormula
		public Group getGroup() { return cGroup; }
		
		//{VLSUnaryNegation}
		public Action getVLSUnaryNegationAction_0() { return cVLSUnaryNegationAction_0; }
		
		//'~'
		public Keyword getTildeKeyword_1() { return cTildeKeyword_1; }
		
		//operand=VLSUnitaryFormula
		public Assignment getOperandAssignment_2() { return cOperandAssignment_2; }
		
		//VLSUnitaryFormula
		public RuleCall getOperandVLSUnitaryFormulaParserRuleCall_2_0() { return cOperandVLSUnitaryFormulaParserRuleCall_2_0; }
	}
	public class VLSUnaryInfixElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "hu.bme.mit.inf.dslreasoner.VampireLanguage.VLSUnaryInfix");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cVLSFunctionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Alternatives cAlternatives_1_0 = (Alternatives)cGroup_1.eContents().get(0);
		private final Group cGroup_1_0_0 = (Group)cAlternatives_1_0.eContents().get(0);
		private final Action cVLSInequalityLeftAction_1_0_0_0 = (Action)cGroup_1_0_0.eContents().get(0);
		private final Keyword cExclamationMarkEqualsSignKeyword_1_0_0_1 = (Keyword)cGroup_1_0_0.eContents().get(1);
		private final Group cGroup_1_0_1 = (Group)cAlternatives_1_0.eContents().get(1);
		private final Action cVLSEqualityLeftAction_1_0_1_0 = (Action)cGroup_1_0_1.eContents().get(0);
		private final Keyword cEqualsSignKeyword_1_0_1_1 = (Keyword)cGroup_1_0_1.eContents().get(1);
		private final Group cGroup_1_0_2 = (Group)cAlternatives_1_0.eContents().get(2);
		private final Action cVLSAssignmentLeftAction_1_0_2_0 = (Action)cGroup_1_0_2.eContents().get(0);
		private final Keyword cColonEqualsSignKeyword_1_0_2_1 = (Keyword)cGroup_1_0_2.eContents().get(1);
		private final Assignment cRightAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cRightVLSFunctionParserRuleCall_1_1_0 = (RuleCall)cRightAssignment_1_1.eContents().get(0);
		
		//VLSUnaryInfix VLSTerm:
		//	VLSFunction (({VLSInequality.left=current} "!=" | {VLSEquality.left=current} "=" | {VLSAssignment.left=current} ":=")
		//	right=VLSFunction)?;
		@Override public ParserRule getRule() { return rule; }
		
		//VLSFunction (({VLSInequality.left=current} "!=" | {VLSEquality.left=current} "=" | {VLSAssignment.left=current} ":=")
		//right=VLSFunction)?
		public Group getGroup() { return cGroup; }
		
		//VLSFunction
		public RuleCall getVLSFunctionParserRuleCall_0() { return cVLSFunctionParserRuleCall_0; }
		
		//(({VLSInequality.left=current} "!=" | {VLSEquality.left=current} "=" | {VLSAssignment.left=current} ":=")
		//right=VLSFunction)?
		public Group getGroup_1() { return cGroup_1; }
		
		//{VLSInequality.left=current} "!=" | {VLSEquality.left=current} "=" | {VLSAssignment.left=current} ":="
		public Alternatives getAlternatives_1_0() { return cAlternatives_1_0; }
		
		//{VLSInequality.left=current} "!="
		public Group getGroup_1_0_0() { return cGroup_1_0_0; }
		
		//{VLSInequality.left=current}
		public Action getVLSInequalityLeftAction_1_0_0_0() { return cVLSInequalityLeftAction_1_0_0_0; }
		
		//"!="
		public Keyword getExclamationMarkEqualsSignKeyword_1_0_0_1() { return cExclamationMarkEqualsSignKeyword_1_0_0_1; }
		
		//{VLSEquality.left=current} "="
		public Group getGroup_1_0_1() { return cGroup_1_0_1; }
		
		//{VLSEquality.left=current}
		public Action getVLSEqualityLeftAction_1_0_1_0() { return cVLSEqualityLeftAction_1_0_1_0; }
		
		//"="
		public Keyword getEqualsSignKeyword_1_0_1_1() { return cEqualsSignKeyword_1_0_1_1; }
		
		//{VLSAssignment.left=current} ":="
		public Group getGroup_1_0_2() { return cGroup_1_0_2; }
		
		//{VLSAssignment.left=current}
		public Action getVLSAssignmentLeftAction_1_0_2_0() { return cVLSAssignmentLeftAction_1_0_2_0; }
		
		//":="
		public Keyword getColonEqualsSignKeyword_1_0_2_1() { return cColonEqualsSignKeyword_1_0_2_1; }
		
		//right=VLSFunction
		public Assignment getRightAssignment_1_1() { return cRightAssignment_1_1; }
		
		//VLSFunction
		public RuleCall getRightVLSFunctionParserRuleCall_1_1_0() { return cRightVLSFunctionParserRuleCall_1_1_0; }
	}
	public class VLSFunctionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "hu.bme.mit.inf.dslreasoner.VampireLanguage.VLSFunction");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cVLSFunctionAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cConstantAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cConstantVLSFunctionDeclarationParserRuleCall_1_0 = (RuleCall)cConstantAssignment_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cLeftParenthesisKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Assignment cTermsAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cTermsVLSFofTermParserRuleCall_2_1_0 = (RuleCall)cTermsAssignment_2_1.eContents().get(0);
		private final Group cGroup_2_2 = (Group)cGroup_2.eContents().get(2);
		private final Keyword cCommaKeyword_2_2_0 = (Keyword)cGroup_2_2.eContents().get(0);
		private final Assignment cTermsAssignment_2_2_1 = (Assignment)cGroup_2_2.eContents().get(1);
		private final RuleCall cTermsVLSFofTermParserRuleCall_2_2_1_0 = (RuleCall)cTermsAssignment_2_2_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_2_3 = (Keyword)cGroup_2.eContents().get(3);
		
		///*
		//enum VLSDefinedFunctor:
		//		UMINUS='$uminus' | SUM='$sum' | DIFFERENCE='$difference' | PRODUCT='$product' | QUOTIENT='$quotient' | 
		//		QUOTIENT_E='$quotient_e' | QUOTIENT_T='$quotient_t' | QUOTIENT_F='$quotient_f' | REMAINDER_E='$remainder_e' |
		//		 REMAINDER_T='$remainder_t' | REMAINDER_F='$remainder_f' | FLOOR='$floor' | CEILING='$ceiling' |
		//		 TRUNCATE='$truncate' | ROUND='$round' | TO_INT='$to_int' | TO_RAT='$to_rat' | TO_REAL='$to_real'
		//    ;
		//*/ VLSFunction VLSTerm:
		//	{VLSFunction} constant=VLSFunctionDeclaration ('(' terms+=VLSFofTerm (',' terms+=VLSFofTerm)* ')')?;
		@Override public ParserRule getRule() { return rule; }
		
		//{VLSFunction} constant=VLSFunctionDeclaration ('(' terms+=VLSFofTerm (',' terms+=VLSFofTerm)* ')')?
		public Group getGroup() { return cGroup; }
		
		//{VLSFunction}
		public Action getVLSFunctionAction_0() { return cVLSFunctionAction_0; }
		
		//constant=VLSFunctionDeclaration
		public Assignment getConstantAssignment_1() { return cConstantAssignment_1; }
		
		//VLSFunctionDeclaration
		public RuleCall getConstantVLSFunctionDeclarationParserRuleCall_1_0() { return cConstantVLSFunctionDeclarationParserRuleCall_1_0; }
		
		//('(' terms+=VLSFofTerm (',' terms+=VLSFofTerm)* ')')?
		public Group getGroup_2() { return cGroup_2; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_2_0() { return cLeftParenthesisKeyword_2_0; }
		
		//terms+=VLSFofTerm
		public Assignment getTermsAssignment_2_1() { return cTermsAssignment_2_1; }
		
		//VLSFofTerm
		public RuleCall getTermsVLSFofTermParserRuleCall_2_1_0() { return cTermsVLSFofTermParserRuleCall_2_1_0; }
		
		//(',' terms+=VLSFofTerm)*
		public Group getGroup_2_2() { return cGroup_2_2; }
		
		//','
		public Keyword getCommaKeyword_2_2_0() { return cCommaKeyword_2_2_0; }
		
		//terms+=VLSFofTerm
		public Assignment getTermsAssignment_2_2_1() { return cTermsAssignment_2_2_1; }
		
		//VLSFofTerm
		public RuleCall getTermsVLSFofTermParserRuleCall_2_2_1_0() { return cTermsVLSFofTermParserRuleCall_2_2_1_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_2_3() { return cRightParenthesisKeyword_2_3; }
	}
	public class VLSFofTermElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "hu.bme.mit.inf.dslreasoner.VampireLanguage.VLSFofTerm");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cVLSVariableParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cVLSFunctionFofParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cVLSDefinedTermParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		
		//VLSFofTerm:
		//	VLSVariable | VLSFunctionFof | VLSDefinedTerm;
		@Override public ParserRule getRule() { return rule; }
		
		////(VLSVariable | VLSFunction | VLSTffConditional | VLSTffLet | VLSTffTuple)
		//VLSVariable | VLSFunctionFof | VLSDefinedTerm
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//VLSVariable
		public RuleCall getVLSVariableParserRuleCall_0() { return cVLSVariableParserRuleCall_0; }
		
		//VLSFunctionFof
		public RuleCall getVLSFunctionFofParserRuleCall_1() { return cVLSFunctionFofParserRuleCall_1; }
		
		//VLSDefinedTerm
		public RuleCall getVLSDefinedTermParserRuleCall_2() { return cVLSDefinedTermParserRuleCall_2; }
	}
	public class VLSVariableElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "hu.bme.mit.inf.dslreasoner.VampireLanguage.VLSVariable");
		private final Assignment cNameAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cNameUPPER_WORD_IDTerminalRuleCall_0 = (RuleCall)cNameAssignment.eContents().get(0);
		
		//VLSVariable:
		//	name=UPPER_WORD_ID;
		@Override public ParserRule getRule() { return rule; }
		
		//name=UPPER_WORD_ID
		public Assignment getNameAssignment() { return cNameAssignment; }
		
		//UPPER_WORD_ID
		public RuleCall getNameUPPER_WORD_IDTerminalRuleCall_0() { return cNameUPPER_WORD_IDTerminalRuleCall_0; }
	}
	public class VLSFunctionFofElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "hu.bme.mit.inf.dslreasoner.VampireLanguage.VLSFunctionFof");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cFunctorAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cFunctorVLSFunctionDeclarationParserRuleCall_0_0 = (RuleCall)cFunctorAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cTermsAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cTermsVLSFofTermParserRuleCall_1_1_0 = (RuleCall)cTermsAssignment_1_1.eContents().get(0);
		private final Group cGroup_1_2 = (Group)cGroup_1.eContents().get(2);
		private final Keyword cCommaKeyword_1_2_0 = (Keyword)cGroup_1_2.eContents().get(0);
		private final Assignment cTermsAssignment_1_2_1 = (Assignment)cGroup_1_2.eContents().get(1);
		private final RuleCall cTermsVLSFofTermParserRuleCall_1_2_1_0 = (RuleCall)cTermsAssignment_1_2_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_1_3 = (Keyword)cGroup_1.eContents().get(3);
		
		//VLSFunctionFof:
		//	functor=VLSFunctionDeclaration ('(' terms+=VLSFofTerm (',' terms+=VLSFofTerm)* ')')?;
		@Override public ParserRule getRule() { return rule; }
		
		////? on next line causes warning
		////TODO might need replace DOLLAR_ID with enum rule 
		//functor=VLSFunctionDeclaration ('(' terms+=VLSFofTerm (',' terms+=VLSFofTerm)* ')')?
		public Group getGroup() { return cGroup; }
		
		////? on next line causes warning
		////TODO might need replace DOLLAR_ID with enum rule 
		//functor=VLSFunctionDeclaration
		public Assignment getFunctorAssignment_0() { return cFunctorAssignment_0; }
		
		//VLSFunctionDeclaration
		public RuleCall getFunctorVLSFunctionDeclarationParserRuleCall_0_0() { return cFunctorVLSFunctionDeclarationParserRuleCall_0_0; }
		
		//('(' terms+=VLSFofTerm (',' terms+=VLSFofTerm)* ')')?
		public Group getGroup_1() { return cGroup_1; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_1_0() { return cLeftParenthesisKeyword_1_0; }
		
		//terms+=VLSFofTerm
		public Assignment getTermsAssignment_1_1() { return cTermsAssignment_1_1; }
		
		//VLSFofTerm
		public RuleCall getTermsVLSFofTermParserRuleCall_1_1_0() { return cTermsVLSFofTermParserRuleCall_1_1_0; }
		
		//(',' terms+=VLSFofTerm)*
		public Group getGroup_1_2() { return cGroup_1_2; }
		
		//','
		public Keyword getCommaKeyword_1_2_0() { return cCommaKeyword_1_2_0; }
		
		//terms+=VLSFofTerm
		public Assignment getTermsAssignment_1_2_1() { return cTermsAssignment_1_2_1; }
		
		//VLSFofTerm
		public RuleCall getTermsVLSFofTermParserRuleCall_1_2_1_0() { return cTermsVLSFofTermParserRuleCall_1_2_1_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_1_3() { return cRightParenthesisKeyword_1_3; }
	}
	public class VLSDefinedTermElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "hu.bme.mit.inf.dslreasoner.VampireLanguage.VLSDefinedTerm");
		private final Assignment cNameAssignment = (Assignment)rule.eContents().get(1);
		private final Alternatives cNameAlternatives_0 = (Alternatives)cNameAssignment.eContents().get(0);
		private final RuleCall cNameDOUBLE_QUOTETerminalRuleCall_0_0 = (RuleCall)cNameAlternatives_0.eContents().get(0);
		private final RuleCall cNameSIGNED_LITERALTerminalRuleCall_0_1 = (RuleCall)cNameAlternatives_0.eContents().get(1);
		private final RuleCall cNameSIGNED_REAL_IDTerminalRuleCall_0_2 = (RuleCall)cNameAlternatives_0.eContents().get(2);
		private final RuleCall cNameSIGNED_RAT_IDTerminalRuleCall_0_3 = (RuleCall)cNameAlternatives_0.eContents().get(3);
		
		//VLSDefinedTerm:
		//	name=(DOUBLE_QUOTE | SIGNED_LITERAL | SIGNED_REAL_ID | SIGNED_RAT_ID);
		@Override public ParserRule getRule() { return rule; }
		
		//name=(DOUBLE_QUOTE | SIGNED_LITERAL | SIGNED_REAL_ID | SIGNED_RAT_ID)
		public Assignment getNameAssignment() { return cNameAssignment; }
		
		//(DOUBLE_QUOTE | SIGNED_LITERAL | SIGNED_REAL_ID | SIGNED_RAT_ID)
		public Alternatives getNameAlternatives_0() { return cNameAlternatives_0; }
		
		//DOUBLE_QUOTE
		public RuleCall getNameDOUBLE_QUOTETerminalRuleCall_0_0() { return cNameDOUBLE_QUOTETerminalRuleCall_0_0; }
		
		//SIGNED_LITERAL
		public RuleCall getNameSIGNED_LITERALTerminalRuleCall_0_1() { return cNameSIGNED_LITERALTerminalRuleCall_0_1; }
		
		//SIGNED_REAL_ID
		public RuleCall getNameSIGNED_REAL_IDTerminalRuleCall_0_2() { return cNameSIGNED_REAL_IDTerminalRuleCall_0_2; }
		
		//SIGNED_RAT_ID
		public RuleCall getNameSIGNED_RAT_IDTerminalRuleCall_0_3() { return cNameSIGNED_RAT_IDTerminalRuleCall_0_3; }
	}
	
	
	private final VampireModelElements pVampireModel;
	private final TerminalRule tALPHA_NUMERIC;
	private final TerminalRule tUPPER_WORD_ID;
	private final TerminalRule tLOWER_WORD_ID;
	private final TerminalRule tDOUBLE_QUOTE;
	private final TerminalRule tSINGLE_QUOTE;
	private final TerminalRule tSIGN;
	private final TerminalRule tDOLLAR_ID;
	private final TerminalRule tDOUBLE_DOLLAR_ID;
	private final TerminalRule tLITERAL;
	private final TerminalRule tSIGNED_LITERAL;
	private final TerminalRule tUNSIGNED_REAL_FRAC_ID;
	private final TerminalRule tUNSIGNED_REAL_EXP_ID;
	private final TerminalRule tSIGNED_REAL_ID;
	private final TerminalRule tUNSIGNED_RAT_ID;
	private final TerminalRule tSIGNED_RAT_ID;
	private final TerminalRule tANY_OTHER;
	private final TerminalRule tSINGLE_COMMENT;
	private final VLSCommentElements pVLSComment;
	private final VLSFunctionDeclarationElements pVLSFunctionDeclaration;
	private final VLSFofFormulaElements pVLSFofFormula;
	private final VLSRoleElements pVLSRole;
	private final VLSAxiomElements pVLSAxiom;
	private final VLSConjectureElements pVLSConjecture;
	private final VLSHypothesisElements pVLSHypothesis;
	private final VLSDefinitionElements pVLSDefinition;
	private final VLSAssumptionElements pVLSAssumption;
	private final VLSLemmaElements pVLSLemma;
	private final VLSTheoremElements pVLSTheorem;
	private final VLSCorollaryElements pVLSCorollary;
	private final VLSNegated_ConjectureElements pVLSNegated_Conjecture;
	private final VLSPlainElements pVLSPlain;
	private final VLSTypeElements pVLSType;
	private final VLSFi_DomainElements pVLSFi_Domain;
	private final VLSFi_FunctorsElements pVLSFi_Functors;
	private final VLSFi_PredicatesElements pVLSFi_Predicates;
	private final VLSUnknownElements pVLSUnknown;
	private final VLSAnnotationElements pVLSAnnotation;
	private final VLSAnnotationTermsElements pVLSAnnotationTerms;
	private final VLSTermElements pVLSTerm;
	private final VLSBinaryElements pVLSBinary;
	private final VLSUnitaryFormulaElements pVLSUnitaryFormula;
	private final VLSUniversalQuantifierElements pVLSUniversalQuantifier;
	private final VLSExistentialQuantifierElements pVLSExistentialQuantifier;
	private final VLSUnaryNegationElements pVLSUnaryNegation;
	private final VLSUnaryInfixElements pVLSUnaryInfix;
	private final VLSFunctionElements pVLSFunction;
	private final VLSFofTermElements pVLSFofTerm;
	private final VLSVariableElements pVLSVariable;
	private final VLSFunctionFofElements pVLSFunctionFof;
	private final VLSDefinedTermElements pVLSDefinedTerm;
	
	private final Grammar grammar;
	
	private final TerminalsGrammarAccess gaTerminals;

	@Inject
	public VampireLanguageGrammarAccess(GrammarProvider grammarProvider,
			TerminalsGrammarAccess gaTerminals) {
		this.grammar = internalFindGrammar(grammarProvider);
		this.gaTerminals = gaTerminals;
		this.pVampireModel = new VampireModelElements();
		this.tALPHA_NUMERIC = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "hu.bme.mit.inf.dslreasoner.VampireLanguage.ALPHA_NUMERIC");
		this.tUPPER_WORD_ID = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "hu.bme.mit.inf.dslreasoner.VampireLanguage.UPPER_WORD_ID");
		this.tLOWER_WORD_ID = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "hu.bme.mit.inf.dslreasoner.VampireLanguage.LOWER_WORD_ID");
		this.tDOUBLE_QUOTE = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "hu.bme.mit.inf.dslreasoner.VampireLanguage.DOUBLE_QUOTE");
		this.tSINGLE_QUOTE = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "hu.bme.mit.inf.dslreasoner.VampireLanguage.SINGLE_QUOTE");
		this.tSIGN = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "hu.bme.mit.inf.dslreasoner.VampireLanguage.SIGN");
		this.tDOLLAR_ID = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "hu.bme.mit.inf.dslreasoner.VampireLanguage.DOLLAR_ID");
		this.tDOUBLE_DOLLAR_ID = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "hu.bme.mit.inf.dslreasoner.VampireLanguage.DOUBLE_DOLLAR_ID");
		this.tLITERAL = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "hu.bme.mit.inf.dslreasoner.VampireLanguage.LITERAL");
		this.tSIGNED_LITERAL = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "hu.bme.mit.inf.dslreasoner.VampireLanguage.SIGNED_LITERAL");
		this.tUNSIGNED_REAL_FRAC_ID = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "hu.bme.mit.inf.dslreasoner.VampireLanguage.UNSIGNED_REAL_FRAC_ID");
		this.tUNSIGNED_REAL_EXP_ID = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "hu.bme.mit.inf.dslreasoner.VampireLanguage.UNSIGNED_REAL_EXP_ID");
		this.tSIGNED_REAL_ID = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "hu.bme.mit.inf.dslreasoner.VampireLanguage.SIGNED_REAL_ID");
		this.tUNSIGNED_RAT_ID = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "hu.bme.mit.inf.dslreasoner.VampireLanguage.UNSIGNED_RAT_ID");
		this.tSIGNED_RAT_ID = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "hu.bme.mit.inf.dslreasoner.VampireLanguage.SIGNED_RAT_ID");
		this.tANY_OTHER = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "hu.bme.mit.inf.dslreasoner.VampireLanguage.ANY_OTHER");
		this.tSINGLE_COMMENT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "hu.bme.mit.inf.dslreasoner.VampireLanguage.SINGLE_COMMENT");
		this.pVLSComment = new VLSCommentElements();
		this.pVLSFunctionDeclaration = new VLSFunctionDeclarationElements();
		this.pVLSFofFormula = new VLSFofFormulaElements();
		this.pVLSRole = new VLSRoleElements();
		this.pVLSAxiom = new VLSAxiomElements();
		this.pVLSConjecture = new VLSConjectureElements();
		this.pVLSHypothesis = new VLSHypothesisElements();
		this.pVLSDefinition = new VLSDefinitionElements();
		this.pVLSAssumption = new VLSAssumptionElements();
		this.pVLSLemma = new VLSLemmaElements();
		this.pVLSTheorem = new VLSTheoremElements();
		this.pVLSCorollary = new VLSCorollaryElements();
		this.pVLSNegated_Conjecture = new VLSNegated_ConjectureElements();
		this.pVLSPlain = new VLSPlainElements();
		this.pVLSType = new VLSTypeElements();
		this.pVLSFi_Domain = new VLSFi_DomainElements();
		this.pVLSFi_Functors = new VLSFi_FunctorsElements();
		this.pVLSFi_Predicates = new VLSFi_PredicatesElements();
		this.pVLSUnknown = new VLSUnknownElements();
		this.pVLSAnnotation = new VLSAnnotationElements();
		this.pVLSAnnotationTerms = new VLSAnnotationTermsElements();
		this.pVLSTerm = new VLSTermElements();
		this.pVLSBinary = new VLSBinaryElements();
		this.pVLSUnitaryFormula = new VLSUnitaryFormulaElements();
		this.pVLSUniversalQuantifier = new VLSUniversalQuantifierElements();
		this.pVLSExistentialQuantifier = new VLSExistentialQuantifierElements();
		this.pVLSUnaryNegation = new VLSUnaryNegationElements();
		this.pVLSUnaryInfix = new VLSUnaryInfixElements();
		this.pVLSFunction = new VLSFunctionElements();
		this.pVLSFofTerm = new VLSFofTermElements();
		this.pVLSVariable = new VLSVariableElements();
		this.pVLSFunctionFof = new VLSFunctionFofElements();
		this.pVLSDefinedTerm = new VLSDefinedTermElements();
	}
	
	protected Grammar internalFindGrammar(GrammarProvider grammarProvider) {
		Grammar grammar = grammarProvider.getGrammar(this);
		while (grammar != null) {
			if ("hu.bme.mit.inf.dslreasoner.VampireLanguage".equals(grammar.getName())) {
				return grammar;
			}
			List<Grammar> grammars = grammar.getUsedGrammars();
			if (!grammars.isEmpty()) {
				grammar = grammars.iterator().next();
			} else {
				return null;
			}
		}
		return grammar;
	}
	
	@Override
	public Grammar getGrammar() {
		return grammar;
	}
	
	
	public TerminalsGrammarAccess getTerminalsGrammarAccess() {
		return gaTerminals;
	}

	
	////@@@@@@@@@@@
	////2 things TODO:
	////1. fix anotations (ln77)
	////2. can only use declared variables in formula (ln 158)
	////@@@@@@@@@@@
	//VampireModel:
	//	(comments+=VLSComment | formulas+=VLSFofFormula)*;
	public VampireModelElements getVampireModelAccess() {
		return pVampireModel;
	}
	
	public ParserRule getVampireModelRule() {
		return getVampireModelAccess().getRule();
	}
	
	//terminal ALPHA_NUMERIC:
	//	'a'..'z' | 'A'..'Z' | '0'..'9' | '_';
	public TerminalRule getALPHA_NUMERICRule() {
		return tALPHA_NUMERIC;
	}
	
	//terminal UPPER_WORD_ID:
	//	'A'..'Z' ALPHA_NUMERIC*;
	public TerminalRule getUPPER_WORD_IDRule() {
		return tUPPER_WORD_ID;
	}
	
	//terminal LOWER_WORD_ID:
	//	'a'..'z' ALPHA_NUMERIC*;
	public TerminalRule getLOWER_WORD_IDRule() {
		return tLOWER_WORD_ID;
	}
	
	//terminal DOUBLE_QUOTE:
	//	'"' ('\\' ('"' | '\\') | !('\\' | '"'))* '"';
	public TerminalRule getDOUBLE_QUOTERule() {
		return tDOUBLE_QUOTE;
	}
	
	//terminal SINGLE_QUOTE:
	//	"'" ('\\' ("'" | '\\') | !('\\' | "'"))+ "'";
	public TerminalRule getSINGLE_QUOTERule() {
		return tSINGLE_QUOTE;
	}
	
	//terminal SIGN:
	//	'+' | '-';
	public TerminalRule getSIGNRule() {
		return tSIGN;
	}
	
	//terminal DOLLAR_ID:
	//	'$' LOWER_WORD_ID;
	public TerminalRule getDOLLAR_IDRule() {
		return tDOLLAR_ID;
	}
	
	//terminal DOUBLE_DOLLAR_ID:
	//	'$$' LOWER_WORD_ID;
	public TerminalRule getDOUBLE_DOLLAR_IDRule() {
		return tDOUBLE_DOLLAR_ID;
	}
	
	//terminal LITERAL:
	//	'0' | '1'..'9' INT?;
	public TerminalRule getLITERALRule() {
		return tLITERAL;
	}
	
	//terminal SIGNED_LITERAL:
	//	SIGN* LITERAL;
	public TerminalRule getSIGNED_LITERALRule() {
		return tSIGNED_LITERAL;
	}
	
	//terminal UNSIGNED_REAL_FRAC_ID:
	//	LITERAL '.' INT;
	public TerminalRule getUNSIGNED_REAL_FRAC_IDRule() {
		return tUNSIGNED_REAL_FRAC_ID;
	}
	
	//terminal UNSIGNED_REAL_EXP_ID:
	//	(LITERAL | UNSIGNED_REAL_FRAC_ID) 'Ee' SIGN* INT;
	public TerminalRule getUNSIGNED_REAL_EXP_IDRule() {
		return tUNSIGNED_REAL_EXP_ID;
	}
	
	//terminal SIGNED_REAL_ID:
	//	SIGN* (UNSIGNED_REAL_FRAC_ID | UNSIGNED_REAL_EXP_ID);
	public TerminalRule getSIGNED_REAL_IDRule() {
		return tSIGNED_REAL_ID;
	}
	
	//terminal UNSIGNED_RAT_ID:
	//	LITERAL '/' '1'..'9' INT?;
	public TerminalRule getUNSIGNED_RAT_IDRule() {
		return tUNSIGNED_RAT_ID;
	}
	
	//terminal SIGNED_RAT_ID:
	//	SIGN* UNSIGNED_RAT_ID;
	public TerminalRule getSIGNED_RAT_IDRule() {
		return tSIGNED_RAT_ID;
	}
	
	//terminal ANY_OTHER:
	//	'%' !('\n' | '\r')* '\r';
	public TerminalRule getANY_OTHERRule() {
		return tANY_OTHER;
	}
	
	//terminal SINGLE_COMMENT:
	//	ANY_OTHER;
	public TerminalRule getSINGLE_COMMENTRule() {
		return tSINGLE_COMMENT;
	}
	
	////terminal ID:  ( !('('|')'|'\r'|'\n') )+ ;
	////////////////////////////////////
	//// VLS types
	////////////////////////////////////
	//// <COMMENT>
	//VLSComment:
	//	comment=SINGLE_COMMENT
	//	//need to add a new line at the end of the file for the case where the last line is a comment
	//;
	public VLSCommentElements getVLSCommentAccess() {
		return pVLSComment;
	}
	
	public ParserRule getVLSCommentRule() {
		return getVLSCommentAccess().getRule();
	}
	
	//VLSFunctionDeclaration:
	//	name=(LOWER_WORD_ID | SINGLE_QUOTE | DOLLAR_ID | DOUBLE_DOLLAR_ID);
	public VLSFunctionDeclarationElements getVLSFunctionDeclarationAccess() {
		return pVLSFunctionDeclaration;
	}
	
	public ParserRule getVLSFunctionDeclarationRule() {
		return getVLSFunctionDeclarationAccess().getRule();
	}
	
	////Formulas
	//VLSFofFormula:
	//	'fof' '(' name=(LOWER_WORD_ID | SIGNED_LITERAL | SINGLE_QUOTE) ',' fofRole=VLSRole ',' fofFormula=VLSTerm (','
	//	annotations=VLSAnnotation)? ')' '.';
	public VLSFofFormulaElements getVLSFofFormulaAccess() {
		return pVLSFofFormula;
	}
	
	public ParserRule getVLSFofFormulaRule() {
		return getVLSFofFormulaAccess().getRule();
	}
	
	///*
	////NAME
	//VLSName:
	//	//(atomic_Word = Atomic_Word | integer = Integer | single_quote_word = Single_Quote_Word)
	//	name = (LOWER_WORD_ID | SIGNED_INT_ID | SINGLE_QUOTE)
	//;
	//*/ //<ROLE>
	//VLSRole:
	//	VLSAxiom | VLSConjecture | VLSHypothesis | VLSDefinition | VLSAssumption | VLSLemma | VLSTheorem | VLSCorollary |
	//	VLSNegated_Conjecture | VLSPlain | VLSType | VLSFi_Domain | VLSFi_Functors | VLSFi_Predicates | VLSUnknown;
	public VLSRoleElements getVLSRoleAccess() {
		return pVLSRole;
	}
	
	public ParserRule getVLSRoleRule() {
		return getVLSRoleAccess().getRule();
	}
	
	//VLSAxiom:
	//	"axiom";
	public VLSAxiomElements getVLSAxiomAccess() {
		return pVLSAxiom;
	}
	
	public ParserRule getVLSAxiomRule() {
		return getVLSAxiomAccess().getRule();
	}
	
	//VLSConjecture:
	//	"conjecture";
	public VLSConjectureElements getVLSConjectureAccess() {
		return pVLSConjecture;
	}
	
	public ParserRule getVLSConjectureRule() {
		return getVLSConjectureAccess().getRule();
	}
	
	//VLSHypothesis:
	//	"hypothesis";
	public VLSHypothesisElements getVLSHypothesisAccess() {
		return pVLSHypothesis;
	}
	
	public ParserRule getVLSHypothesisRule() {
		return getVLSHypothesisAccess().getRule();
	}
	
	//VLSDefinition:
	//	"definition";
	public VLSDefinitionElements getVLSDefinitionAccess() {
		return pVLSDefinition;
	}
	
	public ParserRule getVLSDefinitionRule() {
		return getVLSDefinitionAccess().getRule();
	}
	
	//VLSAssumption:
	//	"assumption";
	public VLSAssumptionElements getVLSAssumptionAccess() {
		return pVLSAssumption;
	}
	
	public ParserRule getVLSAssumptionRule() {
		return getVLSAssumptionAccess().getRule();
	}
	
	//VLSLemma:
	//	"lemma";
	public VLSLemmaElements getVLSLemmaAccess() {
		return pVLSLemma;
	}
	
	public ParserRule getVLSLemmaRule() {
		return getVLSLemmaAccess().getRule();
	}
	
	//VLSTheorem:
	//	"theorem";
	public VLSTheoremElements getVLSTheoremAccess() {
		return pVLSTheorem;
	}
	
	public ParserRule getVLSTheoremRule() {
		return getVLSTheoremAccess().getRule();
	}
	
	//VLSCorollary:
	//	"corollary";
	public VLSCorollaryElements getVLSCorollaryAccess() {
		return pVLSCorollary;
	}
	
	public ParserRule getVLSCorollaryRule() {
		return getVLSCorollaryAccess().getRule();
	}
	
	//VLSNegated_Conjecture:
	//	"negated_conjecture";
	public VLSNegated_ConjectureElements getVLSNegated_ConjectureAccess() {
		return pVLSNegated_Conjecture;
	}
	
	public ParserRule getVLSNegated_ConjectureRule() {
		return getVLSNegated_ConjectureAccess().getRule();
	}
	
	//VLSPlain:
	//	"plain";
	public VLSPlainElements getVLSPlainAccess() {
		return pVLSPlain;
	}
	
	public ParserRule getVLSPlainRule() {
		return getVLSPlainAccess().getRule();
	}
	
	//VLSType:
	//	"type";
	public VLSTypeElements getVLSTypeAccess() {
		return pVLSType;
	}
	
	public ParserRule getVLSTypeRule() {
		return getVLSTypeAccess().getRule();
	}
	
	//VLSFi_Domain:
	//	"fi_domain";
	public VLSFi_DomainElements getVLSFi_DomainAccess() {
		return pVLSFi_Domain;
	}
	
	public ParserRule getVLSFi_DomainRule() {
		return getVLSFi_DomainAccess().getRule();
	}
	
	//VLSFi_Functors:
	//	"fi_functors";
	public VLSFi_FunctorsElements getVLSFi_FunctorsAccess() {
		return pVLSFi_Functors;
	}
	
	public ParserRule getVLSFi_FunctorsRule() {
		return getVLSFi_FunctorsAccess().getRule();
	}
	
	//VLSFi_Predicates:
	//	"fi_predicates";
	public VLSFi_PredicatesElements getVLSFi_PredicatesAccess() {
		return pVLSFi_Predicates;
	}
	
	public ParserRule getVLSFi_PredicatesRule() {
		return getVLSFi_PredicatesAccess().getRule();
	}
	
	//VLSUnknown:
	//	"unknown";
	public VLSUnknownElements getVLSUnknownAccess() {
		return pVLSUnknown;
	}
	
	public ParserRule getVLSUnknownRule() {
		return getVLSUnknownAccess().getRule();
	}
	
	//// <ANNOTATION>
	//// Not at all based on the website. based on what we think the output will be like 
	//VLSAnnotation:
	//	'['? name=(LOWER_WORD_ID | SINGLE_QUOTE | VLSRole)? ('(' followup=VLSAnnotationTerms ')')? ']'?;
	public VLSAnnotationElements getVLSAnnotationAccess() {
		return pVLSAnnotation;
	}
	
	public ParserRule getVLSAnnotationRule() {
		return getVLSAnnotationAccess().getRule();
	}
	
	//VLSAnnotationTerms VLSAnnotation:
	//	terms+=VLSAnnotation (',' terms+=VLSAnnotation)*;
	public VLSAnnotationTermsElements getVLSAnnotationTermsAccess() {
		return pVLSAnnotationTerms;
	}
	
	public ParserRule getVLSAnnotationTermsRule() {
		return getVLSAnnotationTermsAccess().getRule();
	}
	
	////////////////////////////////////
	//// VLS Terms
	////////////////////////////////////
	//VLSTerm:
	//	VLSBinary;
	public VLSTermElements getVLSTermAccess() {
		return pVLSTerm;
	}
	
	public ParserRule getVLSTermRule() {
		return getVLSTermAccess().getRule();
	}
	
	////*
	////VLSBinaryFormula
	//VLSBinary VLSTerm:
	//	VLSUnitaryFormula (({VLSEquivalent.left=current} "<=>" | {VLSImplies.left=current} "=>" |
	//	{VLSRevImplies.left=current} "<=" | {VLSXnor.left=current} "<~>" | {VLSNor.left=current} "~|" |
	//	{VLSNand.left=current} "~&") right=VLSUnitaryFormula | ({VLSAnd.left=current} '&' right=VLSUnitaryFormula)+
	//	| ({VLSOr.left=current} '|' right=VLSUnitaryFormula)+)?;
	public VLSBinaryElements getVLSBinaryAccess() {
		return pVLSBinary;
	}
	
	public ParserRule getVLSBinaryRule() {
		return getVLSBinaryAccess().getRule();
	}
	
	////VLSUnitaryFormula
	//VLSUnitaryFormula VLSTerm:
	//	VLSUniversalQuantifier | VLSExistentialQuantifier | VLSUnaryNegation | VLSUnaryInfix | '(' VLSTerm ')';
	public VLSUnitaryFormulaElements getVLSUnitaryFormulaAccess() {
		return pVLSUnitaryFormula;
	}
	
	public ParserRule getVLSUnitaryFormulaRule() {
		return getVLSUnitaryFormulaAccess().getRule();
	}
	
	//VLSUniversalQuantifier VLSTerm:
	//	{VLSUniversalQuantifier} ("!" '[' variables+=VLSVariable (',' variables+=VLSVariable)* ']' ':')
	//	operand=VLSUnitaryFormula;
	public VLSUniversalQuantifierElements getVLSUniversalQuantifierAccess() {
		return pVLSUniversalQuantifier;
	}
	
	public ParserRule getVLSUniversalQuantifierRule() {
		return getVLSUniversalQuantifierAccess().getRule();
	}
	
	//VLSExistentialQuantifier VLSTerm:
	//	{VLSExistentialQuantifier} ("?" '[' variables+=VLSVariable (',' variables+=VLSVariable)* ']' ':')
	//	operand=VLSUnitaryFormula;
	public VLSExistentialQuantifierElements getVLSExistentialQuantifierAccess() {
		return pVLSExistentialQuantifier;
	}
	
	public ParserRule getVLSExistentialQuantifierRule() {
		return getVLSExistentialQuantifierAccess().getRule();
	}
	
	//VLSUnaryNegation VLSTerm:
	//	{VLSUnaryNegation} '~' operand=VLSUnitaryFormula;
	public VLSUnaryNegationElements getVLSUnaryNegationAccess() {
		return pVLSUnaryNegation;
	}
	
	public ParserRule getVLSUnaryNegationRule() {
		return getVLSUnaryNegationAccess().getRule();
	}
	
	//VLSUnaryInfix VLSTerm:
	//	VLSFunction (({VLSInequality.left=current} "!=" | {VLSEquality.left=current} "=" | {VLSAssignment.left=current} ":=")
	//	right=VLSFunction)?;
	public VLSUnaryInfixElements getVLSUnaryInfixAccess() {
		return pVLSUnaryInfix;
	}
	
	public ParserRule getVLSUnaryInfixRule() {
		return getVLSUnaryInfixAccess().getRule();
	}
	
	///*
	//enum VLSDefinedFunctor:
	//		UMINUS='$uminus' | SUM='$sum' | DIFFERENCE='$difference' | PRODUCT='$product' | QUOTIENT='$quotient' | 
	//		QUOTIENT_E='$quotient_e' | QUOTIENT_T='$quotient_t' | QUOTIENT_F='$quotient_f' | REMAINDER_E='$remainder_e' |
	//		 REMAINDER_T='$remainder_t' | REMAINDER_F='$remainder_f' | FLOOR='$floor' | CEILING='$ceiling' |
	//		 TRUNCATE='$truncate' | ROUND='$round' | TO_INT='$to_int' | TO_RAT='$to_rat' | TO_REAL='$to_real'
	//    ;
	//*/ VLSFunction VLSTerm:
	//	{VLSFunction} constant=VLSFunctionDeclaration ('(' terms+=VLSFofTerm (',' terms+=VLSFofTerm)* ')')?;
	public VLSFunctionElements getVLSFunctionAccess() {
		return pVLSFunction;
	}
	
	public ParserRule getVLSFunctionRule() {
		return getVLSFunctionAccess().getRule();
	}
	
	//VLSFofTerm:
	//	VLSVariable | VLSFunctionFof | VLSDefinedTerm;
	public VLSFofTermElements getVLSFofTermAccess() {
		return pVLSFofTerm;
	}
	
	public ParserRule getVLSFofTermRule() {
		return getVLSFofTermAccess().getRule();
	}
	
	//VLSVariable:
	//	name=UPPER_WORD_ID;
	public VLSVariableElements getVLSVariableAccess() {
		return pVLSVariable;
	}
	
	public ParserRule getVLSVariableRule() {
		return getVLSVariableAccess().getRule();
	}
	
	//VLSFunctionFof:
	//	functor=VLSFunctionDeclaration ('(' terms+=VLSFofTerm (',' terms+=VLSFofTerm)* ')')?;
	public VLSFunctionFofElements getVLSFunctionFofAccess() {
		return pVLSFunctionFof;
	}
	
	public ParserRule getVLSFunctionFofRule() {
		return getVLSFunctionFofAccess().getRule();
	}
	
	//VLSDefinedTerm:
	//	name=(DOUBLE_QUOTE | SIGNED_LITERAL | SIGNED_REAL_ID | SIGNED_RAT_ID);
	public VLSDefinedTermElements getVLSDefinedTermAccess() {
		return pVLSDefinedTerm;
	}
	
	public ParserRule getVLSDefinedTermRule() {
		return getVLSDefinedTermAccess().getRule();
	}
	
	//terminal ID:
	//	'^'? ('a'..'z' | 'A'..'Z' | '_') ('a'..'z' | 'A'..'Z' | '_' | '0'..'9')*;
	public TerminalRule getIDRule() {
		return gaTerminals.getIDRule();
	}
	
	//terminal INT returns ecore::EInt:
	//	'0'..'9'+;
	public TerminalRule getINTRule() {
		return gaTerminals.getINTRule();
	}
	
	//terminal STRING:
	//	'"' ('\\' . | !('\\' | '"'))* '"' | "'" ('\\' . | !('\\' | "'"))* "'";
	public TerminalRule getSTRINGRule() {
		return gaTerminals.getSTRINGRule();
	}
	
	//terminal ML_COMMENT:
	//	'/*'->'*/';
	public TerminalRule getML_COMMENTRule() {
		return gaTerminals.getML_COMMENTRule();
	}
	
	//terminal SL_COMMENT:
	//	'//' !('\n' | '\r')* ('\r'? '\n')?;
	public TerminalRule getSL_COMMENTRule() {
		return gaTerminals.getSL_COMMENTRule();
	}
	
	//terminal WS:
	//	' ' | '\t' | '\r' | '\n'+;
	public TerminalRule getWSRule() {
		return gaTerminals.getWSRule();
	}
}
