/*
 * generated by Xtext 2.12.0
 */
package hu.bme.mit.inf.dslreasoner.serializer;

import com.google.inject.Inject;
import hu.bme.mit.inf.dslreasoner.services.VampireLanguageGrammarAccess;
import hu.bme.mit.inf.dslreasoner.vampireLanguage.VLSAnd;
import hu.bme.mit.inf.dslreasoner.vampireLanguage.VLSAnnotation;
import hu.bme.mit.inf.dslreasoner.vampireLanguage.VLSAssignment;
import hu.bme.mit.inf.dslreasoner.vampireLanguage.VLSComment;
import hu.bme.mit.inf.dslreasoner.vampireLanguage.VLSDefinedTerm;
import hu.bme.mit.inf.dslreasoner.vampireLanguage.VLSEquality;
import hu.bme.mit.inf.dslreasoner.vampireLanguage.VLSEquivalent;
import hu.bme.mit.inf.dslreasoner.vampireLanguage.VLSExistentialQuantifier;
import hu.bme.mit.inf.dslreasoner.vampireLanguage.VLSFofFormula;
import hu.bme.mit.inf.dslreasoner.vampireLanguage.VLSFunction;
import hu.bme.mit.inf.dslreasoner.vampireLanguage.VLSFunctionDeclaration;
import hu.bme.mit.inf.dslreasoner.vampireLanguage.VLSFunctionFof;
import hu.bme.mit.inf.dslreasoner.vampireLanguage.VLSImplies;
import hu.bme.mit.inf.dslreasoner.vampireLanguage.VLSInequality;
import hu.bme.mit.inf.dslreasoner.vampireLanguage.VLSNand;
import hu.bme.mit.inf.dslreasoner.vampireLanguage.VLSNor;
import hu.bme.mit.inf.dslreasoner.vampireLanguage.VLSOr;
import hu.bme.mit.inf.dslreasoner.vampireLanguage.VLSRevImplies;
import hu.bme.mit.inf.dslreasoner.vampireLanguage.VLSUnaryNegation;
import hu.bme.mit.inf.dslreasoner.vampireLanguage.VLSUniversalQuantifier;
import hu.bme.mit.inf.dslreasoner.vampireLanguage.VLSVariable;
import hu.bme.mit.inf.dslreasoner.vampireLanguage.VLSXnor;
import hu.bme.mit.inf.dslreasoner.vampireLanguage.VampireLanguagePackage;
import hu.bme.mit.inf.dslreasoner.vampireLanguage.VampireModel;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class VampireLanguageSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private VampireLanguageGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == VampireLanguagePackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case VampireLanguagePackage.VLS_AND:
				sequence_VLSBinary(context, (VLSAnd) semanticObject); 
				return; 
			case VampireLanguagePackage.VLS_ANNOTATION:
				if (rule == grammarAccess.getVLSAnnotationTermsRule()) {
					sequence_VLSAnnotationTerms(context, (VLSAnnotation) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getVLSAnnotationRule()) {
					sequence_VLSAnnotation(context, (VLSAnnotation) semanticObject); 
					return; 
				}
				else break;
			case VampireLanguagePackage.VLS_ASSIGNMENT:
				sequence_VLSUnaryInfix(context, (VLSAssignment) semanticObject); 
				return; 
			case VampireLanguagePackage.VLS_COMMENT:
				sequence_VLSComment(context, (VLSComment) semanticObject); 
				return; 
			case VampireLanguagePackage.VLS_DEFINED_TERM:
				sequence_VLSDefinedTerm(context, (VLSDefinedTerm) semanticObject); 
				return; 
			case VampireLanguagePackage.VLS_EQUALITY:
				sequence_VLSUnaryInfix(context, (VLSEquality) semanticObject); 
				return; 
			case VampireLanguagePackage.VLS_EQUIVALENT:
				sequence_VLSBinary(context, (VLSEquivalent) semanticObject); 
				return; 
			case VampireLanguagePackage.VLS_EXISTENTIAL_QUANTIFIER:
				sequence_VLSExistentialQuantifier(context, (VLSExistentialQuantifier) semanticObject); 
				return; 
			case VampireLanguagePackage.VLS_FOF_FORMULA:
				sequence_VLSFofFormula(context, (VLSFofFormula) semanticObject); 
				return; 
			case VampireLanguagePackage.VLS_FUNCTION:
				sequence_VLSFunction(context, (VLSFunction) semanticObject); 
				return; 
			case VampireLanguagePackage.VLS_FUNCTION_DECLARATION:
				sequence_VLSFunctionDeclaration(context, (VLSFunctionDeclaration) semanticObject); 
				return; 
			case VampireLanguagePackage.VLS_FUNCTION_FOF:
				sequence_VLSFunctionFof(context, (VLSFunctionFof) semanticObject); 
				return; 
			case VampireLanguagePackage.VLS_IMPLIES:
				sequence_VLSBinary(context, (VLSImplies) semanticObject); 
				return; 
			case VampireLanguagePackage.VLS_INEQUALITY:
				sequence_VLSUnaryInfix(context, (VLSInequality) semanticObject); 
				return; 
			case VampireLanguagePackage.VLS_NAND:
				sequence_VLSBinary(context, (VLSNand) semanticObject); 
				return; 
			case VampireLanguagePackage.VLS_NOR:
				sequence_VLSBinary(context, (VLSNor) semanticObject); 
				return; 
			case VampireLanguagePackage.VLS_OR:
				sequence_VLSBinary(context, (VLSOr) semanticObject); 
				return; 
			case VampireLanguagePackage.VLS_REV_IMPLIES:
				sequence_VLSBinary(context, (VLSRevImplies) semanticObject); 
				return; 
			case VampireLanguagePackage.VLS_UNARY_NEGATION:
				sequence_VLSUnaryNegation(context, (VLSUnaryNegation) semanticObject); 
				return; 
			case VampireLanguagePackage.VLS_UNIVERSAL_QUANTIFIER:
				sequence_VLSUniversalQuantifier(context, (VLSUniversalQuantifier) semanticObject); 
				return; 
			case VampireLanguagePackage.VLS_VARIABLE:
				sequence_VLSVariable(context, (VLSVariable) semanticObject); 
				return; 
			case VampireLanguagePackage.VLS_XNOR:
				sequence_VLSBinary(context, (VLSXnor) semanticObject); 
				return; 
			case VampireLanguagePackage.VAMPIRE_MODEL:
				sequence_VampireModel(context, (VampireModel) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     VLSAnnotationTerms returns VLSAnnotation
	 *
	 * Constraint:
	 *     (terms+=VLSAnnotation terms+=VLSAnnotation*)
	 */
	protected void sequence_VLSAnnotationTerms(ISerializationContext context, VLSAnnotation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     VLSAnnotation returns VLSAnnotation
	 *
	 * Constraint:
	 *     (((name=LOWER_WORD_ID | name=SINGLE_QUOTE | name=VLSRole) followup=VLSAnnotationTerms) | followup=VLSAnnotationTerms)?
	 */
	protected void sequence_VLSAnnotation(ISerializationContext context, VLSAnnotation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     VLSTerm returns VLSAnd
	 *     VLSBinary returns VLSAnd
	 *     VLSBinary.VLSEquivalent_1_0_0_0_0 returns VLSAnd
	 *     VLSBinary.VLSImplies_1_0_0_1_0 returns VLSAnd
	 *     VLSBinary.VLSRevImplies_1_0_0_2_0 returns VLSAnd
	 *     VLSBinary.VLSXnor_1_0_0_3_0 returns VLSAnd
	 *     VLSBinary.VLSNor_1_0_0_4_0 returns VLSAnd
	 *     VLSBinary.VLSNand_1_0_0_5_0 returns VLSAnd
	 *     VLSBinary.VLSAnd_1_1_0 returns VLSAnd
	 *     VLSBinary.VLSOr_1_2_0 returns VLSAnd
	 *     VLSUnitaryFormula returns VLSAnd
	 *
	 * Constraint:
	 *     (left=VLSBinary_VLSAnd_1_1_0 right=VLSUnitaryFormula)
	 */
	protected void sequence_VLSBinary(ISerializationContext context, VLSAnd semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, VampireLanguagePackage.Literals.VLS_AND__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, VampireLanguagePackage.Literals.VLS_AND__LEFT));
			if (transientValues.isValueTransient(semanticObject, VampireLanguagePackage.Literals.VLS_AND__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, VampireLanguagePackage.Literals.VLS_AND__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVLSBinaryAccess().getVLSAndLeftAction_1_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getVLSBinaryAccess().getRightVLSUnitaryFormulaParserRuleCall_1_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     VLSTerm returns VLSEquivalent
	 *     VLSBinary returns VLSEquivalent
	 *     VLSBinary.VLSEquivalent_1_0_0_0_0 returns VLSEquivalent
	 *     VLSBinary.VLSImplies_1_0_0_1_0 returns VLSEquivalent
	 *     VLSBinary.VLSRevImplies_1_0_0_2_0 returns VLSEquivalent
	 *     VLSBinary.VLSXnor_1_0_0_3_0 returns VLSEquivalent
	 *     VLSBinary.VLSNor_1_0_0_4_0 returns VLSEquivalent
	 *     VLSBinary.VLSNand_1_0_0_5_0 returns VLSEquivalent
	 *     VLSBinary.VLSAnd_1_1_0 returns VLSEquivalent
	 *     VLSBinary.VLSOr_1_2_0 returns VLSEquivalent
	 *     VLSUnitaryFormula returns VLSEquivalent
	 *
	 * Constraint:
	 *     (left=VLSBinary_VLSEquivalent_1_0_0_0_0 right=VLSUnitaryFormula)
	 */
	protected void sequence_VLSBinary(ISerializationContext context, VLSEquivalent semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, VampireLanguagePackage.Literals.VLS_EQUIVALENT__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, VampireLanguagePackage.Literals.VLS_EQUIVALENT__LEFT));
			if (transientValues.isValueTransient(semanticObject, VampireLanguagePackage.Literals.VLS_EQUIVALENT__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, VampireLanguagePackage.Literals.VLS_EQUIVALENT__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVLSBinaryAccess().getVLSEquivalentLeftAction_1_0_0_0_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getVLSBinaryAccess().getRightVLSUnitaryFormulaParserRuleCall_1_0_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     VLSTerm returns VLSImplies
	 *     VLSBinary returns VLSImplies
	 *     VLSBinary.VLSEquivalent_1_0_0_0_0 returns VLSImplies
	 *     VLSBinary.VLSImplies_1_0_0_1_0 returns VLSImplies
	 *     VLSBinary.VLSRevImplies_1_0_0_2_0 returns VLSImplies
	 *     VLSBinary.VLSXnor_1_0_0_3_0 returns VLSImplies
	 *     VLSBinary.VLSNor_1_0_0_4_0 returns VLSImplies
	 *     VLSBinary.VLSNand_1_0_0_5_0 returns VLSImplies
	 *     VLSBinary.VLSAnd_1_1_0 returns VLSImplies
	 *     VLSBinary.VLSOr_1_2_0 returns VLSImplies
	 *     VLSUnitaryFormula returns VLSImplies
	 *
	 * Constraint:
	 *     (left=VLSBinary_VLSImplies_1_0_0_1_0 right=VLSUnitaryFormula)
	 */
	protected void sequence_VLSBinary(ISerializationContext context, VLSImplies semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, VampireLanguagePackage.Literals.VLS_IMPLIES__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, VampireLanguagePackage.Literals.VLS_IMPLIES__LEFT));
			if (transientValues.isValueTransient(semanticObject, VampireLanguagePackage.Literals.VLS_IMPLIES__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, VampireLanguagePackage.Literals.VLS_IMPLIES__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVLSBinaryAccess().getVLSImpliesLeftAction_1_0_0_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getVLSBinaryAccess().getRightVLSUnitaryFormulaParserRuleCall_1_0_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     VLSTerm returns VLSNand
	 *     VLSBinary returns VLSNand
	 *     VLSBinary.VLSEquivalent_1_0_0_0_0 returns VLSNand
	 *     VLSBinary.VLSImplies_1_0_0_1_0 returns VLSNand
	 *     VLSBinary.VLSRevImplies_1_0_0_2_0 returns VLSNand
	 *     VLSBinary.VLSXnor_1_0_0_3_0 returns VLSNand
	 *     VLSBinary.VLSNor_1_0_0_4_0 returns VLSNand
	 *     VLSBinary.VLSNand_1_0_0_5_0 returns VLSNand
	 *     VLSBinary.VLSAnd_1_1_0 returns VLSNand
	 *     VLSBinary.VLSOr_1_2_0 returns VLSNand
	 *     VLSUnitaryFormula returns VLSNand
	 *
	 * Constraint:
	 *     (left=VLSBinary_VLSNand_1_0_0_5_0 right=VLSUnitaryFormula)
	 */
	protected void sequence_VLSBinary(ISerializationContext context, VLSNand semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, VampireLanguagePackage.Literals.VLS_NAND__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, VampireLanguagePackage.Literals.VLS_NAND__LEFT));
			if (transientValues.isValueTransient(semanticObject, VampireLanguagePackage.Literals.VLS_NAND__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, VampireLanguagePackage.Literals.VLS_NAND__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVLSBinaryAccess().getVLSNandLeftAction_1_0_0_5_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getVLSBinaryAccess().getRightVLSUnitaryFormulaParserRuleCall_1_0_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     VLSTerm returns VLSNor
	 *     VLSBinary returns VLSNor
	 *     VLSBinary.VLSEquivalent_1_0_0_0_0 returns VLSNor
	 *     VLSBinary.VLSImplies_1_0_0_1_0 returns VLSNor
	 *     VLSBinary.VLSRevImplies_1_0_0_2_0 returns VLSNor
	 *     VLSBinary.VLSXnor_1_0_0_3_0 returns VLSNor
	 *     VLSBinary.VLSNor_1_0_0_4_0 returns VLSNor
	 *     VLSBinary.VLSNand_1_0_0_5_0 returns VLSNor
	 *     VLSBinary.VLSAnd_1_1_0 returns VLSNor
	 *     VLSBinary.VLSOr_1_2_0 returns VLSNor
	 *     VLSUnitaryFormula returns VLSNor
	 *
	 * Constraint:
	 *     (left=VLSBinary_VLSNor_1_0_0_4_0 right=VLSUnitaryFormula)
	 */
	protected void sequence_VLSBinary(ISerializationContext context, VLSNor semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, VampireLanguagePackage.Literals.VLS_NOR__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, VampireLanguagePackage.Literals.VLS_NOR__LEFT));
			if (transientValues.isValueTransient(semanticObject, VampireLanguagePackage.Literals.VLS_NOR__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, VampireLanguagePackage.Literals.VLS_NOR__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVLSBinaryAccess().getVLSNorLeftAction_1_0_0_4_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getVLSBinaryAccess().getRightVLSUnitaryFormulaParserRuleCall_1_0_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     VLSTerm returns VLSOr
	 *     VLSBinary returns VLSOr
	 *     VLSBinary.VLSEquivalent_1_0_0_0_0 returns VLSOr
	 *     VLSBinary.VLSImplies_1_0_0_1_0 returns VLSOr
	 *     VLSBinary.VLSRevImplies_1_0_0_2_0 returns VLSOr
	 *     VLSBinary.VLSXnor_1_0_0_3_0 returns VLSOr
	 *     VLSBinary.VLSNor_1_0_0_4_0 returns VLSOr
	 *     VLSBinary.VLSNand_1_0_0_5_0 returns VLSOr
	 *     VLSBinary.VLSAnd_1_1_0 returns VLSOr
	 *     VLSBinary.VLSOr_1_2_0 returns VLSOr
	 *     VLSUnitaryFormula returns VLSOr
	 *
	 * Constraint:
	 *     (left=VLSBinary_VLSOr_1_2_0 right=VLSUnitaryFormula)
	 */
	protected void sequence_VLSBinary(ISerializationContext context, VLSOr semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, VampireLanguagePackage.Literals.VLS_OR__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, VampireLanguagePackage.Literals.VLS_OR__LEFT));
			if (transientValues.isValueTransient(semanticObject, VampireLanguagePackage.Literals.VLS_OR__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, VampireLanguagePackage.Literals.VLS_OR__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVLSBinaryAccess().getVLSOrLeftAction_1_2_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getVLSBinaryAccess().getRightVLSUnitaryFormulaParserRuleCall_1_2_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     VLSTerm returns VLSRevImplies
	 *     VLSBinary returns VLSRevImplies
	 *     VLSBinary.VLSEquivalent_1_0_0_0_0 returns VLSRevImplies
	 *     VLSBinary.VLSImplies_1_0_0_1_0 returns VLSRevImplies
	 *     VLSBinary.VLSRevImplies_1_0_0_2_0 returns VLSRevImplies
	 *     VLSBinary.VLSXnor_1_0_0_3_0 returns VLSRevImplies
	 *     VLSBinary.VLSNor_1_0_0_4_0 returns VLSRevImplies
	 *     VLSBinary.VLSNand_1_0_0_5_0 returns VLSRevImplies
	 *     VLSBinary.VLSAnd_1_1_0 returns VLSRevImplies
	 *     VLSBinary.VLSOr_1_2_0 returns VLSRevImplies
	 *     VLSUnitaryFormula returns VLSRevImplies
	 *
	 * Constraint:
	 *     (left=VLSBinary_VLSRevImplies_1_0_0_2_0 right=VLSUnitaryFormula)
	 */
	protected void sequence_VLSBinary(ISerializationContext context, VLSRevImplies semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, VampireLanguagePackage.Literals.VLS_REV_IMPLIES__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, VampireLanguagePackage.Literals.VLS_REV_IMPLIES__LEFT));
			if (transientValues.isValueTransient(semanticObject, VampireLanguagePackage.Literals.VLS_REV_IMPLIES__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, VampireLanguagePackage.Literals.VLS_REV_IMPLIES__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVLSBinaryAccess().getVLSRevImpliesLeftAction_1_0_0_2_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getVLSBinaryAccess().getRightVLSUnitaryFormulaParserRuleCall_1_0_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     VLSTerm returns VLSXnor
	 *     VLSBinary returns VLSXnor
	 *     VLSBinary.VLSEquivalent_1_0_0_0_0 returns VLSXnor
	 *     VLSBinary.VLSImplies_1_0_0_1_0 returns VLSXnor
	 *     VLSBinary.VLSRevImplies_1_0_0_2_0 returns VLSXnor
	 *     VLSBinary.VLSXnor_1_0_0_3_0 returns VLSXnor
	 *     VLSBinary.VLSNor_1_0_0_4_0 returns VLSXnor
	 *     VLSBinary.VLSNand_1_0_0_5_0 returns VLSXnor
	 *     VLSBinary.VLSAnd_1_1_0 returns VLSXnor
	 *     VLSBinary.VLSOr_1_2_0 returns VLSXnor
	 *     VLSUnitaryFormula returns VLSXnor
	 *
	 * Constraint:
	 *     (left=VLSBinary_VLSXnor_1_0_0_3_0 right=VLSUnitaryFormula)
	 */
	protected void sequence_VLSBinary(ISerializationContext context, VLSXnor semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, VampireLanguagePackage.Literals.VLS_XNOR__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, VampireLanguagePackage.Literals.VLS_XNOR__LEFT));
			if (transientValues.isValueTransient(semanticObject, VampireLanguagePackage.Literals.VLS_XNOR__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, VampireLanguagePackage.Literals.VLS_XNOR__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVLSBinaryAccess().getVLSXnorLeftAction_1_0_0_3_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getVLSBinaryAccess().getRightVLSUnitaryFormulaParserRuleCall_1_0_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     VLSComment returns VLSComment
	 *
	 * Constraint:
	 *     comment=SINGLE_COMMENT
	 */
	protected void sequence_VLSComment(ISerializationContext context, VLSComment semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, VampireLanguagePackage.Literals.VLS_COMMENT__COMMENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, VampireLanguagePackage.Literals.VLS_COMMENT__COMMENT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVLSCommentAccess().getCommentSINGLE_COMMENTTerminalRuleCall_0(), semanticObject.getComment());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     VLSFofTerm returns VLSDefinedTerm
	 *     VLSDefinedTerm returns VLSDefinedTerm
	 *
	 * Constraint:
	 *     (name=DOUBLE_QUOTE | name=SIGNED_LITERAL | name=SIGNED_REAL_ID | name=SIGNED_RAT_ID)
	 */
	protected void sequence_VLSDefinedTerm(ISerializationContext context, VLSDefinedTerm semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     VLSTerm returns VLSExistentialQuantifier
	 *     VLSBinary returns VLSExistentialQuantifier
	 *     VLSBinary.VLSEquivalent_1_0_0_0_0 returns VLSExistentialQuantifier
	 *     VLSBinary.VLSImplies_1_0_0_1_0 returns VLSExistentialQuantifier
	 *     VLSBinary.VLSRevImplies_1_0_0_2_0 returns VLSExistentialQuantifier
	 *     VLSBinary.VLSXnor_1_0_0_3_0 returns VLSExistentialQuantifier
	 *     VLSBinary.VLSNor_1_0_0_4_0 returns VLSExistentialQuantifier
	 *     VLSBinary.VLSNand_1_0_0_5_0 returns VLSExistentialQuantifier
	 *     VLSBinary.VLSAnd_1_1_0 returns VLSExistentialQuantifier
	 *     VLSBinary.VLSOr_1_2_0 returns VLSExistentialQuantifier
	 *     VLSUnitaryFormula returns VLSExistentialQuantifier
	 *     VLSExistentialQuantifier returns VLSExistentialQuantifier
	 *
	 * Constraint:
	 *     (variables+=VLSVariable variables+=VLSVariable* operand=VLSUnitaryFormula)
	 */
	protected void sequence_VLSExistentialQuantifier(ISerializationContext context, VLSExistentialQuantifier semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     VLSFofFormula returns VLSFofFormula
	 *
	 * Constraint:
	 *     ((name=LOWER_WORD_ID | name=SIGNED_LITERAL | name=SINGLE_QUOTE) fofRole=VLSRole fofFormula=VLSTerm annotations=VLSAnnotation?)
	 */
	protected void sequence_VLSFofFormula(ISerializationContext context, VLSFofFormula semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     VLSFunctionDeclaration returns VLSFunctionDeclaration
	 *
	 * Constraint:
	 *     (name=LOWER_WORD_ID | name=SINGLE_QUOTE | name=DOLLAR_ID | name=DOUBLE_DOLLAR_ID)
	 */
	protected void sequence_VLSFunctionDeclaration(ISerializationContext context, VLSFunctionDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     VLSFofTerm returns VLSFunctionFof
	 *     VLSFunctionFof returns VLSFunctionFof
	 *
	 * Constraint:
	 *     (functor=VLSFunctionDeclaration (terms+=VLSFofTerm terms+=VLSFofTerm*)?)
	 */
	protected void sequence_VLSFunctionFof(ISerializationContext context, VLSFunctionFof semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     VLSTerm returns VLSFunction
	 *     VLSBinary returns VLSFunction
	 *     VLSBinary.VLSEquivalent_1_0_0_0_0 returns VLSFunction
	 *     VLSBinary.VLSImplies_1_0_0_1_0 returns VLSFunction
	 *     VLSBinary.VLSRevImplies_1_0_0_2_0 returns VLSFunction
	 *     VLSBinary.VLSXnor_1_0_0_3_0 returns VLSFunction
	 *     VLSBinary.VLSNor_1_0_0_4_0 returns VLSFunction
	 *     VLSBinary.VLSNand_1_0_0_5_0 returns VLSFunction
	 *     VLSBinary.VLSAnd_1_1_0 returns VLSFunction
	 *     VLSBinary.VLSOr_1_2_0 returns VLSFunction
	 *     VLSUnitaryFormula returns VLSFunction
	 *     VLSUnaryInfix returns VLSFunction
	 *     VLSUnaryInfix.VLSInequality_1_0_0_0 returns VLSFunction
	 *     VLSUnaryInfix.VLSEquality_1_0_1_0 returns VLSFunction
	 *     VLSUnaryInfix.VLSAssignment_1_0_2_0 returns VLSFunction
	 *     VLSFunction returns VLSFunction
	 *
	 * Constraint:
	 *     (constant=VLSFunctionDeclaration (terms+=VLSFofTerm terms+=VLSFofTerm*)?)
	 */
	protected void sequence_VLSFunction(ISerializationContext context, VLSFunction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     VLSTerm returns VLSAssignment
	 *     VLSBinary returns VLSAssignment
	 *     VLSBinary.VLSEquivalent_1_0_0_0_0 returns VLSAssignment
	 *     VLSBinary.VLSImplies_1_0_0_1_0 returns VLSAssignment
	 *     VLSBinary.VLSRevImplies_1_0_0_2_0 returns VLSAssignment
	 *     VLSBinary.VLSXnor_1_0_0_3_0 returns VLSAssignment
	 *     VLSBinary.VLSNor_1_0_0_4_0 returns VLSAssignment
	 *     VLSBinary.VLSNand_1_0_0_5_0 returns VLSAssignment
	 *     VLSBinary.VLSAnd_1_1_0 returns VLSAssignment
	 *     VLSBinary.VLSOr_1_2_0 returns VLSAssignment
	 *     VLSUnitaryFormula returns VLSAssignment
	 *     VLSUnaryInfix returns VLSAssignment
	 *
	 * Constraint:
	 *     (left=VLSUnaryInfix_VLSAssignment_1_0_2_0 right=VLSFunction)
	 */
	protected void sequence_VLSUnaryInfix(ISerializationContext context, VLSAssignment semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, VampireLanguagePackage.Literals.VLS_ASSIGNMENT__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, VampireLanguagePackage.Literals.VLS_ASSIGNMENT__LEFT));
			if (transientValues.isValueTransient(semanticObject, VampireLanguagePackage.Literals.VLS_ASSIGNMENT__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, VampireLanguagePackage.Literals.VLS_ASSIGNMENT__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVLSUnaryInfixAccess().getVLSAssignmentLeftAction_1_0_2_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getVLSUnaryInfixAccess().getRightVLSFunctionParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     VLSTerm returns VLSEquality
	 *     VLSBinary returns VLSEquality
	 *     VLSBinary.VLSEquivalent_1_0_0_0_0 returns VLSEquality
	 *     VLSBinary.VLSImplies_1_0_0_1_0 returns VLSEquality
	 *     VLSBinary.VLSRevImplies_1_0_0_2_0 returns VLSEquality
	 *     VLSBinary.VLSXnor_1_0_0_3_0 returns VLSEquality
	 *     VLSBinary.VLSNor_1_0_0_4_0 returns VLSEquality
	 *     VLSBinary.VLSNand_1_0_0_5_0 returns VLSEquality
	 *     VLSBinary.VLSAnd_1_1_0 returns VLSEquality
	 *     VLSBinary.VLSOr_1_2_0 returns VLSEquality
	 *     VLSUnitaryFormula returns VLSEquality
	 *     VLSUnaryInfix returns VLSEquality
	 *
	 * Constraint:
	 *     (left=VLSUnaryInfix_VLSEquality_1_0_1_0 right=VLSFunction)
	 */
	protected void sequence_VLSUnaryInfix(ISerializationContext context, VLSEquality semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, VampireLanguagePackage.Literals.VLS_EQUALITY__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, VampireLanguagePackage.Literals.VLS_EQUALITY__LEFT));
			if (transientValues.isValueTransient(semanticObject, VampireLanguagePackage.Literals.VLS_EQUALITY__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, VampireLanguagePackage.Literals.VLS_EQUALITY__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVLSUnaryInfixAccess().getVLSEqualityLeftAction_1_0_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getVLSUnaryInfixAccess().getRightVLSFunctionParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     VLSTerm returns VLSInequality
	 *     VLSBinary returns VLSInequality
	 *     VLSBinary.VLSEquivalent_1_0_0_0_0 returns VLSInequality
	 *     VLSBinary.VLSImplies_1_0_0_1_0 returns VLSInequality
	 *     VLSBinary.VLSRevImplies_1_0_0_2_0 returns VLSInequality
	 *     VLSBinary.VLSXnor_1_0_0_3_0 returns VLSInequality
	 *     VLSBinary.VLSNor_1_0_0_4_0 returns VLSInequality
	 *     VLSBinary.VLSNand_1_0_0_5_0 returns VLSInequality
	 *     VLSBinary.VLSAnd_1_1_0 returns VLSInequality
	 *     VLSBinary.VLSOr_1_2_0 returns VLSInequality
	 *     VLSUnitaryFormula returns VLSInequality
	 *     VLSUnaryInfix returns VLSInequality
	 *
	 * Constraint:
	 *     (left=VLSUnaryInfix_VLSInequality_1_0_0_0 right=VLSFunction)
	 */
	protected void sequence_VLSUnaryInfix(ISerializationContext context, VLSInequality semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, VampireLanguagePackage.Literals.VLS_INEQUALITY__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, VampireLanguagePackage.Literals.VLS_INEQUALITY__LEFT));
			if (transientValues.isValueTransient(semanticObject, VampireLanguagePackage.Literals.VLS_INEQUALITY__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, VampireLanguagePackage.Literals.VLS_INEQUALITY__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVLSUnaryInfixAccess().getVLSInequalityLeftAction_1_0_0_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getVLSUnaryInfixAccess().getRightVLSFunctionParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     VLSTerm returns VLSUnaryNegation
	 *     VLSBinary returns VLSUnaryNegation
	 *     VLSBinary.VLSEquivalent_1_0_0_0_0 returns VLSUnaryNegation
	 *     VLSBinary.VLSImplies_1_0_0_1_0 returns VLSUnaryNegation
	 *     VLSBinary.VLSRevImplies_1_0_0_2_0 returns VLSUnaryNegation
	 *     VLSBinary.VLSXnor_1_0_0_3_0 returns VLSUnaryNegation
	 *     VLSBinary.VLSNor_1_0_0_4_0 returns VLSUnaryNegation
	 *     VLSBinary.VLSNand_1_0_0_5_0 returns VLSUnaryNegation
	 *     VLSBinary.VLSAnd_1_1_0 returns VLSUnaryNegation
	 *     VLSBinary.VLSOr_1_2_0 returns VLSUnaryNegation
	 *     VLSUnitaryFormula returns VLSUnaryNegation
	 *     VLSUnaryNegation returns VLSUnaryNegation
	 *
	 * Constraint:
	 *     operand=VLSUnitaryFormula
	 */
	protected void sequence_VLSUnaryNegation(ISerializationContext context, VLSUnaryNegation semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, VampireLanguagePackage.Literals.VLS_UNARY_NEGATION__OPERAND) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, VampireLanguagePackage.Literals.VLS_UNARY_NEGATION__OPERAND));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVLSUnaryNegationAccess().getOperandVLSUnitaryFormulaParserRuleCall_2_0(), semanticObject.getOperand());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     VLSTerm returns VLSUniversalQuantifier
	 *     VLSBinary returns VLSUniversalQuantifier
	 *     VLSBinary.VLSEquivalent_1_0_0_0_0 returns VLSUniversalQuantifier
	 *     VLSBinary.VLSImplies_1_0_0_1_0 returns VLSUniversalQuantifier
	 *     VLSBinary.VLSRevImplies_1_0_0_2_0 returns VLSUniversalQuantifier
	 *     VLSBinary.VLSXnor_1_0_0_3_0 returns VLSUniversalQuantifier
	 *     VLSBinary.VLSNor_1_0_0_4_0 returns VLSUniversalQuantifier
	 *     VLSBinary.VLSNand_1_0_0_5_0 returns VLSUniversalQuantifier
	 *     VLSBinary.VLSAnd_1_1_0 returns VLSUniversalQuantifier
	 *     VLSBinary.VLSOr_1_2_0 returns VLSUniversalQuantifier
	 *     VLSUnitaryFormula returns VLSUniversalQuantifier
	 *     VLSUniversalQuantifier returns VLSUniversalQuantifier
	 *
	 * Constraint:
	 *     (variables+=VLSVariable variables+=VLSVariable* operand=VLSUnitaryFormula)
	 */
	protected void sequence_VLSUniversalQuantifier(ISerializationContext context, VLSUniversalQuantifier semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     VLSFofTerm returns VLSVariable
	 *     VLSVariable returns VLSVariable
	 *
	 * Constraint:
	 *     name=UPPER_WORD_ID
	 */
	protected void sequence_VLSVariable(ISerializationContext context, VLSVariable semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, VampireLanguagePackage.Literals.VLS_VARIABLE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, VampireLanguagePackage.Literals.VLS_VARIABLE__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVLSVariableAccess().getNameUPPER_WORD_IDTerminalRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     VampireModel returns VampireModel
	 *
	 * Constraint:
	 *     (comments+=VLSComment | formulas+=VLSFofFormula)+
	 */
	protected void sequence_VampireModel(ISerializationContext context, VampireModel semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
