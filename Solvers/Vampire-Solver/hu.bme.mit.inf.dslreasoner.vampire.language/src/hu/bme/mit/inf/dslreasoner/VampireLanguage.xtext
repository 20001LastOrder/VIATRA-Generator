grammar hu.bme.mit.inf.dslreasoner.VampireLanguage with org.eclipse.xtext.common.Terminals hidden (WS)

generate vampireLanguage "http://www.bme.hu/mit/inf/dslreasoner/VampireLanguage"

//@@@@@@@@@@@
//2 things TODO:
//1. fix anotations (ln77)
//2. can only use declared variables in formula (ln 158)

//@@@@@@@@@@@

VampireModel:	
	// TODO ensures there is always exactly 1 conjecture
	(comments += VLSComment | formulas += VLSFofFormula)*	
;

//////////////////////////////////
// VLS terminals
//////////////////////////////////

terminal ALPHA_NUMERIC:	( 'a'..'z' | 'A'..'Z' | '0'..'9' | '_'); 
terminal UPPER_WORD_ID: ('A'..'Z') (ALPHA_NUMERIC)*;
terminal LOWER_WORD_ID: ('a'..'z') (ALPHA_NUMERIC)*;


//TODO MIGHT NEED TO IMPLEMENT SOME WAY TO ONLY CONSIDER WHAT IS INSIDE QUOTES AS NAME
//incorporate quotes in the line of calling. ex. "'" name=SINGLEQUOTE "'"
terminal DOUBLE_QUOTE: '"' ( '\\' ('"'|'\\') | !('\\'|'"') )* '"';//from terminal STRING rule, positive about this
terminal SINGLE_QUOTE: "'" ( '\\' ("'"|'\\') | !('\\'|"'") )+ "'";//from terminal STRING rule, positive about this

terminal SIGN: ('+' | '-');

terminal DOLLAR_ID: ('$') (LOWER_WORD_ID);
terminal DOUBLE_DOLLAR_ID: ('$$') (LOWER_WORD_ID);

terminal LITERAL: '0' | ('1'..'9') (INT)?;
terminal SIGNED_LITERAL: (SIGN)* (LITERAL);

terminal UNSIGNED_REAL_FRAC_ID: (LITERAL) ('.') (INT);
terminal UNSIGNED_REAL_EXP_ID: (LITERAL | UNSIGNED_REAL_FRAC_ID) ('Ee') (SIGN)* (INT) ;
terminal SIGNED_REAL_ID: (SIGN)* (UNSIGNED_REAL_FRAC_ID | UNSIGNED_REAL_EXP_ID);

terminal UNSIGNED_RAT_ID:  (LITERAL) ('/') ('1'..'9') (INT)? ;
terminal SIGNED_RAT_ID: (SIGN)* (UNSIGNED_RAT_ID);

//Overwriting is necessary
terminal ANY_OTHER: '%' (!('\n'|'\r'))* ('\r');
terminal SINGLE_COMMENT: ANY_OTHER;
//terminal ID:  ( !('('|')'|'\r'|'\n') )+ ;



//////////////////////////////////
// VLS types
//////////////////////////////////
// <COMMENT>
VLSComment:
	comment = SINGLE_COMMENT
	//need to add a new line at the end of the file for the case where the last line is a comment
;

VLSFunctionDeclaration: name = (LOWER_WORD_ID | SINGLE_QUOTE | DOLLAR_ID | DOUBLE_DOLLAR_ID );




//Formulas
VLSFofFormula:
	'fof' '(' name = (LOWER_WORD_ID | SIGNED_LITERAL | SINGLE_QUOTE) ',' fofRole = VLSRole ',' fofFormula = VLSTerm (',' annotations = VLSAnnotation)? ')' '.'
;
/*
//NAME
VLSName:
	//(atomic_Word = Atomic_Word | integer = Integer | single_quote_word = Single_Quote_Word)
	name = (LOWER_WORD_ID | SIGNED_INT_ID | SINGLE_QUOTE)
;
*/
//<ROLE>
VLSRole:
	VLSAxiom | VLSConjecture | VLSHypothesis | VLSDefinition |
	VLSAssumption | VLSLemma | VLSTheorem | VLSCorollary | VLSNegated_Conjecture |
	VLSPlain | VLSType |VLSFi_Domain | VLSFi_Functors | VLSFi_Predicates | VLSUnknown
;

VLSAxiom:
	"axiom"
;

VLSConjecture:
	"conjecture"
;

VLSHypothesis:
	"hypothesis"
;
	
VLSDefinition:
	"definition"
;

VLSAssumption:
	"assumption"
;
		
VLSLemma:
	"lemma"
;
			
VLSTheorem:
	"theorem"
;
				
VLSCorollary:
	"corollary"
;
			
VLSNegated_Conjecture:
	"negated_conjecture"	
;

VLSPlain:
	"plain"
;

VLSType:
	"type"
;

VLSFi_Domain:
	"fi_domain"
;

VLSFi_Functors:
	"fi_functors"
;

VLSFi_Predicates:
	"fi_predicates"
;

VLSUnknown:
	"unknown"
;

// <ANNOTATION>
// Not at all based on the website. based on what we think the output will be like 
VLSAnnotation:
	('[')? (name = (LOWER_WORD_ID  | SINGLE_QUOTE | VLSRole))? ( '('  followup = VLSAnnotationTerms ')' )? (']')?
;

VLSAnnotationTerms returns VLSAnnotation:
	terms += VLSAnnotation (',' terms += VLSAnnotation )*
;

//////////////////////////////////
// VLS Terms
//////////////////////////////////

VLSTerm: 
	//( VLSLogic | VLSSequent)
	VLSBinary
;
//*
//VLSBinaryFormula
VLSBinary returns VLSTerm:
	VLSUnitaryFormula
	(
		(({VLSEquivalent.left = current} "<=>" |
			{VLSImplies.left = current} "=>" |
			{VLSRevImplies.left = current} "<=" |
			{VLSXnor.left = current} "<~>" |
			{VLSNor.left = current} "~|" |
			{VLSNand.left = current} "~&")	right = VLSUnitaryFormula) 
		| 
		({VLSAnd.left = current} '&' right = VLSUnitaryFormula)+
		|
		({VLSOr.left = current} '|' right = VLSUnitaryFormula)+
	)?
;

//VLSUnitaryFormula
VLSUnitaryFormula returns VLSTerm:
	VLSUniversalQuantifier  | VLSExistentialQuantifier | VLSUnaryNegation | VLSUnaryInfix | '(' VLSTerm ')'
;

VLSUniversalQuantifier  returns VLSTerm:
	{VLSUniversalQuantifier} (("!") '[' variables += VLSVariable (','  variables += VLSVariable)* ']' ':') operand = VLSUnitaryFormula
;

VLSExistentialQuantifier  returns VLSTerm:
	{VLSExistentialQuantifier} (("?") '[' variables += VLSVariable (','  variables += VLSVariable)* ']' ':') operand = VLSUnitaryFormula
;

VLSUnaryNegation   returns VLSTerm:
	{VLSUnaryNegation} ('~') operand = VLSUnitaryFormula
;

VLSUnaryInfix returns VLSTerm:
	VLSFunction (({VLSInequality.left = current} "!=" |	
		{VLSEquality.left = current} "=" |
		{VLSAssignment.left = current} ":=")
		right = VLSFunction)? 
;

/*
enum VLSDefinedFunctor:
		UMINUS='$uminus' | SUM='$sum' | DIFFERENCE='$difference' | PRODUCT='$product' | QUOTIENT='$quotient' | 
		QUOTIENT_E='$quotient_e' | QUOTIENT_T='$quotient_t' | QUOTIENT_F='$quotient_f' | REMAINDER_E='$remainder_e' |
		 REMAINDER_T='$remainder_t' | REMAINDER_F='$remainder_f' | FLOOR='$floor' | CEILING='$ceiling' |
		 TRUNCATE='$truncate' | ROUND='$round' | TO_INT='$to_int' | TO_RAT='$to_rat' | TO_REAL='$to_real'
    ;
*/

VLSFunction returns VLSTerm:
	//? on next line causes warning
	//TODO might need replace DOLLAR_ID with enum rule 
	//{VLSFunction} constant = (LOWER_WORD_ID | SINGLE_QUOTE | DOLLAR_ID | DOUBLE_DOLLAR_ID ) ( '(' terms += VLSFofTerm (',' terms += VLSFofTerm)* ')')?
	{VLSFunction} constant = VLSFunctionDeclaration ( '(' terms += VLSFofTerm (',' terms += VLSFofTerm)* ')')?	
;

VLSFofTerm:
	//(VLSVariable | VLSFunction | VLSTffConditional | VLSTffLet | VLSTffTuple)
	(VLSVariable | VLSFunctionFof | VLSDefinedTerm )
;

VLSVariable:
	name = UPPER_WORD_ID
;

VLSFunctionFof:
	//? on next line causes warning
	//TODO might need replace DOLLAR_ID with enum rule 
	functor = VLSFunctionDeclaration ( '(' terms += VLSFofTerm (',' terms += VLSFofTerm)* ')')?
;

VLSDefinedTerm:
	name = (DOUBLE_QUOTE | SIGNED_LITERAL | SIGNED_REAL_ID | SIGNED_RAT_ID)
;
