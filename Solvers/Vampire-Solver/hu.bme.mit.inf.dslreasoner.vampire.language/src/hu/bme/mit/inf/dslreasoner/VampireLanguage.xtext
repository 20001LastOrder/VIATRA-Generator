grammar hu.bme.mit.inf.dslreasoner.VampireLanguage with org.eclipse.xtext.common.Terminals hidden (WS)

generate vampireLanguage "http://www.bme.hu/mit/inf/dslreasoner/VampireLanguage"

//@@@@@@@@@@@
//2 things TODO:
//1. fix anotations (ln77)
//2. can only use declared variables in formula (ln 158)

//@@@@@@@@@@@

VampireModel:	
	// TODO ensures there is always exactly 1 conjecture
	(comments += VLSComment | formulas += VLSFofFormula)*	
;

//////////////////////////////////
// VLS terminals
//////////////////////////////////

terminal ALPHA_NUMERIC:	( 'a'..'z' | 'A'..'Z' | '0'..'9' | '_'); 
terminal UPPER_WORD_ID: ('A'..'Z') (ALPHA_NUMERIC)*;
terminal LOWER_WORD_ID: ('a'..'z') (ALPHA_NUMERIC)*;


//TODO MIGHT NEED TO IMPLEMENT SOME WAY TO ONLY CONSIDER WHAT IS INSIDE QUOTES AS NAME
//incorporate quotes in the line of calling. ex. "'" name=SINGLEQUOTE "'"
terminal DOUBLE_QUOTE: '"' ( '\\' ('"'|'\\') | !('\\'|'"') )* '"';//from terminal STRING rule, positive about this
terminal SINGLE_QUOTE: "'" ( '\\' ("'"|'\\') | !('\\'|"'") )+ "'";//from terminal STRING rule, positive about this

terminal DOLLAR_ID: ('$') (LOWER_WORD_ID);
terminal DOUBLE_DOLLAR_ID: ('$$') (LOWER_WORD_ID);

terminal UNSIGNED_INT_ID: '0' | ('1'..'9') (INT)?;
terminal SIGNED_INT_ID: ('+' | '-')? (UNSIGNED_INT_ID);

terminal UNSIGNED_REAL_FRAC_ID: (UNSIGNED_INT_ID) ('.') (INT);
terminal UNSIGNED_REAL_EXP_ID: (UNSIGNED_INT_ID | UNSIGNED_REAL_FRAC_ID) ('Ee') ('+' |'-')? (INT) ;
terminal SIGNED_REAL_ID: ('+' | '-')? (UNSIGNED_REAL_FRAC_ID | UNSIGNED_REAL_EXP_ID);

terminal UNSIGNED_RAT_ID:  (UNSIGNED_INT_ID) ('/') ('1'..'9') (INT)? ;
terminal SIGNED_RAT_ID: ('+' | '-')? (UNSIGNED_RAT_ID);

//Overwriting is necessary
terminal ANY_OTHER: '%' (!('\n'|'\r'))* ('\r');
terminal SINGLE_COMMENT: ANY_OTHER;
//terminal ID:  ( !('('|')'|'\r'|'\n') )+ ;
//ANNOTATION_ID: ID;
//terminal ANNOTATION_ID: LOWER_WORD_ID;
//////////////////////////////////
// VLS types
//////////////////////////////////
// <COMMENT>
VLSComment:
	comment = SINGLE_COMMENT
;

//Formulas
VLSFofFormula:
	'fof' '(' name = (LOWER_WORD_ID | SIGNED_INT_ID | SINGLE_QUOTE) ',' fofRole = VLSRole ',' fofFormula = VLSTerm (',' annotations = VLSAnnotation)? ')' '.'
;
/*
//NAME
VLSName:
	//(atomic_Word = Atomic_Word | integer = Integer | single_quote_word = Single_Quote_Word)
	name = (LOWER_WORD_ID | SIGNED_INT_ID | SINGLE_QUOTE)
;
*/
//<ROLE>
enum VLSRole:
	axiom | conjecture | hypothesis | definition |
	assumption | lemma | theorem | corollary | negated_conjecture |
	plain | type |fi_domain | fi_functors | fi_predicates | unknown
;

// <ANNOTATION>
//TODO POTENTIAL MAKE THE ANNOTATION STRUCTURE BETTER, Includes modifying terminal rule
// Not at all based on the website. based on what we think the output will be like 
VLSAnnotation:
	(name = LOWER_WORD_ID)? closure_rule = Closure_Rule
;

Closure_Rule returns VLSAnnotation:
	(name = LOWER_WORD_ID) | '('  VLSAnnotation ')' 
;

//////////////////////////////////
// VLS Terms
//////////////////////////////////

VLSTerm: 
	//( VLSLogic | VLSSequent)
	VLSBinary
;
//*
//VLSBinaryFormula
VLSBinary returns VLSTerm:
	VLSUnitaryFormula
	(
		(({VLSEquivalent.left = current} "<=>" |
			{VLSImplies.left = current} "=>" |
			{VLSRevImplies.left = current} "<=" |
			{VLSXnor.left = current} "<~>" |
			{VLSNor.left = current} "~|" |
			{VLSNand.left = current} "~&")	right = VLSUnitaryFormula) 
		| 
		({VLSAnd.left = current} '&' right = VLSUnitaryFormula)+
		|
		({VLSOr.left = current} '|' right = VLSUnitaryFormula)+
	)?
;

//VLSUnitaryFormula
VLSUnitaryFormula returns VLSTerm:
	VLSUniversalQuantifier  | VLSExistentialQuantifier | VLSUnaryNegation | VLSUnaryInfix | '(' VLSTerm ')'
;

VLSUniversalQuantifier  returns VLSTerm:
	{VLSUniversalQuantifier} (("!") '[' variables += VLSVariable (','  variables += VLSVariable)* ']' ':') operand = VLSUnitaryFormula
;

VLSExistentialQuantifier  returns VLSTerm:
	{VLSExistentialQuantifier} (("?") '[' variables += VLSVariable (','  variables += VLSVariable)* ']' ':') operand = VLSUnitaryFormula
;

VLSUnaryNegation   returns VLSTerm:
	{VLSUnaryNegation} ('~') operand = VLSUnitaryFormula
;

VLSUnaryInfix returns VLSTerm:
	VLSFunction (({VLSInequality.left = current} "!=" |	
		{VLSEquality.left = current} "=" |
		{VLSAssignment.left = current} ":=")
		right = VLSFunction)? 
;

/*
enum VLSDefinedFunctor:
		UMINUS='$uminus' | SUM='$sum' | DIFFERENCE='$difference' | PRODUCT='$product' | QUOTIENT='$quotient' | 
		QUOTIENT_E='$quotient_e' | QUOTIENT_T='$quotient_t' | QUOTIENT_F='$quotient_f' | REMAINDER_E='$remainder_e' |
		 REMAINDER_T='$remainder_t' | REMAINDER_F='$remainder_f' | FLOOR='$floor' | CEILING='$ceiling' |
		 TRUNCATE='$truncate' | ROUND='$round' | TO_INT='$to_int' | TO_RAT='$to_rat' | TO_REAL='$to_real'
    ;
*/

VLSFunction returns VLSTerm:
	//? on next line causes warning
	//TODO might need replace DOLLAR_ID with enum rule 
	{VLSFunction} constant = (LOWER_WORD_ID | SINGLE_QUOTE | DOLLAR_ID | DOUBLE_DOLLAR_ID ) ( '(' terms += VLSFofTerm (',' terms += VLSFofTerm)* ')')?
;

VLSFofTerm:
	//(VLSVariable | VLSFunction | VLSTffConditional | VLSTffLet | VLSTffTuple)
	(VLSVariable | VLSFunctionFof | VLSDefinedTerm )
;

VLSVariable:
	name = UPPER_WORD_ID
;

VLSFunctionFof:
	//? on next line causes warning
	//TODO might need replace DOLLAR_ID with enum rule 
	name = (LOWER_WORD_ID | SINGLE_QUOTE | DOLLAR_ID | DOUBLE_DOLLAR_ID ) ( '(' terms += VLSFofTerm (',' terms += VLSFofTerm)* ')')?
;

VLSDefinedTerm:
	name = (DOUBLE_QUOTE | SIGNED_INT_ID | SIGNED_REAL_ID | SIGNED_RAT_ID)
;
