/*
 * generated by Xtext 2.10.0
 */
package hu.bme.mit.inf.dslreasoner.tests

import com.google.inject.Inject
import hu.bme.mit.inf.dslreasoner.VampireLanguageStandaloneSetup
import hu.bme.mit.inf.dslreasoner.ecore2logic.ecore2logicannotations.Ecore2logicannotationsPackage
import hu.bme.mit.inf.dslreasoner.logic.model.logicproblem.LogicProblem
import hu.bme.mit.inf.dslreasoner.logic.model.logicproblem.LogicproblemPackage
import hu.bme.mit.inf.dslreasoner.vampire.queries.util.VLSAndQuerySpecification
import hu.bme.mit.inf.dslreasoner.vampire.queries.util.VLSAnnotationQuerySpecification
import hu.bme.mit.inf.dslreasoner.vampire.queries.util.VLSCommentQuerySpecification
import hu.bme.mit.inf.dslreasoner.vampire.queries.util.VLSEquivalentQuerySpecification
import hu.bme.mit.inf.dslreasoner.vampire.queries.util.VLSExistentialQuantifierQuerySpecification
import hu.bme.mit.inf.dslreasoner.vampire.queries.util.VLSFofFormulaQuerySpecification
import hu.bme.mit.inf.dslreasoner.vampire.queries.util.VLSFofTermQuerySpecification
import hu.bme.mit.inf.dslreasoner.vampire.queries.util.VLSFunctionFofQuerySpecification
import hu.bme.mit.inf.dslreasoner.vampire.queries.util.VLSFunctionQuerySpecification
import hu.bme.mit.inf.dslreasoner.vampire.queries.util.VLSInequalityQuerySpecification
import hu.bme.mit.inf.dslreasoner.vampire.queries.util.VLSOrQuerySpecification
import hu.bme.mit.inf.dslreasoner.vampire.queries.util.VLSUnaryNegationQuerySpecification
import hu.bme.mit.inf.dslreasoner.vampire.queries.util.VLSUniversalQuantifierQuerySpecification
import hu.bme.mit.inf.dslreasoner.vampireLanguage.VampireLanguageFactory
import hu.bme.mit.inf.dslreasoner.vampireLanguage.VampireModel
import hu.bme.mit.inf.dslreasoner.viatra2logic.viatra2logicannotations.Viatra2LogicAnnotationsPackage
import java.io.File
import java.io.IOException
import java.util.Collections
import java.util.Scanner
import logic2vampire.Logic2vampireFactory
import org.eclipse.emf.common.util.URI
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.emf.ecore.resource.ResourceSet
import org.eclipse.emf.ecore.xmi.impl.XMIResourceFactoryImpl
import org.eclipse.viatra.query.runtime.api.ViatraQueryEngine
import org.eclipse.viatra.query.runtime.emf.EMFScope
import org.eclipse.xtext.testing.InjectWith
import org.eclipse.xtext.testing.XtextRunner
import org.eclipse.xtext.testing.util.ParseHelper
import org.junit.Test
import org.junit.runner.RunWith

import static org.junit.Assert.*

@RunWith(XtextRunner)
@InjectWith(VampireLanguageInjectorProvider)
class VampireLanguageParsingTest{

	@Inject
	ParseHelper<VampireModel> parseHelper
	
	@Test 
	def void test1() {
		
		//THIS TEST reads from a file and converts the written lines into a graph model
		
		//*
		System.out.println("Beginning                     " + System.currentTimeMillis)
		val model = parseHelper.parse(new Scanner(new File("TestFiles/Test.tptp")).useDelimiter("\\Z").next())
		System.out.println("Model has been parsed:        " + System.currentTimeMillis)
		//model.eAllContents
		//System.out.println("called all model components   " + System.currentTimeMillis)
		
		// Create a query engine on the model
		val scope = new EMFScope(model)
		System.out.println("scope defined on model:       " + System.currentTimeMillis)
		val vqe = ViatraQueryEngine.on(scope)
		System.out.println("engine defined on scope:      " + System.currentTimeMillis)
		// Initialize a query on the model
		val cmtMatcher = vqe.getMatcher(VLSCommentQuerySpecification.instance())
		val fofFmlaMatcher = vqe.getMatcher(VLSFofFormulaQuerySpecification.instance())
		val AnnotMatcher = vqe.getMatcher(VLSAnnotationQuerySpecification.instance())
			
		val andMatcher = vqe.getMatcher(VLSAndQuerySpecification.instance())
		val orMatcher = vqe.getMatcher(VLSOrQuerySpecification.instance())
		val eqMatcher = vqe.getMatcher(VLSEquivalentQuerySpecification.instance())
		val fctMatcher = vqe.getMatcher(VLSFunctionQuerySpecification.instance())
		val negMatcher = vqe.getMatcher(VLSUnaryNegationQuerySpecification.instance())
		val exisMatcher = vqe.getMatcher(VLSExistentialQuantifierQuerySpecification.instance())
		val univMatcher = vqe.getMatcher(VLSUniversalQuantifierQuerySpecification.instance())
		val ineqMatcher = vqe.getMatcher(VLSInequalityQuerySpecification.instance())
		val fofFctMatcher = vqe.getMatcher(VLSFunctionFofQuerySpecification.instance())
		val fofTmMatcher = vqe.getMatcher(VLSFofTermQuerySpecification.instance())
		System.out.println("got all matchers:             " + System.currentTimeMillis)
		
		assertEquals(2, cmtMatcher.countMatches())
		assertEquals(4, fofFmlaMatcher.countMatches())
		assertEquals(8, AnnotMatcher.countMatches())		

		assertEquals(2, andMatcher.countMatches())
		assertEquals(4, orMatcher.countMatches())
		assertEquals(1, eqMatcher.countMatches())
		assertEquals(12, fctMatcher.countMatches())
		assertEquals(2, negMatcher.countMatches())
		assertEquals(2, exisMatcher.countMatches())
		assertEquals(1, univMatcher.countMatches())
		assertEquals(1, ineqMatcher.countMatches())
		assertEquals(1, fofFctMatcher.countMatches())
		assertEquals(9, fofTmMatcher.countMatches())
		System.out.println("Assertions completed:         " + System.currentTimeMillis)
		/*
		 * //Comments
		assertEquals(2, model.comments.size)
		assertEquals("%thisIsAComment", model.comments.head.comment)
		assertEquals("%123*()Comment", model.comments.drop(1).head.comment)
		//assertEquals("thisIsAComment", model.comments.head.comment)
		//assertEquals("123*()Comment", model.comments.drop(1).head.comment)
		
		//FOF FORMULAS
		assertEquals(4, model.formulas.size)
		
		assertEquals("test", model.formulas.head.name)
		assertEquals(VLSRole.AXIOM, model.formulas.head.fofRole )
		//assertEquals("cst7", n.name)
		
		//Formula2_Quantifiers, Negation
		assertEquals("-123", model.formulas.drop(1).head.name)
		assertEquals(VLSRole.CONJECTURE, model.formulas.drop(1).head.fofRole)
		
		//Formula3_Quantifier, VLSTerm
		assertEquals("0", model.formulas.drop(2).head.name)
		assertEquals(VLSRole.HYPOTHESIS, model.formulas.drop(2).head.fofRole)
		
		//Formula5_FofTerms
		assertEquals("'HE||0'", model.formulas.drop(3).head.name)
		assertEquals(VLSRole.ASSUMPTION, model.formulas.drop(3).head.fofRole)
		* */
	}
	
	@Test
	def void test2() {
		
		//THIS TEST creates a graph model step by step and creates 2 files from it: 
		//1 containing equivalent lines of code (.tptp) and 1 (.i2v) that I am guessing is just another version of the model...
		
		val injector = new VampireLanguageStandaloneSetup().createInjectorAndDoEMFRegistration()
		val rs = injector.getInstance(typeof(ResourceSet));
		
		LogicproblemPackage.eINSTANCE.eClass()
		Ecore2logicannotationsPackage.eINSTANCE.eClass()
		Viatra2LogicAnnotationsPackage.eINSTANCE.eClass()
		val reg = Resource.Factory.Registry.INSTANCE
		val map = reg.extensionToFactoryMap
		map.put("xmi", new XMIResourceFactoryImpl)
		map.put("l2v", new XMIResourceFactoryImpl)
		
		
		// Load and create top level elements
		// Load source model
		val logicURI = URI.createFileURI("LogicModels/Step1_Metamodel.xmi")
		val logRes = rs.getResource(logicURI, true)
		val logicProblem =  logRes.contents.get(0) as LogicProblem

		// Create target model
		val tptpRes = rs.createResource(URI.createURI("testCreateFile.tptp"));
		val vampireModel = VampireLanguageFactory.eINSTANCE.createVampireModel();
		
		// Create trace model
		val l2vRes = rs.createResource(URI.createURI("l2vFile.l2v"))
		val traceModel = Logic2vampireFactory.eINSTANCE.createLogic2Vampire()
		
		traceModel.logic = logicProblem
		traceModel.vampire = vampireModel
		
		// Query and create elements 		
		// Get one logic relation
		val logicRel = logicProblem.relations.get(0)
		
		// create a vampire formula
		val formula = VampireLanguageFactory.eINSTANCE.createVLSFofFormula();
		vampireModel.formulas.add(formula)
		
		formula.setName("posterPres");
		formula.setFofRole("axiom")
		val and = VampireLanguageFactory.eINSTANCE.createVLSAnd();
		val lf = VampireLanguageFactory.eINSTANCE.createVLSFunction();
		lf.setConstant("vivek")
		and.setLeft(lf)
		val rf = VampireLanguageFactory.eINSTANCE.createVLSFunction();
		rf.setConstant("aren")
		and.setRight(rf)
		formula.setFofFormula(and)

		// create trace element		
		val traceElement = Logic2vampireFactory.eINSTANCE.createLogic2VampireTrace()
		traceElement.vlsFormula.add(formula)
		traceElement.termDescription.add(logicRel)
		traceModel.traces.add(traceElement)
		
		// adding models to resources
		tptpRes.contents.add(vampireModel)
		l2vRes.contents.add(traceModel)
		try {
			tptpRes.save(Collections.EMPTY_MAP);
			l2vRes.save(Collections.EMPTY_MAP);
		} catch (IOException e) {
			e.printStackTrace();
		}
		
	}
	
	@Test
	def void testPosterPresentation() {
		
		//THIS TEST creates a graph model step by step and creates 2 files from it: 
		//1 containing the model (.xmi) and 1 containing equivalent lines of code (.tptp)
		
		// creating the resources for the model
		val injector = new VampireLanguageStandaloneSetup().createInjectorAndDoEMFRegistration()
		val rs = injector.getInstance(typeof(ResourceSet));
		
		val reg = Resource.Factory.Registry.INSTANCE
		val map = reg.extensionToFactoryMap
		map.put("xmi", new XMIResourceFactoryImpl)		

		val xmiResource = rs.createResource(URI.createURI("posterPresModel.xmi"))

		val tptpResource = rs.createResource(URI.createURI("posterPresCode.tptp"))
		val vampireModel = VampireLanguageFactory.eINSTANCE.createVampireModel()
		
		// create an instance of the Vampire metamodel
		
		//Comment
		val comment = VampireLanguageFactory.eINSTANCE.createVLSComment()
		vampireModel.comments.add(comment)
		
		comment.setComment("% Welcome to the Poster Presentation Day Demo \r")
		
		//Formula
		val formula = VampireLanguageFactory.eINSTANCE.createVLSFofFormula()
		vampireModel.formulas.add(formula)
		
		formula.setName("formulaName")
		formula.setFofRole("axiom")
		
		val exisQuant = VampireLanguageFactory.eINSTANCE.createVLSExistentialQuantifier()
		val vrbl = VampireLanguageFactory.eINSTANCE.createVLSVariable()
		vrbl.setName("X")
		exisQuant.variables.add(vrbl)
		
		val and = VampireLanguageFactory.eINSTANCE.createVLSAnd()
		val left = VampireLanguageFactory.eINSTANCE.createVLSFunction()
		left.setConstant("term1")
		and.setLeft(left)
		val right = VampireLanguageFactory.eINSTANCE.createVLSFunction()
		right.setConstant("term2")
		and.setRight(right)
		
		exisQuant.setOperand(and)
		
		formula.setFofFormula(exisQuant)
		
		val annot = VampireLanguageFactory.eINSTANCE.createVLSAnnotation()
		val closRl = VampireLanguageFactory.eINSTANCE.createVLSAnnotation()
		closRl.setName("formulaAnnotation")
		annot.setFollowup(closRl)
		formula.setAnnotations(annot)
		
		// saving the results
		xmiResource.contents.add(vampireModel)
		
		try {
			xmiResource.save(Collections.EMPTY_MAP)
		} catch (IOException e) {
			e.printStackTrace()
		}
	
		tptpResource.contents.add(vampireModel)
		
		try {
			tptpResource.save(Collections.EMPTY_MAP)
		} catch (IOException e) {
			e.printStackTrace()
		}
		}
	
}
