<?xml version="1.0" encoding="ASCII"?>
<partialinterpretation:PartialInterpretation xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:ecore2logicannotations="http://www.bme.hu/mit/inf/dslreasoner/logic/model/language/ecore2logicannotation" xmlns:language="http://www.bme.hu/mit/inf/dslreasoner/logic/model/language" xmlns:partialinterpretation="http://www.bme.hu/mit/inf/dslreasoner/viatrasolver/partialinterpretationlanguage" xmlns:viatra2logicannotations="http://www.bme.hu/mit/inf/dslreasoner/logic/model/language/viatra2logicannotation" problem="//@problemConainer" maxNewElements="0">
  <partialrelationinterpretation interpretationOf="//@problemConainer/@relations.0" param1="//@problemConainer/@relations.0/@parameters.0" param2="//@problemConainer/@relations.0/@parameters.1">
    <relationlinks xsi:type="partialinterpretation:BinaryElementRelationLink" param1="//@newElements.4" param2="//@newElements.2"/>
    <relationlinks xsi:type="partialinterpretation:BinaryElementRelationLink" param1="//@newElements.2" param2="//@newElements.4"/>
    <relationlinks xsi:type="partialinterpretation:BinaryElementRelationLink" param1="//@newElements.6" param2="//@newElements.2"/>
    <relationlinks xsi:type="partialinterpretation:BinaryElementRelationLink" param1="//@newElements.2" param2="//@newElements.6"/>
    <relationlinks xsi:type="partialinterpretation:BinaryElementRelationLink" param1="//@newElements.6" param2="//@newElements.8"/>
    <relationlinks xsi:type="partialinterpretation:BinaryElementRelationLink" param1="//@newElements.8" param2="//@newElements.6"/>
    <relationlinks xsi:type="partialinterpretation:BinaryElementRelationLink" param1="//@newElements.10" param2="//@newElements.4"/>
    <relationlinks xsi:type="partialinterpretation:BinaryElementRelationLink" param1="//@newElements.4" param2="//@newElements.10"/>
  </partialrelationinterpretation>
  <partialrelationinterpretation interpretationOf="//@problemConainer/@relations.1" param1="//@problemConainer/@relations.1/@parameters.0" param2="//@problemConainer/@relations.1/@parameters.1">
    <relationlinks xsi:type="partialinterpretation:BinaryElementRelationLink" param1="//@newElements.4" param2="//@newElements.5"/>
    <relationlinks xsi:type="partialinterpretation:BinaryElementRelationLink" param1="//@newElements.2" param2="//@newElements.3"/>
    <relationlinks xsi:type="partialinterpretation:BinaryElementRelationLink" param1="//@newElements.6" param2="//@newElements.7"/>
    <relationlinks xsi:type="partialinterpretation:BinaryElementRelationLink" param1="//@newElements.8" param2="//@newElements.9"/>
    <relationlinks xsi:type="partialinterpretation:BinaryElementRelationLink" param1="//@newElements.10" param2="//@newElements.11"/>
  </partialrelationinterpretation>
  <partialrelationinterpretation interpretationOf="//@problemConainer/@relations.2" param1="//@problemConainer/@relations.2/@parameters.0" param2="//@problemConainer/@relations.2/@parameters.1">
    <relationlinks xsi:type="partialinterpretation:BinaryElementRelationLink" param1="//@problemConainer/@elements.0" param2="//@newElements.3"/>
    <relationlinks xsi:type="partialinterpretation:BinaryElementRelationLink" param1="//@problemConainer/@elements.0" param2="//@newElements.5"/>
    <relationlinks xsi:type="partialinterpretation:BinaryElementRelationLink" param1="//@problemConainer/@elements.0" param2="//@newElements.7"/>
    <relationlinks xsi:type="partialinterpretation:BinaryElementRelationLink" param1="//@problemConainer/@elements.0" param2="//@newElements.9"/>
    <relationlinks xsi:type="partialinterpretation:BinaryElementRelationLink" param1="//@problemConainer/@elements.0" param2="//@newElements.11"/>
  </partialrelationinterpretation>
  <partialrelationinterpretation interpretationOf="//@problemConainer/@relations.3" param1="//@problemConainer/@relations.3/@parameters.0" param2="//@problemConainer/@relations.3/@parameters.1">
    <relationlinks xsi:type="partialinterpretation:BinaryElementRelationLink" param1="//@problemConainer/@elements.0" param2="//@newElements.4"/>
    <relationlinks xsi:type="partialinterpretation:BinaryElementRelationLink" param1="//@problemConainer/@elements.0" param2="//@newElements.6"/>
    <relationlinks xsi:type="partialinterpretation:BinaryElementRelationLink" param1="//@problemConainer/@elements.0" param2="//@newElements.8"/>
    <relationlinks xsi:type="partialinterpretation:BinaryElementRelationLink" param1="//@problemConainer/@elements.0" param2="//@newElements.10"/>
  </partialrelationinterpretation>
  <partialrelationinterpretation interpretationOf="//@problemConainer/@relations.4" param1="//@problemConainer/@relations.4/@parameters.0" param2="//@problemConainer/@relations.4/@parameters.1">
    <relationlinks xsi:type="partialinterpretation:BinaryElementRelationLink" param1="//@problemConainer/@elements.0" param2="//@newElements.2"/>
  </partialrelationinterpretation>
  <partialrelationinterpretation interpretationOf="//@problemConainer/@relations.5" param1="//@problemConainer/@relations.5/@parameters.0" param2="//@problemConainer/@relations.5/@parameters.1">
    <relationlinks xsi:type="partialinterpretation:BinaryElementRelationLink" param1="//@newElements.2" param2="//@newElements.8"/>
  </partialrelationinterpretation>
  <partialrelationinterpretation interpretationOf="//@problemConainer/@relations.6" param1="//@problemConainer/@relations.6/@parameters.0" param2="//@problemConainer/@relations.6/@parameters.1">
    <relationlinks xsi:type="partialinterpretation:BinaryElementRelationLink" param1="//@newElements.2" param2="//@newElements.4"/>
  </partialrelationinterpretation>
  <partialrelationinterpretation interpretationOf="//@problemConainer/@relations.7" param1="//@problemConainer/@relations.7/@parameters.0" param2="//@problemConainer/@relations.7/@parameters.1">
    <relationlinks xsi:type="partialinterpretation:BinaryElementRelationLink" param1="//@newElements.5" param2="//@newElements.4"/>
    <relationlinks xsi:type="partialinterpretation:BinaryElementRelationLink" param1="//@newElements.3" param2="//@newElements.2"/>
    <relationlinks xsi:type="partialinterpretation:BinaryElementRelationLink" param1="//@newElements.7" param2="//@newElements.6"/>
    <relationlinks xsi:type="partialinterpretation:BinaryElementRelationLink" param1="//@newElements.9" param2="//@newElements.8"/>
    <relationlinks xsi:type="partialinterpretation:BinaryElementRelationLink" param1="//@newElements.11" param2="//@newElements.10"/>
  </partialrelationinterpretation>
  <newElements xsi:type="partialinterpretation:BooleanElement" name="true" valueSet="true" value="true"/>
  <newElements xsi:type="partialinterpretation:BooleanElement" name="false" valueSet="true"/>
  <newElements/>
  <newElements/>
  <newElements/>
  <newElements/>
  <newElements/>
  <newElements/>
  <newElements/>
  <newElements/>
  <newElements/>
  <newElements/>
  <partialtypeinterpratation xsi:type="partialinterpretation:PartialBooleanInterpretation" elements="//@newElements.0 //@newElements.1"/>
  <partialtypeinterpratation xsi:type="partialinterpretation:PartialIntegerInterpretation" elements="//@openWorldElements.0"/>
  <partialtypeinterpratation xsi:type="partialinterpretation:PartialRealInterpretation" elements="//@openWorldElements.1"/>
  <partialtypeinterpratation xsi:type="partialinterpretation:PartialStringInterpretation" elements="//@openWorldElements.2"/>
  <partialtypeinterpratation xsi:type="partialinterpretation:PartialComplexTypeInterpretation" elements="//@newElements.2 //@newElements.4 //@newElements.6 //@newElements.8 //@newElements.10" scopes="//@scopes.0" interpretationOf="//@problemConainer/@types.0"/>
  <partialtypeinterpratation xsi:type="partialinterpretation:PartialComplexTypeInterpretation" elements="//@problemConainer/@elements.0" scopes="//@scopes.1" interpretationOf="//@problemConainer/@types.1"/>
  <partialtypeinterpratation xsi:type="partialinterpretation:PartialComplexTypeInterpretation" elements="//@newElements.2" scopes="//@scopes.2" supertypeInterpretation="//@partialtypeinterpratation.4" interpretationOf="//@problemConainer/@types.2"/>
  <partialtypeinterpratation xsi:type="partialinterpretation:PartialComplexTypeInterpretation" elements="//@newElements.3 //@newElements.5 //@newElements.7 //@newElements.9 //@newElements.11" scopes="//@scopes.3" interpretationOf="//@problemConainer/@types.3"/>
  <partialtypeinterpratation xsi:type="partialinterpretation:PartialComplexTypeInterpretation" scopes="//@scopes.4" supertypeInterpretation="//@partialtypeinterpratation.5" interpretationOf="//@problemConainer/@types.5"/>
  <openWorldElements xsi:type="partialinterpretation:IntegerElement" name="New Integers"/>
  <openWorldElements xsi:type="partialinterpretation:RealElement" name="New Reals"/>
  <openWorldElements xsi:type="partialinterpretation:StringElement" name="New Strings"/>
  <openWorldElements name="New Objects"/>
  <problemConainer>
    <types xsi:type="language:TypeDeclaration" name="Segment class" subtypes="//@problemConainer/@types.2"/>
    <types xsi:type="language:TypeDeclaration" name="Modes3ModelRoot class" subtypes="//@problemConainer/@types.4 //@problemConainer/@types.5" isAbstract="true"/>
    <types xsi:type="language:TypeDeclaration" name="Turnout class" supertypes="//@problemConainer/@types.0"/>
    <types xsi:type="language:TypeDeclaration" name="Train class"/>
    <types xsi:type="language:TypeDefinition" name="Modes3ModelRoot class DefinedPart" supertypes="//@problemConainer/@types.1" elements="//@problemConainer/@elements.0"/>
    <types xsi:type="language:TypeDeclaration" name="Modes3ModelRoot class UndefinedPart" supertypes="//@problemConainer/@types.1"/>
    <assertions name="upperMultiplicity connectedTo Segment" annotations="//@problemConainer/@annotations.0">
      <value xsi:type="language:Forall">
        <quantifiedVariables name="src">
          <range xsi:type="language:ComplexTypeReference" referred="//@problemConainer/@types.0"/>
        </quantifiedVariables>
        <quantifiedVariables name="trg 1">
          <range xsi:type="language:ComplexTypeReference" referred="//@problemConainer/@types.0"/>
        </quantifiedVariables>
        <quantifiedVariables name="trg 2">
          <range xsi:type="language:ComplexTypeReference" referred="//@problemConainer/@types.0"/>
        </quantifiedVariables>
        <quantifiedVariables name="trg 3">
          <range xsi:type="language:ComplexTypeReference" referred="//@problemConainer/@types.0"/>
        </quantifiedVariables>
        <expression xsi:type="language:Impl">
          <leftOperand xsi:type="language:And">
            <operands xsi:type="language:SymbolicValue" symbolicReference="//@problemConainer/@relations.0">
              <parameterSubstitutions xsi:type="language:SymbolicValue" symbolicReference="//@problemConainer/@assertions.0/@value/@quantifiedVariables.0"/>
              <parameterSubstitutions xsi:type="language:SymbolicValue" symbolicReference="//@problemConainer/@assertions.0/@value/@quantifiedVariables.1"/>
            </operands>
            <operands xsi:type="language:SymbolicValue" symbolicReference="//@problemConainer/@relations.0">
              <parameterSubstitutions xsi:type="language:SymbolicValue" symbolicReference="//@problemConainer/@assertions.0/@value/@quantifiedVariables.0"/>
              <parameterSubstitutions xsi:type="language:SymbolicValue" symbolicReference="//@problemConainer/@assertions.0/@value/@quantifiedVariables.2"/>
            </operands>
            <operands xsi:type="language:SymbolicValue" symbolicReference="//@problemConainer/@relations.0">
              <parameterSubstitutions xsi:type="language:SymbolicValue" symbolicReference="//@problemConainer/@assertions.0/@value/@quantifiedVariables.0"/>
              <parameterSubstitutions xsi:type="language:SymbolicValue" symbolicReference="//@problemConainer/@assertions.0/@value/@quantifiedVariables.3"/>
            </operands>
          </leftOperand>
          <rightOperand xsi:type="language:Not">
            <operand xsi:type="language:Distinct">
              <operands xsi:type="language:SymbolicValue" symbolicReference="//@problemConainer/@assertions.0/@value/@quantifiedVariables.1"/>
              <operands xsi:type="language:SymbolicValue" symbolicReference="//@problemConainer/@assertions.0/@value/@quantifiedVariables.2"/>
              <operands xsi:type="language:SymbolicValue" symbolicReference="//@problemConainer/@assertions.0/@value/@quantifiedVariables.3"/>
            </operand>
          </rightOperand>
        </expression>
      </value>
    </assertions>
    <assertions name="upperMultiplicity occupiedBy Segment" annotations="//@problemConainer/@annotations.1">
      <value xsi:type="language:Forall">
        <quantifiedVariables name="src">
          <range xsi:type="language:ComplexTypeReference" referred="//@problemConainer/@types.0"/>
        </quantifiedVariables>
        <quantifiedVariables name="trg 1">
          <range xsi:type="language:ComplexTypeReference" referred="//@problemConainer/@types.3"/>
        </quantifiedVariables>
        <quantifiedVariables name="trg 2">
          <range xsi:type="language:ComplexTypeReference" referred="//@problemConainer/@types.3"/>
        </quantifiedVariables>
        <expression xsi:type="language:Impl">
          <leftOperand xsi:type="language:And">
            <operands xsi:type="language:SymbolicValue" symbolicReference="//@problemConainer/@relations.1">
              <parameterSubstitutions xsi:type="language:SymbolicValue" symbolicReference="//@problemConainer/@assertions.1/@value/@quantifiedVariables.0"/>
              <parameterSubstitutions xsi:type="language:SymbolicValue" symbolicReference="//@problemConainer/@assertions.1/@value/@quantifiedVariables.1"/>
            </operands>
            <operands xsi:type="language:SymbolicValue" symbolicReference="//@problemConainer/@relations.1">
              <parameterSubstitutions xsi:type="language:SymbolicValue" symbolicReference="//@problemConainer/@assertions.1/@value/@quantifiedVariables.0"/>
              <parameterSubstitutions xsi:type="language:SymbolicValue" symbolicReference="//@problemConainer/@assertions.1/@value/@quantifiedVariables.2"/>
            </operands>
          </leftOperand>
          <rightOperand xsi:type="language:Not">
            <operand xsi:type="language:Distinct">
              <operands xsi:type="language:SymbolicValue" symbolicReference="//@problemConainer/@assertions.1/@value/@quantifiedVariables.1"/>
              <operands xsi:type="language:SymbolicValue" symbolicReference="//@problemConainer/@assertions.1/@value/@quantifiedVariables.2"/>
            </operand>
          </rightOperand>
        </expression>
      </value>
    </assertions>
    <assertions name="lowerMultiplicity straight Turnout" annotations="//@problemConainer/@annotations.2">
      <value xsi:type="language:Forall">
        <quantifiedVariables name="src">
          <range xsi:type="language:ComplexTypeReference" referred="//@problemConainer/@types.2"/>
        </quantifiedVariables>
        <expression xsi:type="language:Exists">
          <quantifiedVariables name="trg 1">
            <range xsi:type="language:ComplexTypeReference" referred="//@problemConainer/@types.0"/>
          </quantifiedVariables>
          <expression xsi:type="language:And">
            <operands xsi:type="language:SymbolicValue" symbolicReference="//@problemConainer/@relations.5">
              <parameterSubstitutions xsi:type="language:SymbolicValue" symbolicReference="//@problemConainer/@assertions.2/@value/@quantifiedVariables.0"/>
              <parameterSubstitutions xsi:type="language:SymbolicValue" symbolicReference="//@problemConainer/@assertions.2/@value/@expression/@quantifiedVariables.0"/>
            </operands>
          </expression>
        </expression>
      </value>
    </assertions>
    <assertions name="upperMultiplicity straight Turnout" annotations="//@problemConainer/@annotations.3">
      <value xsi:type="language:Forall">
        <quantifiedVariables name="src">
          <range xsi:type="language:ComplexTypeReference" referred="//@problemConainer/@types.2"/>
        </quantifiedVariables>
        <quantifiedVariables name="trg 1">
          <range xsi:type="language:ComplexTypeReference" referred="//@problemConainer/@types.0"/>
        </quantifiedVariables>
        <quantifiedVariables name="trg 2">
          <range xsi:type="language:ComplexTypeReference" referred="//@problemConainer/@types.0"/>
        </quantifiedVariables>
        <expression xsi:type="language:Impl">
          <leftOperand xsi:type="language:And">
            <operands xsi:type="language:SymbolicValue" symbolicReference="//@problemConainer/@relations.5">
              <parameterSubstitutions xsi:type="language:SymbolicValue" symbolicReference="//@problemConainer/@assertions.3/@value/@quantifiedVariables.0"/>
              <parameterSubstitutions xsi:type="language:SymbolicValue" symbolicReference="//@problemConainer/@assertions.3/@value/@quantifiedVariables.1"/>
            </operands>
            <operands xsi:type="language:SymbolicValue" symbolicReference="//@problemConainer/@relations.5">
              <parameterSubstitutions xsi:type="language:SymbolicValue" symbolicReference="//@problemConainer/@assertions.3/@value/@quantifiedVariables.0"/>
              <parameterSubstitutions xsi:type="language:SymbolicValue" symbolicReference="//@problemConainer/@assertions.3/@value/@quantifiedVariables.2"/>
            </operands>
          </leftOperand>
          <rightOperand xsi:type="language:Not">
            <operand xsi:type="language:Distinct">
              <operands xsi:type="language:SymbolicValue" symbolicReference="//@problemConainer/@assertions.3/@value/@quantifiedVariables.1"/>
              <operands xsi:type="language:SymbolicValue" symbolicReference="//@problemConainer/@assertions.3/@value/@quantifiedVariables.2"/>
            </operand>
          </rightOperand>
        </expression>
      </value>
    </assertions>
    <assertions name="lowerMultiplicity divergent Turnout" annotations="//@problemConainer/@annotations.4">
      <value xsi:type="language:Forall">
        <quantifiedVariables name="src">
          <range xsi:type="language:ComplexTypeReference" referred="//@problemConainer/@types.2"/>
        </quantifiedVariables>
        <expression xsi:type="language:Exists">
          <quantifiedVariables name="trg 1">
            <range xsi:type="language:ComplexTypeReference" referred="//@problemConainer/@types.0"/>
          </quantifiedVariables>
          <expression xsi:type="language:And">
            <operands xsi:type="language:SymbolicValue" symbolicReference="//@problemConainer/@relations.6">
              <parameterSubstitutions xsi:type="language:SymbolicValue" symbolicReference="//@problemConainer/@assertions.4/@value/@quantifiedVariables.0"/>
              <parameterSubstitutions xsi:type="language:SymbolicValue" symbolicReference="//@problemConainer/@assertions.4/@value/@expression/@quantifiedVariables.0"/>
            </operands>
          </expression>
        </expression>
      </value>
    </assertions>
    <assertions name="upperMultiplicity divergent Turnout" annotations="//@problemConainer/@annotations.5">
      <value xsi:type="language:Forall">
        <quantifiedVariables name="src">
          <range xsi:type="language:ComplexTypeReference" referred="//@problemConainer/@types.2"/>
        </quantifiedVariables>
        <quantifiedVariables name="trg 1">
          <range xsi:type="language:ComplexTypeReference" referred="//@problemConainer/@types.0"/>
        </quantifiedVariables>
        <quantifiedVariables name="trg 2">
          <range xsi:type="language:ComplexTypeReference" referred="//@problemConainer/@types.0"/>
        </quantifiedVariables>
        <expression xsi:type="language:Impl">
          <leftOperand xsi:type="language:And">
            <operands xsi:type="language:SymbolicValue" symbolicReference="//@problemConainer/@relations.6">
              <parameterSubstitutions xsi:type="language:SymbolicValue" symbolicReference="//@problemConainer/@assertions.5/@value/@quantifiedVariables.0"/>
              <parameterSubstitutions xsi:type="language:SymbolicValue" symbolicReference="//@problemConainer/@assertions.5/@value/@quantifiedVariables.1"/>
            </operands>
            <operands xsi:type="language:SymbolicValue" symbolicReference="//@problemConainer/@relations.6">
              <parameterSubstitutions xsi:type="language:SymbolicValue" symbolicReference="//@problemConainer/@assertions.5/@value/@quantifiedVariables.0"/>
              <parameterSubstitutions xsi:type="language:SymbolicValue" symbolicReference="//@problemConainer/@assertions.5/@value/@quantifiedVariables.2"/>
            </operands>
          </leftOperand>
          <rightOperand xsi:type="language:Not">
            <operand xsi:type="language:Distinct">
              <operands xsi:type="language:SymbolicValue" symbolicReference="//@problemConainer/@assertions.5/@value/@quantifiedVariables.1"/>
              <operands xsi:type="language:SymbolicValue" symbolicReference="//@problemConainer/@assertions.5/@value/@quantifiedVariables.2"/>
            </operand>
          </rightOperand>
        </expression>
      </value>
    </assertions>
    <assertions name="lowerMultiplicity location Train" annotations="//@problemConainer/@annotations.6">
      <value xsi:type="language:Forall">
        <quantifiedVariables name="src">
          <range xsi:type="language:ComplexTypeReference" referred="//@problemConainer/@types.3"/>
        </quantifiedVariables>
        <expression xsi:type="language:Exists">
          <quantifiedVariables name="trg 1">
            <range xsi:type="language:ComplexTypeReference" referred="//@problemConainer/@types.0"/>
          </quantifiedVariables>
          <expression xsi:type="language:And">
            <operands xsi:type="language:SymbolicValue" symbolicReference="//@problemConainer/@relations.7">
              <parameterSubstitutions xsi:type="language:SymbolicValue" symbolicReference="//@problemConainer/@assertions.6/@value/@quantifiedVariables.0"/>
              <parameterSubstitutions xsi:type="language:SymbolicValue" symbolicReference="//@problemConainer/@assertions.6/@value/@expression/@quantifiedVariables.0"/>
            </operands>
          </expression>
        </expression>
      </value>
    </assertions>
    <assertions name="upperMultiplicity location Train" annotations="//@problemConainer/@annotations.7">
      <value xsi:type="language:Forall">
        <quantifiedVariables name="src">
          <range xsi:type="language:ComplexTypeReference" referred="//@problemConainer/@types.3"/>
        </quantifiedVariables>
        <quantifiedVariables name="trg 1">
          <range xsi:type="language:ComplexTypeReference" referred="//@problemConainer/@types.0"/>
        </quantifiedVariables>
        <quantifiedVariables name="trg 2">
          <range xsi:type="language:ComplexTypeReference" referred="//@problemConainer/@types.0"/>
        </quantifiedVariables>
        <expression xsi:type="language:Impl">
          <leftOperand xsi:type="language:And">
            <operands xsi:type="language:SymbolicValue" symbolicReference="//@problemConainer/@relations.7">
              <parameterSubstitutions xsi:type="language:SymbolicValue" symbolicReference="//@problemConainer/@assertions.7/@value/@quantifiedVariables.0"/>
              <parameterSubstitutions xsi:type="language:SymbolicValue" symbolicReference="//@problemConainer/@assertions.7/@value/@quantifiedVariables.1"/>
            </operands>
            <operands xsi:type="language:SymbolicValue" symbolicReference="//@problemConainer/@relations.7">
              <parameterSubstitutions xsi:type="language:SymbolicValue" symbolicReference="//@problemConainer/@assertions.7/@value/@quantifiedVariables.0"/>
              <parameterSubstitutions xsi:type="language:SymbolicValue" symbolicReference="//@problemConainer/@assertions.7/@value/@quantifiedVariables.2"/>
            </operands>
          </leftOperand>
          <rightOperand xsi:type="language:Not">
            <operand xsi:type="language:Distinct">
              <operands xsi:type="language:SymbolicValue" symbolicReference="//@problemConainer/@assertions.7/@value/@quantifiedVariables.1"/>
              <operands xsi:type="language:SymbolicValue" symbolicReference="//@problemConainer/@assertions.7/@value/@quantifiedVariables.2"/>
            </operand>
          </rightOperand>
        </expression>
      </value>
    </assertions>
    <assertions name="oppositeReference occupiedBy Segment" annotations="//@problemConainer/@annotations.8">
      <value xsi:type="language:Forall">
        <quantifiedVariables name="src">
          <range xsi:type="language:ComplexTypeReference" referred="//@problemConainer/@types.0"/>
        </quantifiedVariables>
        <quantifiedVariables name="trg">
          <range xsi:type="language:ComplexTypeReference" referred="//@problemConainer/@types.3"/>
        </quantifiedVariables>
        <expression xsi:type="language:Iff">
          <leftOperand xsi:type="language:SymbolicValue" symbolicReference="//@problemConainer/@relations.1">
            <parameterSubstitutions xsi:type="language:SymbolicValue" symbolicReference="//@problemConainer/@assertions.8/@value/@quantifiedVariables.0"/>
            <parameterSubstitutions xsi:type="language:SymbolicValue" symbolicReference="//@problemConainer/@assertions.8/@value/@quantifiedVariables.1"/>
          </leftOperand>
          <rightOperand xsi:type="language:SymbolicValue" symbolicReference="//@problemConainer/@relations.7">
            <parameterSubstitutions xsi:type="language:SymbolicValue" symbolicReference="//@problemConainer/@assertions.8/@value/@quantifiedVariables.1"/>
            <parameterSubstitutions xsi:type="language:SymbolicValue" symbolicReference="//@problemConainer/@assertions.8/@value/@quantifiedVariables.0"/>
          </rightOperand>
        </expression>
      </value>
    </assertions>
    <assertions name="oppositeReference connectedTo reference Segment connectedTo reference Segment" annotations="//@problemConainer/@annotations.9">
      <value xsi:type="language:Forall">
        <quantifiedVariables name="src">
          <range xsi:type="language:ComplexTypeReference" referred="//@problemConainer/@types.0"/>
        </quantifiedVariables>
        <quantifiedVariables name="trg">
          <range xsi:type="language:ComplexTypeReference" referred="//@problemConainer/@types.0"/>
        </quantifiedVariables>
        <expression xsi:type="language:Iff">
          <leftOperand xsi:type="language:SymbolicValue" symbolicReference="//@problemConainer/@relations.0">
            <parameterSubstitutions xsi:type="language:SymbolicValue" symbolicReference="//@problemConainer/@assertions.9/@value/@quantifiedVariables.0"/>
            <parameterSubstitutions xsi:type="language:SymbolicValue" symbolicReference="//@problemConainer/@assertions.9/@value/@quantifiedVariables.1"/>
          </leftOperand>
          <rightOperand xsi:type="language:SymbolicValue" symbolicReference="//@problemConainer/@relations.0">
            <parameterSubstitutions xsi:type="language:SymbolicValue" symbolicReference="//@problemConainer/@assertions.9/@value/@quantifiedVariables.1"/>
            <parameterSubstitutions xsi:type="language:SymbolicValue" symbolicReference="//@problemConainer/@assertions.9/@value/@quantifiedVariables.0"/>
          </rightOperand>
        </expression>
      </value>
    </assertions>
    <assertions name="errorpattern modes3 queries turnoutInSegments" annotations="//@problemConainer/@annotations.27">
      <value xsi:type="language:Forall">
        <quantifiedVariables name="p0">
          <range xsi:type="language:ComplexTypeReference" referred="//@problemConainer/@types.2"/>
        </quantifiedVariables>
        <expression xsi:type="language:Not">
          <operand xsi:type="language:SymbolicValue" symbolicReference="//@problemConainer/@relations.8">
            <parameterSubstitutions xsi:type="language:SymbolicValue" symbolicReference="//@problemConainer/@assertions.10/@value/@quantifiedVariables.0"/>
          </operand>
        </expression>
      </value>
    </assertions>
    <assertions name="errorpattern modes3 queries tooManyInputsOfSegment" annotations="//@problemConainer/@annotations.28">
      <value xsi:type="language:Forall">
        <quantifiedVariables name="p0">
          <range xsi:type="language:ComplexTypeReference" referred="//@problemConainer/@types.0"/>
        </quantifiedVariables>
        <expression xsi:type="language:Not">
          <operand xsi:type="language:SymbolicValue" symbolicReference="//@problemConainer/@relations.9">
            <parameterSubstitutions xsi:type="language:SymbolicValue" symbolicReference="//@problemConainer/@assertions.11/@value/@quantifiedVariables.0"/>
          </operand>
        </expression>
      </value>
    </assertions>
    <assertions name="errorpattern modes3 queries turnoutConnectedToBothOutputs" annotations="//@problemConainer/@annotations.29">
      <value xsi:type="language:Forall">
        <quantifiedVariables name="p0">
          <range xsi:type="language:ComplexTypeReference" referred="//@problemConainer/@types.2"/>
        </quantifiedVariables>
        <expression xsi:type="language:Not">
          <operand xsi:type="language:SymbolicValue" symbolicReference="//@problemConainer/@relations.10">
            <parameterSubstitutions xsi:type="language:SymbolicValue" symbolicReference="//@problemConainer/@assertions.12/@value/@quantifiedVariables.0"/>
          </operand>
        </expression>
      </value>
    </assertions>
    <assertions name="errorpattern modes3 queries turnoutOutputsAreSame" annotations="//@problemConainer/@annotations.30">
      <value xsi:type="language:Forall">
        <quantifiedVariables name="p0">
          <range xsi:type="language:ComplexTypeReference" referred="//@problemConainer/@types.2"/>
        </quantifiedVariables>
        <expression xsi:type="language:Not">
          <operand xsi:type="language:SymbolicValue" symbolicReference="//@problemConainer/@relations.12">
            <parameterSubstitutions xsi:type="language:SymbolicValue" symbolicReference="//@problemConainer/@assertions.13/@value/@quantifiedVariables.0"/>
          </operand>
        </expression>
      </value>
    </assertions>
    <assertions name="errorpattern modes3 queries tooManyExtraInputsOfTurnout" annotations="//@problemConainer/@annotations.31">
      <value xsi:type="language:Forall">
        <quantifiedVariables name="p0">
          <range xsi:type="language:ComplexTypeReference" referred="//@problemConainer/@types.2"/>
        </quantifiedVariables>
        <expression xsi:type="language:Not">
          <operand xsi:type="language:SymbolicValue" symbolicReference="//@problemConainer/@relations.13">
            <parameterSubstitutions xsi:type="language:SymbolicValue" symbolicReference="//@problemConainer/@assertions.14/@value/@quantifiedVariables.0"/>
          </operand>
        </expression>
      </value>
    </assertions>
    <assertions name="errorpattern modes3 queries unreachable" annotations="//@problemConainer/@annotations.32">
      <value xsi:type="language:Forall">
        <quantifiedVariables name="p0">
          <range xsi:type="language:ComplexTypeReference" referred="//@problemConainer/@types.0"/>
        </quantifiedVariables>
        <quantifiedVariables name="p1">
          <range xsi:type="language:ComplexTypeReference" referred="//@problemConainer/@types.0"/>
        </quantifiedVariables>
        <expression xsi:type="language:Not">
          <operand xsi:type="language:SymbolicValue" symbolicReference="//@problemConainer/@relations.14">
            <parameterSubstitutions xsi:type="language:SymbolicValue" symbolicReference="//@problemConainer/@assertions.15/@value/@quantifiedVariables.0"/>
            <parameterSubstitutions xsi:type="language:SymbolicValue" symbolicReference="//@problemConainer/@assertions.15/@value/@quantifiedVariables.1"/>
          </operand>
        </expression>
      </value>
    </assertions>
    <assertions name="errorpattern modes3 queries connectedToReflexive" annotations="//@problemConainer/@annotations.33">
      <value xsi:type="language:Forall">
        <quantifiedVariables name="p0">
          <range xsi:type="language:ComplexTypeReference" referred="//@problemConainer/@types.0"/>
        </quantifiedVariables>
        <expression xsi:type="language:Not">
          <operand xsi:type="language:SymbolicValue" symbolicReference="//@problemConainer/@relations.15">
            <parameterSubstitutions xsi:type="language:SymbolicValue" symbolicReference="//@problemConainer/@assertions.16/@value/@quantifiedVariables.0"/>
          </operand>
        </expression>
      </value>
    </assertions>
    <assertions name="errorpattern modes3 queries outputReflexive" annotations="//@problemConainer/@annotations.34">
      <value xsi:type="language:Forall">
        <quantifiedVariables name="p0">
          <range xsi:type="language:ComplexTypeReference" referred="//@problemConainer/@types.2"/>
        </quantifiedVariables>
        <expression xsi:type="language:Not">
          <operand xsi:type="language:SymbolicValue" symbolicReference="//@problemConainer/@relations.18">
            <parameterSubstitutions xsi:type="language:SymbolicValue" symbolicReference="//@problemConainer/@assertions.17/@value/@quantifiedVariables.0"/>
          </operand>
        </expression>
      </value>
    </assertions>
    <assertions name="errorpattern modes3 queries noExtraInputOfTurnout" annotations="//@problemConainer/@annotations.35">
      <value xsi:type="language:Forall">
        <quantifiedVariables name="p0">
          <range xsi:type="language:ComplexTypeReference" referred="//@problemConainer/@types.2"/>
        </quantifiedVariables>
        <expression xsi:type="language:Not">
          <operand xsi:type="language:SymbolicValue" symbolicReference="//@problemConainer/@relations.22">
            <parameterSubstitutions xsi:type="language:SymbolicValue" symbolicReference="//@problemConainer/@assertions.18/@value/@quantifiedVariables.0"/>
          </operand>
        </expression>
      </value>
    </assertions>
    <assertions name="errorpattern modes3 queries connectedToNotSymmetric" annotations="//@problemConainer/@annotations.36">
      <value xsi:type="language:Forall">
        <quantifiedVariables name="p0">
          <range xsi:type="language:ComplexTypeReference" referred="//@problemConainer/@types.0"/>
        </quantifiedVariables>
        <quantifiedVariables name="p1">
          <range xsi:type="language:ComplexTypeReference" referred="//@problemConainer/@types.0"/>
        </quantifiedVariables>
        <expression xsi:type="language:Not">
          <operand xsi:type="language:SymbolicValue" symbolicReference="//@problemConainer/@relations.23">
            <parameterSubstitutions xsi:type="language:SymbolicValue" symbolicReference="//@problemConainer/@assertions.19/@value/@quantifiedVariables.0"/>
            <parameterSubstitutions xsi:type="language:SymbolicValue" symbolicReference="//@problemConainer/@assertions.19/@value/@quantifiedVariables.1"/>
          </operand>
        </expression>
      </value>
    </assertions>
    <relations xsi:type="language:RelationDeclaration" name="connectedTo reference Segment">
      <parameters xsi:type="language:ComplexTypeReference" referred="//@problemConainer/@types.0"/>
      <parameters xsi:type="language:ComplexTypeReference" referred="//@problemConainer/@types.0"/>
    </relations>
    <relations xsi:type="language:RelationDeclaration" name="occupiedBy reference Segment">
      <parameters xsi:type="language:ComplexTypeReference" referred="//@problemConainer/@types.0"/>
      <parameters xsi:type="language:ComplexTypeReference" referred="//@problemConainer/@types.3"/>
    </relations>
    <relations xsi:type="language:RelationDeclaration" name="trains reference Modes3ModelRoot">
      <parameters xsi:type="language:ComplexTypeReference" referred="//@problemConainer/@types.1"/>
      <parameters xsi:type="language:ComplexTypeReference" referred="//@problemConainer/@types.3"/>
    </relations>
    <relations xsi:type="language:RelationDeclaration" name="segments reference Modes3ModelRoot">
      <parameters xsi:type="language:ComplexTypeReference" referred="//@problemConainer/@types.1"/>
      <parameters xsi:type="language:ComplexTypeReference" referred="//@problemConainer/@types.0"/>
    </relations>
    <relations xsi:type="language:RelationDeclaration" name="turnouts reference Modes3ModelRoot">
      <parameters xsi:type="language:ComplexTypeReference" referred="//@problemConainer/@types.1"/>
      <parameters xsi:type="language:ComplexTypeReference" referred="//@problemConainer/@types.2"/>
    </relations>
    <relations xsi:type="language:RelationDeclaration" name="straight reference Turnout">
      <parameters xsi:type="language:ComplexTypeReference" referred="//@problemConainer/@types.2"/>
      <parameters xsi:type="language:ComplexTypeReference" referred="//@problemConainer/@types.0"/>
    </relations>
    <relations xsi:type="language:RelationDeclaration" name="divergent reference Turnout">
      <parameters xsi:type="language:ComplexTypeReference" referred="//@problemConainer/@types.2"/>
      <parameters xsi:type="language:ComplexTypeReference" referred="//@problemConainer/@types.0"/>
    </relations>
    <relations xsi:type="language:RelationDeclaration" name="location reference Train">
      <parameters xsi:type="language:ComplexTypeReference" referred="//@problemConainer/@types.3"/>
      <parameters xsi:type="language:ComplexTypeReference" referred="//@problemConainer/@types.0"/>
    </relations>
    <relations xsi:type="language:RelationDefinition" name="pattern modes3 queries turnoutInSegments" annotations="//@problemConainer/@annotations.10">
      <parameters xsi:type="language:ComplexTypeReference" referred="//@problemConainer/@types.2"/>
      <variables name="parameter T">
        <range xsi:type="language:ComplexTypeReference" referred="//@problemConainer/@types.2"/>
      </variables>
      <value xsi:type="language:Or">
        <operands xsi:type="language:Exists">
          <quantifiedVariables name="variable 0">
            <range xsi:type="language:ComplexTypeReference" referred="//@problemConainer/@types.1"/>
          </quantifiedVariables>
          <expression xsi:type="language:And">
            <operands xsi:type="language:InstanceOf">
              <value xsi:type="language:SymbolicValue" symbolicReference="//@problemConainer/@relations.8/@variables.0"/>
              <range xsi:type="language:ComplexTypeReference" referred="//@problemConainer/@types.2"/>
            </operands>
            <operands xsi:type="language:SymbolicValue" symbolicReference="//@problemConainer/@relations.3">
              <parameterSubstitutions xsi:type="language:SymbolicValue" symbolicReference="//@problemConainer/@relations.8/@value/@operands.0/@quantifiedVariables.0"/>
              <parameterSubstitutions xsi:type="language:SymbolicValue" symbolicReference="//@problemConainer/@relations.8/@variables.0"/>
            </operands>
          </expression>
        </operands>
      </value>
    </relations>
    <relations xsi:type="language:RelationDefinition" name="pattern modes3 queries tooManyInputsOfSegment" annotations="//@problemConainer/@annotations.11">
      <parameters xsi:type="language:ComplexTypeReference" referred="//@problemConainer/@types.0"/>
      <variables name="parameter S">
        <range xsi:type="language:ComplexTypeReference" referred="//@problemConainer/@types.0"/>
      </variables>
      <value xsi:type="language:Or">
        <operands xsi:type="language:Exists">
          <quantifiedVariables name="variable I1">
            <range xsi:type="language:ComplexTypeReference" referred="//@problemConainer/@types.0"/>
          </quantifiedVariables>
          <quantifiedVariables name="variable I2">
            <range xsi:type="language:ComplexTypeReference" referred="//@problemConainer/@types.0"/>
          </quantifiedVariables>
          <quantifiedVariables name="variable I3">
            <range xsi:type="language:ComplexTypeReference" referred="//@problemConainer/@types.0"/>
          </quantifiedVariables>
          <expression xsi:type="language:And">
            <operands xsi:type="language:Not">
              <operand xsi:type="language:SymbolicValue" symbolicReference="//@problemConainer/@relations.11">
                <parameterSubstitutions xsi:type="language:SymbolicValue" symbolicReference="//@problemConainer/@relations.9/@variables.0"/>
              </operand>
            </operands>
            <operands xsi:type="language:SymbolicValue" symbolicReference="//@problemConainer/@relations.24">
              <parameterSubstitutions xsi:type="language:SymbolicValue" symbolicReference="//@problemConainer/@relations.9/@value/@operands.0/@quantifiedVariables.0"/>
              <parameterSubstitutions xsi:type="language:SymbolicValue" symbolicReference="//@problemConainer/@relations.9/@variables.0"/>
            </operands>
            <operands xsi:type="language:SymbolicValue" symbolicReference="//@problemConainer/@relations.24">
              <parameterSubstitutions xsi:type="language:SymbolicValue" symbolicReference="//@problemConainer/@relations.9/@value/@operands.0/@quantifiedVariables.1"/>
              <parameterSubstitutions xsi:type="language:SymbolicValue" symbolicReference="//@problemConainer/@relations.9/@variables.0"/>
            </operands>
            <operands xsi:type="language:SymbolicValue" symbolicReference="//@problemConainer/@relations.24">
              <parameterSubstitutions xsi:type="language:SymbolicValue" symbolicReference="//@problemConainer/@relations.9/@value/@operands.0/@quantifiedVariables.2"/>
              <parameterSubstitutions xsi:type="language:SymbolicValue" symbolicReference="//@problemConainer/@relations.9/@variables.0"/>
            </operands>
            <operands xsi:type="language:Distinct">
              <operands xsi:type="language:SymbolicValue" symbolicReference="//@problemConainer/@relations.9/@value/@operands.0/@quantifiedVariables.0"/>
              <operands xsi:type="language:SymbolicValue" symbolicReference="//@problemConainer/@relations.9/@value/@operands.0/@quantifiedVariables.1"/>
            </operands>
            <operands xsi:type="language:Distinct">
              <operands xsi:type="language:SymbolicValue" symbolicReference="//@problemConainer/@relations.9/@value/@operands.0/@quantifiedVariables.0"/>
              <operands xsi:type="language:SymbolicValue" symbolicReference="//@problemConainer/@relations.9/@value/@operands.0/@quantifiedVariables.2"/>
            </operands>
            <operands xsi:type="language:Distinct">
              <operands xsi:type="language:SymbolicValue" symbolicReference="//@problemConainer/@relations.9/@value/@operands.0/@quantifiedVariables.1"/>
              <operands xsi:type="language:SymbolicValue" symbolicReference="//@problemConainer/@relations.9/@value/@operands.0/@quantifiedVariables.2"/>
            </operands>
          </expression>
        </operands>
      </value>
    </relations>
    <relations xsi:type="language:RelationDefinition" name="pattern modes3 queries turnoutConnectedToBothOutputs" annotations="//@problemConainer/@annotations.12">
      <parameters xsi:type="language:ComplexTypeReference" referred="//@problemConainer/@types.2"/>
      <variables name="parameter T">
        <range xsi:type="language:ComplexTypeReference" referred="//@problemConainer/@types.2"/>
      </variables>
      <value xsi:type="language:Or">
        <operands xsi:type="language:Exists">
          <quantifiedVariables name="variable Straight">
            <range xsi:type="language:ComplexTypeReference" referred="//@problemConainer/@types.0"/>
          </quantifiedVariables>
          <quantifiedVariables name="variable Divergent">
            <range xsi:type="language:ComplexTypeReference" referred="//@problemConainer/@types.0"/>
          </quantifiedVariables>
          <expression xsi:type="language:And">
            <operands xsi:type="language:SymbolicValue" symbolicReference="//@problemConainer/@relations.5">
              <parameterSubstitutions xsi:type="language:SymbolicValue" symbolicReference="//@problemConainer/@relations.10/@variables.0"/>
              <parameterSubstitutions xsi:type="language:SymbolicValue" symbolicReference="//@problemConainer/@relations.10/@value/@operands.0/@quantifiedVariables.0"/>
            </operands>
            <operands xsi:type="language:SymbolicValue" symbolicReference="//@problemConainer/@relations.6">
              <parameterSubstitutions xsi:type="language:SymbolicValue" symbolicReference="//@problemConainer/@relations.10/@variables.0"/>
              <parameterSubstitutions xsi:type="language:SymbolicValue" symbolicReference="//@problemConainer/@relations.10/@value/@operands.0/@quantifiedVariables.1"/>
            </operands>
            <operands xsi:type="language:SymbolicValue" symbolicReference="//@problemConainer/@relations.0">
              <parameterSubstitutions xsi:type="language:SymbolicValue" symbolicReference="//@problemConainer/@relations.10/@variables.0"/>
              <parameterSubstitutions xsi:type="language:SymbolicValue" symbolicReference="//@problemConainer/@relations.10/@value/@operands.0/@quantifiedVariables.0"/>
            </operands>
            <operands xsi:type="language:InstanceOf">
              <value xsi:type="language:SymbolicValue" symbolicReference="//@problemConainer/@relations.10/@value/@operands.0/@quantifiedVariables.0"/>
              <range xsi:type="language:ComplexTypeReference" referred="//@problemConainer/@types.0"/>
            </operands>
            <operands xsi:type="language:SymbolicValue" symbolicReference="//@problemConainer/@relations.0">
              <parameterSubstitutions xsi:type="language:SymbolicValue" symbolicReference="//@problemConainer/@relations.10/@variables.0"/>
              <parameterSubstitutions xsi:type="language:SymbolicValue" symbolicReference="//@problemConainer/@relations.10/@value/@operands.0/@quantifiedVariables.1"/>
            </operands>
            <operands xsi:type="language:InstanceOf">
              <value xsi:type="language:SymbolicValue" symbolicReference="//@problemConainer/@relations.10/@value/@operands.0/@quantifiedVariables.1"/>
              <range xsi:type="language:ComplexTypeReference" referred="//@problemConainer/@types.0"/>
            </operands>
          </expression>
        </operands>
      </value>
    </relations>
    <relations xsi:type="language:RelationDefinition" name="pattern modes3 queries turnout" annotations="//@problemConainer/@annotations.13">
      <parameters xsi:type="language:ComplexTypeReference" referred="//@problemConainer/@types.2"/>
      <variables name="parameter T">
        <range xsi:type="language:ComplexTypeReference" referred="//@problemConainer/@types.2"/>
      </variables>
      <value xsi:type="language:Or">
        <operands xsi:type="language:And">
          <operands xsi:type="language:InstanceOf">
            <value xsi:type="language:SymbolicValue" symbolicReference="//@problemConainer/@relations.11/@variables.0"/>
            <range xsi:type="language:ComplexTypeReference" referred="//@problemConainer/@types.2"/>
          </operands>
        </operands>
      </value>
    </relations>
    <relations xsi:type="language:RelationDefinition" name="pattern modes3 queries turnoutOutputsAreSame" annotations="//@problemConainer/@annotations.14">
      <parameters xsi:type="language:ComplexTypeReference" referred="//@problemConainer/@types.2"/>
      <variables name="parameter T">
        <range xsi:type="language:ComplexTypeReference" referred="//@problemConainer/@types.2"/>
      </variables>
      <value xsi:type="language:Or">
        <operands xsi:type="language:Exists">
          <quantifiedVariables name="variable S">
            <range xsi:type="language:ComplexTypeReference" referred="//@problemConainer/@types.0"/>
          </quantifiedVariables>
          <expression xsi:type="language:And">
            <operands xsi:type="language:SymbolicValue" symbolicReference="//@problemConainer/@relations.5">
              <parameterSubstitutions xsi:type="language:SymbolicValue" symbolicReference="//@problemConainer/@relations.12/@variables.0"/>
              <parameterSubstitutions xsi:type="language:SymbolicValue" symbolicReference="//@problemConainer/@relations.12/@value/@operands.0/@quantifiedVariables.0"/>
            </operands>
            <operands xsi:type="language:SymbolicValue" symbolicReference="//@problemConainer/@relations.6">
              <parameterSubstitutions xsi:type="language:SymbolicValue" symbolicReference="//@problemConainer/@relations.12/@variables.0"/>
              <parameterSubstitutions xsi:type="language:SymbolicValue" symbolicReference="//@problemConainer/@relations.12/@value/@operands.0/@quantifiedVariables.0"/>
            </operands>
            <operands xsi:type="language:InstanceOf">
              <value xsi:type="language:SymbolicValue" symbolicReference="//@problemConainer/@relations.12/@value/@operands.0/@quantifiedVariables.0"/>
              <range xsi:type="language:ComplexTypeReference" referred="//@problemConainer/@types.0"/>
            </operands>
          </expression>
        </operands>
      </value>
    </relations>
    <relations xsi:type="language:RelationDefinition" name="pattern modes3 queries tooManyExtraInputsOfTurnout" annotations="//@problemConainer/@annotations.15">
      <parameters xsi:type="language:ComplexTypeReference" referred="//@problemConainer/@types.2"/>
      <variables name="parameter T">
        <range xsi:type="language:ComplexTypeReference" referred="//@problemConainer/@types.2"/>
      </variables>
      <value xsi:type="language:Or">
        <operands xsi:type="language:Exists">
          <quantifiedVariables name="variable I1">
            <range xsi:type="language:ComplexTypeReference" referred="//@problemConainer/@types.0"/>
          </quantifiedVariables>
          <quantifiedVariables name="variable I2">
            <range xsi:type="language:ComplexTypeReference" referred="//@problemConainer/@types.0"/>
          </quantifiedVariables>
          <expression xsi:type="language:And">
            <operands xsi:type="language:SymbolicValue" symbolicReference="//@problemConainer/@relations.20">
              <parameterSubstitutions xsi:type="language:SymbolicValue" symbolicReference="//@problemConainer/@relations.13/@variables.0"/>
              <parameterSubstitutions xsi:type="language:SymbolicValue" symbolicReference="//@problemConainer/@relations.13/@value/@operands.0/@quantifiedVariables.0"/>
            </operands>
            <operands xsi:type="language:SymbolicValue" symbolicReference="//@problemConainer/@relations.20">
              <parameterSubstitutions xsi:type="language:SymbolicValue" symbolicReference="//@problemConainer/@relations.13/@variables.0"/>
              <parameterSubstitutions xsi:type="language:SymbolicValue" symbolicReference="//@problemConainer/@relations.13/@value/@operands.0/@quantifiedVariables.1"/>
            </operands>
            <operands xsi:type="language:Distinct">
              <operands xsi:type="language:SymbolicValue" symbolicReference="//@problemConainer/@relations.13/@value/@operands.0/@quantifiedVariables.0"/>
              <operands xsi:type="language:SymbolicValue" symbolicReference="//@problemConainer/@relations.13/@value/@operands.0/@quantifiedVariables.1"/>
            </operands>
          </expression>
        </operands>
      </value>
    </relations>
    <relations xsi:type="language:RelationDefinition" name="pattern modes3 queries unreachable" annotations="//@problemConainer/@annotations.16">
      <parameters xsi:type="language:ComplexTypeReference" referred="//@problemConainer/@types.0"/>
      <parameters xsi:type="language:ComplexTypeReference" referred="//@problemConainer/@types.0"/>
      <variables name="parameter S1">
        <range xsi:type="language:ComplexTypeReference" referred="//@problemConainer/@types.0"/>
      </variables>
      <variables name="parameter S2">
        <range xsi:type="language:ComplexTypeReference" referred="//@problemConainer/@types.0"/>
      </variables>
      <value xsi:type="language:Or">
        <operands xsi:type="language:And">
          <operands xsi:type="language:InstanceOf">
            <value xsi:type="language:SymbolicValue" symbolicReference="//@problemConainer/@relations.14/@variables.0"/>
            <range xsi:type="language:ComplexTypeReference" referred="//@problemConainer/@types.0"/>
          </operands>
          <operands xsi:type="language:InstanceOf">
            <value xsi:type="language:SymbolicValue" symbolicReference="//@problemConainer/@relations.14/@variables.1"/>
            <range xsi:type="language:ComplexTypeReference" referred="//@problemConainer/@types.0"/>
          </operands>
          <operands xsi:type="language:Not">
            <operand xsi:type="language:SymbolicValue" symbolicReference="//@problemConainer/@relations.21">
              <parameterSubstitutions xsi:type="language:SymbolicValue" symbolicReference="//@problemConainer/@relations.14/@variables.0"/>
              <parameterSubstitutions xsi:type="language:SymbolicValue" symbolicReference="//@problemConainer/@relations.14/@variables.1"/>
            </operand>
          </operands>
        </operands>
      </value>
    </relations>
    <relations xsi:type="language:RelationDefinition" name="pattern modes3 queries connectedToReflexive" annotations="//@problemConainer/@annotations.17">
      <parameters xsi:type="language:ComplexTypeReference" referred="//@problemConainer/@types.0"/>
      <variables name="parameter S">
        <range xsi:type="language:ComplexTypeReference" referred="//@problemConainer/@types.0"/>
      </variables>
      <value xsi:type="language:Or">
        <operands xsi:type="language:And">
          <operands xsi:type="language:SymbolicValue" symbolicReference="//@problemConainer/@relations.0">
            <parameterSubstitutions xsi:type="language:SymbolicValue" symbolicReference="//@problemConainer/@relations.15/@variables.0"/>
            <parameterSubstitutions xsi:type="language:SymbolicValue" symbolicReference="//@problemConainer/@relations.15/@variables.0"/>
          </operands>
        </operands>
      </value>
    </relations>
    <relations xsi:type="language:RelationDefinition" name="pattern modes3 queries turnoutOutput" annotations="//@problemConainer/@annotations.18">
      <parameters xsi:type="language:ComplexTypeReference" referred="//@problemConainer/@types.2"/>
      <parameters xsi:type="language:ComplexTypeReference" referred="//@problemConainer/@types.0"/>
      <variables name="parameter T">
        <range xsi:type="language:ComplexTypeReference" referred="//@problemConainer/@types.2"/>
      </variables>
      <variables name="parameter S">
        <range xsi:type="language:ComplexTypeReference" referred="//@problemConainer/@types.0"/>
      </variables>
      <value xsi:type="language:Or">
        <operands xsi:type="language:And">
          <operands xsi:type="language:SymbolicValue" symbolicReference="//@problemConainer/@relations.5">
            <parameterSubstitutions xsi:type="language:SymbolicValue" symbolicReference="//@problemConainer/@relations.16/@variables.0"/>
            <parameterSubstitutions xsi:type="language:SymbolicValue" symbolicReference="//@problemConainer/@relations.16/@variables.1"/>
          </operands>
          <operands xsi:type="language:InstanceOf">
            <value xsi:type="language:SymbolicValue" symbolicReference="//@problemConainer/@relations.16/@variables.1"/>
            <range xsi:type="language:ComplexTypeReference" referred="//@problemConainer/@types.0"/>
          </operands>
        </operands>
        <operands xsi:type="language:And">
          <operands xsi:type="language:SymbolicValue" symbolicReference="//@problemConainer/@relations.6">
            <parameterSubstitutions xsi:type="language:SymbolicValue" symbolicReference="//@problemConainer/@relations.16/@variables.0"/>
            <parameterSubstitutions xsi:type="language:SymbolicValue" symbolicReference="//@problemConainer/@relations.16/@variables.1"/>
          </operands>
          <operands xsi:type="language:InstanceOf">
            <value xsi:type="language:SymbolicValue" symbolicReference="//@problemConainer/@relations.16/@variables.1"/>
            <range xsi:type="language:ComplexTypeReference" referred="//@problemConainer/@types.0"/>
          </operands>
        </operands>
      </value>
    </relations>
    <relations xsi:type="language:RelationDefinition" name="pattern modes3 queries connectedTo" annotations="//@problemConainer/@annotations.19">
      <parameters xsi:type="language:ComplexTypeReference" referred="//@problemConainer/@types.0"/>
      <parameters xsi:type="language:ComplexTypeReference" referred="//@problemConainer/@types.0"/>
      <variables name="parameter S1">
        <range xsi:type="language:ComplexTypeReference" referred="//@problemConainer/@types.0"/>
      </variables>
      <variables name="parameter S2">
        <range xsi:type="language:ComplexTypeReference" referred="//@problemConainer/@types.0"/>
      </variables>
      <value xsi:type="language:Or">
        <operands xsi:type="language:And">
          <operands xsi:type="language:SymbolicValue" symbolicReference="//@problemConainer/@relations.0">
            <parameterSubstitutions xsi:type="language:SymbolicValue" symbolicReference="//@problemConainer/@relations.17/@variables.0"/>
            <parameterSubstitutions xsi:type="language:SymbolicValue" symbolicReference="//@problemConainer/@relations.17/@variables.1"/>
          </operands>
          <operands xsi:type="language:InstanceOf">
            <value xsi:type="language:SymbolicValue" symbolicReference="//@problemConainer/@relations.17/@variables.1"/>
            <range xsi:type="language:ComplexTypeReference" referred="//@problemConainer/@types.0"/>
          </operands>
        </operands>
      </value>
    </relations>
    <relations xsi:type="language:RelationDefinition" name="pattern modes3 queries outputReflexive" annotations="//@problemConainer/@annotations.20">
      <parameters xsi:type="language:ComplexTypeReference" referred="//@problemConainer/@types.2"/>
      <variables name="parameter T">
        <range xsi:type="language:ComplexTypeReference" referred="//@problemConainer/@types.2"/>
      </variables>
      <value xsi:type="language:Or">
        <operands xsi:type="language:And">
          <operands xsi:type="language:SymbolicValue" symbolicReference="//@problemConainer/@relations.16">
            <parameterSubstitutions xsi:type="language:SymbolicValue" symbolicReference="//@problemConainer/@relations.18/@variables.0"/>
            <parameterSubstitutions xsi:type="language:SymbolicValue" symbolicReference="//@problemConainer/@relations.18/@variables.0"/>
          </operands>
        </operands>
      </value>
    </relations>
    <relations xsi:type="language:RelationDefinition" name="pattern modes3 queries adjacent" annotations="//@problemConainer/@annotations.21">
      <parameters xsi:type="language:ComplexTypeReference" referred="//@problemConainer/@types.0"/>
      <parameters xsi:type="language:ComplexTypeReference" referred="//@problemConainer/@types.0"/>
      <variables name="parameter S1">
        <range xsi:type="language:ComplexTypeReference" referred="//@problemConainer/@types.0"/>
      </variables>
      <variables name="parameter S2">
        <range xsi:type="language:ComplexTypeReference" referred="//@problemConainer/@types.0"/>
      </variables>
      <value xsi:type="language:Or">
        <operands xsi:type="language:And">
          <operands xsi:type="language:SymbolicValue" symbolicReference="//@problemConainer/@relations.24">
            <parameterSubstitutions xsi:type="language:SymbolicValue" symbolicReference="//@problemConainer/@relations.19/@variables.0"/>
            <parameterSubstitutions xsi:type="language:SymbolicValue" symbolicReference="//@problemConainer/@relations.19/@variables.1"/>
          </operands>
        </operands>
        <operands xsi:type="language:And">
          <operands xsi:type="language:SymbolicValue" symbolicReference="//@problemConainer/@relations.16">
            <parameterSubstitutions xsi:type="language:SymbolicValue" symbolicReference="//@problemConainer/@relations.19/@variables.1"/>
            <parameterSubstitutions xsi:type="language:SymbolicValue" symbolicReference="//@problemConainer/@relations.19/@variables.0"/>
          </operands>
        </operands>
      </value>
    </relations>
    <relations xsi:type="language:RelationDefinition" name="pattern modes3 queries extraInputOfTurnout" annotations="//@problemConainer/@annotations.22">
      <parameters xsi:type="language:ComplexTypeReference" referred="//@problemConainer/@types.2"/>
      <parameters xsi:type="language:ComplexTypeReference" referred="//@problemConainer/@types.0"/>
      <variables name="parameter T">
        <range xsi:type="language:ComplexTypeReference" referred="//@problemConainer/@types.2"/>
      </variables>
      <variables name="parameter S">
        <range xsi:type="language:ComplexTypeReference" referred="//@problemConainer/@types.0"/>
      </variables>
      <value xsi:type="language:Or">
        <operands xsi:type="language:Exists">
          <quantifiedVariables name="variable Straight">
            <range xsi:type="language:ComplexTypeReference" referred="//@problemConainer/@types.0"/>
          </quantifiedVariables>
          <quantifiedVariables name="variable Divergent">
            <range xsi:type="language:ComplexTypeReference" referred="//@problemConainer/@types.0"/>
          </quantifiedVariables>
          <expression xsi:type="language:And">
            <operands xsi:type="language:SymbolicValue" symbolicReference="//@problemConainer/@relations.5">
              <parameterSubstitutions xsi:type="language:SymbolicValue" symbolicReference="//@problemConainer/@relations.20/@variables.0"/>
              <parameterSubstitutions xsi:type="language:SymbolicValue" symbolicReference="//@problemConainer/@relations.20/@value/@operands.0/@quantifiedVariables.0"/>
            </operands>
            <operands xsi:type="language:InstanceOf">
              <value xsi:type="language:SymbolicValue" symbolicReference="//@problemConainer/@relations.20/@value/@operands.0/@quantifiedVariables.0"/>
              <range xsi:type="language:ComplexTypeReference" referred="//@problemConainer/@types.0"/>
            </operands>
            <operands xsi:type="language:SymbolicValue" symbolicReference="//@problemConainer/@relations.6">
              <parameterSubstitutions xsi:type="language:SymbolicValue" symbolicReference="//@problemConainer/@relations.20/@variables.0"/>
              <parameterSubstitutions xsi:type="language:SymbolicValue" symbolicReference="//@problemConainer/@relations.20/@value/@operands.0/@quantifiedVariables.1"/>
            </operands>
            <operands xsi:type="language:InstanceOf">
              <value xsi:type="language:SymbolicValue" symbolicReference="//@problemConainer/@relations.20/@value/@operands.0/@quantifiedVariables.1"/>
              <range xsi:type="language:ComplexTypeReference" referred="//@problemConainer/@types.0"/>
            </operands>
            <operands xsi:type="language:SymbolicValue" symbolicReference="//@problemConainer/@relations.24">
              <parameterSubstitutions xsi:type="language:SymbolicValue" symbolicReference="//@problemConainer/@relations.20/@variables.1"/>
              <parameterSubstitutions xsi:type="language:SymbolicValue" symbolicReference="//@problemConainer/@relations.20/@variables.0"/>
            </operands>
            <operands xsi:type="language:Distinct">
              <operands xsi:type="language:SymbolicValue" symbolicReference="//@problemConainer/@relations.20/@variables.1"/>
              <operands xsi:type="language:SymbolicValue" symbolicReference="//@problemConainer/@relations.20/@value/@operands.0/@quantifiedVariables.0"/>
            </operands>
            <operands xsi:type="language:Distinct">
              <operands xsi:type="language:SymbolicValue" symbolicReference="//@problemConainer/@relations.20/@variables.1"/>
              <operands xsi:type="language:SymbolicValue" symbolicReference="//@problemConainer/@relations.20/@value/@operands.0/@quantifiedVariables.1"/>
            </operands>
          </expression>
        </operands>
      </value>
    </relations>
    <relations xsi:type="language:RelationDefinition" name="pattern modes3 queries reachable" annotations="//@problemConainer/@annotations.23">
      <parameters xsi:type="language:ComplexTypeReference" referred="//@problemConainer/@types.0"/>
      <parameters xsi:type="language:ComplexTypeReference" referred="//@problemConainer/@types.0"/>
      <variables name="parameter S1">
        <range xsi:type="language:ComplexTypeReference" referred="//@problemConainer/@types.0"/>
      </variables>
      <variables name="parameter S2">
        <range xsi:type="language:ComplexTypeReference" referred="//@problemConainer/@types.0"/>
      </variables>
      <value xsi:type="language:Or">
        <operands xsi:type="language:And">
          <operands xsi:type="language:InstanceOf">
            <value xsi:type="language:SymbolicValue" symbolicReference="//@problemConainer/@relations.21/@variables.1"/>
            <range xsi:type="language:ComplexTypeReference" referred="//@problemConainer/@types.0"/>
          </operands>
        </operands>
        <operands xsi:type="language:And">
          <operands xsi:type="language:TransitiveClosure" relation="//@problemConainer/@relations.19">
            <leftOperand xsi:type="language:SymbolicValue" symbolicReference="//@problemConainer/@relations.21/@variables.0"/>
            <rightOperand xsi:type="language:SymbolicValue" symbolicReference="//@problemConainer/@relations.21/@variables.1"/>
          </operands>
        </operands>
      </value>
    </relations>
    <relations xsi:type="language:RelationDefinition" name="pattern modes3 queries noExtraInputOfTurnout" annotations="//@problemConainer/@annotations.24">
      <parameters xsi:type="language:ComplexTypeReference" referred="//@problemConainer/@types.2"/>
      <variables name="parameter T">
        <range xsi:type="language:ComplexTypeReference" referred="//@problemConainer/@types.2"/>
      </variables>
      <value xsi:type="language:Or">
        <operands xsi:type="language:Forall">
          <quantifiedVariables name="variable 0">
            <range xsi:type="language:ComplexTypeReference" referred="//@problemConainer/@types.0"/>
          </quantifiedVariables>
          <expression xsi:type="language:And">
            <operands xsi:type="language:InstanceOf">
              <value xsi:type="language:SymbolicValue" symbolicReference="//@problemConainer/@relations.22/@variables.0"/>
              <range xsi:type="language:ComplexTypeReference" referred="//@problemConainer/@types.2"/>
            </operands>
            <operands xsi:type="language:Not">
              <operand xsi:type="language:SymbolicValue" symbolicReference="//@problemConainer/@relations.20">
                <parameterSubstitutions xsi:type="language:SymbolicValue" symbolicReference="//@problemConainer/@relations.22/@variables.0"/>
                <parameterSubstitutions xsi:type="language:SymbolicValue" symbolicReference="//@problemConainer/@relations.22/@value/@operands.0/@quantifiedVariables.0"/>
              </operand>
            </operands>
          </expression>
        </operands>
      </value>
    </relations>
    <relations xsi:type="language:RelationDefinition" name="pattern modes3 queries connectedToNotSymmetric" annotations="//@problemConainer/@annotations.25">
      <parameters xsi:type="language:ComplexTypeReference" referred="//@problemConainer/@types.0"/>
      <parameters xsi:type="language:ComplexTypeReference" referred="//@problemConainer/@types.0"/>
      <variables name="parameter S1">
        <range xsi:type="language:ComplexTypeReference" referred="//@problemConainer/@types.0"/>
      </variables>
      <variables name="parameter S2">
        <range xsi:type="language:ComplexTypeReference" referred="//@problemConainer/@types.0"/>
      </variables>
      <value xsi:type="language:Or">
        <operands xsi:type="language:And">
          <operands xsi:type="language:SymbolicValue" symbolicReference="//@problemConainer/@relations.0">
            <parameterSubstitutions xsi:type="language:SymbolicValue" symbolicReference="//@problemConainer/@relations.23/@variables.0"/>
            <parameterSubstitutions xsi:type="language:SymbolicValue" symbolicReference="//@problemConainer/@relations.23/@variables.1"/>
          </operands>
          <operands xsi:type="language:InstanceOf">
            <value xsi:type="language:SymbolicValue" symbolicReference="//@problemConainer/@relations.23/@variables.1"/>
            <range xsi:type="language:ComplexTypeReference" referred="//@problemConainer/@types.0"/>
          </operands>
          <operands xsi:type="language:Not">
            <operand xsi:type="language:SymbolicValue" symbolicReference="//@problemConainer/@relations.17">
              <parameterSubstitutions xsi:type="language:SymbolicValue" symbolicReference="//@problemConainer/@relations.23/@variables.1"/>
              <parameterSubstitutions xsi:type="language:SymbolicValue" symbolicReference="//@problemConainer/@relations.23/@variables.0"/>
            </operand>
          </operands>
        </operands>
      </value>
    </relations>
    <relations xsi:type="language:RelationDefinition" name="pattern modes3 queries output" annotations="//@problemConainer/@annotations.26">
      <parameters xsi:type="language:ComplexTypeReference" referred="//@problemConainer/@types.0"/>
      <parameters xsi:type="language:ComplexTypeReference" referred="//@problemConainer/@types.0"/>
      <variables name="parameter S1">
        <range xsi:type="language:ComplexTypeReference" referred="//@problemConainer/@types.0"/>
      </variables>
      <variables name="parameter S2">
        <range xsi:type="language:ComplexTypeReference" referred="//@problemConainer/@types.0"/>
      </variables>
      <value xsi:type="language:Or">
        <operands xsi:type="language:And">
          <operands xsi:type="language:SymbolicValue" symbolicReference="//@problemConainer/@relations.0">
            <parameterSubstitutions xsi:type="language:SymbolicValue" symbolicReference="//@problemConainer/@relations.24/@variables.0"/>
            <parameterSubstitutions xsi:type="language:SymbolicValue" symbolicReference="//@problemConainer/@relations.24/@variables.1"/>
          </operands>
          <operands xsi:type="language:InstanceOf">
            <value xsi:type="language:SymbolicValue" symbolicReference="//@problemConainer/@relations.24/@variables.1"/>
            <range xsi:type="language:ComplexTypeReference" referred="//@problemConainer/@types.0"/>
          </operands>
        </operands>
        <operands xsi:type="language:And">
          <operands xsi:type="language:SymbolicValue" symbolicReference="//@problemConainer/@relations.16">
            <parameterSubstitutions xsi:type="language:SymbolicValue" symbolicReference="//@problemConainer/@relations.24/@variables.0"/>
            <parameterSubstitutions xsi:type="language:SymbolicValue" symbolicReference="//@problemConainer/@relations.24/@variables.1"/>
          </operands>
        </operands>
      </value>
    </relations>
    <elements name="o 1" definedInType="//@problemConainer/@types.4"/>
    <containmentHierarchies typesOrderedInHierarchy="//@problemConainer/@types.0 //@problemConainer/@types.2 //@problemConainer/@types.3 //@problemConainer/@types.1 //@problemConainer/@types.4 //@problemConainer/@types.5" containmentRelations="//@problemConainer/@relations.2 //@problemConainer/@relations.3 //@problemConainer/@relations.4"/>
    <annotations xsi:type="ecore2logicannotations:UpperMultiplicityAssertion" target="//@problemConainer/@assertions.0" relation="//@problemConainer/@relations.0" upper="2"/>
    <annotations xsi:type="ecore2logicannotations:UpperMultiplicityAssertion" target="//@problemConainer/@assertions.1" relation="//@problemConainer/@relations.1" upper="1"/>
    <annotations xsi:type="ecore2logicannotations:LowerMultiplicityAssertion" target="//@problemConainer/@assertions.2" relation="//@problemConainer/@relations.5" lower="1"/>
    <annotations xsi:type="ecore2logicannotations:UpperMultiplicityAssertion" target="//@problemConainer/@assertions.3" relation="//@problemConainer/@relations.5" upper="1"/>
    <annotations xsi:type="ecore2logicannotations:LowerMultiplicityAssertion" target="//@problemConainer/@assertions.4" relation="//@problemConainer/@relations.6" lower="1"/>
    <annotations xsi:type="ecore2logicannotations:UpperMultiplicityAssertion" target="//@problemConainer/@assertions.5" relation="//@problemConainer/@relations.6" upper="1"/>
    <annotations xsi:type="ecore2logicannotations:LowerMultiplicityAssertion" target="//@problemConainer/@assertions.6" relation="//@problemConainer/@relations.7" lower="1"/>
    <annotations xsi:type="ecore2logicannotations:UpperMultiplicityAssertion" target="//@problemConainer/@assertions.7" relation="//@problemConainer/@relations.7" upper="1"/>
    <annotations xsi:type="ecore2logicannotations:InverseRelationAssertion" target="//@problemConainer/@assertions.8" inverseA="//@problemConainer/@relations.1" inverseB="//@problemConainer/@relations.7"/>
    <annotations xsi:type="ecore2logicannotations:InverseRelationAssertion" target="//@problemConainer/@assertions.9" inverseA="//@problemConainer/@relations.0" inverseB="//@problemConainer/@relations.0"/>
    <annotations xsi:type="viatra2logicannotations:TransfomedViatraQuery" target="//@problemConainer/@relations.8" patternFullyQualifiedName="modes3.queries.turnoutInSegments">
      <variableTrace targetLogicVariable="//@problemConainer/@relations.8/@value/@operands.0/@quantifiedVariables.0"/>
    </annotations>
    <annotations xsi:type="viatra2logicannotations:TransfomedViatraQuery" target="//@problemConainer/@relations.9" patternFullyQualifiedName="modes3.queries.tooManyInputsOfSegment">
      <variableTrace targetLogicVariable="//@problemConainer/@relations.9/@value/@operands.0/@quantifiedVariables.0"/>
      <variableTrace targetLogicVariable="//@problemConainer/@relations.9/@value/@operands.0/@quantifiedVariables.1"/>
      <variableTrace targetLogicVariable="//@problemConainer/@relations.9/@value/@operands.0/@quantifiedVariables.2"/>
    </annotations>
    <annotations xsi:type="viatra2logicannotations:TransfomedViatraQuery" target="//@problemConainer/@relations.10" patternFullyQualifiedName="modes3.queries.turnoutConnectedToBothOutputs">
      <variableTrace targetLogicVariable="//@problemConainer/@relations.10/@value/@operands.0/@quantifiedVariables.0"/>
      <variableTrace targetLogicVariable="//@problemConainer/@relations.10/@value/@operands.0/@quantifiedVariables.1"/>
    </annotations>
    <annotations xsi:type="viatra2logicannotations:TransfomedViatraQuery" target="//@problemConainer/@relations.11" patternFullyQualifiedName="modes3.queries.turnout"/>
    <annotations xsi:type="viatra2logicannotations:TransfomedViatraQuery" target="//@problemConainer/@relations.12" patternFullyQualifiedName="modes3.queries.turnoutOutputsAreSame">
      <variableTrace targetLogicVariable="//@problemConainer/@relations.12/@value/@operands.0/@quantifiedVariables.0"/>
    </annotations>
    <annotations xsi:type="viatra2logicannotations:TransfomedViatraQuery" target="//@problemConainer/@relations.13" patternFullyQualifiedName="modes3.queries.tooManyExtraInputsOfTurnout">
      <variableTrace targetLogicVariable="//@problemConainer/@relations.13/@value/@operands.0/@quantifiedVariables.0"/>
      <variableTrace targetLogicVariable="//@problemConainer/@relations.13/@value/@operands.0/@quantifiedVariables.1"/>
    </annotations>
    <annotations xsi:type="viatra2logicannotations:TransfomedViatraQuery" target="//@problemConainer/@relations.14" patternFullyQualifiedName="modes3.queries.unreachable"/>
    <annotations xsi:type="viatra2logicannotations:TransfomedViatraQuery" target="//@problemConainer/@relations.15" patternFullyQualifiedName="modes3.queries.connectedToReflexive"/>
    <annotations xsi:type="viatra2logicannotations:TransfomedViatraQuery" target="//@problemConainer/@relations.16" patternFullyQualifiedName="modes3.queries.turnoutOutput"/>
    <annotations xsi:type="viatra2logicannotations:TransfomedViatraQuery" target="//@problemConainer/@relations.17" patternFullyQualifiedName="modes3.queries.connectedTo"/>
    <annotations xsi:type="viatra2logicannotations:TransfomedViatraQuery" target="//@problemConainer/@relations.18" patternFullyQualifiedName="modes3.queries.outputReflexive"/>
    <annotations xsi:type="viatra2logicannotations:TransfomedViatraQuery" target="//@problemConainer/@relations.19" patternFullyQualifiedName="modes3.queries.adjacent"/>
    <annotations xsi:type="viatra2logicannotations:TransfomedViatraQuery" target="//@problemConainer/@relations.20" patternFullyQualifiedName="modes3.queries.extraInputOfTurnout">
      <variableTrace targetLogicVariable="//@problemConainer/@relations.20/@value/@operands.0/@quantifiedVariables.0"/>
      <variableTrace targetLogicVariable="//@problemConainer/@relations.20/@value/@operands.0/@quantifiedVariables.1"/>
    </annotations>
    <annotations xsi:type="viatra2logicannotations:TransfomedViatraQuery" target="//@problemConainer/@relations.21" patternFullyQualifiedName="modes3.queries.reachable"/>
    <annotations xsi:type="viatra2logicannotations:TransfomedViatraQuery" target="//@problemConainer/@relations.22" patternFullyQualifiedName="modes3.queries.noExtraInputOfTurnout">
      <variableTrace targetLogicVariable="//@problemConainer/@relations.22/@value/@operands.0/@quantifiedVariables.0"/>
    </annotations>
    <annotations xsi:type="viatra2logicannotations:TransfomedViatraQuery" target="//@problemConainer/@relations.23" patternFullyQualifiedName="modes3.queries.connectedToNotSymmetric"/>
    <annotations xsi:type="viatra2logicannotations:TransfomedViatraQuery" target="//@problemConainer/@relations.24" patternFullyQualifiedName="modes3.queries.output"/>
    <annotations xsi:type="viatra2logicannotations:TransformedViatraWellformednessConstraint" target="//@problemConainer/@assertions.10" query="//@problemConainer/@annotations.10"/>
    <annotations xsi:type="viatra2logicannotations:TransformedViatraWellformednessConstraint" target="//@problemConainer/@assertions.11" query="//@problemConainer/@annotations.11"/>
    <annotations xsi:type="viatra2logicannotations:TransformedViatraWellformednessConstraint" target="//@problemConainer/@assertions.12" query="//@problemConainer/@annotations.12"/>
    <annotations xsi:type="viatra2logicannotations:TransformedViatraWellformednessConstraint" target="//@problemConainer/@assertions.13" query="//@problemConainer/@annotations.14"/>
    <annotations xsi:type="viatra2logicannotations:TransformedViatraWellformednessConstraint" target="//@problemConainer/@assertions.14" query="//@problemConainer/@annotations.15"/>
    <annotations xsi:type="viatra2logicannotations:TransformedViatraWellformednessConstraint" target="//@problemConainer/@assertions.15" query="//@problemConainer/@annotations.16"/>
    <annotations xsi:type="viatra2logicannotations:TransformedViatraWellformednessConstraint" target="//@problemConainer/@assertions.16" query="//@problemConainer/@annotations.17"/>
    <annotations xsi:type="viatra2logicannotations:TransformedViatraWellformednessConstraint" target="//@problemConainer/@assertions.17" query="//@problemConainer/@annotations.20"/>
    <annotations xsi:type="viatra2logicannotations:TransformedViatraWellformednessConstraint" target="//@problemConainer/@assertions.18" query="//@problemConainer/@annotations.24"/>
    <annotations xsi:type="viatra2logicannotations:TransformedViatraWellformednessConstraint" target="//@problemConainer/@assertions.19" query="//@problemConainer/@annotations.25"/>
  </problemConainer>
  <scopes maxNewElements="0" targetTypeInterpretation="//@partialtypeinterpratation.4"/>
  <scopes maxNewElements="0" targetTypeInterpretation="//@partialtypeinterpratation.5"/>
  <scopes maxNewElements="0" targetTypeInterpretation="//@partialtypeinterpratation.6"/>
  <scopes maxNewElements="0" targetTypeInterpretation="//@partialtypeinterpratation.7"/>
  <scopes maxNewElements="0" targetTypeInterpretation="//@partialtypeinterpratation.8"/>
</partialinterpretation:PartialInterpretation>
