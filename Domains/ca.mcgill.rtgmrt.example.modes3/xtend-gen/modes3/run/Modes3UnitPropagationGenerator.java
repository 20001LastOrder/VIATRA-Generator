package modes3.run;

import hu.bme.mit.inf.dslreasoner.ecore2logic.Ecore2Logic;
import hu.bme.mit.inf.dslreasoner.ecore2logic.Ecore2Logic_Trace;
import hu.bme.mit.inf.dslreasoner.logic.model.logiclanguage.Relation;
import hu.bme.mit.inf.dslreasoner.logic.model.logiclanguage.Type;
import hu.bme.mit.inf.dslreasoner.viatrasolver.logic2viatra.Modality;
import hu.bme.mit.inf.dslreasoner.viatrasolver.logic2viatra.patterns.PatternGenerator;
import hu.bme.mit.inf.dslreasoner.viatrasolver.logic2viatra.patterns.UnitPropagationPatternGenerator;
import java.util.Collections;
import java.util.Map;
import modes3.Modes3Package;
import modes3.queries.Adjacent;
import modes3.queries.Output;
import org.eclipse.viatra.query.runtime.matchers.psystem.queries.PQuery;
import org.eclipse.xtend2.lib.StringConcatenationClient;
import org.eclipse.xtext.xbase.lib.CollectionLiterals;
import org.eclipse.xtext.xbase.lib.Extension;
import org.eclipse.xtext.xbase.lib.Pair;

@SuppressWarnings("all")
public class Modes3UnitPropagationGenerator implements UnitPropagationPatternGenerator {
  private static final String MUST_NOT_CONNECTED_TO = "mustNotConnectedTo";
  
  private static final String MUST_NOT_STRAIGHT = "mustNotStraight";
  
  private static final String MUST_NOT_DIVERGENT = "mustNotDivergent";
  
  private static final String MUST_CONNECTED_TO = "mustConnectedTo";
  
  private static final String MUST_STRAIGHT = "mustStraight";
  
  private static final String MUST_DIVERGENT = "mustDivergent";
  
  private final Type segmentType;
  
  private final Type simpleSegmentType;
  
  private final Type turnoutType;
  
  private final Relation connectedToRelation;
  
  private final Relation straightRelation;
  
  private final Relation divergentRelation;
  
  public Modes3UnitPropagationGenerator(@Extension final Ecore2Logic ecore2Logic, final Ecore2Logic_Trace ecore2LogicTrace) {
    @Extension
    final Modes3Package Modes3Package = modes3.Modes3Package.eINSTANCE;
    this.segmentType = ecore2Logic.TypeofEClass(ecore2LogicTrace, Modes3Package.getSegment());
    this.simpleSegmentType = ecore2Logic.TypeofEClass(ecore2LogicTrace, Modes3Package.getSimpleSegment());
    this.turnoutType = ecore2Logic.TypeofEClass(ecore2LogicTrace, Modes3Package.getTurnout());
    this.connectedToRelation = ecore2Logic.relationOfReference(ecore2LogicTrace, Modes3Package.getSegment_ConnectedTo());
    this.straightRelation = ecore2Logic.relationOfReference(ecore2LogicTrace, Modes3Package.getTurnout_Straight());
    this.divergentRelation = ecore2Logic.relationOfReference(ecore2LogicTrace, Modes3Package.getTurnout_Divergent());
  }
  
  @Override
  public Map<Relation, String> getMustPatterns() {
    Pair<Relation, String> _mappedTo = Pair.<Relation, String>of(this.connectedToRelation, Modes3UnitPropagationGenerator.MUST_CONNECTED_TO);
    Pair<Relation, String> _mappedTo_1 = Pair.<Relation, String>of(this.straightRelation, Modes3UnitPropagationGenerator.MUST_STRAIGHT);
    Pair<Relation, String> _mappedTo_2 = Pair.<Relation, String>of(this.divergentRelation, Modes3UnitPropagationGenerator.MUST_DIVERGENT);
    return Collections.<Relation, String>unmodifiableMap(CollectionLiterals.<Relation, String>newHashMap(_mappedTo, _mappedTo_1, _mappedTo_2));
  }
  
  @Override
  public Map<Relation, String> getMustNotPatterns() {
    Pair<Relation, String> _mappedTo = Pair.<Relation, String>of(this.connectedToRelation, Modes3UnitPropagationGenerator.MUST_NOT_CONNECTED_TO);
    Pair<Relation, String> _mappedTo_1 = Pair.<Relation, String>of(this.straightRelation, Modes3UnitPropagationGenerator.MUST_NOT_STRAIGHT);
    Pair<Relation, String> _mappedTo_2 = Pair.<Relation, String>of(this.divergentRelation, Modes3UnitPropagationGenerator.MUST_NOT_DIVERGENT);
    return Collections.<Relation, String>unmodifiableMap(CollectionLiterals.<Relation, String>newHashMap(_mappedTo, _mappedTo_1, _mappedTo_2));
  }
  
  @Override
  public StringConcatenationClient getAdditionalPatterns(@Extension final PatternGenerator generator, final Map<String, PQuery> fqnToPQuery) {
    StringConcatenationClient _xblockexpression = null;
    {
      StringConcatenationClient _client = new StringConcatenationClient() {
        @Override
        protected void appendTo(StringConcatenationClient.TargetStringConcatenation _builder) {
          _builder.append("problem: LogicProblem, interpretation: PartialInterpretation,");
          _builder.newLine();
          _builder.append("source: DefinedElement, target: DefinedElement");
          _builder.newLine();
        }
      };
      final StringConcatenationClient parameters = _client;
      StringConcatenationClient _client_1 = new StringConcatenationClient() {
        @Override
        protected void appendTo(StringConcatenationClient.TargetStringConcatenation _builder) {
          _builder.append("find interpretation(problem, interpretation);");
          _builder.newLine();
          _builder.append("find mustExist(problem, interpretation, source);");
          _builder.newLine();
          _builder.append("find mustExist(problem, interpretation, target);");
          _builder.newLine();
        }
      };
      final StringConcatenationClient commonMustParameterConstraints = _client_1;
      StringConcatenationClient _client_2 = new StringConcatenationClient() {
        @Override
        protected void appendTo(StringConcatenationClient.TargetStringConcatenation _builder) {
          _builder.append("find interpretation(problem, interpretation);");
          _builder.newLine();
          _builder.append("find mayExist(problem, interpretation, source);");
          _builder.newLine();
          _builder.append("find mayExist(problem, interpretation, target);");
          _builder.newLine();
        }
      };
      final StringConcatenationClient commonMayParameterConstraints = _client_2;
      StringConcatenationClient _client_3 = new StringConcatenationClient() {
        @Override
        protected void appendTo(StringConcatenationClient.TargetStringConcatenation _builder) {
          _builder.append("pattern mayInput(");
          _builder.append(parameters);
          _builder.append(") {");
          _builder.newLineIfNotEmpty();
          _builder.append("\t");
          _builder.append(commonMayParameterConstraints, "\t");
          _builder.newLineIfNotEmpty();
          _builder.append("\t");
          CharSequence _referInstanceOf = generator.getTypeIndexer().referInstanceOf(Modes3UnitPropagationGenerator.this.segmentType, Modality.MAY, "target");
          _builder.append(_referInstanceOf, "\t");
          _builder.newLineIfNotEmpty();
          _builder.append("\t");
          CharSequence _referPattern = generator.getRelationDefinitionIndexer().referPattern(fqnToPQuery.get(Adjacent.instance().getFullyQualifiedName()), new String[] { "target", "source" }, Modality.MAY, true, false);
          _builder.append(_referPattern, "\t");
          _builder.newLineIfNotEmpty();
          _builder.append("\t");
          _builder.append("neg ");
          CharSequence _referRelation = generator.referRelation(Modes3UnitPropagationGenerator.this.straightRelation, "target", "source", Modality.MUST, fqnToPQuery);
          _builder.append(_referRelation, "\t");
          _builder.newLineIfNotEmpty();
          _builder.append("\t");
          _builder.append("neg ");
          CharSequence _referRelation_1 = generator.referRelation(Modes3UnitPropagationGenerator.this.straightRelation, "target", "source", Modality.MUST, fqnToPQuery);
          _builder.append(_referRelation_1, "\t");
          _builder.newLineIfNotEmpty();
          _builder.append("}");
          _builder.newLine();
          _builder.newLine();
          _builder.append("pattern multipleMayInput(problem: LogicProblem, interpretation: PartialInterpretation,");
          _builder.newLine();
          _builder.append("\t\t\t");
          _builder.append("target: DefinedElement) {");
          _builder.newLine();
          _builder.append("\t");
          _builder.append("find interpretation(problem, interpretation);");
          _builder.newLine();
          _builder.append("\t");
          _builder.append("find mustExist(problem, interpretation, target);");
          _builder.newLine();
          _builder.append("\t");
          _builder.append("find mayInput(problem, interpretaton, source1, target);");
          _builder.newLine();
          _builder.append("\t");
          _builder.append("find mayInput(problem, interpretaton, source2, target);");
          _builder.newLine();
          _builder.append("\t");
          _builder.append("neg find mustEquivalent(problem, interpretation, source1, source2);");
          _builder.newLine();
          _builder.append("}");
          _builder.newLine();
          _builder.newLine();
          _builder.append("pattern multipleMayStraight(problem: LogicProblem, interpretation: PartialInterpretation,");
          _builder.newLine();
          _builder.append("\t\t\t");
          _builder.append("source: DefinedElement) {");
          _builder.newLine();
          _builder.append("\t");
          _builder.append("find interpretation(problem, interpretation);");
          _builder.newLine();
          _builder.append("\t");
          _builder.append("find mustExist(problem, interpretation, source);");
          _builder.newLine();
          _builder.append("\t");
          CharSequence _referInstanceOf_1 = generator.getTypeIndexer().referInstanceOf(Modes3UnitPropagationGenerator.this.turnoutType, Modality.MAY, "source");
          _builder.append(_referInstanceOf_1, "\t");
          _builder.newLineIfNotEmpty();
          _builder.append("\t");
          CharSequence _referRelation_2 = generator.referRelation(Modes3UnitPropagationGenerator.this.straightRelation, "source", "target1", Modality.MAY, fqnToPQuery);
          _builder.append(_referRelation_2, "\t");
          _builder.newLineIfNotEmpty();
          _builder.append("\t");
          CharSequence _referRelation_3 = generator.referRelation(Modes3UnitPropagationGenerator.this.straightRelation, "source", "target2", Modality.MAY, fqnToPQuery);
          _builder.append(_referRelation_3, "\t");
          _builder.newLineIfNotEmpty();
          _builder.append("\t");
          _builder.append("neg find mustEquivalent(problem, interpretation, target1, target2);");
          _builder.newLine();
          _builder.append("}");
          _builder.newLine();
          _builder.newLine();
          _builder.append("pattern multipleMayDivergent(problem: LogicProblem, interpretation: PartialInterpretation,");
          _builder.newLine();
          _builder.append("\t\t\t");
          _builder.append("source: DefinedElement) {");
          _builder.newLine();
          _builder.append("\t");
          _builder.append("find interpretation(problem, interpretation);");
          _builder.newLine();
          _builder.append("\t");
          _builder.append("find mustExist(problem, interpretation, source);");
          _builder.newLine();
          _builder.append("\t");
          CharSequence _referInstanceOf_2 = generator.getTypeIndexer().referInstanceOf(Modes3UnitPropagationGenerator.this.turnoutType, Modality.MAY, "source");
          _builder.append(_referInstanceOf_2, "\t");
          _builder.newLineIfNotEmpty();
          _builder.append("\t");
          CharSequence _referRelation_4 = generator.referRelation(Modes3UnitPropagationGenerator.this.divergentRelation, "source", "target1", Modality.MAY, fqnToPQuery);
          _builder.append(_referRelation_4, "\t");
          _builder.newLineIfNotEmpty();
          _builder.append("\t");
          CharSequence _referRelation_5 = generator.referRelation(Modes3UnitPropagationGenerator.this.divergentRelation, "source", "target2", Modality.MAY, fqnToPQuery);
          _builder.append(_referRelation_5, "\t");
          _builder.newLineIfNotEmpty();
          _builder.append("\t");
          _builder.append("neg find mustEquivalent(problem, interpretation, target1, target2);");
          _builder.newLine();
          _builder.append("}");
          _builder.newLine();
          _builder.newLine();
          _builder.append("pattern ");
          _builder.append(Modes3UnitPropagationGenerator.MUST_CONNECTED_TO);
          _builder.append("(");
          _builder.append(parameters);
          _builder.append(") {");
          _builder.newLineIfNotEmpty();
          _builder.append("\t");
          _builder.append(commonMustParameterConstraints, "\t");
          _builder.newLineIfNotEmpty();
          _builder.append("\t");
          CharSequence _referInstanceOf_3 = generator.getTypeIndexer().referInstanceOf(Modes3UnitPropagationGenerator.this.segmentType, Modality.MAY, "target");
          _builder.append(_referInstanceOf_3, "\t");
          _builder.newLineIfNotEmpty();
          _builder.append("\t");
          _builder.append("find mayInput(problem, interpretaton, source, target);");
          _builder.newLine();
          _builder.append("\t");
          _builder.append("neg find multipleMayInput(problem, interpretaton, target);");
          _builder.newLine();
          _builder.append("\t");
          CharSequence _referRelation_6 = generator.referRelation(Modes3UnitPropagationGenerator.this.connectedToRelation, "source", "target", Modality.MAY, fqnToPQuery);
          _builder.append(_referRelation_6, "\t");
          _builder.newLineIfNotEmpty();
          _builder.append("\t");
          _builder.append("neg ");
          CharSequence _referRelation_7 = generator.referRelation(Modes3UnitPropagationGenerator.this.connectedToRelation, "source", "target", Modality.MUST, fqnToPQuery);
          _builder.append(_referRelation_7, "\t");
          _builder.newLineIfNotEmpty();
          _builder.append("\t");
          _builder.append("neg ");
          CharSequence _referRelation_8 = generator.referRelation(Modes3UnitPropagationGenerator.this.straightRelation, "source", "target", Modality.MAY, fqnToPQuery);
          _builder.append(_referRelation_8, "\t");
          _builder.newLineIfNotEmpty();
          _builder.append("\t");
          _builder.append("neg ");
          CharSequence _referRelation_9 = generator.referRelation(Modes3UnitPropagationGenerator.this.divergentRelation, "source", "target", Modality.MAY, fqnToPQuery);
          _builder.append(_referRelation_9, "\t");
          _builder.newLineIfNotEmpty();
          _builder.append("}");
          _builder.newLine();
          _builder.newLine();
          _builder.append("pattern ");
          _builder.append(Modes3UnitPropagationGenerator.MUST_STRAIGHT);
          _builder.append("(");
          _builder.append(parameters);
          _builder.append(") {");
          _builder.newLineIfNotEmpty();
          _builder.append("\t");
          _builder.append(commonMustParameterConstraints, "\t");
          _builder.newLineIfNotEmpty();
          _builder.append("\t");
          _builder.append("neg ");
          CharSequence _referRelation_10 = generator.referRelation(Modes3UnitPropagationGenerator.this.straightRelation, "source", "_", Modality.MUST, fqnToPQuery);
          _builder.append(_referRelation_10, "\t");
          _builder.newLineIfNotEmpty();
          _builder.append("\t");
          _builder.append("neg find multipleMayStraight(problem, interpretation, source);");
          _builder.newLine();
          _builder.append("\t");
          CharSequence _referRelation_11 = generator.referRelation(Modes3UnitPropagationGenerator.this.straightRelation, "source", "target", Modality.MAY, fqnToPQuery);
          _builder.append(_referRelation_11, "\t");
          _builder.newLineIfNotEmpty();
          _builder.append("\t");
          _builder.append("neg ");
          CharSequence _referRelation_12 = generator.referRelation(Modes3UnitPropagationGenerator.this.straightRelation, "source", "target", Modality.MUST, fqnToPQuery);
          _builder.append(_referRelation_12, "\t");
          _builder.newLineIfNotEmpty();
          _builder.append("} or {");
          _builder.newLine();
          _builder.append("\t");
          _builder.append(commonMustParameterConstraints, "\t");
          _builder.newLineIfNotEmpty();
          _builder.append("\t");
          CharSequence _referInstanceOf_4 = generator.getTypeIndexer().referInstanceOf(Modes3UnitPropagationGenerator.this.segmentType, Modality.MAY, "target");
          _builder.append(_referInstanceOf_4, "\t");
          _builder.newLineIfNotEmpty();
          _builder.append("\t");
          _builder.append("find mayInput(problem, interpretaton, source, target);");
          _builder.newLine();
          _builder.append("\t");
          _builder.append("neg find multipleMayInput(problem, interpretaton, target);");
          _builder.newLine();
          _builder.append("\t");
          _builder.append("neg ");
          CharSequence _referRelation_13 = generator.referRelation(Modes3UnitPropagationGenerator.this.connectedToRelation, "source", "target", Modality.MAY, fqnToPQuery);
          _builder.append(_referRelation_13, "\t");
          _builder.newLineIfNotEmpty();
          _builder.append("\t");
          CharSequence _referRelation_14 = generator.referRelation(Modes3UnitPropagationGenerator.this.straightRelation, "source", "target", Modality.MAY, fqnToPQuery);
          _builder.append(_referRelation_14, "\t");
          _builder.newLineIfNotEmpty();
          _builder.append("\t");
          _builder.append("neg ");
          CharSequence _referRelation_15 = generator.referRelation(Modes3UnitPropagationGenerator.this.straightRelation, "source", "target", Modality.MUST, fqnToPQuery);
          _builder.append(_referRelation_15, "\t");
          _builder.newLineIfNotEmpty();
          _builder.append("\t");
          _builder.append("neg ");
          CharSequence _referRelation_16 = generator.referRelation(Modes3UnitPropagationGenerator.this.divergentRelation, "source", "target", Modality.MAY, fqnToPQuery);
          _builder.append(_referRelation_16, "\t");
          _builder.newLineIfNotEmpty();
          _builder.append("}");
          _builder.newLine();
          _builder.newLine();
          _builder.append("pattern ");
          _builder.append(Modes3UnitPropagationGenerator.MUST_DIVERGENT);
          _builder.append("(");
          _builder.append(parameters);
          _builder.append(") {");
          _builder.newLineIfNotEmpty();
          _builder.append("\t");
          _builder.append(commonMustParameterConstraints, "\t");
          _builder.newLineIfNotEmpty();
          _builder.append("\t");
          _builder.append("neg ");
          CharSequence _referRelation_17 = generator.referRelation(Modes3UnitPropagationGenerator.this.divergentRelation, "source", "_", Modality.MUST, fqnToPQuery);
          _builder.append(_referRelation_17, "\t");
          _builder.newLineIfNotEmpty();
          _builder.append("\t");
          _builder.append("neg find multipleMayDivergent(problem, interpretation, source);");
          _builder.newLine();
          _builder.append("\t");
          CharSequence _referRelation_18 = generator.referRelation(Modes3UnitPropagationGenerator.this.divergentRelation, "source", "target", Modality.MAY, fqnToPQuery);
          _builder.append(_referRelation_18, "\t");
          _builder.newLineIfNotEmpty();
          _builder.append("\t");
          _builder.append("neg ");
          CharSequence _referRelation_19 = generator.referRelation(Modes3UnitPropagationGenerator.this.divergentRelation, "source", "target", Modality.MUST, fqnToPQuery);
          _builder.append(_referRelation_19, "\t");
          _builder.newLineIfNotEmpty();
          _builder.append("} or {");
          _builder.newLine();
          _builder.append("\t");
          _builder.append(commonMustParameterConstraints, "\t");
          _builder.newLineIfNotEmpty();
          _builder.append("\t");
          CharSequence _referInstanceOf_5 = generator.getTypeIndexer().referInstanceOf(Modes3UnitPropagationGenerator.this.segmentType, Modality.MAY, "target");
          _builder.append(_referInstanceOf_5, "\t");
          _builder.newLineIfNotEmpty();
          _builder.append("\t");
          _builder.append("find mayInput(problem, interpretaton, source, target);");
          _builder.newLine();
          _builder.append("\t");
          _builder.append("neg find multipleMayInput(problem, interpretaton, target);");
          _builder.newLine();
          _builder.append("\t");
          _builder.append("neg ");
          CharSequence _referRelation_20 = generator.referRelation(Modes3UnitPropagationGenerator.this.connectedToRelation, "source", "target", Modality.MAY, fqnToPQuery);
          _builder.append(_referRelation_20, "\t");
          _builder.newLineIfNotEmpty();
          _builder.append("\t");
          _builder.append("neg ");
          CharSequence _referRelation_21 = generator.referRelation(Modes3UnitPropagationGenerator.this.straightRelation, "source", "target", Modality.MAY, fqnToPQuery);
          _builder.append(_referRelation_21, "\t");
          _builder.newLineIfNotEmpty();
          _builder.append("\t");
          CharSequence _referRelation_22 = generator.referRelation(Modes3UnitPropagationGenerator.this.divergentRelation, "source", "target", Modality.MAY, fqnToPQuery);
          _builder.append(_referRelation_22, "\t");
          _builder.newLineIfNotEmpty();
          _builder.append("\t");
          _builder.append("neg ");
          CharSequence _referRelation_23 = generator.referRelation(Modes3UnitPropagationGenerator.this.divergentRelation, "source", "target", Modality.MUST, fqnToPQuery);
          _builder.append(_referRelation_23, "\t");
          _builder.newLineIfNotEmpty();
          _builder.append("}");
          _builder.newLine();
          _builder.newLine();
          _builder.append("pattern turnoutOutput_must_to_true_by_straight(");
          _builder.append(parameters);
          _builder.append(", T : DefinedElement, S : DefinedElement) {");
          _builder.newLineIfNotEmpty();
          _builder.append("\t");
          _builder.append(commonMayParameterConstraints, "\t");
          _builder.newLineIfNotEmpty();
          _builder.append("\t");
          CharSequence _referInstanceOf_6 = generator.getTypeIndexer().referInstanceOf(Modes3UnitPropagationGenerator.this.turnoutType, Modality.MAY, "source");
          _builder.append(_referInstanceOf_6, "\t");
          _builder.newLineIfNotEmpty();
          _builder.append("\t");
          CharSequence _referInstanceOf_7 = generator.getTypeIndexer().referInstanceOf(Modes3UnitPropagationGenerator.this.segmentType, Modality.MAY, "target");
          _builder.append(_referInstanceOf_7, "\t");
          _builder.newLineIfNotEmpty();
          _builder.append("\t");
          _builder.append("T == source;");
          _builder.newLine();
          _builder.append("\t");
          _builder.append("S == target;");
          _builder.newLine();
          _builder.append("}");
          _builder.newLine();
          _builder.newLine();
          _builder.append("pattern turnoutOutput_must_to_true_by_divergent(");
          _builder.append(parameters);
          _builder.append(", T : DefinedElement, S : DefinedElement) {");
          _builder.newLineIfNotEmpty();
          _builder.append("\t");
          _builder.append(commonMayParameterConstraints, "\t");
          _builder.newLineIfNotEmpty();
          _builder.append("\t");
          CharSequence _referInstanceOf_8 = generator.getTypeIndexer().referInstanceOf(Modes3UnitPropagationGenerator.this.turnoutType, Modality.MAY, "source");
          _builder.append(_referInstanceOf_8, "\t");
          _builder.newLineIfNotEmpty();
          _builder.append("\t");
          CharSequence _referInstanceOf_9 = generator.getTypeIndexer().referInstanceOf(Modes3UnitPropagationGenerator.this.segmentType, Modality.MAY, "target");
          _builder.append(_referInstanceOf_9, "\t");
          _builder.newLineIfNotEmpty();
          _builder.append("\t");
          _builder.append("T == source;");
          _builder.newLine();
          _builder.append("\t");
          _builder.append("S == target;");
          _builder.newLine();
          _builder.append("}");
          _builder.newLine();
          _builder.newLine();
          _builder.append("pattern output_must_to_true_by_connectedTo(");
          _builder.append(parameters);
          _builder.append(", S1 : DefinedElement, S2 : DefinedElement) {");
          _builder.newLineIfNotEmpty();
          _builder.append("\t");
          _builder.append(commonMayParameterConstraints, "\t");
          _builder.newLineIfNotEmpty();
          _builder.append("\t");
          CharSequence _referInstanceOf_10 = generator.getTypeIndexer().referInstanceOf(Modes3UnitPropagationGenerator.this.segmentType, Modality.MAY, "source");
          _builder.append(_referInstanceOf_10, "\t");
          _builder.newLineIfNotEmpty();
          _builder.append("\t");
          CharSequence _referInstanceOf_11 = generator.getTypeIndexer().referInstanceOf(Modes3UnitPropagationGenerator.this.segmentType, Modality.MAY, "target");
          _builder.append(_referInstanceOf_11, "\t");
          _builder.newLineIfNotEmpty();
          _builder.append("\t");
          _builder.append("S1 == source;");
          _builder.newLine();
          _builder.append("\t");
          _builder.append("S2 == target;");
          _builder.newLine();
          _builder.append("}");
          _builder.newLine();
          _builder.newLine();
          _builder.append("pattern output_must_to_true_by_straight(");
          _builder.append(parameters);
          _builder.append(", S1 : DefinedElement, S2 : DefinedElement) {");
          _builder.newLineIfNotEmpty();
          _builder.append("\t");
          _builder.append("find turnoutOutput_must_to_true_by_straight(problem, interpretation, source, target, S1, S2);");
          _builder.newLine();
          _builder.append("}");
          _builder.newLine();
          _builder.newLine();
          _builder.append("pattern output_must_to_true_by_divergent(");
          _builder.append(parameters);
          _builder.append(", S1 : DefinedElement, S2 : DefinedElement) {");
          _builder.newLineIfNotEmpty();
          _builder.append("\t");
          _builder.append("find turnoutOutput_must_to_true_by_divergent(problem, interpretation, source, target, S1, S2);");
          _builder.newLine();
          _builder.append("}");
          _builder.newLine();
          _builder.newLine();
          _builder.append("pattern adjacent_must_to_true_by_connectedTo(");
          _builder.append(parameters);
          _builder.append(", S1 : DefinedElement, S2 : DefinedElement) {");
          _builder.newLineIfNotEmpty();
          _builder.append("\t");
          _builder.append("find output_must_to_true_by_connectedTo(problem, interpretation, source, target, S1, S2);");
          _builder.newLine();
          _builder.append("}");
          _builder.newLine();
          _builder.newLine();
          _builder.append("pattern adjacent_must_to_true_by_straight(");
          _builder.append(parameters);
          _builder.append(", S1 : DefinedElement, S2 : DefinedElement) {");
          _builder.newLineIfNotEmpty();
          _builder.append("\t");
          _builder.append("find output_must_to_true_by_straight(problem, interpretation, source, target, S1, S2);");
          _builder.newLine();
          _builder.append("} or {");
          _builder.newLine();
          _builder.append("\t");
          _builder.append("find turnoutOutput_must_to_true_by_straight(problem, interpretation, source, target, S2, S1);");
          _builder.newLine();
          _builder.append("}");
          _builder.newLine();
          _builder.newLine();
          _builder.append("pattern adjacent_must_to_true_by_divergent(");
          _builder.append(parameters);
          _builder.append(", S1 : DefinedElement, S2 : DefinedElement) {");
          _builder.newLineIfNotEmpty();
          _builder.append("\t");
          _builder.append("find output_must_to_true_by_divergent(problem, interpretation, source, target, S1, S2);");
          _builder.newLine();
          _builder.append("} or {");
          _builder.newLine();
          _builder.append("\t");
          _builder.append("find turnoutOutput_must_to_true_by_divergent(problem, interpretation, source, target, S2, S1);");
          _builder.newLine();
          _builder.append("}");
          _builder.newLine();
          _builder.newLine();
          _builder.append("pattern connectedToReflexive_must_to_true_by_connectedTo(");
          _builder.append(parameters);
          _builder.append(", S : DefinedElement) {");
          _builder.newLineIfNotEmpty();
          _builder.append("\t");
          _builder.append("find mustExist(problem, interpretation, source);");
          _builder.newLine();
          _builder.append("\t");
          CharSequence _referInstanceOf_12 = generator.getTypeIndexer().referInstanceOf(Modes3UnitPropagationGenerator.this.segmentType, Modality.MUST, "source");
          _builder.append(_referInstanceOf_12, "\t");
          _builder.newLineIfNotEmpty();
          _builder.append("\t");
          _builder.append("S == source;");
          _builder.newLine();
          _builder.append("\t");
          _builder.append("S == target;");
          _builder.newLine();
          _builder.append("}");
          _builder.newLine();
          _builder.newLine();
          _builder.append("pattern outputReflexive_must_to_true_by_straight(");
          _builder.append(parameters);
          _builder.append(", T : DefinedElement) {");
          _builder.newLineIfNotEmpty();
          _builder.append("\t");
          _builder.append("find turnoutOutput_must_to_true_by_straight(problem, interpretation, source, target, T, T);");
          _builder.newLine();
          _builder.append("}");
          _builder.newLine();
          _builder.newLine();
          _builder.append("pattern outputReflexive_must_to_true_by_divergent(");
          _builder.append(parameters);
          _builder.append(", T : DefinedElement) {");
          _builder.newLineIfNotEmpty();
          _builder.append("\t");
          _builder.append("find turnoutOutput_must_to_true_by_divergent(problem, interpretation, source, target, T, T);");
          _builder.newLine();
          _builder.append("}");
          _builder.newLine();
          _builder.newLine();
          _builder.append("pattern turnoutOutputsAreSame_must_to_true_by_straight(");
          _builder.append(parameters);
          _builder.append(", T : DefinedElement) {");
          _builder.newLineIfNotEmpty();
          _builder.append("\t");
          _builder.append(commonMayParameterConstraints, "\t");
          _builder.newLineIfNotEmpty();
          _builder.append("\t");
          CharSequence _referInstanceOf_13 = generator.getTypeIndexer().referInstanceOf(Modes3UnitPropagationGenerator.this.turnoutType, Modality.MAY, "source");
          _builder.append(_referInstanceOf_13, "\t");
          _builder.newLineIfNotEmpty();
          _builder.append("\t");
          CharSequence _referInstanceOf_14 = generator.getTypeIndexer().referInstanceOf(Modes3UnitPropagationGenerator.this.segmentType, Modality.MAY, "target");
          _builder.append(_referInstanceOf_14, "\t");
          _builder.newLineIfNotEmpty();
          _builder.append("\t");
          _builder.append("T == source;");
          _builder.newLine();
          _builder.append("\t");
          _builder.append("S == target;");
          _builder.newLine();
          _builder.append("\t");
          CharSequence _referRelation_24 = generator.referRelation(Modes3UnitPropagationGenerator.this.divergentRelation, "T", "S", Modality.MUST, fqnToPQuery);
          _builder.append(_referRelation_24, "\t");
          _builder.newLineIfNotEmpty();
          _builder.append("}");
          _builder.newLine();
          _builder.newLine();
          _builder.append("pattern turnoutOutputsAreSame_must_to_true_by_divergent(");
          _builder.append(parameters);
          _builder.append(", T : DefinedElement) {");
          _builder.newLineIfNotEmpty();
          _builder.append("\t");
          _builder.append(commonMayParameterConstraints, "\t");
          _builder.newLineIfNotEmpty();
          _builder.append("\t");
          CharSequence _referInstanceOf_15 = generator.getTypeIndexer().referInstanceOf(Modes3UnitPropagationGenerator.this.turnoutType, Modality.MAY, "source");
          _builder.append(_referInstanceOf_15, "\t");
          _builder.newLineIfNotEmpty();
          _builder.append("\t");
          CharSequence _referInstanceOf_16 = generator.getTypeIndexer().referInstanceOf(Modes3UnitPropagationGenerator.this.segmentType, Modality.MAY, "target");
          _builder.append(_referInstanceOf_16, "\t");
          _builder.newLineIfNotEmpty();
          _builder.append("\t");
          _builder.append("T == source;");
          _builder.newLine();
          _builder.append("\t");
          _builder.append("S == target;");
          _builder.newLine();
          _builder.append("\t");
          CharSequence _referRelation_25 = generator.referRelation(Modes3UnitPropagationGenerator.this.straightRelation, "T", "S", Modality.MUST, fqnToPQuery);
          _builder.append(_referRelation_25, "\t");
          _builder.newLineIfNotEmpty();
          _builder.append("}");
          _builder.newLine();
          _builder.newLine();
          _builder.append("pattern tooManyInputsOfSegment_must_to_true_by_connectedTo(");
          _builder.append(parameters);
          _builder.append(", S : DefinedElement) {");
          _builder.newLineIfNotEmpty();
          _builder.append("\t");
          _builder.append("find mustExist(problem, interpretation, S);");
          _builder.newLine();
          _builder.append("\t");
          CharSequence _referInstanceOf_17 = generator.getTypeIndexer().referInstanceOf(Modes3UnitPropagationGenerator.this.simpleSegmentType, Modality.MUST, "S");
          _builder.append(_referInstanceOf_17, "\t");
          _builder.newLineIfNotEmpty();
          _builder.append("\t");
          _builder.append("find output_must_to_true_by_connectedTo(problem, interpretation, source, target, I1, S);");
          _builder.newLine();
          _builder.append("\t");
          CharSequence _referPattern_1 = generator.getRelationDefinitionIndexer().referPattern(fqnToPQuery.get(Output.instance().getFullyQualifiedName()), new String[] { "I2", "S" }, Modality.MUST, true, false);
          _builder.append(_referPattern_1, "\t");
          _builder.newLineIfNotEmpty();
          _builder.append("\t");
          CharSequence _referPattern_2 = generator.getRelationDefinitionIndexer().referPattern(fqnToPQuery.get(Output.instance().getFullyQualifiedName()), new String[] { "I3", "S" }, Modality.MUST, true, false);
          _builder.append(_referPattern_2, "\t");
          _builder.newLineIfNotEmpty();
          _builder.append("\t");
          _builder.append("I1 != I2;");
          _builder.newLine();
          _builder.append("\t");
          _builder.append("I1 != I3;");
          _builder.newLine();
          _builder.append("\t");
          _builder.append("I2 != I3;");
          _builder.newLine();
          _builder.append("}");
          _builder.newLine();
          _builder.newLine();
          _builder.append("pattern tooManyInputsOfSegment_must_to_true_by_straight(");
          _builder.append(parameters);
          _builder.append(", S : DefinedElement) {");
          _builder.newLineIfNotEmpty();
          _builder.append("\t");
          _builder.append("find mustExist(problem, interpretation, S);");
          _builder.newLine();
          _builder.append("\t");
          CharSequence _referInstanceOf_18 = generator.getTypeIndexer().referInstanceOf(Modes3UnitPropagationGenerator.this.simpleSegmentType, Modality.MUST, "S");
          _builder.append(_referInstanceOf_18, "\t");
          _builder.newLineIfNotEmpty();
          _builder.append("\t");
          _builder.append("find output_must_to_true_by_straight(problem, interpretation, source, target, I1, S);");
          _builder.newLine();
          _builder.append("\t");
          CharSequence _referPattern_3 = generator.getRelationDefinitionIndexer().referPattern(fqnToPQuery.get(Output.instance().getFullyQualifiedName()), new String[] { "I2", "S" }, Modality.MUST, true, false);
          _builder.append(_referPattern_3, "\t");
          _builder.newLineIfNotEmpty();
          _builder.append("\t");
          CharSequence _referPattern_4 = generator.getRelationDefinitionIndexer().referPattern(fqnToPQuery.get(Output.instance().getFullyQualifiedName()), new String[] { "I3", "S" }, Modality.MUST, true, false);
          _builder.append(_referPattern_4, "\t");
          _builder.newLineIfNotEmpty();
          _builder.append("\t");
          _builder.append("I1 != I2;");
          _builder.newLine();
          _builder.append("\t");
          _builder.append("I1 != I3;");
          _builder.newLine();
          _builder.append("\t");
          _builder.append("I2 != I3;");
          _builder.newLine();
          _builder.append("}");
          _builder.newLine();
          _builder.newLine();
          _builder.append("pattern tooManyInputsOfSegment_must_to_true_by_divergent(");
          _builder.append(parameters);
          _builder.append(", S : DefinedElement) {");
          _builder.newLineIfNotEmpty();
          _builder.append("\t");
          _builder.append("find mustExist(problem, interpretation, S);");
          _builder.newLine();
          _builder.append("\t");
          CharSequence _referInstanceOf_19 = generator.getTypeIndexer().referInstanceOf(Modes3UnitPropagationGenerator.this.simpleSegmentType, Modality.MUST, "S");
          _builder.append(_referInstanceOf_19, "\t");
          _builder.newLineIfNotEmpty();
          _builder.append("\t");
          _builder.append("find output_must_to_true_by_divergent(problem, interpretation, source, target, I1, S);");
          _builder.newLine();
          _builder.append("\t");
          CharSequence _referPattern_5 = generator.getRelationDefinitionIndexer().referPattern(fqnToPQuery.get(Output.instance().getFullyQualifiedName()), new String[] { "I2", "S" }, Modality.MUST, true, false);
          _builder.append(_referPattern_5, "\t");
          _builder.newLineIfNotEmpty();
          _builder.append("\t");
          CharSequence _referPattern_6 = generator.getRelationDefinitionIndexer().referPattern(fqnToPQuery.get(Output.instance().getFullyQualifiedName()), new String[] { "I3", "S" }, Modality.MUST, true, false);
          _builder.append(_referPattern_6, "\t");
          _builder.newLineIfNotEmpty();
          _builder.append("\t");
          _builder.append("I1 != I2;");
          _builder.newLine();
          _builder.append("\t");
          _builder.append("I1 != I3;");
          _builder.newLine();
          _builder.append("\t");
          _builder.append("I2 != I3;");
          _builder.newLine();
          _builder.append("}");
          _builder.newLine();
          _builder.newLine();
          _builder.append("pattern turnoutConnectedToBothOutputs_must_to_true_by_connectedTo(");
          _builder.append(parameters);
          _builder.append(", T : DefinedElement) {");
          _builder.newLineIfNotEmpty();
          _builder.append("\t");
          _builder.append(commonMayParameterConstraints, "\t");
          _builder.newLineIfNotEmpty();
          _builder.append("\t");
          _builder.append("find mustExist(problem, interpretation, Straight);");
          _builder.newLine();
          _builder.append("\t");
          _builder.append("find mustExist(problem, interpretation, Divergent);");
          _builder.newLine();
          _builder.append("\t");
          CharSequence _referInstanceOf_20 = generator.getTypeIndexer().referInstanceOf(Modes3UnitPropagationGenerator.this.turnoutType, Modality.MAY, "source");
          _builder.append(_referInstanceOf_20, "\t");
          _builder.newLineIfNotEmpty();
          _builder.append("\t");
          CharSequence _referInstanceOf_21 = generator.getTypeIndexer().referInstanceOf(Modes3UnitPropagationGenerator.this.segmentType, Modality.MAY, "target");
          _builder.append(_referInstanceOf_21, "\t");
          _builder.newLineIfNotEmpty();
          _builder.append("\t");
          CharSequence _referInstanceOf_22 = generator.getTypeIndexer().referInstanceOf(Modes3UnitPropagationGenerator.this.segmentType, Modality.MUST, "Straight");
          _builder.append(_referInstanceOf_22, "\t");
          _builder.newLineIfNotEmpty();
          _builder.append("\t");
          CharSequence _referInstanceOf_23 = generator.getTypeIndexer().referInstanceOf(Modes3UnitPropagationGenerator.this.segmentType, Modality.MUST, "Divergent");
          _builder.append(_referInstanceOf_23, "\t");
          _builder.newLineIfNotEmpty();
          _builder.append("\t");
          CharSequence _referRelation_26 = generator.referRelation(Modes3UnitPropagationGenerator.this.straightRelation, "T", "Straight", Modality.MUST, fqnToPQuery);
          _builder.append(_referRelation_26, "\t");
          _builder.newLineIfNotEmpty();
          _builder.append("\t");
          CharSequence _referRelation_27 = generator.referRelation(Modes3UnitPropagationGenerator.this.divergentRelation, "T", "Divergent", Modality.MUST, fqnToPQuery);
          _builder.append(_referRelation_27, "\t");
          _builder.newLineIfNotEmpty();
          _builder.append("\t");
          _builder.append("T == source;");
          _builder.newLine();
          _builder.append("\t");
          _builder.append("Straight == target;");
          _builder.newLine();
          _builder.append("\t");
          CharSequence _referRelation_28 = generator.referRelation(Modes3UnitPropagationGenerator.this.connectedToRelation, "T", "Divergent", Modality.MUST, fqnToPQuery);
          _builder.append(_referRelation_28, "\t");
          _builder.newLineIfNotEmpty();
          _builder.append("} or {");
          _builder.newLine();
          _builder.append("\t");
          _builder.append(commonMayParameterConstraints, "\t");
          _builder.newLineIfNotEmpty();
          _builder.append("\t");
          _builder.append("find mustExist(problem, interpretation, Straight);");
          _builder.newLine();
          _builder.append("\t");
          _builder.append("find mustExist(problem, interpretation, Divergent);");
          _builder.newLine();
          _builder.append("\t");
          CharSequence _referInstanceOf_24 = generator.getTypeIndexer().referInstanceOf(Modes3UnitPropagationGenerator.this.turnoutType, Modality.MAY, "source");
          _builder.append(_referInstanceOf_24, "\t");
          _builder.newLineIfNotEmpty();
          _builder.append("\t");
          CharSequence _referInstanceOf_25 = generator.getTypeIndexer().referInstanceOf(Modes3UnitPropagationGenerator.this.segmentType, Modality.MAY, "target");
          _builder.append(_referInstanceOf_25, "\t");
          _builder.newLineIfNotEmpty();
          _builder.append("\t");
          CharSequence _referInstanceOf_26 = generator.getTypeIndexer().referInstanceOf(Modes3UnitPropagationGenerator.this.segmentType, Modality.MUST, "Straight");
          _builder.append(_referInstanceOf_26, "\t");
          _builder.newLineIfNotEmpty();
          _builder.append("\t");
          CharSequence _referInstanceOf_27 = generator.getTypeIndexer().referInstanceOf(Modes3UnitPropagationGenerator.this.segmentType, Modality.MUST, "Divergent");
          _builder.append(_referInstanceOf_27, "\t");
          _builder.newLineIfNotEmpty();
          _builder.append("\t");
          CharSequence _referRelation_29 = generator.referRelation(Modes3UnitPropagationGenerator.this.straightRelation, "T", "Straight", Modality.MUST, fqnToPQuery);
          _builder.append(_referRelation_29, "\t");
          _builder.newLineIfNotEmpty();
          _builder.append("\t");
          CharSequence _referRelation_30 = generator.referRelation(Modes3UnitPropagationGenerator.this.divergentRelation, "T", "Divergent", Modality.MUST, fqnToPQuery);
          _builder.append(_referRelation_30, "\t");
          _builder.newLineIfNotEmpty();
          _builder.append("\t");
          CharSequence _referRelation_31 = generator.referRelation(Modes3UnitPropagationGenerator.this.connectedToRelation, "T", "Straight", Modality.MUST, fqnToPQuery);
          _builder.append(_referRelation_31, "\t");
          _builder.newLineIfNotEmpty();
          _builder.append("\t");
          _builder.append("T == source;");
          _builder.newLine();
          _builder.append("\t");
          _builder.append("Straight == target;");
          _builder.newLine();
          _builder.append("}");
          _builder.newLine();
          _builder.newLine();
          _builder.append("pattern turnoutConnectedToBothOutputs_must_to_true_by_straight(");
          _builder.append(parameters);
          _builder.append(", T : DefinedElement) {");
          _builder.newLineIfNotEmpty();
          _builder.append("\t");
          _builder.append(commonMayParameterConstraints, "\t");
          _builder.newLineIfNotEmpty();
          _builder.append("\t");
          _builder.append("find mustExist(problem, interpretation, Straight);");
          _builder.newLine();
          _builder.append("\t");
          _builder.append("find mustExist(problem, interpretation, Divergent);");
          _builder.newLine();
          _builder.append("\t");
          CharSequence _referInstanceOf_28 = generator.getTypeIndexer().referInstanceOf(Modes3UnitPropagationGenerator.this.turnoutType, Modality.MAY, "source");
          _builder.append(_referInstanceOf_28, "\t");
          _builder.newLineIfNotEmpty();
          _builder.append("\t");
          CharSequence _referInstanceOf_29 = generator.getTypeIndexer().referInstanceOf(Modes3UnitPropagationGenerator.this.segmentType, Modality.MAY, "target");
          _builder.append(_referInstanceOf_29, "\t");
          _builder.newLineIfNotEmpty();
          _builder.append("\t");
          CharSequence _referInstanceOf_30 = generator.getTypeIndexer().referInstanceOf(Modes3UnitPropagationGenerator.this.segmentType, Modality.MUST, "Straight");
          _builder.append(_referInstanceOf_30, "\t");
          _builder.newLineIfNotEmpty();
          _builder.append("\t");
          CharSequence _referInstanceOf_31 = generator.getTypeIndexer().referInstanceOf(Modes3UnitPropagationGenerator.this.segmentType, Modality.MUST, "Divergent");
          _builder.append(_referInstanceOf_31, "\t");
          _builder.newLineIfNotEmpty();
          _builder.append("\t");
          _builder.append("T == source;");
          _builder.newLine();
          _builder.append("\t");
          _builder.append("Straight == target;");
          _builder.newLine();
          _builder.append("\t");
          CharSequence _referRelation_32 = generator.referRelation(Modes3UnitPropagationGenerator.this.divergentRelation, "T", "Divergent", Modality.MUST, fqnToPQuery);
          _builder.append(_referRelation_32, "\t");
          _builder.newLineIfNotEmpty();
          _builder.append("\t");
          CharSequence _referRelation_33 = generator.referRelation(Modes3UnitPropagationGenerator.this.connectedToRelation, "T", "Straight", Modality.MUST, fqnToPQuery);
          _builder.append(_referRelation_33, "\t");
          _builder.newLineIfNotEmpty();
          _builder.append("\t");
          CharSequence _referRelation_34 = generator.referRelation(Modes3UnitPropagationGenerator.this.connectedToRelation, "T", "Divergent", Modality.MUST, fqnToPQuery);
          _builder.append(_referRelation_34, "\t");
          _builder.newLineIfNotEmpty();
          _builder.append("}");
          _builder.newLine();
          _builder.newLine();
          _builder.append("pattern turnoutConnectedToBothOutputs_must_to_true_by_divergent(");
          _builder.append(parameters);
          _builder.append(", T : DefinedElement) {");
          _builder.newLineIfNotEmpty();
          _builder.append("\t");
          _builder.append(commonMayParameterConstraints, "\t");
          _builder.newLineIfNotEmpty();
          _builder.append("\t");
          _builder.append("find mustExist(problem, interpretation, Straight);");
          _builder.newLine();
          _builder.append("\t");
          _builder.append("find mustExist(problem, interpretation, Divergent);");
          _builder.newLine();
          _builder.append("\t");
          CharSequence _referInstanceOf_32 = generator.getTypeIndexer().referInstanceOf(Modes3UnitPropagationGenerator.this.turnoutType, Modality.MAY, "source");
          _builder.append(_referInstanceOf_32, "\t");
          _builder.newLineIfNotEmpty();
          _builder.append("\t");
          CharSequence _referInstanceOf_33 = generator.getTypeIndexer().referInstanceOf(Modes3UnitPropagationGenerator.this.segmentType, Modality.MAY, "target");
          _builder.append(_referInstanceOf_33, "\t");
          _builder.newLineIfNotEmpty();
          _builder.append("\t");
          CharSequence _referInstanceOf_34 = generator.getTypeIndexer().referInstanceOf(Modes3UnitPropagationGenerator.this.segmentType, Modality.MUST, "Straight");
          _builder.append(_referInstanceOf_34, "\t");
          _builder.newLineIfNotEmpty();
          _builder.append("\t");
          CharSequence _referInstanceOf_35 = generator.getTypeIndexer().referInstanceOf(Modes3UnitPropagationGenerator.this.segmentType, Modality.MUST, "Divergent");
          _builder.append(_referInstanceOf_35, "\t");
          _builder.newLineIfNotEmpty();
          _builder.append("\t");
          CharSequence _referRelation_35 = generator.referRelation(Modes3UnitPropagationGenerator.this.straightRelation, "T", "Straight", Modality.MUST, fqnToPQuery);
          _builder.append(_referRelation_35, "\t");
          _builder.newLineIfNotEmpty();
          _builder.append("\t");
          _builder.append("T == source;");
          _builder.newLine();
          _builder.append("\t");
          _builder.append("Divergent == target;");
          _builder.newLine();
          _builder.append("\t");
          CharSequence _referRelation_36 = generator.referRelation(Modes3UnitPropagationGenerator.this.connectedToRelation, "T", "Straight", Modality.MUST, fqnToPQuery);
          _builder.append(_referRelation_36, "\t");
          _builder.newLineIfNotEmpty();
          _builder.append("\t");
          CharSequence _referRelation_37 = generator.referRelation(Modes3UnitPropagationGenerator.this.connectedToRelation, "T", "Divergent", Modality.MUST, fqnToPQuery);
          _builder.append(_referRelation_37, "\t");
          _builder.newLineIfNotEmpty();
          _builder.append("}");
          _builder.newLine();
          _builder.newLine();
          _builder.append("pattern tooManyInputsOfTurnout_must_to_true_by_connectedTo(");
          _builder.append(parameters);
          _builder.append(", T : DefinedElement) {");
          _builder.newLineIfNotEmpty();
          _builder.append("\t");
          _builder.append("find mustExist(problem, interpretation, S);");
          _builder.newLine();
          _builder.append("\t");
          CharSequence _referInstanceOf_36 = generator.getTypeIndexer().referInstanceOf(Modes3UnitPropagationGenerator.this.turnoutType, Modality.MUST, "S");
          _builder.append(_referInstanceOf_36, "\t");
          _builder.newLineIfNotEmpty();
          _builder.append("\t");
          _builder.append("find adjacent_must_to_true_by_connectedTo(problem, interpretation, source, target, I1, S);");
          _builder.newLine();
          _builder.append("\t");
          CharSequence _referPattern_7 = generator.getRelationDefinitionIndexer().referPattern(fqnToPQuery.get(Adjacent.instance().getFullyQualifiedName()), new String[] { "I2", "S" }, Modality.MUST, true, false);
          _builder.append(_referPattern_7, "\t");
          _builder.newLineIfNotEmpty();
          _builder.append("\t");
          CharSequence _referPattern_8 = generator.getRelationDefinitionIndexer().referPattern(fqnToPQuery.get(Adjacent.instance().getFullyQualifiedName()), new String[] { "I3", "S" }, Modality.MUST, true, false);
          _builder.append(_referPattern_8, "\t");
          _builder.newLineIfNotEmpty();
          _builder.append("\t");
          CharSequence _referPattern_9 = generator.getRelationDefinitionIndexer().referPattern(fqnToPQuery.get(Adjacent.instance().getFullyQualifiedName()), new String[] { "I4", "S" }, Modality.MUST, true, false);
          _builder.append(_referPattern_9, "\t");
          _builder.newLineIfNotEmpty();
          _builder.append("\t");
          _builder.append("I1 != I2;");
          _builder.newLine();
          _builder.append("\t");
          _builder.append("I1 != I3;");
          _builder.newLine();
          _builder.append("\t");
          _builder.append("I1 != I4;");
          _builder.newLine();
          _builder.append("\t");
          _builder.append("I2 != I3;");
          _builder.newLine();
          _builder.append("\t");
          _builder.append("I2 != I4;");
          _builder.newLine();
          _builder.append("\t");
          _builder.append("I3 != I4;");
          _builder.newLine();
          _builder.append("}");
          _builder.newLine();
          _builder.newLine();
          _builder.append("pattern tooManyInputsOfTurnout_must_to_true_by_straight(");
          _builder.append(parameters);
          _builder.append(", T : DefinedElement) {");
          _builder.newLineIfNotEmpty();
          _builder.append("\t");
          _builder.append("find mustExist(problem, interpretation, S);");
          _builder.newLine();
          _builder.append("\t");
          CharSequence _referInstanceOf_37 = generator.getTypeIndexer().referInstanceOf(Modes3UnitPropagationGenerator.this.turnoutType, Modality.MUST, "S");
          _builder.append(_referInstanceOf_37, "\t");
          _builder.newLineIfNotEmpty();
          _builder.append("\t");
          _builder.append("find adjacent_must_to_true_by_straight(problem, interpretation, source, target, I1, S);");
          _builder.newLine();
          _builder.append("\t");
          CharSequence _referPattern_10 = generator.getRelationDefinitionIndexer().referPattern(fqnToPQuery.get(Adjacent.instance().getFullyQualifiedName()), new String[] { "I2", "S" }, Modality.MUST, true, false);
          _builder.append(_referPattern_10, "\t");
          _builder.newLineIfNotEmpty();
          _builder.append("\t");
          CharSequence _referPattern_11 = generator.getRelationDefinitionIndexer().referPattern(fqnToPQuery.get(Adjacent.instance().getFullyQualifiedName()), new String[] { "I3", "S" }, Modality.MUST, true, false);
          _builder.append(_referPattern_11, "\t");
          _builder.newLineIfNotEmpty();
          _builder.append("\t");
          CharSequence _referPattern_12 = generator.getRelationDefinitionIndexer().referPattern(fqnToPQuery.get(Adjacent.instance().getFullyQualifiedName()), new String[] { "I4", "S" }, Modality.MUST, true, false);
          _builder.append(_referPattern_12, "\t");
          _builder.newLineIfNotEmpty();
          _builder.append("\t");
          _builder.append("I1 != I2;");
          _builder.newLine();
          _builder.append("\t");
          _builder.append("I1 != I3;");
          _builder.newLine();
          _builder.append("\t");
          _builder.append("I1 != I4;");
          _builder.newLine();
          _builder.append("\t");
          _builder.append("I2 != I3;");
          _builder.newLine();
          _builder.append("\t");
          _builder.append("I2 != I4;");
          _builder.newLine();
          _builder.append("\t");
          _builder.append("I3 != I4;");
          _builder.newLine();
          _builder.append("}");
          _builder.newLine();
          _builder.newLine();
          _builder.append("pattern tooManyInputsOfTurnout_must_to_true_by_divergent(");
          _builder.append(parameters);
          _builder.append(", T : DefinedElement) {");
          _builder.newLineIfNotEmpty();
          _builder.append("\t");
          _builder.append("find mustExist(problem, interpretation, S);");
          _builder.newLine();
          _builder.append("\t");
          CharSequence _referInstanceOf_38 = generator.getTypeIndexer().referInstanceOf(Modes3UnitPropagationGenerator.this.turnoutType, Modality.MUST, "S");
          _builder.append(_referInstanceOf_38, "\t");
          _builder.newLineIfNotEmpty();
          _builder.append("\t");
          _builder.append("find adjacent_must_to_true_by_divergent(problem, interpretation, source, target, I1, S);");
          _builder.newLine();
          _builder.append("\t");
          CharSequence _referPattern_13 = generator.getRelationDefinitionIndexer().referPattern(fqnToPQuery.get(Adjacent.instance().getFullyQualifiedName()), new String[] { "I2", "S" }, Modality.MUST, true, false);
          _builder.append(_referPattern_13, "\t");
          _builder.newLineIfNotEmpty();
          _builder.append("\t");
          CharSequence _referPattern_14 = generator.getRelationDefinitionIndexer().referPattern(fqnToPQuery.get(Adjacent.instance().getFullyQualifiedName()), new String[] { "I3", "S" }, Modality.MUST, true, false);
          _builder.append(_referPattern_14, "\t");
          _builder.newLineIfNotEmpty();
          _builder.append("\t");
          CharSequence _referPattern_15 = generator.getRelationDefinitionIndexer().referPattern(fqnToPQuery.get(Adjacent.instance().getFullyQualifiedName()), new String[] { "I4", "S" }, Modality.MUST, true, false);
          _builder.append(_referPattern_15, "\t");
          _builder.newLineIfNotEmpty();
          _builder.append("\t");
          _builder.append("I1 != I2;");
          _builder.newLine();
          _builder.append("\t");
          _builder.append("I1 != I3;");
          _builder.newLine();
          _builder.append("\t");
          _builder.append("I1 != I4;");
          _builder.newLine();
          _builder.append("\t");
          _builder.append("I2 != I3;");
          _builder.newLine();
          _builder.append("\t");
          _builder.append("I2 != I4;");
          _builder.newLine();
          _builder.append("\t");
          _builder.append("I3 != I4;");
          _builder.newLine();
          _builder.append("}");
          _builder.newLine();
          _builder.newLine();
          _builder.append("pattern ");
          _builder.append(Modes3UnitPropagationGenerator.MUST_NOT_CONNECTED_TO);
          _builder.append("_helper(");
          _builder.append(parameters);
          _builder.append(") {");
          _builder.newLineIfNotEmpty();
          _builder.append("\t");
          _builder.append("find connectedToReflexive_must_to_true_by_connectedTo(problem, interpretation, source, target, _);");
          _builder.newLine();
          _builder.append("} or {");
          _builder.newLine();
          _builder.append("\t");
          _builder.append("find tooManyInputsOfSegment_must_to_true_by_connectedTo(problem, interpretation, source, target, _);");
          _builder.newLine();
          _builder.append("} or {");
          _builder.newLine();
          _builder.append("\t");
          _builder.append("find turnoutConnectedToBothOutputs_must_to_true_by_connectedTo(problem, interpretation, source, target, _);");
          _builder.newLine();
          _builder.append("} or {");
          _builder.newLine();
          _builder.append("\t");
          _builder.append("find tooManyInputsOfTurnout_must_to_true_by_connectedTo(problem, interpretation, source, target, _);");
          _builder.newLine();
          _builder.append("}");
          _builder.newLine();
          _builder.newLine();
          _builder.append("pattern ");
          _builder.append(Modes3UnitPropagationGenerator.MUST_NOT_CONNECTED_TO);
          _builder.append("(");
          _builder.append(parameters);
          _builder.append(") {");
          _builder.newLineIfNotEmpty();
          _builder.append("\t");
          _builder.append("find ");
          _builder.append(Modes3UnitPropagationGenerator.MUST_NOT_CONNECTED_TO, "\t");
          _builder.append("_helper(problem, interpretation, source, target);");
          _builder.newLineIfNotEmpty();
          _builder.append("} or {");
          _builder.newLine();
          _builder.append("\t");
          _builder.append("find ");
          _builder.append(Modes3UnitPropagationGenerator.MUST_NOT_CONNECTED_TO, "\t");
          _builder.append("_helper(problem, interpretation, target, source);");
          _builder.newLineIfNotEmpty();
          _builder.append("}");
          _builder.newLine();
          _builder.newLine();
          _builder.append("pattern ");
          _builder.append(Modes3UnitPropagationGenerator.MUST_NOT_STRAIGHT);
          _builder.append("(");
          _builder.append(parameters);
          _builder.append(") {");
          _builder.newLineIfNotEmpty();
          _builder.append("\t");
          _builder.append("find outputReflexive_must_to_true_by_straight(problem, interpretation, source, target, _);");
          _builder.newLine();
          _builder.append("} or {");
          _builder.newLine();
          _builder.append("\t");
          _builder.append("find turnoutOutputsAreSame_must_to_true_by_straight(problem, interpretation, source, target, _);");
          _builder.newLine();
          _builder.append("} or {");
          _builder.newLine();
          _builder.append("\t");
          _builder.append("find tooManyInputsOfSegment_must_to_true_by_straight(problem, interpretation, source, target, _);");
          _builder.newLine();
          _builder.append("} or {");
          _builder.newLine();
          _builder.append("\t");
          _builder.append("find turnoutConnectedToBothOutputs_must_to_true_by_straight(problem, interpretation, source, target, _);");
          _builder.newLine();
          _builder.append("} or {");
          _builder.newLine();
          _builder.append("\t");
          _builder.append("find tooManyInputsOfTurnout_must_to_true_by_straight(problem, interpretation, source, target, _);");
          _builder.newLine();
          _builder.append("}");
          _builder.newLine();
          _builder.newLine();
          _builder.append("pattern ");
          _builder.append(Modes3UnitPropagationGenerator.MUST_NOT_DIVERGENT);
          _builder.append("(");
          _builder.append(parameters);
          _builder.append(") {");
          _builder.newLineIfNotEmpty();
          _builder.append("\t");
          _builder.append("find outputReflexive_must_to_true_by_divergent(problem, interpretation, source, target, _);");
          _builder.newLine();
          _builder.append("} or {");
          _builder.newLine();
          _builder.append("\t");
          _builder.append("find turnoutOutputsAreSame_must_to_true_by_divergent(problem, interpretation, source, target, _);");
          _builder.newLine();
          _builder.append("} or {");
          _builder.newLine();
          _builder.append("\t");
          _builder.append("find tooManyInputsOfSegment_must_to_true_by_divergent(problem, interpretation, source, target, _);");
          _builder.newLine();
          _builder.append("} or {");
          _builder.newLine();
          _builder.append("\t");
          _builder.append("find turnoutConnectedToBothOutputs_must_to_true_by_divergent(problem, interpretation, source, target, _);");
          _builder.newLine();
          _builder.append("} or {");
          _builder.newLine();
          _builder.append("\t");
          _builder.append("find tooManyInputsOfTurnout_must_to_true_by_divergent(problem, interpretation, source, target, _);");
          _builder.newLine();
          _builder.append("}");
          _builder.newLine();
        }
      };
      _xblockexpression = _client_3;
    }
    return _xblockexpression;
  }
}
